/**
 * Copyright 2022 The Magma Authors.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @generated
 * This file is generated by "nms/scripts/generateAPIFromSwagger.sh".
 */
/* tslint:disable */
/* eslint-disable */
/**
 * Magma
 * Magma REST APIs
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * aaa server configuration
 * @export
 * @interface AaaServer
 */
export interface AaaServer {
    /**
     * 
     * @type {boolean}
     * @memberof AaaServer
     */
    'accounting_enabled'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AaaServer
     */
    'acct_reporting_enabled'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AaaServer
     */
    'create_session_on_auth'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AaaServer
     */
    'event_logging_enabled'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof AaaServer
     */
    'idle_session_timeout_ms'?: number;
    /**
     * 
     * @type {RadiusConfig}
     * @memberof AaaServer
     */
    'radius_config'?: RadiusConfig;
}
/**
 * 
 * @export
 * @interface AggregatedMaximumBitrate
 */
export interface AggregatedMaximumBitrate {
    /**
     * 
     * @type {number}
     * @memberof AggregatedMaximumBitrate
     */
    'max_bandwidth_dl': number;
    /**
     * 
     * @type {number}
     * @memberof AggregatedMaximumBitrate
     */
    'max_bandwidth_ul': number;
}
/**
 * Configuration for log aggregation
 * @export
 * @interface AggregationLoggingConfigs
 */
export interface AggregationLoggingConfigs {
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof AggregationLoggingConfigs
     */
    'target_files_by_tag'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof AggregationLoggingConfigs
     */
    'throttle_interval'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof AggregationLoggingConfigs
     */
    'throttle_rate'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof AggregationLoggingConfigs
     */
    'throttle_window'?: number | null;
}
/**
 * 
 * @export
 * @interface AlertBulkUploadResponse
 */
export interface AlertBulkUploadResponse {
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof AlertBulkUploadResponse
     */
    'errors': { [key: string]: string; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof AlertBulkUploadResponse
     */
    'statuses': { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface AlertReceiverConfig
 */
export interface AlertReceiverConfig {
    /**
     * 
     * @type {Array<EmailReceiver>}
     * @memberof AlertReceiverConfig
     */
    'email_configs'?: Array<EmailReceiver>;
    /**
     * 
     * @type {string}
     * @memberof AlertReceiverConfig
     */
    'name': string;
    /**
     * 
     * @type {Array<SlackReceiver>}
     * @memberof AlertReceiverConfig
     */
    'slack_configs'?: Array<SlackReceiver>;
    /**
     * 
     * @type {Array<WebhookReceiver>}
     * @memberof AlertReceiverConfig
     */
    'webhook_configs'?: Array<WebhookReceiver>;
}
/**
 * 
 * @export
 * @interface AlertRoutingTree
 */
export interface AlertRoutingTree {
    /**
     * 
     * @type {boolean}
     * @memberof AlertRoutingTree
     */
    'continue'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof AlertRoutingTree
     */
    'group_by'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof AlertRoutingTree
     */
    'group_interval'?: string;
    /**
     * 
     * @type {string}
     * @memberof AlertRoutingTree
     */
    'group_wait'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof AlertRoutingTree
     */
    'match'?: { [key: string]: string; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof AlertRoutingTree
     */
    'match_re'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof AlertRoutingTree
     */
    'receiver': string;
    /**
     * 
     * @type {string}
     * @memberof AlertRoutingTree
     */
    'repeat_interval'?: string;
    /**
     * 
     * @type {Array<AlertRoutingTree>}
     * @memberof AlertRoutingTree
     */
    'routes'?: Array<AlertRoutingTree>;
}
/**
 * 
 * @export
 * @interface AlertSilenceStatus
 */
export interface AlertSilenceStatus {
    /**
     * 
     * @type {string}
     * @memberof AlertSilenceStatus
     */
    'state': string;
}
/**
 * 
 * @export
 * @interface AlertSilencer
 */
export interface AlertSilencer {
    /**
     * 
     * @type {string}
     * @memberof AlertSilencer
     */
    'comment': string;
    /**
     * 
     * @type {string}
     * @memberof AlertSilencer
     */
    'createdBy': string;
    /**
     * 
     * @type {string}
     * @memberof AlertSilencer
     */
    'endsAt': string;
    /**
     * 
     * @type {Array<Matcher>}
     * @memberof AlertSilencer
     */
    'matchers': Array<Matcher>;
    /**
     * 
     * @type {string}
     * @memberof AlertSilencer
     */
    'startsAt': string;
}
/**
 * 
 * @export
 * @interface AllowedGrePeer
 */
export interface AllowedGrePeer {
    /**
     * 
     * @type {string}
     * @memberof AllowedGrePeer
     */
    'ip': string;
    /**
     * 
     * @type {number}
     * @memberof AllowedGrePeer
     */
    'key'?: number | null;
}
/**
 * 
 * @export
 * @interface Apn
 */
export interface Apn {
    /**
     * 
     * @type {ApnConfiguration}
     * @memberof Apn
     */
    'apn_configuration': ApnConfiguration;
    /**
     * 
     * @type {string}
     * @memberof Apn
     */
    'apn_name': string;
}
/**
 * 
 * @export
 * @interface ApnConfiguration
 */
export interface ApnConfiguration {
    /**
     * 
     * @type {AggregatedMaximumBitrate}
     * @memberof ApnConfiguration
     */
    'ambr': AggregatedMaximumBitrate;
    /**
     * Value identifier for PDN type (0=IPv4 1=IPv6 2=IPv4v6 3=IPv4orv6)
     * @type {number}
     * @memberof ApnConfiguration
     */
    'pdn_type'?: number;
    /**
     * 
     * @type {QosProfile}
     * @memberof ApnConfiguration
     */
    'qos_profile': QosProfile;
}
/**
 * 
 * @export
 * @interface ApnResource
 */
export interface ApnResource {
    /**
     * 
     * @type {string}
     * @memberof ApnResource
     */
    'apn_name': string;
    /**
     * 
     * @type {string}
     * @memberof ApnResource
     */
    'gateway_ip'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApnResource
     */
    'gateway_mac'?: string;
    /**
     * APN resource ID must be unique across all gateways in a network
     * @type {string}
     * @memberof ApnResource
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof ApnResource
     */
    'vlan_id'?: number;
}
/**
 * Allocation and retention priority
 * @export
 * @interface Arp
 */
export interface Arp {
    /**
     * 
     * @type {boolean}
     * @memberof Arp
     */
    'preemption_capability'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Arp
     */
    'preemption_vulnerability'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Arp
     */
    'priority_level'?: number;
}
/**
 * 
 * @export
 * @interface BaseNameRecord
 */
export interface BaseNameRecord {
    /**
     * Subscribers which have been assigned this policy base name
     * @type {Array<string>}
     * @memberof BaseNameRecord
     */
    'assigned_subscribers'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof BaseNameRecord
     */
    'name': string;
    /**
     * List of rule names
     * @type {Array<string>}
     * @memberof BaseNameRecord
     */
    'rule_names': Array<string>;
}
/**
 * Call Trace
 * @export
 * @interface CallTrace
 */
export interface CallTrace {
    /**
     * 
     * @type {CallTraceConfig}
     * @memberof CallTrace
     */
    'config': CallTraceConfig;
    /**
     * 
     * @type {CallTraceState}
     * @memberof CallTrace
     */
    'state'?: CallTraceState;
}
/**
 * Call Trace spec
 * @export
 * @interface CallTraceConfig
 */
export interface CallTraceConfig {
    /**
     * Capture filter options for TShark as it would be typed out in shell. Only applies if trace_type is GATEWAY_CUSTOM. 
     * @type {string}
     * @memberof CallTraceConfig
     */
    'capture_filters'?: string;
    /**
     * Display filter options for TShark as it would be typed out in shell. Only applies if trace_type is GATEWAY_CUSTOM. 
     * @type {string}
     * @memberof CallTraceConfig
     */
    'display_filters'?: string;
    /**
     * ID of gateway to run call tracing on
     * @type {string}
     * @memberof CallTraceConfig
     */
    'gateway_id'?: string;
    /**
     * Timeout of call trace in seconds
     * @type {number}
     * @memberof CallTraceConfig
     */
    'timeout'?: number;
    /**
     * 
     * @type {string}
     * @memberof CallTraceConfig
     */
    'trace_id': string;
    /**
     * Trace Type:  * GATEWAY - Call trace for a gateway 
     * @type {string}
     * @memberof CallTraceConfig
     */
    'trace_type': CallTraceConfigTraceTypeEnum;
}

export const CallTraceConfigTraceTypeEnum = {
    Gateway: 'GATEWAY'
} as const;

export type CallTraceConfigTraceTypeEnum = typeof CallTraceConfigTraceTypeEnum[keyof typeof CallTraceConfigTraceTypeEnum];

/**
 * Full state object of a call trace
 * @export
 * @interface CallTraceState
 */
export interface CallTraceState {
    /**
     * True if the trace is available for download
     * @type {boolean}
     * @memberof CallTraceState
     */
    'call_trace_available'?: boolean;
    /**
     * True if trace has been requested to end
     * @type {boolean}
     * @memberof CallTraceState
     */
    'call_trace_ending'?: boolean;
}
/**
 * 
 * @export
 * @interface Capabilities
 */
export interface Capabilities {
    /**
     * this is the maximum allowed difference in MHz between leftmost end of leftmost channel and rightmost end of rightmost channel used by a Base Station (eNB)
     * @type {number}
     * @memberof Capabilities
     */
    'max_ibw_mhz': number;
    /**
     * max tx power available on cbsd
     * @type {number}
     * @memberof Capabilities
     */
    'max_power': number;
    /**
     * min tx power available on cbsd
     * @type {number}
     * @memberof Capabilities
     */
    'min_power': number;
    /**
     * 
     * @type {number}
     * @memberof Capabilities
     */
    'number_of_antennas': number;
}
/**
 * Health status of a Carrier Wifi Gateway
 * @export
 * @interface CarrierWifiGatewayHealthStatus
 */
export interface CarrierWifiGatewayHealthStatus {
    /**
     * 
     * @type {string}
     * @memberof CarrierWifiGatewayHealthStatus
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof CarrierWifiGatewayHealthStatus
     */
    'status': CarrierWifiGatewayHealthStatusStatusEnum;
}

export const CarrierWifiGatewayHealthStatusStatusEnum = {
    Healthy: 'HEALTHY',
    Unhealthy: 'UNHEALTHY'
} as const;

export type CarrierWifiGatewayHealthStatusStatusEnum = typeof CarrierWifiGatewayHealthStatusStatusEnum[keyof typeof CarrierWifiGatewayHealthStatusStatusEnum];

/**
 * Full state object of an ha pair
 * @export
 * @interface CarrierWifiHaPairState
 */
export interface CarrierWifiHaPairState {
    /**
     * 
     * @type {CarrierWifiGatewayHealthStatus}
     * @memberof CarrierWifiHaPairState
     */
    'gateway1_health'?: CarrierWifiGatewayHealthStatus;
    /**
     * 
     * @type {CarrierWifiGatewayHealthStatus}
     * @memberof CarrierWifiHaPairState
     */
    'gateway2_health'?: CarrierWifiGatewayHealthStatus;
    /**
     * 
     * @type {CarrierWifiHaPairStatus}
     * @memberof CarrierWifiHaPairState
     */
    'ha_pair_status'?: CarrierWifiHaPairStatus;
}
/**
 * Status of a Carrier Wifi HA pair status
 * @export
 * @interface CarrierWifiHaPairStatus
 */
export interface CarrierWifiHaPairStatus {
    /**
     * 
     * @type {string}
     * @memberof CarrierWifiHaPairStatus
     */
    'active_gateway': string;
}
/**
 * 
 * @export
 * @interface Cbsd
 */
export interface Cbsd {
    /**
     * 
     * @type {Capabilities}
     * @memberof Cbsd
     */
    'capabilities': Capabilities;
    /**
     * this flag controls eNB behavior, should multiple grants be used for Carrier Aggregation, or one for Single Carrier
     * @type {boolean}
     * @memberof Cbsd
     */
    'carrier_aggregation_enabled': boolean;
    /**
     * is the radio type A (only) or B (also applies to A/B type radios)
     * @type {string}
     * @memberof Cbsd
     */
    'cbsd_category': CbsdCbsdCategoryEnum;
    /**
     * id of cbsd in SAS
     * @type {string}
     * @memberof Cbsd
     */
    'cbsd_id'?: string;
    /**
     * desired state of cbsd in SAS
     * @type {string}
     * @memberof Cbsd
     */
    'desired_state': CbsdDesiredStateEnum;
    /**
     * 
     * @type {string}
     * @memberof Cbsd
     */
    'fcc_id': string;
    /**
     * 
     * @type {FrequencyPreferences}
     * @memberof Cbsd
     */
    'frequency_preferences': FrequencyPreferences;
    /**
     * tells Domain Proxy how many grants from SAS should be maintained. If enabled, Domain Proxy will try to maintain at least 2 grants, if disabled, Domain Proxy will maintain only 1 grant
     * @type {boolean}
     * @memberof Cbsd
     */
    'grant_redundancy': boolean;
    /**
     * 
     * @type {Array<Grant>}
     * @memberof Cbsd
     */
    'grants'?: Array<Grant>;
    /**
     * database id of cbsd
     * @type {number}
     * @memberof Cbsd
     */
    'id': number;
    /**
     * 
     * @type {InstallationParam}
     * @memberof Cbsd
     */
    'installation_param': InstallationParam;
    /**
     * false if cbsd have not contacted DP for certain amount of time
     * @type {boolean}
     * @memberof Cbsd
     */
    'is_active': boolean;
    /**
     * 
     * @type {string}
     * @memberof Cbsd
     */
    'serial_number': string;
    /**
     * should the CBSD be registered in a single-step mode
     * @type {boolean}
     * @memberof Cbsd
     */
    'single_step_enabled': boolean;
    /**
     * state of cbsd in SAS
     * @type {string}
     * @memberof Cbsd
     */
    'state': CbsdStateEnum;
    /**
     * 
     * @type {string}
     * @memberof Cbsd
     */
    'user_id': string;
}

export const CbsdCbsdCategoryEnum = {
    A: 'a',
    B: 'b'
} as const;

export type CbsdCbsdCategoryEnum = typeof CbsdCbsdCategoryEnum[keyof typeof CbsdCbsdCategoryEnum];
export const CbsdDesiredStateEnum = {
    Unregistered: 'unregistered',
    Registered: 'registered'
} as const;

export type CbsdDesiredStateEnum = typeof CbsdDesiredStateEnum[keyof typeof CbsdDesiredStateEnum];
export const CbsdStateEnum = {
    Unregistered: 'unregistered',
    Registered: 'registered'
} as const;

export type CbsdStateEnum = typeof CbsdStateEnum[keyof typeof CbsdStateEnum];

/**
 * Highly available gateway pool in an LTE network
 * @export
 * @interface CellularGatewayPool
 */
export interface CellularGatewayPool {
    /**
     * 
     * @type {CellularGatewayPoolConfigs}
     * @memberof CellularGatewayPool
     */
    'config': CellularGatewayPoolConfigs;
    /**
     * 
     * @type {Array<string>}
     * @memberof CellularGatewayPool
     */
    'gateway_ids': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof CellularGatewayPool
     */
    'gateway_pool_id': string;
    /**
     * 
     * @type {string}
     * @memberof CellularGatewayPool
     */
    'gateway_pool_name'?: string;
}
/**
 * Configuration for gateway pool
 * @export
 * @interface CellularGatewayPoolConfigs
 */
export interface CellularGatewayPoolConfigs {
    /**
     * 
     * @type {number}
     * @memberof CellularGatewayPoolConfigs
     */
    'mme_group_id': number;
}
/**
 * Record in a gateway pool
 * @export
 * @interface CellularGatewayPoolRecord
 */
export interface CellularGatewayPoolRecord {
    /**
     * 
     * @type {string}
     * @memberof CellularGatewayPoolRecord
     */
    'gateway_pool_id': string;
    /**
     * 
     * @type {number}
     * @memberof CellularGatewayPoolRecord
     */
    'mme_code': number;
    /**
     * 
     * @type {number}
     * @memberof CellularGatewayPoolRecord
     */
    'mme_relative_capacity': number;
}
/**
 * 
 * @export
 * @interface ChallengeKey
 */
export interface ChallengeKey {
    /**
     * 
     * @type {string}
     * @memberof ChallengeKey
     */
    'key'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChallengeKey
     */
    'key_type': ChallengeKeyKeyTypeEnum;
}

export const ChallengeKeyKeyTypeEnum = {
    Echo: 'ECHO',
    SoftwareEcdsaSha256: 'SOFTWARE_ECDSA_SHA256'
} as const;

export type ChallengeKeyKeyTypeEnum = typeof ChallengeKeyKeyTypeEnum[keyof typeof ChallengeKeyKeyTypeEnum];

/**
 * 
 * @export
 * @interface ConfigInfo
 */
export interface ConfigInfo {
    /**
     * 
     * @type {number}
     * @memberof ConfigInfo
     */
    'mconfig_created_at'?: number;
}
/**
 * 
 * @export
 * @interface ControlProxy
 */
export interface ControlProxy {
    /**
     * Contents of a gateway control_proxy.yml
     * @type {string}
     * @memberof ControlProxy
     */
    'control_proxy': string;
}
/**
 * csfb configuration
 * @export
 * @interface Csfb
 */
export interface Csfb {
    /**
     * 
     * @type {SctpClientConfigs}
     * @memberof Csfb
     */
    'client'?: SctpClientConfigs;
}
/**
 * Full description of a CWF gateway
 * @export
 * @interface CwfGateway
 */
export interface CwfGateway {
    /**
     * 
     * @type {GatewayCwfConfigs}
     * @memberof CwfGateway
     */
    'carrier_wifi': GatewayCwfConfigs;
    /**
     * 
     * @type {string}
     * @memberof CwfGateway
     */
    'description': string;
    /**
     * 
     * @type {GatewayDevice}
     * @memberof CwfGateway
     */
    'device'?: GatewayDevice;
    /**
     * 
     * @type {string}
     * @memberof CwfGateway
     */
    'id': string;
    /**
     * 
     * @type {MagmadGatewayConfigs}
     * @memberof CwfGateway
     */
    'magmad': MagmadGatewayConfigs;
    /**
     * 
     * @type {string}
     * @memberof CwfGateway
     */
    'name': string;
    /**
     * 
     * @type {RegistrationInfo}
     * @memberof CwfGateway
     */
    'registration_info'?: RegistrationInfo;
    /**
     * 
     * @type {GatewayStatus}
     * @memberof CwfGateway
     */
    'status'?: GatewayStatus;
    /**
     * 
     * @type {string}
     * @memberof CwfGateway
     */
    'tier': string;
}
/**
 * HA Gateway pair in a Carrier Wifi Network
 * @export
 * @interface CwfHaPair
 */
export interface CwfHaPair {
    /**
     * 
     * @type {CwfHaPairConfigs}
     * @memberof CwfHaPair
     */
    'config': CwfHaPairConfigs;
    /**
     * 
     * @type {string}
     * @memberof CwfHaPair
     */
    'gateway_id_1': string;
    /**
     * 
     * @type {string}
     * @memberof CwfHaPair
     */
    'gateway_id_2': string;
    /**
     * 
     * @type {string}
     * @memberof CwfHaPair
     */
    'ha_pair_id': string;
    /**
     * 
     * @type {CarrierWifiHaPairState}
     * @memberof CwfHaPair
     */
    'state'?: CarrierWifiHaPairState;
}
/**
 * Configuration for HA Gateway pair in a Carrier Wifi Network
 * @export
 * @interface CwfHaPairConfigs
 */
export interface CwfHaPairConfigs {
    /**
     * 
     * @type {string}
     * @memberof CwfHaPairConfigs
     */
    'transport_virtual_ip': string;
}
/**
 * Carrier Wifi Network spec
 * @export
 * @interface CwfNetwork
 */
export interface CwfNetwork {
    /**
     * 
     * @type {NetworkCarrierWifiConfigs}
     * @memberof CwfNetwork
     */
    'carrier_wifi': NetworkCarrierWifiConfigs;
    /**
     * 
     * @type {string}
     * @memberof CwfNetwork
     */
    'description': string;
    /**
     * 
     * @type {NetworkDnsConfig}
     * @memberof CwfNetwork
     */
    'dns': NetworkDnsConfig;
    /**
     * 
     * @type {NetworkFeatures}
     * @memberof CwfNetwork
     */
    'features'?: NetworkFeatures;
    /**
     * 
     * @type {FederatedNetworkConfigs}
     * @memberof CwfNetwork
     */
    'federation': FederatedNetworkConfigs;
    /**
     * 
     * @type {string}
     * @memberof CwfNetwork
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CwfNetwork
     */
    'name': string;
    /**
     * 
     * @type {NetworkSubscriberConfig}
     * @memberof CwfNetwork
     */
    'subscriber_config'?: NetworkSubscriberConfig;
}
/**
 * CWF subscriber directory record
 * @export
 * @interface CwfSubscriberDirectoryRecord
 */
export interface CwfSubscriberDirectoryRecord {
    /**
     * 
     * @type {string}
     * @memberof CwfSubscriberDirectoryRecord
     */
    'ipv4_addr'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CwfSubscriberDirectoryRecord
     */
    'location_history': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof CwfSubscriberDirectoryRecord
     */
    'mac_addr'?: string;
}
/**
 * Diameter Configuration of The Client
 * @export
 * @interface DiameterClientConfigs
 */
export interface DiameterClientConfigs {
    /**
     * 
     * @type {string}
     * @memberof DiameterClientConfigs
     */
    'address'?: string;
    /**
     * 
     * @type {string}
     * @memberof DiameterClientConfigs
     */
    'dest_host'?: string;
    /**
     * 
     * @type {string}
     * @memberof DiameterClientConfigs
     */
    'dest_realm'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof DiameterClientConfigs
     */
    'disable_dest_host'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof DiameterClientConfigs
     */
    'host'?: string;
    /**
     * 
     * @type {string}
     * @memberof DiameterClientConfigs
     */
    'local_address'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof DiameterClientConfigs
     */
    'overwrite_dest_host'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof DiameterClientConfigs
     */
    'product_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof DiameterClientConfigs
     */
    'protocol'?: DiameterClientConfigsProtocolEnum;
    /**
     * 
     * @type {string}
     * @memberof DiameterClientConfigs
     */
    'realm'?: string;
    /**
     * 
     * @type {number}
     * @memberof DiameterClientConfigs
     */
    'request_timeout'?: number;
    /**
     * 
     * @type {number}
     * @memberof DiameterClientConfigs
     */
    'retransmits'?: number;
    /**
     * 
     * @type {number}
     * @memberof DiameterClientConfigs
     */
    'retry_count'?: number;
    /**
     * 
     * @type {number}
     * @memberof DiameterClientConfigs
     */
    'watchdog_interval'?: number;
}

export const DiameterClientConfigsProtocolEnum = {
    Tcp: 'tcp',
    Tcp4: 'tcp4',
    Tcp6: 'tcp6',
    Sctp: 'sctp',
    Sctp4: 'sctp4',
    Sctp6: 'sctp6'
} as const;

export type DiameterClientConfigsProtocolEnum = typeof DiameterClientConfigsProtocolEnum[keyof typeof DiameterClientConfigsProtocolEnum];

/**
 * Diameter Configuration of The Server
 * @export
 * @interface DiameterServerConfigs
 */
export interface DiameterServerConfigs {
    /**
     * 
     * @type {string}
     * @memberof DiameterServerConfigs
     */
    'address'?: string;
    /**
     * 
     * @type {string}
     * @memberof DiameterServerConfigs
     */
    'dest_host'?: string;
    /**
     * 
     * @type {string}
     * @memberof DiameterServerConfigs
     */
    'dest_realm'?: string;
    /**
     * 
     * @type {string}
     * @memberof DiameterServerConfigs
     */
    'local_address'?: string;
    /**
     * 
     * @type {string}
     * @memberof DiameterServerConfigs
     */
    'protocol'?: DiameterServerConfigsProtocolEnum;
}

export const DiameterServerConfigsProtocolEnum = {
    Tcp: 'tcp',
    Tcp4: 'tcp4',
    Tcp6: 'tcp6',
    Sctp: 'sctp',
    Sctp4: 'sctp4',
    Sctp6: 'sctp6'
} as const;

export type DiameterServerConfigsProtocolEnum = typeof DiameterServerConfigsProtocolEnum[keyof typeof DiameterServerConfigsProtocolEnum];

/**
 * 
 * @export
 * @interface DiskPartition
 */
export interface DiskPartition {
    /**
     * Name of the device
     * @type {string}
     * @memberof DiskPartition
     */
    'device'?: string;
    /**
     * Free disk space of the device in bytes
     * @type {number}
     * @memberof DiskPartition
     */
    'free'?: number;
    /**
     * Mount point of the device
     * @type {string}
     * @memberof DiskPartition
     */
    'mount_point'?: string;
    /**
     * Total disk space of the device in bytes
     * @type {number}
     * @memberof DiskPartition
     */
    'total'?: number;
    /**
     * Used disk space of the device in bytes
     * @type {number}
     * @memberof DiskPartition
     */
    'used'?: number;
}
/**
 * 
 * @export
 * @interface DistributionPackage
 */
export interface DistributionPackage {
    /**
     * 
     * @type {string}
     * @memberof DistributionPackage
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof DistributionPackage
     */
    'version'?: string;
}
/**
 * Mapping used for DNS resolving from a domain
 * @export
 * @interface DnsConfigRecord
 */
export interface DnsConfigRecord {
    /**
     * 
     * @type {Array<string>}
     * @memberof DnsConfigRecord
     */
    'a_record'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof DnsConfigRecord
     */
    'aaaa_record'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof DnsConfigRecord
     */
    'cname_record'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof DnsConfigRecord
     */
    'domain': string;
}
/**
 * eap_aka configuration
 * @export
 * @interface EapAka
 */
export interface EapAka {
    /**
     * 
     * @type {number}
     * @memberof EapAka
     */
    'mnc_len'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof EapAka
     */
    'plmn_ids'?: Array<string>;
    /**
     * 
     * @type {EapAkaTimeouts}
     * @memberof EapAka
     */
    'timeout'?: EapAkaTimeouts;
    /**
     * 
     * @type {boolean}
     * @memberof EapAka
     */
    'use_s6a'?: boolean;
}
/**
 * 
 * @export
 * @interface EapAkaTimeouts
 */
export interface EapAkaTimeouts {
    /**
     * 
     * @type {number}
     * @memberof EapAkaTimeouts
     */
    'challenge_ms'?: number;
    /**
     * 
     * @type {number}
     * @memberof EapAkaTimeouts
     */
    'error_notification_ms'?: number;
    /**
     * 
     * @type {number}
     * @memberof EapAkaTimeouts
     */
    'session_authenticated_ms'?: number;
    /**
     * 
     * @type {number}
     * @memberof EapAkaTimeouts
     */
    'session_ms'?: number;
}
/**
 * eap_sim configuration
 * @export
 * @interface EapSim
 */
export interface EapSim {
    /**
     * 
     * @type {number}
     * @memberof EapSim
     */
    'mnc_len'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof EapSim
     */
    'plmn_ids'?: Array<string>;
    /**
     * 
     * @type {EapSimTimeouts}
     * @memberof EapSim
     */
    'timeout'?: EapSimTimeouts;
    /**
     * 
     * @type {boolean}
     * @memberof EapSim
     */
    'use_s6a'?: boolean;
}
/**
 * 
 * @export
 * @interface EapSimTimeouts
 */
export interface EapSimTimeouts {
    /**
     * 
     * @type {number}
     * @memberof EapSimTimeouts
     */
    'challenge_ms'?: number;
    /**
     * 
     * @type {number}
     * @memberof EapSimTimeouts
     */
    'error_notification_ms'?: number;
    /**
     * 
     * @type {number}
     * @memberof EapSimTimeouts
     */
    'session_authenticated_ms'?: number;
    /**
     * 
     * @type {number}
     * @memberof EapSimTimeouts
     */
    'session_ms'?: number;
}
/**
 * 
 * @export
 * @interface ElasticHit
 */
export interface ElasticHit {
    /**
     * 
     * @type {string}
     * @memberof ElasticHit
     */
    '_id': string;
    /**
     * 
     * @type {string}
     * @memberof ElasticHit
     */
    '_index': string;
    /**
     * 
     * @type {string}
     * @memberof ElasticHit
     */
    '_primary_term'?: string;
    /**
     * 
     * @type {number}
     * @memberof ElasticHit
     */
    '_score'?: number;
    /**
     * 
     * @type {number}
     * @memberof ElasticHit
     */
    '_seq_no'?: number;
    /**
     * 
     * @type {Array<number>}
     * @memberof ElasticHit
     */
    '_sort'?: Array<number>;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ElasticHit
     */
    '_source': { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof ElasticHit
     */
    '_type': string;
}
/**
 * 
 * @export
 * @interface EmailReceiver
 */
export interface EmailReceiver {
    /**
     * 
     * @type {string}
     * @memberof EmailReceiver
     */
    'auth_identity'?: string;
    /**
     * 
     * @type {string}
     * @memberof EmailReceiver
     */
    'auth_password'?: string;
    /**
     * 
     * @type {string}
     * @memberof EmailReceiver
     */
    'auth_secret'?: string;
    /**
     * 
     * @type {string}
     * @memberof EmailReceiver
     */
    'auth_username'?: string;
    /**
     * 
     * @type {string}
     * @memberof EmailReceiver
     */
    'from': string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof EmailReceiver
     */
    'headers'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof EmailReceiver
     */
    'hello'?: string;
    /**
     * 
     * @type {string}
     * @memberof EmailReceiver
     */
    'html'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof EmailReceiver
     */
    'send_resolved'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof EmailReceiver
     */
    'smarthost': string;
    /**
     * 
     * @type {string}
     * @memberof EmailReceiver
     */
    'text'?: string;
    /**
     * 
     * @type {string}
     * @memberof EmailReceiver
     */
    'to': string;
}
/**
 * Representation of an enodeB
 * @export
 * @interface Enodeb
 */
export interface Enodeb {
    /**
     * 
     * @type {string}
     * @memberof Enodeb
     */
    'attached_gateway_id'?: string;
    /**
     * 
     * @type {EnodebConfiguration}
     * @memberof Enodeb
     */
    'config': EnodebConfiguration;
    /**
     * 
     * @type {string}
     * @memberof Enodeb
     */
    'description'?: string;
    /**
     * 
     * @type {EnodebConfig}
     * @memberof Enodeb
     */
    'enodeb_config'?: EnodebConfig;
    /**
     * 
     * @type {string}
     * @memberof Enodeb
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Enodeb
     */
    'serial': string;
}
/**
 * Configuration for managed / unmanaged eNodeb
 * @export
 * @interface EnodebConfig
 */
export interface EnodebConfig {
    /**
     * 
     * @type {string}
     * @memberof EnodebConfig
     */
    'config_type': EnodebConfigConfigTypeEnum;
    /**
     * 
     * @type {EnodebConfiguration}
     * @memberof EnodebConfig
     */
    'managed_config'?: EnodebConfiguration;
    /**
     * 
     * @type {UnmanagedEnodebConfiguration}
     * @memberof EnodebConfig
     */
    'unmanaged_config'?: UnmanagedEnodebConfiguration;
}

export const EnodebConfigConfigTypeEnum = {
    Managed: 'MANAGED',
    Unmanaged: 'UNMANAGED'
} as const;

export type EnodebConfigConfigTypeEnum = typeof EnodebConfigConfigTypeEnum[keyof typeof EnodebConfigConfigTypeEnum];

/**
 * Configuration for an enodeB. Unfilled fields will be inherited from LTE network and gateway configuration.
 * @export
 * @interface EnodebConfiguration
 */
export interface EnodebConfiguration {
    /**
     * 
     * @type {number}
     * @memberof EnodebConfiguration
     */
    'bandwidth_mhz'?: number;
    /**
     * 
     * @type {number}
     * @memberof EnodebConfiguration
     */
    'cell_id': number;
    /**
     * 
     * @type {string}
     * @memberof EnodebConfiguration
     */
    'device_class': EnodebConfigurationDeviceClassEnum;
    /**
     * 
     * @type {number}
     * @memberof EnodebConfiguration
     */
    'earfcndl'?: number;
    /**
     * 
     * @type {number}
     * @memberof EnodebConfiguration
     */
    'pci'?: number;
    /**
     * 
     * @type {number}
     * @memberof EnodebConfiguration
     */
    'special_subframe_pattern'?: number;
    /**
     * 
     * @type {number}
     * @memberof EnodebConfiguration
     */
    'subframe_assignment'?: number;
    /**
     * 
     * @type {number}
     * @memberof EnodebConfiguration
     */
    'tac'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof EnodebConfiguration
     */
    'transmit_enabled': boolean;
}

export const EnodebConfigurationDeviceClassEnum = {
    BaicellsNova233G2OdFdd: 'Baicells Nova-233 G2 OD FDD',
    BaicellsNova243OdTdd: 'Baicells Nova-243 OD TDD',
    BaicellsNeutrino224IdFdd: 'Baicells Neutrino 224 ID FDD',
    BaicellsIdTddFdd: 'Baicells ID TDD/FDD',
    NuRanCaviumOcLte: 'NuRAN Cavium OC-LTE',
    FreedomFiOne: 'FreedomFi One'
} as const;

export type EnodebConfigurationDeviceClassEnum = typeof EnodebConfigurationDeviceClassEnum[keyof typeof EnodebConfigurationDeviceClassEnum];

/**
 * Single Enodeb State
 * @export
 * @interface EnodebState
 */
export interface EnodebState {
    /**
     * 
     * @type {boolean}
     * @memberof EnodebState
     */
    'enodeb_configured': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof EnodebState
     */
    'enodeb_connected': boolean;
    /**
     * 
     * @type {string}
     * @memberof EnodebState
     */
    'fsm_state': string;
    /**
     * 
     * @type {boolean}
     * @memberof EnodebState
     */
    'gps_connected': boolean;
    /**
     * 
     * @type {string}
     * @memberof EnodebState
     */
    'gps_latitude': string;
    /**
     * 
     * @type {string}
     * @memberof EnodebState
     */
    'gps_longitude': string;
    /**
     * 
     * @type {string}
     * @memberof EnodebState
     */
    'ip_address'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof EnodebState
     */
    'mme_connected': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof EnodebState
     */
    'opstate_enabled': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof EnodebState
     */
    'ptp_connected': boolean;
    /**
     * Gateway ID from which the enodeb state was reported
     * @type {string}
     * @memberof EnodebState
     */
    'reporting_gateway_id'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof EnodebState
     */
    'rf_tx_desired': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof EnodebState
     */
    'rf_tx_on': boolean;
    /**
     * Time at which the state was reported in ms
     * @type {number}
     * @memberof EnodebState
     */
    'time_reported'?: number;
    /**
     * 
     * @type {number}
     * @memberof EnodebState
     */
    'ues_connected'?: number;
}
/**
 * 
 * @export
 * @interface Event
 */
export interface Event {
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'event_type': string;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'hardware_id': string;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'stream_name': string;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'tag': string;
    /**
     * The timestamp in ISO 8601 format
     * @type {string}
     * @memberof Event
     */
    'timestamp': string;
    /**
     * 
     * @type {object}
     * @memberof Event
     */
    'value': object;
}
/**
 * Mapping for PLMN, imsi ranges, vs its gateway mode
 * @export
 * @interface FederatedModeMap
 */
export interface FederatedModeMap {
    /**
     * If Enabled is false, mapping will not be applied
     * @type {boolean}
     * @memberof FederatedModeMap
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {Array<ModeMapItem>}
     * @memberof FederatedModeMap
     */
    'mapping'?: Array<ModeMapItem>;
}
/**
 * Configs for networks that are federated
 * @export
 * @interface FederatedNetworkConfigs
 */
export interface FederatedNetworkConfigs {
    /**
     * 
     * @type {FederatedModeMap}
     * @memberof FederatedNetworkConfigs
     */
    'federated_modes_mapping'?: FederatedModeMap;
    /**
     * 
     * @type {string}
     * @memberof FederatedNetworkConfigs
     */
    'feg_network_id': string;
}
/**
 * Full description of a federation gateway
 * @export
 * @interface FederationGateway
 */
export interface FederationGateway {
    /**
     * 
     * @type {string}
     * @memberof FederationGateway
     */
    'description': string;
    /**
     * 
     * @type {GatewayDevice}
     * @memberof FederationGateway
     */
    'device'?: GatewayDevice;
    /**
     * 
     * @type {GatewayFederationConfigs}
     * @memberof FederationGateway
     */
    'federation': GatewayFederationConfigs;
    /**
     * 
     * @type {string}
     * @memberof FederationGateway
     */
    'id': string;
    /**
     * 
     * @type {MagmadGatewayConfigs}
     * @memberof FederationGateway
     */
    'magmad': MagmadGatewayConfigs;
    /**
     * 
     * @type {string}
     * @memberof FederationGateway
     */
    'name': string;
    /**
     * 
     * @type {RegistrationInfo}
     * @memberof FederationGateway
     */
    'registration_info'?: RegistrationInfo;
    /**
     * 
     * @type {GatewayStatus}
     * @memberof FederationGateway
     */
    'status'?: GatewayStatus;
    /**
     * 
     * @type {string}
     * @memberof FederationGateway
     */
    'tier': string;
}
/**
 * Health status of a Federation Gateway
 * @export
 * @interface FederationGatewayHealthStatus
 */
export interface FederationGatewayHealthStatus {
    /**
     * 
     * @type {string}
     * @memberof FederationGatewayHealthStatus
     */
    'description': string;
    /**
     * 
     * @type {{ [key: string]: ServiceStatusHealth; }}
     * @memberof FederationGatewayHealthStatus
     */
    'service_status'?: { [key: string]: ServiceStatusHealth; };
    /**
     * 
     * @type {string}
     * @memberof FederationGatewayHealthStatus
     */
    'status': FederationGatewayHealthStatusStatusEnum;
}

export const FederationGatewayHealthStatusStatusEnum = {
    Healthy: 'HEALTHY',
    Unhealthy: 'UNHEALTHY'
} as const;

export type FederationGatewayHealthStatusStatusEnum = typeof FederationGatewayHealthStatusStatusEnum[keyof typeof FederationGatewayHealthStatusStatusEnum];

/**
 * Status of a Federation HA cluster
 * @export
 * @interface FederationNetworkClusterStatus
 */
export interface FederationNetworkClusterStatus {
    /**
     * 
     * @type {string}
     * @memberof FederationNetworkClusterStatus
     */
    'active_gateway': string;
}
/**
 * Federated LTE Network spec
 * @export
 * @interface FegLteNetwork
 */
export interface FegLteNetwork {
    /**
     * 
     * @type {NetworkCellularConfigs}
     * @memberof FegLteNetwork
     */
    'cellular': NetworkCellularConfigs;
    /**
     * 
     * @type {string}
     * @memberof FegLteNetwork
     */
    'description': string;
    /**
     * 
     * @type {NetworkDnsConfig}
     * @memberof FegLteNetwork
     */
    'dns': NetworkDnsConfig;
    /**
     * 
     * @type {NetworkFeatures}
     * @memberof FegLteNetwork
     */
    'features'?: NetworkFeatures;
    /**
     * 
     * @type {FederatedNetworkConfigs}
     * @memberof FegLteNetwork
     */
    'federation': FederatedNetworkConfigs;
    /**
     * 
     * @type {string}
     * @memberof FegLteNetwork
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof FegLteNetwork
     */
    'name': string;
}
/**
 * Federation Network spec
 * @export
 * @interface FegNetwork
 */
export interface FegNetwork {
    /**
     * 
     * @type {string}
     * @memberof FegNetwork
     */
    'description': string;
    /**
     * 
     * @type {NetworkDnsConfig}
     * @memberof FegNetwork
     */
    'dns': NetworkDnsConfig;
    /**
     * 
     * @type {NetworkFeatures}
     * @memberof FegNetwork
     */
    'features'?: NetworkFeatures;
    /**
     * 
     * @type {NetworkFederationConfigs}
     * @memberof FegNetwork
     */
    'federation': NetworkFederationConfigs;
    /**
     * 
     * @type {string}
     * @memberof FegNetwork
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof FegNetwork
     */
    'name': string;
    /**
     * 
     * @type {NetworkSubscriberConfig}
     * @memberof FegNetwork
     */
    'subscriber_config'?: NetworkSubscriberConfig;
}
/**
 * 
 * @export
 * @interface FlowDescription
 */
export interface FlowDescription {
    /**
     * 
     * @type {string}
     * @memberof FlowDescription
     */
    'action': FlowDescriptionActionEnum;
    /**
     * 
     * @type {FlowMatch}
     * @memberof FlowDescription
     */
    'match': FlowMatch;
}

export const FlowDescriptionActionEnum = {
    Permit: 'PERMIT',
    Deny: 'DENY'
} as const;

export type FlowDescriptionActionEnum = typeof FlowDescriptionActionEnum[keyof typeof FlowDescriptionActionEnum];

/**
 * 
 * @export
 * @interface FlowMatch
 */
export interface FlowMatch {
    /**
     * 
     * @type {string}
     * @memberof FlowMatch
     */
    'direction': FlowMatchDirectionEnum;
    /**
     * 
     * @type {IpAddress}
     * @memberof FlowMatch
     */
    'ip_dst'?: IpAddress;
    /**
     * 
     * @type {string}
     * @memberof FlowMatch
     */
    'ip_proto': FlowMatchIpProtoEnum;
    /**
     * 
     * @type {IpAddress}
     * @memberof FlowMatch
     */
    'ip_src'?: IpAddress;
    /**
     * 
     * @type {string}
     * @memberof FlowMatch
     */
    'ipv4_dst'?: string;
    /**
     * 
     * @type {string}
     * @memberof FlowMatch
     */
    'ipv4_src'?: string;
    /**
     * 
     * @type {number}
     * @memberof FlowMatch
     */
    'tcp_dst'?: number;
    /**
     * 
     * @type {number}
     * @memberof FlowMatch
     */
    'tcp_src'?: number;
    /**
     * 
     * @type {number}
     * @memberof FlowMatch
     */
    'udp_dst'?: number;
    /**
     * 
     * @type {number}
     * @memberof FlowMatch
     */
    'udp_src'?: number;
}

export const FlowMatchDirectionEnum = {
    Uplink: 'UPLINK',
    Downlink: 'DOWNLINK'
} as const;

export type FlowMatchDirectionEnum = typeof FlowMatchDirectionEnum[keyof typeof FlowMatchDirectionEnum];
export const FlowMatchIpProtoEnum = {
    Ip: 'IPPROTO_IP',
    Tcp: 'IPPROTO_TCP',
    Udp: 'IPPROTO_UDP',
    Icmp: 'IPPROTO_ICMP'
} as const;

export type FlowMatchIpProtoEnum = typeof FlowMatchIpProtoEnum[keyof typeof FlowMatchIpProtoEnum];

/**
 * 
 * @export
 * @interface FlowQos
 */
export interface FlowQos {
    /**
     * 
     * @type {number}
     * @memberof FlowQos
     */
    'max_req_bw_dl': number;
    /**
     * 
     * @type {number}
     * @memberof FlowQos
     */
    'max_req_bw_ul': number;
}
/**
 * 
 * @export
 * @interface FrequencyPreferences
 */
export interface FrequencyPreferences {
    /**
     * preferred bandwidth of sas channel
     * @type {number}
     * @memberof FrequencyPreferences
     */
    'bandwidth_mhz': number;
    /**
     * list of preferred frequencies (midpoints) of sas channels
     * @type {Array<number>}
     * @memberof FrequencyPreferences
     */
    'frequencies_mhz': Array<number>;
}
/**
 * Cellular configuration for LTE gateway
 * @export
 * @interface GatewayCellularConfigs
 */
export interface GatewayCellularConfigs {
    /**
     * 
     * @type {GatewayDnsConfigs}
     * @memberof GatewayCellularConfigs
     */
    'dns'?: GatewayDnsConfigs;
    /**
     * 
     * @type {GatewayEpcConfigs}
     * @memberof GatewayCellularConfigs
     */
    'epc': GatewayEpcConfigs;
    /**
     * 
     * @type {GatewayHeConfig}
     * @memberof GatewayCellularConfigs
     */
    'he_config'?: GatewayHeConfig;
    /**
     * 
     * @type {GatewayNgcConfigs}
     * @memberof GatewayCellularConfigs
     */
    'ngc'?: GatewayNgcConfigs;
    /**
     * 
     * @type {GatewayNonEpsConfigs}
     * @memberof GatewayCellularConfigs
     */
    'non_eps_service'?: GatewayNonEpsConfigs;
    /**
     * 
     * @type {Array<CellularGatewayPoolRecord>}
     * @memberof GatewayCellularConfigs
     */
    'pooling'?: Array<CellularGatewayPoolRecord>;
    /**
     * 
     * @type {GatewayRanConfigs}
     * @memberof GatewayCellularConfigs
     */
    'ran': GatewayRanConfigs;
}
/**
 * CWF configuration for a gateway
 * @export
 * @interface GatewayCwfConfigs
 */
export interface GatewayCwfConfigs {
    /**
     * 
     * @type {Array<AllowedGrePeer>}
     * @memberof GatewayCwfConfigs
     */
    'allowed_gre_peers': Array<AllowedGrePeer>;
    /**
     * 
     * @type {GatewayHealthConfigs}
     * @memberof GatewayCwfConfigs
     */
    'gateway_health_configs'?: GatewayHealthConfigs;
    /**
     * 
     * @type {IpdrExportDst}
     * @memberof GatewayCwfConfigs
     */
    'ipdr_export_dst'?: IpdrExportDst;
}
/**
 * Information about the physical device corresponding to a gateway
 * @export
 * @interface GatewayDevice
 */
export interface GatewayDevice {
    /**
     * 
     * @type {string}
     * @memberof GatewayDevice
     */
    'hardware_id': string;
    /**
     * 
     * @type {ChallengeKey}
     * @memberof GatewayDevice
     */
    'key': ChallengeKey;
}
/**
 * DNS configuration for a gateway
 * @export
 * @interface GatewayDnsConfigs
 */
export interface GatewayDnsConfigs {
    /**
     * 
     * @type {boolean}
     * @memberof GatewayDnsConfigs
     */
    'dhcp_server_enabled': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GatewayDnsConfigs
     */
    'enable_caching': boolean;
    /**
     * 
     * @type {number}
     * @memberof GatewayDnsConfigs
     */
    'local_ttl': number;
    /**
     * 
     * @type {Array<DnsConfigRecord>}
     * @memberof GatewayDnsConfigs
     */
    'records'?: Array<DnsConfigRecord>;
}
/**
 * EPC configuration for an LTE gateway
 * @export
 * @interface GatewayEpcConfigs
 */
export interface GatewayEpcConfigs {
    /**
     * Flag to enable or disable congestion control on MME
     * @type {boolean}
     * @memberof GatewayEpcConfigs
     */
    'congestion_control_enabled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof GatewayEpcConfigs
     */
    'dns_primary'?: string;
    /**
     * 
     * @type {string}
     * @memberof GatewayEpcConfigs
     */
    'dns_secondary'?: string;
    /**
     * 
     * @type {string}
     * @memberof GatewayEpcConfigs
     */
    'ip_block': string;
    /**
     * IP address for IPv4 P-CSCF on the AGW
     * @type {string}
     * @memberof GatewayEpcConfigs
     */
    'ipv4_p_cscf_addr'?: string;
    /**
     * IP address for IPv4 S1U endpoint on the AGW
     * @type {string}
     * @memberof GatewayEpcConfigs
     */
    'ipv4_sgw_s1u_addr'?: string;
    /**
     * 
     * @type {string}
     * @memberof GatewayEpcConfigs
     */
    'ipv6_block'?: string;
    /**
     * IPv6 DNS Server address on the AGW
     * @type {string}
     * @memberof GatewayEpcConfigs
     */
    'ipv6_dns_addr'?: string;
    /**
     * IP address for IPv6 P-CSCF on the AGW
     * @type {string}
     * @memberof GatewayEpcConfigs
     */
    'ipv6_p_cscf_addr'?: string;
    /**
     * 
     * @type {string}
     * @memberof GatewayEpcConfigs
     */
    'ipv6_prefix_allocation_mode'?: GatewayEpcConfigsIpv6PrefixAllocationModeEnum;
    /**
     * 
     * @type {boolean}
     * @memberof GatewayEpcConfigs
     */
    'nat_enabled': boolean;
    /**
     * UPF Node Identifier
     * @type {string}
     * @memberof GatewayEpcConfigs
     */
    'node_identifier'?: string;
    /**
     * IP address of gateway for management interface on the AGW
     * @type {string}
     * @memberof GatewayEpcConfigs
     */
    'sgi_management_iface_gw'?: string;
    /**
     * IPv6 address for management interface on the AGW in CIDR format
     * @type {string}
     * @memberof GatewayEpcConfigs
     */
    'sgi_management_iface_ipv6_addr'?: string;
    /**
     * IPv6 address of gateway for management interface on the AGW
     * @type {string}
     * @memberof GatewayEpcConfigs
     */
    'sgi_management_iface_ipv6_gw'?: string;
    /**
     * IP address for management interface on the AGW, If not specified AGW uses DHCP to configure it.
     * @type {string}
     * @memberof GatewayEpcConfigs
     */
    'sgi_management_iface_static_ip'?: string;
    /**
     * VLAN ID for management interface traffic on the AGW
     * @type {string}
     * @memberof GatewayEpcConfigs
     */
    'sgi_management_iface_vlan'?: string;
    /**
     * Interval in seconds between gateway requests to sync its subscriberdb with the cloud.
     * @type {number}
     * @memberof GatewayEpcConfigs
     */
    'subscriberdb_sync_interval'?: number;
}

export const GatewayEpcConfigsIpv6PrefixAllocationModeEnum = {
    Random: 'RANDOM',
    Hash: 'HASH'
} as const;

export type GatewayEpcConfigsIpv6PrefixAllocationModeEnum = typeof GatewayEpcConfigsIpv6PrefixAllocationModeEnum[keyof typeof GatewayEpcConfigsIpv6PrefixAllocationModeEnum];

/**
 * Federation configuration for a gateway
 * @export
 * @interface GatewayFederationConfigs
 */
export interface GatewayFederationConfigs {
    /**
     * 
     * @type {AaaServer}
     * @memberof GatewayFederationConfigs
     */
    'aaa_server': AaaServer;
    /**
     * 
     * @type {Csfb}
     * @memberof GatewayFederationConfigs
     */
    'csfb'?: Csfb;
    /**
     * 
     * @type {EapAka}
     * @memberof GatewayFederationConfigs
     */
    'eap_aka': EapAka;
    /**
     * 
     * @type {EapSim}
     * @memberof GatewayFederationConfigs
     */
    'eap_sim'?: EapSim;
    /**
     * 
     * @type {Gx}
     * @memberof GatewayFederationConfigs
     */
    'gx': Gx;
    /**
     * 
     * @type {Gy}
     * @memberof GatewayFederationConfigs
     */
    'gy': Gy;
    /**
     * 
     * @type {Health}
     * @memberof GatewayFederationConfigs
     */
    'health': Health;
    /**
     * 
     * @type {Hss}
     * @memberof GatewayFederationConfigs
     */
    'hss': Hss;
    /**
     * neutral host PLMN ID to serving FeG network routes
     * @type {{ [key: string]: string; }}
     * @memberof GatewayFederationConfigs
     */
    'nh_routes'?: { [key: string]: string; };
    /**
     * 
     * @type {S6a}
     * @memberof GatewayFederationConfigs
     */
    's6a': S6a;
    /**
     * 
     * @type {S8}
     * @memberof GatewayFederationConfigs
     */
    's8'?: S8;
    /**
     * served network IDs
     * @type {Array<string>}
     * @memberof GatewayFederationConfigs
     */
    'served_network_ids': Array<string>;
    /**
     * served neutral host IDs
     * @type {Array<string>}
     * @memberof GatewayFederationConfigs
     */
    'served_nh_ids'?: Array<string>;
    /**
     * 
     * @type {Swx}
     * @memberof GatewayFederationConfigs
     */
    'swx': Swx;
}
/**
 * Header Enrichment configuration
 * @export
 * @interface GatewayHeConfig
 */
export interface GatewayHeConfig {
    /**
     * True if headers should be encrypted
     * @type {boolean}
     * @memberof GatewayHeConfig
     */
    'enable_encryption': boolean;
    /**
     * True if header enrichment feature should be disabled for gateway
     * @type {boolean}
     * @memberof GatewayHeConfig
     */
    'enable_header_enrichment': boolean;
    /**
     * Key to be used in header encryption
     * @type {string}
     * @memberof GatewayHeConfig
     */
    'encryption_key'?: string;
    /**
     * 
     * @type {string}
     * @memberof GatewayHeConfig
     */
    'he_encoding_type': GatewayHeConfigHeEncodingTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof GatewayHeConfig
     */
    'he_encryption_algorithm': GatewayHeConfigHeEncryptionAlgorithmEnum;
    /**
     * 
     * @type {string}
     * @memberof GatewayHeConfig
     */
    'he_hash_function': GatewayHeConfigHeHashFunctionEnum;
    /**
     * Hmac key to be used in header encryption
     * @type {string}
     * @memberof GatewayHeConfig
     */
    'hmac_key'?: string;
}

export const GatewayHeConfigHeEncodingTypeEnum = {
    Base64: 'BASE64',
    Hex2Bin: 'HEX2BIN'
} as const;

export type GatewayHeConfigHeEncodingTypeEnum = typeof GatewayHeConfigHeEncodingTypeEnum[keyof typeof GatewayHeConfigHeEncodingTypeEnum];
export const GatewayHeConfigHeEncryptionAlgorithmEnum = {
    Rc4: 'RC4',
    Aes256CbcHmacMd5: 'AES256_CBC_HMAC_MD5',
    Aes256EcbHmacMd5: 'AES256_ECB_HMAC_MD5',
    GzippedAes256EcbSha1: 'GZIPPED_AES256_ECB_SHA1'
} as const;

export type GatewayHeConfigHeEncryptionAlgorithmEnum = typeof GatewayHeConfigHeEncryptionAlgorithmEnum[keyof typeof GatewayHeConfigHeEncryptionAlgorithmEnum];
export const GatewayHeConfigHeHashFunctionEnum = {
    Md5: 'MD5',
    Hex: 'HEX',
    Sha256: 'SHA256'
} as const;

export type GatewayHeConfigHeHashFunctionEnum = typeof GatewayHeConfigHeHashFunctionEnum[keyof typeof GatewayHeConfigHeHashFunctionEnum];

/**
 * Configuration threshold for gateway health service
 * @export
 * @interface GatewayHealthConfigs
 */
export interface GatewayHealthConfigs {
    /**
     * 
     * @type {number}
     * @memberof GatewayHealthConfigs
     */
    'cpu_util_threshold_pct'?: number;
    /**
     * 
     * @type {number}
     * @memberof GatewayHealthConfigs
     */
    'gre_probe_interval_secs'?: number;
    /**
     * 
     * @type {number}
     * @memberof GatewayHealthConfigs
     */
    'icmp_probe_pkt_count'?: number;
    /**
     * 
     * @type {number}
     * @memberof GatewayHealthConfigs
     */
    'mem_util_threshold_pct'?: number;
}
/**
 * Configuration for gateway logging (local and aggregation configs)
 * @export
 * @interface GatewayLoggingConfigs
 */
export interface GatewayLoggingConfigs {
    /**
     * 
     * @type {AggregationLoggingConfigs}
     * @memberof GatewayLoggingConfigs
     */
    'aggregation'?: AggregationLoggingConfigs;
    /**
     * 
     * @type {number}
     * @memberof GatewayLoggingConfigs
     */
    'event_verbosity'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof GatewayLoggingConfigs
     */
    'log_level': GatewayLoggingConfigsLogLevelEnum;
}

export const GatewayLoggingConfigsLogLevelEnum = {
    Debug: 'DEBUG',
    Info: 'INFO',
    Warning: 'WARNING',
    Error: 'ERROR',
    Fatal: 'FATAL'
} as const;

export type GatewayLoggingConfigsLogLevelEnum = typeof GatewayLoggingConfigsLogLevelEnum[keyof typeof GatewayLoggingConfigsLogLevelEnum];

/**
 * NextGeneration Core configuration for gateway
 * @export
 * @interface GatewayNgcConfigs
 */
export interface GatewayNgcConfigs {
    /**
     * AMF Default Slice Descriptor. This is an optional parameter that complements the Slice/Service type(s) to allow to differentiate amongst multiple Network Slices of the same Slice/Service type. This IE shall be absent if no SD value is associated with the SST. Range is 0-FFFFFF. See clause 28.4.2 of 3GPP TS 23.003.
     * @type {string}
     * @memberof GatewayNgcConfigs
     */
    'amf_default_sd'?: string;
    /**
     * AMF Default Slice Service Type. Values 0 to 127 correspond to the standardized SST range. Values 128 to 255 correspond to the Operator-specific range. See clause 28.4.2 of 3GPP TS 23.003. Standardized values are defined in clause 5.15.2.2 of 3GPP TS 23.501.
     * @type {number}
     * @memberof GatewayNgcConfigs
     */
    'amf_default_sst'?: number;
    /**
     * FQDN (Fully Qualified Domain Name) of the AMF as defined in clause 28.3.2.5 of 3GPP TS 23.003.
     * @type {string}
     * @memberof GatewayNgcConfigs
     */
    'amf_name'?: string;
    /**
     * String identifying the AMF Pointer (6 bits), range is 0-3F, as specified in clause 2.10.1 of 3GPP TS 23.003.
     * @type {string}
     * @memberof GatewayNgcConfigs
     */
    'amf_pointer'?: string;
    /**
     * String identifying the AMF Region ID (8 bits), range is 0-FF, as specified in clause 2.10.1 of 3GPP TS 23.003.
     * @type {string}
     * @memberof GatewayNgcConfigs
     */
    'amf_region_id'?: string;
    /**
     * String identifying the AMF Set ID (10 bits), range is 0-3FF, as specified in clause 2.10.1 of 3GPP TS 23.003.
     * @type {string}
     * @memberof GatewayNgcConfigs
     */
    'amf_set_id'?: string;
}
/**
 * Non-EPS service configuration for a gateway
 * @export
 * @interface GatewayNonEpsConfigs
 */
export interface GatewayNonEpsConfigs {
    /**
     * 
     * @type {Array<number>}
     * @memberof GatewayNonEpsConfigs
     */
    'arfcn_2g'?: Array<number>;
    /**
     * 
     * @type {string}
     * @memberof GatewayNonEpsConfigs
     */
    'csfb_mcc'?: string;
    /**
     * 
     * @type {string}
     * @memberof GatewayNonEpsConfigs
     */
    'csfb_mnc'?: string;
    /**
     * 
     * @type {number}
     * @memberof GatewayNonEpsConfigs
     */
    'csfb_rat'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof GatewayNonEpsConfigs
     */
    'lac'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof GatewayNonEpsConfigs
     */
    'non_eps_service_control': number;
}
/**
 * RAN configuration for LTE gateway
 * @export
 * @interface GatewayRanConfigs
 */
export interface GatewayRanConfigs {
    /**
     * 
     * @type {number}
     * @memberof GatewayRanConfigs
     */
    'pci': number;
    /**
     * 
     * @type {boolean}
     * @memberof GatewayRanConfigs
     */
    'transmit_enabled': boolean;
}
/**
 * 
 * @export
 * @interface GatewayStatus
 */
export interface GatewayStatus {
    /**
     * 
     * @type {number}
     * @memberof GatewayStatus
     */
    'cert_expiration_time'?: number;
    /**
     * 
     * @type {number}
     * @memberof GatewayStatus
     */
    'checkin_time'?: number;
    /**
     * 
     * @type {string}
     * @memberof GatewayStatus
     */
    'hardware_id'?: string;
    /**
     * deprecated
     * @type {string}
     * @memberof GatewayStatus
     */
    'kernel_version'?: string;
    /**
     * deprecated
     * @type {Array<string>}
     * @memberof GatewayStatus
     */
    'kernel_versions_installed'?: Array<string>;
    /**
     * 
     * @type {MachineInfo}
     * @memberof GatewayStatus
     */
    'machine_info'?: MachineInfo;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof GatewayStatus
     */
    'meta'?: { [key: string]: string; };
    /**
     * 
     * @type {PlatformInfo}
     * @memberof GatewayStatus
     */
    'platform_info'?: PlatformInfo;
    /**
     * 
     * @type {SystemStatus}
     * @memberof GatewayStatus
     */
    'system_status'?: SystemStatus;
    /**
     * deprecated
     * @type {string}
     * @memberof GatewayStatus
     */
    'version'?: string;
    /**
     * deprecated
     * @type {string}
     * @memberof GatewayStatus
     */
    'vpn_ip'?: string;
}
/**
 * Configuration for gateway VPN access
 * @export
 * @interface GatewayVpnConfigs
 */
export interface GatewayVpnConfigs {
    /**
     * 
     * @type {boolean}
     * @memberof GatewayVpnConfigs
     */
    'enable_shell': boolean;
}
/**
 * Guaranteed bit rate
 * @export
 * @interface Gbr
 */
export interface Gbr {
    /**
     * 
     * @type {number}
     * @memberof Gbr
     */
    'downlink': number;
    /**
     * 
     * @type {number}
     * @memberof Gbr
     */
    'uplink': number;
}
/**
 * 
 * @export
 * @interface GenericCommandParams
 */
export interface GenericCommandParams {
    /**
     * 
     * @type {string}
     * @memberof GenericCommandParams
     */
    'command': string;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof GenericCommandParams
     */
    'params'?: { [key: string]: object; };
}
/**
 * 
 * @export
 * @interface GenericCommandResponse
 */
export interface GenericCommandResponse {
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof GenericCommandResponse
     */
    'response'?: { [key: string]: object; };
}
/**
 * 
 * @export
 * @interface GettableAlert
 */
export interface GettableAlert {
    /**
     * 
     * @type {string}
     * @memberof GettableAlert
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface GettableAlertSilencer
 */
export interface GettableAlertSilencer {
    /**
     * 
     * @type {string}
     * @memberof GettableAlertSilencer
     */
    'comment': string;
    /**
     * 
     * @type {string}
     * @memberof GettableAlertSilencer
     */
    'createdBy': string;
    /**
     * 
     * @type {string}
     * @memberof GettableAlertSilencer
     */
    'endsAt': string;
    /**
     * 
     * @type {Array<Matcher>}
     * @memberof GettableAlertSilencer
     */
    'matchers': Array<Matcher>;
    /**
     * 
     * @type {string}
     * @memberof GettableAlertSilencer
     */
    'startsAt': string;
    /**
     * 
     * @type {string}
     * @memberof GettableAlertSilencer
     */
    'id': string;
    /**
     * 
     * @type {AlertSilenceStatus}
     * @memberof GettableAlertSilencer
     */
    'status': AlertSilenceStatus;
    /**
     * 
     * @type {string}
     * @memberof GettableAlertSilencer
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface GettableAlertSilencerAllOf
 */
export interface GettableAlertSilencerAllOf {
    /**
     * 
     * @type {string}
     * @memberof GettableAlertSilencerAllOf
     */
    'id': string;
    /**
     * 
     * @type {AlertSilenceStatus}
     * @memberof GettableAlertSilencerAllOf
     */
    'status': AlertSilenceStatus;
    /**
     * 
     * @type {string}
     * @memberof GettableAlertSilencerAllOf
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface Grant
 */
export interface Grant {
    /**
     * 
     * @type {number}
     * @memberof Grant
     */
    'bandwidth_mhz': number;
    /**
     * 
     * @type {number}
     * @memberof Grant
     */
    'frequency_mhz': number;
    /**
     * 
     * @type {string}
     * @memberof Grant
     */
    'grant_expire_time'?: string;
    /**
     * 
     * @type {number}
     * @memberof Grant
     */
    'max_eirp': number;
    /**
     * 
     * @type {string}
     * @memberof Grant
     */
    'state': GrantStateEnum;
    /**
     * 
     * @type {string}
     * @memberof Grant
     */
    'transmit_expire_time'?: string;
}

export const GrantStateEnum = {
    Granted: 'granted',
    Authorized: 'authorized',
    Unsync: 'unsync'
} as const;

export type GrantStateEnum = typeof GrantStateEnum[keyof typeof GrantStateEnum];

/**
 * gx configuration
 * @export
 * @interface Gx
 */
export interface Gx {
    /**
     * 
     * @type {boolean}
     * @memberof Gx
     */
    'disableGx'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Gx
     */
    'overwrite_apn'?: string;
    /**
     * 
     * @type {DiameterClientConfigs}
     * @memberof Gx
     */
    'server'?: DiameterClientConfigs;
    /**
     * 
     * @type {Array<DiameterClientConfigs>}
     * @memberof Gx
     */
    'servers'?: Array<DiameterClientConfigs>;
    /**
     * 
     * @type {Array<VirtualApnRule>}
     * @memberof Gx
     */
    'virtual_apn_rules'?: Array<VirtualApnRule>;
}
/**
 * 
 * @export
 * @interface Gy
 */
export interface Gy {
    /**
     * 
     * @type {boolean}
     * @memberof Gy
     */
    'disableGy'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Gy
     */
    'init_method'?: number;
    /**
     * 
     * @type {string}
     * @memberof Gy
     */
    'overwrite_apn'?: string;
    /**
     * 
     * @type {DiameterClientConfigs}
     * @memberof Gy
     */
    'server'?: DiameterClientConfigs;
    /**
     * 
     * @type {Array<DiameterClientConfigs>}
     * @memberof Gy
     */
    'servers'?: Array<DiameterClientConfigs>;
    /**
     * 
     * @type {Array<VirtualApnRule>}
     * @memberof Gy
     */
    'virtual_apn_rules'?: Array<VirtualApnRule>;
}
/**
 * health service configuration
 * @export
 * @interface Health
 */
export interface Health {
    /**
     * 
     * @type {number}
     * @memberof Health
     */
    'cloud_disable_period_secs'?: number;
    /**
     * 
     * @type {number}
     * @memberof Health
     */
    'cpu_utilization_threshold'?: number;
    /**
     * FeG services for the health service to monitor
     * @type {Array<string>}
     * @memberof Health
     */
    'health_services'?: Array<HealthHealthServicesEnum>;
    /**
     * 
     * @type {number}
     * @memberof Health
     */
    'local_disable_period_secs'?: number;
    /**
     * 
     * @type {number}
     * @memberof Health
     */
    'memory_available_threshold'?: number;
    /**
     * 
     * @type {number}
     * @memberof Health
     */
    'minimum_request_threshold'?: number;
    /**
     * 
     * @type {number}
     * @memberof Health
     */
    'request_failure_threshold'?: number;
    /**
     * 
     * @type {number}
     * @memberof Health
     */
    'update_failure_threshold'?: number;
    /**
     * 
     * @type {number}
     * @memberof Health
     */
    'update_interval_secs'?: number;
}

export const HealthHealthServicesEnum = {
    S6AProxy: 'S6A_PROXY',
    SessionProxy: 'SESSION_PROXY',
    SwxProxy: 'SWX_PROXY'
} as const;

export type HealthHealthServicesEnum = typeof HealthHealthServicesEnum[keyof typeof HealthHealthServicesEnum];

/**
 * HSS configuration
 * @export
 * @interface Hss
 */
export interface Hss {
    /**
     * 
     * @type {SubscriptionProfile}
     * @memberof Hss
     */
    'default_sub_profile'?: SubscriptionProfile;
    /**
     * 
     * @type {string}
     * @memberof Hss
     */
    'lte_auth_amf'?: string;
    /**
     * 
     * @type {string}
     * @memberof Hss
     */
    'lte_auth_op'?: string;
    /**
     * 
     * @type {DiameterServerConfigs}
     * @memberof Hss
     */
    'server'?: DiameterServerConfigs;
    /**
     * 
     * @type {boolean}
     * @memberof Hss
     */
    'stream_subscribers'?: boolean;
    /**
     * 
     * @type {{ [key: string]: SubscriptionProfile; }}
     * @memberof Hss
     */
    'sub_profiles'?: { [key: string]: SubscriptionProfile; };
}
/**
 * 
 * @export
 * @interface HttpConfig
 */
export interface HttpConfig {
    /**
     * 
     * @type {HttpConfigBasicAuth}
     * @memberof HttpConfig
     */
    'basic_auth'?: HttpConfigBasicAuth;
    /**
     * 
     * @type {string}
     * @memberof HttpConfig
     */
    'bearer_token'?: string;
    /**
     * 
     * @type {string}
     * @memberof HttpConfig
     */
    'proxy_url'?: string;
}
/**
 * 
 * @export
 * @interface HttpConfigBasicAuth
 */
export interface HttpConfigBasicAuth {
    /**
     * 
     * @type {string}
     * @memberof HttpConfigBasicAuth
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof HttpConfigBasicAuth
     */
    'username': string;
}
/**
 * ICMP status of a subscriber device
 * @export
 * @interface IcmpStatus
 */
export interface IcmpStatus {
    /**
     * Timestamp of last reported status for the subscriber in ms
     * @type {number}
     * @memberof IcmpStatus
     */
    'last_reported_time'?: number;
    /**
     * 
     * @type {number}
     * @memberof IcmpStatus
     */
    'latency_ms': number;
}
/**
 * IMEI (type allocation code and serial number)
 * @export
 * @interface Imei
 */
export interface Imei {
    /**
     * 
     * @type {string}
     * @memberof Imei
     */
    'snr'?: string;
    /**
     * 
     * @type {string}
     * @memberof Imei
     */
    'tac': string;
}
/**
 * 
 * @export
 * @interface InstallationParam
 */
export interface InstallationParam {
    /**
     * 
     * @type {number}
     * @memberof InstallationParam
     */
    'antenna_gain'?: number | null;
    /**
     * the CBSD antenna height in meters
     * @type {number}
     * @memberof InstallationParam
     */
    'height_m'?: number | null;
    /**
     * AGL - relative to the ground level. AMSL - relative to the mean sea level
     * @type {string}
     * @memberof InstallationParam
     */
    'height_type'?: InstallationParamHeightTypeEnum;
    /**
     * true if the CBSD is located indoors
     * @type {boolean}
     * @memberof InstallationParam
     */
    'indoor_deployment'?: boolean | null;
    /**
     * latitude coordinates of the radio in degrees
     * @type {number}
     * @memberof InstallationParam
     */
    'latitude_deg'?: number | null;
    /**
     * longitude coordinates of the radio in degrees
     * @type {number}
     * @memberof InstallationParam
     */
    'longitude_deg'?: number | null;
}

export const InstallationParamHeightTypeEnum = {
    Agl: 'agl',
    Amsl: 'amsl'
} as const;

export type InstallationParamHeightTypeEnum = typeof InstallationParamHeightTypeEnum[keyof typeof InstallationParamHeightTypeEnum];

/**
 * IP address
 * @export
 * @interface IpAddress
 */
export interface IpAddress {
    /**
     * 
     * @type {string}
     * @memberof IpAddress
     */
    'address'?: string;
    /**
     * 
     * @type {string}
     * @memberof IpAddress
     */
    'version'?: IpAddressVersionEnum;
}

export const IpAddressVersionEnum = {
    Ipv4: 'IPv4',
    Ipv6: 'IPv6'
} as const;

export type IpAddressVersionEnum = typeof IpAddressVersionEnum[keyof typeof IpAddressVersionEnum];

/**
 * 
 * @export
 * @interface IpdrExportDst
 */
export interface IpdrExportDst {
    /**
     * 
     * @type {string}
     * @memberof IpdrExportDst
     */
    'ip': string;
    /**
     * 
     * @type {number}
     * @memberof IpdrExportDst
     */
    'port': number;
}
/**
 * 
 * @export
 * @interface LabelPair
 */
export interface LabelPair {
    /**
     * 
     * @type {string}
     * @memberof LabelPair
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof LabelPair
     */
    'value': string;
}
/**
 * 
 * @export
 * @interface LiUes
 */
export interface LiUes {
    /**
     * 
     * @type {Array<string>}
     * @memberof LiUes
     */
    'imsis': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof LiUes
     */
    'ips': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof LiUes
     */
    'macs': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof LiUes
     */
    'msisdns': Array<string>;
}
/**
 * 
 * @export
 * @interface Log
 */
export interface Log {
    /**
     * Body of log
     * @type {string}
     * @memberof Log
     */
    'body': string;
    /**
     * Fcc Id of cbsd involved in log
     * @type {string}
     * @memberof Log
     */
    'fcc_id': string;
    /**
     * log origin
     * @type {string}
     * @memberof Log
     */
    'from': LogFromEnum;
    /**
     * Serial number of cbsd involved in log
     * @type {string}
     * @memberof Log
     */
    'serial_number': string;
    /**
     * Datetime of log
     * @type {string}
     * @memberof Log
     */
    'time': string;
    /**
     * log destination
     * @type {string}
     * @memberof Log
     */
    'to': LogToEnum;
    /**
     * Type of log
     * @type {string}
     * @memberof Log
     */
    'type': string;
}

export const LogFromEnum = {
    Sas: 'SAS',
    Dp: 'DP',
    Cbsd: 'CBSD'
} as const;

export type LogFromEnum = typeof LogFromEnum[keyof typeof LogFromEnum];
export const LogToEnum = {
    Sas: 'SAS',
    Dp: 'DP',
    Cbsd: 'CBSD'
} as const;

export type LogToEnum = typeof LogToEnum[keyof typeof LogToEnum];

/**
 * Full description of an LTE gateway
 * @export
 * @interface LteGateway
 */
export interface LteGateway {
    /**
     * APN resources keyed by APN name
     * @type {{ [key: string]: ApnResource; }}
     * @memberof LteGateway
     */
    'apn_resources'?: { [key: string]: ApnResource; };
    /**
     * 
     * @type {GatewayCellularConfigs}
     * @memberof LteGateway
     */
    'cellular': GatewayCellularConfigs;
    /**
     * Describes whether the last check-in happened recently, taking the magmad check-in interval into account. 
     * @type {boolean}
     * @memberof LteGateway
     */
    'checked_in_recently': boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof LteGateway
     */
    'connected_enodeb_serials': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof LteGateway
     */
    'description': string;
    /**
     * 
     * @type {GatewayDevice}
     * @memberof LteGateway
     */
    'device'?: GatewayDevice;
    /**
     * 
     * @type {string}
     * @memberof LteGateway
     */
    'id': string;
    /**
     * 
     * @type {MagmadGatewayConfigs}
     * @memberof LteGateway
     */
    'magmad': MagmadGatewayConfigs;
    /**
     * 
     * @type {string}
     * @memberof LteGateway
     */
    'name': string;
    /**
     * 
     * @type {RegistrationInfo}
     * @memberof LteGateway
     */
    'registration_info'?: RegistrationInfo;
    /**
     * 
     * @type {GatewayStatus}
     * @memberof LteGateway
     */
    'status'?: GatewayStatus;
    /**
     * 
     * @type {string}
     * @memberof LteGateway
     */
    'tier': string;
}
/**
 * LTE Network spec
 * @export
 * @interface LteNetwork
 */
export interface LteNetwork {
    /**
     * 
     * @type {NetworkCellularConfigs}
     * @memberof LteNetwork
     */
    'cellular': NetworkCellularConfigs;
    /**
     * 
     * @type {string}
     * @memberof LteNetwork
     */
    'description': string;
    /**
     * 
     * @type {NetworkDnsConfig}
     * @memberof LteNetwork
     */
    'dns': NetworkDnsConfig;
    /**
     * 
     * @type {NetworkFeatures}
     * @memberof LteNetwork
     */
    'features'?: NetworkFeatures;
    /**
     * 
     * @type {string}
     * @memberof LteNetwork
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof LteNetwork
     */
    'name': string;
    /**
     * 
     * @type {NetworkSubscriberConfig}
     * @memberof LteNetwork
     */
    'subscriber_config'?: NetworkSubscriberConfig;
}
/**
 * 
 * @export
 * @interface LteSubscription
 */
export interface LteSubscription {
    /**
     * 
     * @type {string}
     * @memberof LteSubscription
     */
    'auth_algo': LteSubscriptionAuthAlgoEnum;
    /**
     * 
     * @type {string}
     * @memberof LteSubscription
     */
    'auth_key': string;
    /**
     * 
     * @type {string}
     * @memberof LteSubscription
     */
    'auth_opc'?: string;
    /**
     * 
     * @type {string}
     * @memberof LteSubscription
     */
    'state': LteSubscriptionStateEnum;
    /**
     * 
     * @type {string}
     * @memberof LteSubscription
     */
    'sub_profile': string;
}

export const LteSubscriptionAuthAlgoEnum = {
    Milenage: 'MILENAGE'
} as const;

export type LteSubscriptionAuthAlgoEnum = typeof LteSubscriptionAuthAlgoEnum[keyof typeof LteSubscriptionAuthAlgoEnum];
export const LteSubscriptionStateEnum = {
    Inactive: 'INACTIVE',
    Active: 'ACTIVE'
} as const;

export type LteSubscriptionStateEnum = typeof LteSubscriptionStateEnum[keyof typeof LteSubscriptionStateEnum];

/**
 * 
 * @export
 * @interface MachineInfo
 */
export interface MachineInfo {
    /**
     * 
     * @type {MachineInfoCpuInfo}
     * @memberof MachineInfo
     */
    'cpu_info'?: MachineInfoCpuInfo;
    /**
     * 
     * @type {MachineInfoNetworkInfo}
     * @memberof MachineInfo
     */
    'network_info'?: MachineInfoNetworkInfo;
}
/**
 * 
 * @export
 * @interface MachineInfoCpuInfo
 */
export interface MachineInfoCpuInfo {
    /**
     * 
     * @type {string}
     * @memberof MachineInfoCpuInfo
     */
    'architecture'?: string;
    /**
     * 
     * @type {number}
     * @memberof MachineInfoCpuInfo
     */
    'core_count'?: number;
    /**
     * 
     * @type {string}
     * @memberof MachineInfoCpuInfo
     */
    'model_name'?: string;
    /**
     * 
     * @type {number}
     * @memberof MachineInfoCpuInfo
     */
    'threads_per_core'?: number;
}
/**
 * 
 * @export
 * @interface MachineInfoNetworkInfo
 */
export interface MachineInfoNetworkInfo {
    /**
     * 
     * @type {Array<NetworkInterface>}
     * @memberof MachineInfoNetworkInfo
     */
    'network_interfaces'?: Array<NetworkInterface>;
    /**
     * 
     * @type {Array<Route>}
     * @memberof MachineInfoNetworkInfo
     */
    'routing_table'?: Array<Route>;
}
/**
 * Full representation of a generic gateway
 * @export
 * @interface MagmadGateway
 */
export interface MagmadGateway {
    /**
     * 
     * @type {string}
     * @memberof MagmadGateway
     */
    'description': string;
    /**
     * 
     * @type {GatewayDevice}
     * @memberof MagmadGateway
     */
    'device'?: GatewayDevice;
    /**
     * 
     * @type {string}
     * @memberof MagmadGateway
     */
    'id': string;
    /**
     * 
     * @type {MagmadGatewayConfigs}
     * @memberof MagmadGateway
     */
    'magmad': MagmadGatewayConfigs;
    /**
     * 
     * @type {string}
     * @memberof MagmadGateway
     */
    'name': string;
    /**
     * 
     * @type {RegistrationInfo}
     * @memberof MagmadGateway
     */
    'registration_info'?: RegistrationInfo;
    /**
     * 
     * @type {GatewayStatus}
     * @memberof MagmadGateway
     */
    'status'?: GatewayStatus;
    /**
     * 
     * @type {string}
     * @memberof MagmadGateway
     */
    'tier': string;
}
/**
 * Configuration for the magmad gateway agent
 * @export
 * @interface MagmadGatewayConfigs
 */
export interface MagmadGatewayConfigs {
    /**
     * 
     * @type {boolean}
     * @memberof MagmadGatewayConfigs
     */
    'autoupgrade_enabled': boolean;
    /**
     * 
     * @type {number}
     * @memberof MagmadGatewayConfigs
     */
    'autoupgrade_poll_interval': number;
    /**
     * 
     * @type {number}
     * @memberof MagmadGatewayConfigs
     */
    'checkin_interval': number;
    /**
     * 
     * @type {number}
     * @memberof MagmadGatewayConfigs
     */
    'checkin_timeout': number;
    /**
     * 
     * @type {Array<string>}
     * @memberof MagmadGatewayConfigs
     */
    'dynamic_services'?: Array<string>;
    /**
     * 
     * @type {{ [key: string]: boolean; }}
     * @memberof MagmadGatewayConfigs
     */
    'feature_flags'?: { [key: string]: boolean; };
    /**
     * 
     * @type {GatewayLoggingConfigs}
     * @memberof MagmadGatewayConfigs
     */
    'logging'?: GatewayLoggingConfigs;
    /**
     * 
     * @type {GatewayVpnConfigs}
     * @memberof MagmadGatewayConfigs
     */
    'vpn'?: GatewayVpnConfigs;
}
/**
 * 
 * @export
 * @interface Matcher
 */
export interface Matcher {
    /**
     * 
     * @type {boolean}
     * @memberof Matcher
     */
    'isRegex': boolean;
    /**
     * 
     * @type {string}
     * @memberof Matcher
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Matcher
     */
    'value': string;
}
/**
 * Item containing {mode, [plmnA, plmB], [imsi1, imsi2], [apnY, apnZ]}
 * @export
 * @interface ModeMapItem
 */
export interface ModeMapItem {
    /**
     * 
     * @type {string}
     * @memberof ModeMapItem
     */
    'apn'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModeMapItem
     */
    'imsi_range'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModeMapItem
     */
    'mode'?: ModeMapItemModeEnum;
    /**
     * 
     * @type {string}
     * @memberof ModeMapItem
     */
    'plmn'?: string;
}

export const ModeMapItemModeEnum = {
    LocalSubscriber: 'local_subscriber',
    S8Subscriber: 's8_subscriber'
} as const;

export type ModeMapItemModeEnum = typeof ModeMapItemModeEnum[keyof typeof ModeMapItemModeEnum];

/**
 * 
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * 
     * @type {string}
     * @memberof ModelError
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface MsisdnAssignment
 */
export interface MsisdnAssignment {
    /**
     * 
     * @type {string}
     * @memberof MsisdnAssignment
     */
    'id': string;
    /**
     * Mobile station international subscriber directory number
     * @type {string}
     * @memberof MsisdnAssignment
     */
    'msisdn': string;
}
/**
 * Subset of call trace fields which are mutable
 * @export
 * @interface MutableCallTrace
 */
export interface MutableCallTrace {
    /**
     * True if requesting call trace to end
     * @type {boolean}
     * @memberof MutableCallTrace
     */
    'requested_end': boolean;
}
/**
 * 
 * @export
 * @interface MutableCbsd
 */
export interface MutableCbsd {
    /**
     * 
     * @type {Capabilities}
     * @memberof MutableCbsd
     */
    'capabilities': Capabilities;
    /**
     * this flag controls eNB behavior, should multiple grants be used for Carrier Aggregation, or one for Single Carrier
     * @type {boolean}
     * @memberof MutableCbsd
     */
    'carrier_aggregation_enabled': boolean;
    /**
     * is the radio type A (only) or B (also applies to A/B type radios)
     * @type {string}
     * @memberof MutableCbsd
     */
    'cbsd_category': MutableCbsdCbsdCategoryEnum;
    /**
     * desired state of cbsd in SAS
     * @type {string}
     * @memberof MutableCbsd
     */
    'desired_state': MutableCbsdDesiredStateEnum;
    /**
     * 
     * @type {string}
     * @memberof MutableCbsd
     */
    'fcc_id': string;
    /**
     * 
     * @type {FrequencyPreferences}
     * @memberof MutableCbsd
     */
    'frequency_preferences': FrequencyPreferences;
    /**
     * Tells Domain Proxy how many grants from SAS should be maintained. If enabled, Domain Proxy will try to maintain at least 2 grants, if disabled, Domain Proxy will maintain only 1 grant
     * @type {boolean}
     * @memberof MutableCbsd
     */
    'grant_redundancy': boolean;
    /**
     * 
     * @type {MutableInstallationParam}
     * @memberof MutableCbsd
     */
    'installation_param'?: MutableInstallationParam;
    /**
     * 
     * @type {string}
     * @memberof MutableCbsd
     */
    'serial_number': string;
    /**
     * should the CBSD be registered in a single-step mode
     * @type {boolean}
     * @memberof MutableCbsd
     */
    'single_step_enabled': boolean;
    /**
     * 
     * @type {string}
     * @memberof MutableCbsd
     */
    'user_id': string;
}

export const MutableCbsdCbsdCategoryEnum = {
    A: 'a',
    B: 'b'
} as const;

export type MutableCbsdCbsdCategoryEnum = typeof MutableCbsdCbsdCategoryEnum[keyof typeof MutableCbsdCbsdCategoryEnum];
export const MutableCbsdDesiredStateEnum = {
    Unregistered: 'unregistered',
    Registered: 'registered'
} as const;

export type MutableCbsdDesiredStateEnum = typeof MutableCbsdDesiredStateEnum[keyof typeof MutableCbsdDesiredStateEnum];

/**
 * Mutable version of the cellular gateway pool
 * @export
 * @interface MutableCellularGatewayPool
 */
export interface MutableCellularGatewayPool {
    /**
     * 
     * @type {CellularGatewayPoolConfigs}
     * @memberof MutableCellularGatewayPool
     */
    'config': CellularGatewayPoolConfigs;
    /**
     * 
     * @type {string}
     * @memberof MutableCellularGatewayPool
     */
    'gateway_pool_id': string;
    /**
     * 
     * @type {string}
     * @memberof MutableCellularGatewayPool
     */
    'gateway_pool_name'?: string;
}
/**
 * CWF gateway object with read-only fields omitted
 * @export
 * @interface MutableCwfGateway
 */
export interface MutableCwfGateway {
    /**
     * 
     * @type {GatewayCwfConfigs}
     * @memberof MutableCwfGateway
     */
    'carrier_wifi': GatewayCwfConfigs;
    /**
     * 
     * @type {string}
     * @memberof MutableCwfGateway
     */
    'description': string;
    /**
     * 
     * @type {GatewayDevice}
     * @memberof MutableCwfGateway
     */
    'device'?: GatewayDevice;
    /**
     * 
     * @type {string}
     * @memberof MutableCwfGateway
     */
    'id': string;
    /**
     * 
     * @type {MagmadGatewayConfigs}
     * @memberof MutableCwfGateway
     */
    'magmad': MagmadGatewayConfigs;
    /**
     * 
     * @type {string}
     * @memberof MutableCwfGateway
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof MutableCwfGateway
     */
    'tier': string;
}
/**
 * HA Gateway pair with read-only fields omitted
 * @export
 * @interface MutableCwfHaPair
 */
export interface MutableCwfHaPair {
    /**
     * 
     * @type {CwfHaPairConfigs}
     * @memberof MutableCwfHaPair
     */
    'config': CwfHaPairConfigs;
    /**
     * 
     * @type {string}
     * @memberof MutableCwfHaPair
     */
    'gateway_id_1': string;
    /**
     * 
     * @type {string}
     * @memberof MutableCwfHaPair
     */
    'gateway_id_2': string;
    /**
     * 
     * @type {string}
     * @memberof MutableCwfHaPair
     */
    'ha_pair_id': string;
}
/**
 * Federation gateway object with read-only fields omitted
 * @export
 * @interface MutableFederationGateway
 */
export interface MutableFederationGateway {
    /**
     * 
     * @type {string}
     * @memberof MutableFederationGateway
     */
    'description': string;
    /**
     * 
     * @type {GatewayDevice}
     * @memberof MutableFederationGateway
     */
    'device'?: GatewayDevice;
    /**
     * 
     * @type {GatewayFederationConfigs}
     * @memberof MutableFederationGateway
     */
    'federation'?: GatewayFederationConfigs;
    /**
     * 
     * @type {string}
     * @memberof MutableFederationGateway
     */
    'id': string;
    /**
     * 
     * @type {MagmadGatewayConfigs}
     * @memberof MutableFederationGateway
     */
    'magmad': MagmadGatewayConfigs;
    /**
     * 
     * @type {string}
     * @memberof MutableFederationGateway
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof MutableFederationGateway
     */
    'tier': string;
}
/**
 * 
 * @export
 * @interface MutableInstallationParam
 */
export interface MutableInstallationParam {
    /**
     * 
     * @type {number}
     * @memberof MutableInstallationParam
     */
    'antenna_gain'?: number | null;
}
/**
 * LTE gateway object with read-only fields omitted
 * @export
 * @interface MutableLteGateway
 */
export interface MutableLteGateway {
    /**
     * APN resources keyed by APN name
     * @type {{ [key: string]: ApnResource; }}
     * @memberof MutableLteGateway
     */
    'apn_resources'?: { [key: string]: ApnResource; };
    /**
     * 
     * @type {GatewayCellularConfigs}
     * @memberof MutableLteGateway
     */
    'cellular': GatewayCellularConfigs;
    /**
     * 
     * @type {Array<string>}
     * @memberof MutableLteGateway
     */
    'connected_enodeb_serials': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof MutableLteGateway
     */
    'description': string;
    /**
     * 
     * @type {GatewayDevice}
     * @memberof MutableLteGateway
     */
    'device'?: GatewayDevice;
    /**
     * 
     * @type {string}
     * @memberof MutableLteGateway
     */
    'id': string;
    /**
     * 
     * @type {MagmadGatewayConfigs}
     * @memberof MutableLteGateway
     */
    'magmad': MagmadGatewayConfigs;
    /**
     * 
     * @type {string}
     * @memberof MutableLteGateway
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof MutableLteGateway
     */
    'tier': string;
}
/**
 * 
 * @export
 * @interface MutableRatingGroup
 */
export interface MutableRatingGroup {
    /**
     * 
     * @type {string}
     * @memberof MutableRatingGroup
     */
    'limit_type': MutableRatingGroupLimitTypeEnum;
}

export const MutableRatingGroupLimitTypeEnum = {
    Finite: 'FINITE',
    InfiniteUnmetered: 'INFINITE_UNMETERED',
    InfiniteMetered: 'INFINITE_METERED'
} as const;

export type MutableRatingGroupLimitTypeEnum = typeof MutableRatingGroupLimitTypeEnum[keyof typeof MutableRatingGroupLimitTypeEnum];

/**
 * 
 * @export
 * @interface MutableSmsMessage
 */
export interface MutableSmsMessage {
    /**
     * 
     * @type {string}
     * @memberof MutableSmsMessage
     */
    'imsi': string;
    /**
     * 
     * @type {string}
     * @memberof MutableSmsMessage
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof MutableSmsMessage
     */
    'source_msisdn': string;
}
/**
 * Subset of subscriber field which are mutable
 * @export
 * @interface MutableSubscriber
 */
export interface MutableSubscriber {
    /**
     * APNs that are allowed for this subscriber
     * @type {Array<string>}
     * @memberof MutableSubscriber
     */
    'active_apns'?: Array<string>;
    /**
     * List of base names
     * @type {Array<string>}
     * @memberof MutableSubscriber
     */
    'active_base_names'?: Array<string>;
    /**
     * Policies which are globally active for this subscriber
     * @type {Array<string>}
     * @memberof MutableSubscriber
     */
    'active_policies'?: Array<string>;
    /**
     * APN-specific policies for this subscriber
     * @type {{ [key: string]: Array<string>; }}
     * @memberof MutableSubscriber
     */
    'active_policies_by_apn'?: { [key: string]: Array<string>; };
    /**
     * List of core network types.
     * @type {Array<string>}
     * @memberof MutableSubscriber
     */
    'forbidden_network_types'?: Array<MutableSubscriberForbiddenNetworkTypesEnum>;
    /**
     * 
     * @type {string}
     * @memberof MutableSubscriber
     */
    'id': string;
    /**
     * 
     * @type {LteSubscription}
     * @memberof MutableSubscriber
     */
    'lte': LteSubscription;
    /**
     * Name for the subscriber
     * @type {string}
     * @memberof MutableSubscriber
     */
    'name'?: string;
    /**
     * Mapping of APN ID to static IP address to allocate for the subscriber at the edge
     * @type {{ [key: string]: string; }}
     * @memberof MutableSubscriber
     */
    'static_ips'?: { [key: string]: string; };
}

export const MutableSubscriberForbiddenNetworkTypesEnum = {
    Epc: 'EPC',
    _5Gc: '5GC'
} as const;

export type MutableSubscriberForbiddenNetworkTypesEnum = typeof MutableSubscriberForbiddenNetworkTypesEnum[keyof typeof MutableSubscriberForbiddenNetworkTypesEnum];

/**
 * Orchestrator network spec
 * @export
 * @interface Network
 */
export interface Network {
    /**
     * 
     * @type {string}
     * @memberof Network
     */
    'description': string;
    /**
     * 
     * @type {NetworkDnsConfig}
     * @memberof Network
     */
    'dns': NetworkDnsConfig;
    /**
     * 
     * @type {NetworkFeatures}
     * @memberof Network
     */
    'features'?: NetworkFeatures;
    /**
     * 
     * @type {string}
     * @memberof Network
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Network
     */
    'name': string;
    /**
     * 
     * @type {NetworkSentryConfig}
     * @memberof Network
     */
    'sentry_config'?: NetworkSentryConfig;
    /**
     * 
     * @type {StateConfig}
     * @memberof Network
     */
    'state_config'?: StateConfig;
    /**
     * The type of the network
     * @type {string}
     * @memberof Network
     */
    'type'?: string;
}
/**
 * Carrier WiFi configuration for a network
 * @export
 * @interface NetworkCarrierWifiConfigs
 */
export interface NetworkCarrierWifiConfigs {
    /**
     * 
     * @type {AaaServer}
     * @memberof NetworkCarrierWifiConfigs
     */
    'aaa_server': AaaServer;
    /**
     * 
     * @type {string}
     * @memberof NetworkCarrierWifiConfigs
     */
    'default_rule_id': string;
    /**
     * 
     * @type {EapAka}
     * @memberof NetworkCarrierWifiConfigs
     */
    'eap_aka': EapAka;
    /**
     * 
     * @type {EapSim}
     * @memberof NetworkCarrierWifiConfigs
     */
    'eap_sim'?: EapSim;
    /**
     * 
     * @type {LiUes}
     * @memberof NetworkCarrierWifiConfigs
     */
    'li_ues'?: LiUes;
    /**
     * Configuration for network services. Services will be instantiated in the listed order.
     * @type {Array<string>}
     * @memberof NetworkCarrierWifiConfigs
     */
    'network_services': Array<NetworkCarrierWifiConfigsNetworkServicesEnum>;
}

export const NetworkCarrierWifiConfigsNetworkServicesEnum = {
    Dpi: 'dpi',
    PolicyEnforcement: 'policy_enforcement'
} as const;

export type NetworkCarrierWifiConfigsNetworkServicesEnum = typeof NetworkCarrierWifiConfigsNetworkServicesEnum[keyof typeof NetworkCarrierWifiConfigsNetworkServicesEnum];

/**
 * Cellular configuration for a network
 * @export
 * @interface NetworkCellularConfigs
 */
export interface NetworkCellularConfigs {
    /**
     * 
     * @type {NetworkEpcConfigs}
     * @memberof NetworkCellularConfigs
     */
    'epc': NetworkEpcConfigs;
    /**
     * Name of the federated network serving this LTE network. Blank for non federated
     * @type {string}
     * @memberof NetworkCellularConfigs
     */
    'feg_network_id'?: string;
    /**
     * 
     * @type {NetworkNgcConfigs}
     * @memberof NetworkCellularConfigs
     */
    'ngc'?: NetworkNgcConfigs;
    /**
     * 
     * @type {NetworkRanConfigs}
     * @memberof NetworkCellularConfigs
     */
    'ran': NetworkRanConfigs;
}
/**
 * DNS configuration for a network
 * @export
 * @interface NetworkDnsConfig
 */
export interface NetworkDnsConfig {
    /**
     * 
     * @type {boolean}
     * @memberof NetworkDnsConfig
     */
    'dhcp_server_enabled'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof NetworkDnsConfig
     */
    'enable_caching': boolean;
    /**
     * 
     * @type {number}
     * @memberof NetworkDnsConfig
     */
    'local_ttl': number;
    /**
     * 
     * @type {Array<DnsConfigRecord>}
     * @memberof NetworkDnsConfig
     */
    'records'?: Array<DnsConfigRecord>;
}
/**
 * EPC (evolved packet core) cellular configuration for a network
 * @export
 * @interface NetworkEpcConfigs
 */
export interface NetworkEpcConfigs {
    /**
     * 
     * @type {boolean}
     * @memberof NetworkEpcConfigs
     */
    'cloud_subscriberdb_enabled'?: boolean;
    /**
     * Network configuration flag for congestion control on EPC
     * @type {boolean}
     * @memberof NetworkEpcConfigs
     */
    'congestion_control_enabled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof NetworkEpcConfigs
     */
    'default_rule_id'?: string;
    /**
     * Enables 5G Standalone (SA) at a network level
     * @type {boolean}
     * @memberof NetworkEpcConfigs
     */
    'enable5g_features'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof NetworkEpcConfigs
     */
    'gx_gy_relay_enabled': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof NetworkEpcConfigs
     */
    'hss_relay_enabled': boolean;
    /**
     * 
     * @type {string}
     * @memberof NetworkEpcConfigs
     */
    'lte_auth_amf': string;
    /**
     * 
     * @type {string}
     * @memberof NetworkEpcConfigs
     */
    'lte_auth_op': string;
    /**
     * 
     * @type {string}
     * @memberof NetworkEpcConfigs
     */
    'mcc': string;
    /**
     * 
     * @type {string}
     * @memberof NetworkEpcConfigs
     */
    'mnc': string;
    /**
     * 
     * @type {NetworkEpcConfigsMobility}
     * @memberof NetworkEpcConfigs
     */
    'mobility'?: NetworkEpcConfigsMobility;
    /**
     * Configuration for network services. Services will be instantiated in the listed order.
     * @type {Array<string>}
     * @memberof NetworkEpcConfigs
     */
    'network_services'?: Array<NetworkEpcConfigsNetworkServicesEnum>;
    /**
     * List of IMEIs restricted in the network
     * @type {Array<Imei>}
     * @memberof NetworkEpcConfigs
     */
    'restricted_imeis'?: Array<Imei>;
    /**
     * List of PLMN IDs restricted in the network
     * @type {Array<PlmnConfig>}
     * @memberof NetworkEpcConfigs
     */
    'restricted_plmns'?: Array<PlmnConfig>;
    /**
     * Mapping service areas to tacs in the network
     * @type {{ [key: string]: Array<number>; }}
     * @memberof NetworkEpcConfigs
     */
    'service_area_maps'?: { [key: string]: Array<number>; };
    /**
     * 
     * @type {{ [key: string]: NetworkEpcConfigsSubProfilesValue; }}
     * @memberof NetworkEpcConfigs
     */
    'sub_profiles'?: { [key: string]: NetworkEpcConfigsSubProfilesValue; };
    /**
     * Interval in seconds between gateway requests to sync its subscriberdb with the cloud.
     * @type {number}
     * @memberof NetworkEpcConfigs
     */
    'subscriberdb_sync_interval'?: number;
    /**
     * 
     * @type {number}
     * @memberof NetworkEpcConfigs
     */
    'tac': number;
}

export const NetworkEpcConfigsNetworkServicesEnum = {
    Dpi: 'dpi',
    PolicyEnforcement: 'policy_enforcement'
} as const;

export type NetworkEpcConfigsNetworkServicesEnum = typeof NetworkEpcConfigsNetworkServicesEnum[keyof typeof NetworkEpcConfigsNetworkServicesEnum];

/**
 * Configuration for IP Allocation (Mobility).
 * @export
 * @interface NetworkEpcConfigsMobility
 */
export interface NetworkEpcConfigsMobility {
    /**
     * 
     * @type {boolean}
     * @memberof NetworkEpcConfigsMobility
     */
    'enable_multi_apn_ip_allocation'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof NetworkEpcConfigsMobility
     */
    'enable_static_ip_assignments'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof NetworkEpcConfigsMobility
     */
    'ip_allocation_mode': NetworkEpcConfigsMobilityIpAllocationModeEnum;
    /**
     * 
     * @type {NetworkEpcConfigsMobilityNat}
     * @memberof NetworkEpcConfigsMobility
     */
    'nat'?: NetworkEpcConfigsMobilityNat;
    /**
     * 
     * @type {Array<string>}
     * @memberof NetworkEpcConfigsMobility
     */
    'reserved_addresses'?: Array<string>;
    /**
     * 
     * @type {NetworkEpcConfigsMobilityStatic}
     * @memberof NetworkEpcConfigsMobility
     */
    'static'?: NetworkEpcConfigsMobilityStatic;
}

export const NetworkEpcConfigsMobilityIpAllocationModeEnum = {
    Nat: 'NAT',
    Static: 'STATIC',
    DhcpPassthrough: 'DHCP_PASSTHROUGH',
    DhcpBroadcast: 'DHCP_BROADCAST'
} as const;

export type NetworkEpcConfigsMobilityIpAllocationModeEnum = typeof NetworkEpcConfigsMobilityIpAllocationModeEnum[keyof typeof NetworkEpcConfigsMobilityIpAllocationModeEnum];

/**
 * 
 * @export
 * @interface NetworkEpcConfigsMobilityNat
 */
export interface NetworkEpcConfigsMobilityNat {
    /**
     * 
     * @type {Array<string>}
     * @memberof NetworkEpcConfigsMobilityNat
     */
    'ip_blocks'?: Array<string>;
}
/**
 * 
 * @export
 * @interface NetworkEpcConfigsMobilityStatic
 */
export interface NetworkEpcConfigsMobilityStatic {
    /**
     * 
     * @type {{ [key: string]: Array<string>; }}
     * @memberof NetworkEpcConfigsMobilityStatic
     */
    'ip_blocks_by_tac'?: { [key: string]: Array<string>; };
}
/**
 * 
 * @export
 * @interface NetworkEpcConfigsSubProfilesValue
 */
export interface NetworkEpcConfigsSubProfilesValue {
    /**
     * 
     * @type {number}
     * @memberof NetworkEpcConfigsSubProfilesValue
     */
    'max_dl_bit_rate': number;
    /**
     * 
     * @type {number}
     * @memberof NetworkEpcConfigsSubProfilesValue
     */
    'max_ul_bit_rate': number;
}
/**
 * Feature flags for a network
 * @export
 * @interface NetworkFeatures
 */
export interface NetworkFeatures {
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof NetworkFeatures
     */
    'features'?: { [key: string]: string; };
}
/**
 * Federation configuration for a network
 * @export
 * @interface NetworkFederationConfigs
 */
export interface NetworkFederationConfigs {
    /**
     * 
     * @type {AaaServer}
     * @memberof NetworkFederationConfigs
     */
    'aaa_server': AaaServer;
    /**
     * 
     * @type {Csfb}
     * @memberof NetworkFederationConfigs
     */
    'csfb'?: Csfb;
    /**
     * 
     * @type {EapAka}
     * @memberof NetworkFederationConfigs
     */
    'eap_aka': EapAka;
    /**
     * 
     * @type {EapSim}
     * @memberof NetworkFederationConfigs
     */
    'eap_sim'?: EapSim;
    /**
     * 
     * @type {Gx}
     * @memberof NetworkFederationConfigs
     */
    'gx': Gx;
    /**
     * 
     * @type {Gy}
     * @memberof NetworkFederationConfigs
     */
    'gy': Gy;
    /**
     * 
     * @type {Health}
     * @memberof NetworkFederationConfigs
     */
    'health': Health;
    /**
     * 
     * @type {Hss}
     * @memberof NetworkFederationConfigs
     */
    'hss': Hss;
    /**
     * neutral host PLMN ID to serving FeG network routes
     * @type {{ [key: string]: string; }}
     * @memberof NetworkFederationConfigs
     */
    'nh_routes'?: { [key: string]: string; };
    /**
     * 
     * @type {S6a}
     * @memberof NetworkFederationConfigs
     */
    's6a': S6a;
    /**
     * 
     * @type {S8}
     * @memberof NetworkFederationConfigs
     */
    's8'?: S8;
    /**
     * served network IDs
     * @type {Array<string>}
     * @memberof NetworkFederationConfigs
     */
    'served_network_ids': Array<string>;
    /**
     * served neutral host IDs
     * @type {Array<string>}
     * @memberof NetworkFederationConfigs
     */
    'served_nh_ids'?: Array<string>;
    /**
     * 
     * @type {Swx}
     * @memberof NetworkFederationConfigs
     */
    'swx': Swx;
}
/**
 * 
 * @export
 * @interface NetworkInterface
 */
export interface NetworkInterface {
    /**
     * 
     * @type {Array<string>}
     * @memberof NetworkInterface
     */
    'ip_addresses'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof NetworkInterface
     */
    'ipv6_addresses'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof NetworkInterface
     */
    'mac_address'?: string;
    /**
     * 
     * @type {string}
     * @memberof NetworkInterface
     */
    'network_interface_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof NetworkInterface
     */
    'status'?: NetworkInterfaceStatusEnum;
}

export const NetworkInterfaceStatusEnum = {
    Up: 'UP',
    Down: 'DOWN',
    Unknown: 'UNKNOWN'
} as const;

export type NetworkInterfaceStatusEnum = typeof NetworkInterfaceStatusEnum[keyof typeof NetworkInterfaceStatusEnum];

/**
 * NextGeneration Core configuration for network
 * @export
 * @interface NetworkNgcConfigs
 */
export interface NetworkNgcConfigs {
    /**
     * List of SuciProfiles shall be configured only for 5G
     * @type {Array<SuciProfile>}
     * @memberof NetworkNgcConfigs
     */
    'suci_profiles'?: Array<SuciProfile>;
}
/**
 * Network Probe State
 * @export
 * @interface NetworkProbeData
 */
export interface NetworkProbeData {
    /**
     * The timestamp in ISO 8601 format of last exported record
     * @type {string}
     * @memberof NetworkProbeData
     */
    'last_exported': string;
    /**
     * 
     * @type {number}
     * @memberof NetworkProbeData
     */
    'sequence_number': number;
    /**
     * 
     * @type {string}
     * @memberof NetworkProbeData
     */
    'target_id': string;
}
/**
 * Network Probe Destination
 * @export
 * @interface NetworkProbeDestination
 */
export interface NetworkProbeDestination {
    /**
     * 
     * @type {NetworkProbeDestinationDetails}
     * @memberof NetworkProbeDestination
     */
    'destination_details': NetworkProbeDestinationDetails;
    /**
     * 
     * @type {string}
     * @memberof NetworkProbeDestination
     */
    'destination_id': string;
}
/**
 * 
 * @export
 * @interface NetworkProbeDestinationDetails
 */
export interface NetworkProbeDestinationDetails {
    /**
     * destination tls client certificate.
     * @type {string}
     * @memberof NetworkProbeDestinationDetails
     */
    'certificate': string;
    /**
     * 
     * @type {string}
     * @memberof NetworkProbeDestinationDetails
     */
    'delivery_address': string;
    /**
     * 
     * @type {string}
     * @memberof NetworkProbeDestinationDetails
     */
    'delivery_type': NetworkProbeDestinationDetailsDeliveryTypeEnum;
    /**
     * destination tls client private key.
     * @type {string}
     * @memberof NetworkProbeDestinationDetails
     */
    'private_key': string;
    /**
     * enables exporter to skip server certs verification.
     * @type {boolean}
     * @memberof NetworkProbeDestinationDetails
     */
    'skip_verify_server': boolean;
}

export const NetworkProbeDestinationDetailsDeliveryTypeEnum = {
    All: 'all',
    EventsOnly: 'events_only'
} as const;

export type NetworkProbeDestinationDetailsDeliveryTypeEnum = typeof NetworkProbeDestinationDetailsDeliveryTypeEnum[keyof typeof NetworkProbeDestinationDetailsDeliveryTypeEnum];

/**
 * Network Probe Task
 * @export
 * @interface NetworkProbeTask
 */
export interface NetworkProbeTask {
    /**
     * 
     * @type {NetworkProbeTaskDetails}
     * @memberof NetworkProbeTask
     */
    'task_details': NetworkProbeTaskDetails;
    /**
     * 
     * @type {string}
     * @memberof NetworkProbeTask
     */
    'task_id': string;
}
/**
 * 
 * @export
 * @interface NetworkProbeTaskDetails
 */
export interface NetworkProbeTaskDetails {
    /**
     * 
     * @type {number}
     * @memberof NetworkProbeTaskDetails
     */
    'correlation_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof NetworkProbeTaskDetails
     */
    'delivery_type': NetworkProbeTaskDetailsDeliveryTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof NetworkProbeTaskDetails
     */
    'domain_id'?: string;
    /**
     * the duration in seconds after which the task will expire.
     * @type {number}
     * @memberof NetworkProbeTaskDetails
     */
    'duration'?: number;
    /**
     * represents the mobile operator identifier
     * @type {number}
     * @memberof NetworkProbeTaskDetails
     */
    'operator_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof NetworkProbeTaskDetails
     */
    'target_id': string;
    /**
     * 
     * @type {string}
     * @memberof NetworkProbeTaskDetails
     */
    'target_type': NetworkProbeTaskDetailsTargetTypeEnum;
    /**
     * The timestamp in ISO 8601 format
     * @type {string}
     * @memberof NetworkProbeTaskDetails
     */
    'timestamp'?: string;
}

export const NetworkProbeTaskDetailsDeliveryTypeEnum = {
    All: 'all',
    EventsOnly: 'events_only'
} as const;

export type NetworkProbeTaskDetailsDeliveryTypeEnum = typeof NetworkProbeTaskDetailsDeliveryTypeEnum[keyof typeof NetworkProbeTaskDetailsDeliveryTypeEnum];
export const NetworkProbeTaskDetailsTargetTypeEnum = {
    Imsi: 'imsi',
    Imei: 'imei',
    Msisdn: 'msisdn'
} as const;

export type NetworkProbeTaskDetailsTargetTypeEnum = typeof NetworkProbeTaskDetailsTargetTypeEnum[keyof typeof NetworkProbeTaskDetailsTargetTypeEnum];

/**
 * RAN (radio access network) cellular configuration for a network
 * @export
 * @interface NetworkRanConfigs
 */
export interface NetworkRanConfigs {
    /**
     * 
     * @type {number}
     * @memberof NetworkRanConfigs
     */
    'bandwidth_mhz': number;
    /**
     * 
     * @type {NetworkRanConfigsFddConfig}
     * @memberof NetworkRanConfigs
     */
    'fdd_config'?: NetworkRanConfigsFddConfig;
    /**
     * 
     * @type {NetworkRanConfigsTddConfig}
     * @memberof NetworkRanConfigs
     */
    'tdd_config'?: NetworkRanConfigsTddConfig;
}
/**
 * 
 * @export
 * @interface NetworkRanConfigsFddConfig
 */
export interface NetworkRanConfigsFddConfig {
    /**
     * 
     * @type {number}
     * @memberof NetworkRanConfigsFddConfig
     */
    'earfcndl': number;
    /**
     * 
     * @type {number}
     * @memberof NetworkRanConfigsFddConfig
     */
    'earfcnul': number;
}
/**
 * 
 * @export
 * @interface NetworkRanConfigsTddConfig
 */
export interface NetworkRanConfigsTddConfig {
    /**
     * 
     * @type {number}
     * @memberof NetworkRanConfigsTddConfig
     */
    'earfcndl': number;
    /**
     * 
     * @type {number}
     * @memberof NetworkRanConfigsTddConfig
     */
    'special_subframe_pattern': number;
    /**
     * 
     * @type {number}
     * @memberof NetworkRanConfigsTddConfig
     */
    'subframe_assignment': number;
}
/**
 * Sentry.io configuration
 * @export
 * @interface NetworkSentryConfig
 */
export interface NetworkSentryConfig {
    /**
     * log message patterns that are excluded (regex substring match)
     * @type {Array<string>}
     * @memberof NetworkSentryConfig
     */
    'exclusion_patterns'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof NetworkSentryConfig
     */
    'number_of_lines_in_log'?: number;
    /**
     * 
     * @type {number}
     * @memberof NetworkSentryConfig
     */
    'sample_rate'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof NetworkSentryConfig
     */
    'upload_mme_log'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof NetworkSentryConfig
     */
    'url_native'?: string;
    /**
     * 
     * @type {string}
     * @memberof NetworkSentryConfig
     */
    'url_python'?: string;
}
/**
 * Network-wide Subscriber Configuration
 * @export
 * @interface NetworkSubscriberConfig
 */
export interface NetworkSubscriberConfig {
    /**
     * List of base names
     * @type {Array<string>}
     * @memberof NetworkSubscriberConfig
     */
    'network_wide_base_names'?: Array<string>;
    /**
     * List of rule names
     * @type {Array<string>}
     * @memberof NetworkSubscriberConfig
     */
    'network_wide_rule_names'?: Array<string>;
}
/**
 * Page of cbsds
 * @export
 * @interface PaginatedCbsds
 */
export interface PaginatedCbsds {
    /**
     * 
     * @type {Array<Cbsd>}
     * @memberof PaginatedCbsds
     */
    'cbsds': Array<Cbsd>;
    /**
     * Total number of cbsds
     * @type {number}
     * @memberof PaginatedCbsds
     */
    'total_count': number;
}
/**
 * Page of eNodeBs
 * @export
 * @interface PaginatedEnodebs
 */
export interface PaginatedEnodebs {
    /**
     * 
     * @type {{ [key: string]: Enodeb; }}
     * @memberof PaginatedEnodebs
     */
    'enodebs': { [key: string]: Enodeb; };
    /**
     * Base64-encoded page token for subsequent paginated API requests
     * @type {string}
     * @memberof PaginatedEnodebs
     */
    'page_token': string;
    /**
     * Estimated total number of eNodeBs
     * @type {number}
     * @memberof PaginatedEnodebs
     */
    'total_count': number;
}
/**
 * Page of gateways
 * @export
 * @interface PaginatedGateways
 */
export interface PaginatedGateways {
    /**
     * 
     * @type {{ [key: string]: MagmadGateway; }}
     * @memberof PaginatedGateways
     */
    'gateways': { [key: string]: MagmadGateway; };
    /**
     * Base64-encoded page token for subsequent paginated API requests
     * @type {string}
     * @memberof PaginatedGateways
     */
    'page_token': string;
    /**
     * Estimated total number of gateways
     * @type {number}
     * @memberof PaginatedGateways
     */
    'total_count': number;
}
/**
 * Page of logs
 * @export
 * @interface PaginatedLogs
 */
export interface PaginatedLogs {
    /**
     * 
     * @type {Array<Log>}
     * @memberof PaginatedLogs
     */
    'logs': Array<Log>;
    /**
     * Total number of logs
     * @type {number}
     * @memberof PaginatedLogs
     */
    'total_count': number;
}
/**
 * Page of subscriber IDs
 * @export
 * @interface PaginatedSubscriberIds
 */
export interface PaginatedSubscriberIds {
    /**
     * Base64-encoded page token for subsequent paginated API requests
     * @type {string}
     * @memberof PaginatedSubscriberIds
     */
    'next_page_token': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof PaginatedSubscriberIds
     */
    'subscribers': Array<string>;
    /**
     * Estimated total number of subscriber entries
     * @type {number}
     * @memberof PaginatedSubscriberIds
     */
    'total_count': number;
}
/**
 * Page of subscribers
 * @export
 * @interface PaginatedSubscribers
 */
export interface PaginatedSubscribers {
    /**
     * Base64-encoded page token for subsequent paginated API requests
     * @type {string}
     * @memberof PaginatedSubscribers
     */
    'next_page_token': string;
    /**
     * 
     * @type {{ [key: string]: Subscriber; }}
     * @memberof PaginatedSubscribers
     */
    'subscribers': { [key: string]: Subscriber; };
    /**
     * estimated total number of subscriber entries
     * @type {number}
     * @memberof PaginatedSubscribers
     */
    'total_count': number;
}
/**
 * 
 * @export
 * @interface PingRequest
 */
export interface PingRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof PingRequest
     */
    'hosts': Array<string>;
    /**
     * 
     * @type {number}
     * @memberof PingRequest
     */
    'packets'?: number;
}
/**
 * 
 * @export
 * @interface PingResponse
 */
export interface PingResponse {
    /**
     * 
     * @type {Array<PingResult>}
     * @memberof PingResponse
     */
    'pings': Array<PingResult>;
}
/**
 * 
 * @export
 * @interface PingResult
 */
export interface PingResult {
    /**
     * 
     * @type {number}
     * @memberof PingResult
     */
    'avg_response_ms'?: number;
    /**
     * 
     * @type {string}
     * @memberof PingResult
     */
    'error'?: string;
    /**
     * 
     * @type {string}
     * @memberof PingResult
     */
    'host_or_ip': string;
    /**
     * 
     * @type {number}
     * @memberof PingResult
     */
    'num_packets': number;
    /**
     * 
     * @type {number}
     * @memberof PingResult
     */
    'packets_received'?: number;
    /**
     * 
     * @type {number}
     * @memberof PingResult
     */
    'packets_transmitted'?: number;
}
/**
 * 
 * @export
 * @interface PlatformInfo
 */
export interface PlatformInfo {
    /**
     * 
     * @type {ConfigInfo}
     * @memberof PlatformInfo
     */
    'config_info'?: ConfigInfo;
    /**
     * 
     * @type {string}
     * @memberof PlatformInfo
     */
    'kernel_version'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof PlatformInfo
     */
    'kernel_versions_installed'?: Array<string>;
    /**
     * 
     * @type {Array<DistributionPackage>}
     * @memberof PlatformInfo
     */
    'packages'?: Array<DistributionPackage>;
    /**
     * 
     * @type {string}
     * @memberof PlatformInfo
     */
    'vpn_ip'?: string;
}
/**
 * PLMN Configuration
 * @export
 * @interface PlmnConfig
 */
export interface PlmnConfig {
    /**
     * 
     * @type {string}
     * @memberof PlmnConfig
     */
    'mcc': string;
    /**
     * 
     * @type {string}
     * @memberof PlmnConfig
     */
    'mnc': string;
}
/**
 * The policy specifies whether a user is  either denied or allowed access to read/write a resource. If the resource is of type URI, the path field should be filled in. If the resource is of type NETWORK_ID or TENANT_ID, the resourceIDs field should be filled in. 
 * @export
 * @interface Policy
 */
export interface Policy {
    /**
     * 
     * @type {string}
     * @memberof Policy
     */
    'action'?: PolicyActionEnum;
    /**
     * 
     * @type {string}
     * @memberof Policy
     */
    'effect'?: PolicyEffectEnum;
    /**
     * 
     * @type {string}
     * @memberof Policy
     */
    'path'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Policy
     */
    'resourceIDs'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Policy
     */
    'resourceType'?: PolicyResourceTypeEnum;
}

export const PolicyActionEnum = {
    Read: 'READ',
    Write: 'WRITE'
} as const;

export type PolicyActionEnum = typeof PolicyActionEnum[keyof typeof PolicyActionEnum];
export const PolicyEffectEnum = {
    Deny: 'DENY',
    Allow: 'ALLOW'
} as const;

export type PolicyEffectEnum = typeof PolicyEffectEnum[keyof typeof PolicyEffectEnum];
export const PolicyResourceTypeEnum = {
    NetworkId: 'NETWORK_ID',
    TenantId: 'TENANT_ID',
    Uri: 'URI'
} as const;

export type PolicyResourceTypeEnum = typeof PolicyResourceTypeEnum[keyof typeof PolicyResourceTypeEnum];

/**
 * An object that defines a user\'s permissions to access resources
 * @export
 * @interface PolicyList
 */
export interface PolicyList {
    /**
     * 
     * @type {Array<Policy>}
     * @memberof PolicyList
     */
    'policies': Array<Policy>;
    /**
     * 
     * @type {string}
     * @memberof PolicyList
     */
    'token': string;
}
/**
 * 
 * @export
 * @interface PolicyQosProfile
 */
export interface PolicyQosProfile {
    /**
     * 
     * @type {Arp}
     * @memberof PolicyQosProfile
     */
    'arp'?: Arp;
    /**
     * 
     * @type {QosClassId}
     * @memberof PolicyQosProfile
     */
    'class_id': QosClassId;
    /**
     * 
     * @type {Gbr}
     * @memberof PolicyQosProfile
     */
    'gbr'?: Gbr;
    /**
     * 
     * @type {string}
     * @memberof PolicyQosProfile
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof PolicyQosProfile
     */
    'max_req_bw_dl': number;
    /**
     * 
     * @type {number}
     * @memberof PolicyQosProfile
     */
    'max_req_bw_ul': number;
}
/**
 * 
 * @export
 * @interface PolicyRule
 */
export interface PolicyRule {
    /**
     * 
     * @type {string}
     * @memberof PolicyRule
     */
    'app_name'?: PolicyRuleAppNameEnum;
    /**
     * 
     * @type {string}
     * @memberof PolicyRule
     */
    'app_service_type'?: PolicyRuleAppServiceTypeEnum;
    /**
     * Subscribers which have been assigned this policy not as part of a base name
     * @type {Array<string>}
     * @memberof PolicyRule
     */
    'assigned_subscribers'?: Array<string>;
    /**
     * 
     * @type {Array<FlowDescription>}
     * @memberof PolicyRule
     */
    'flow_list': Array<FlowDescription>;
    /**
     * List of URL targets for header enrichment
     * @type {Array<string>}
     * @memberof PolicyRule
     */
    'header_enrichment_targets'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof PolicyRule
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof PolicyRule
     */
    'monitoring_key'?: string;
    /**
     * 
     * @type {number}
     * @memberof PolicyRule
     */
    'priority': number;
    /**
     * ID of the QoS profile associated with this policy
     * @type {string}
     * @memberof PolicyRule
     */
    'qos_profile'?: string;
    /**
     * 
     * @type {number}
     * @memberof PolicyRule
     */
    'rating_group'?: number;
    /**
     * 
     * @type {RedirectInformation}
     * @memberof PolicyRule
     */
    'redirect'?: RedirectInformation;
    /**
     * 
     * @type {number}
     * @memberof PolicyRule
     */
    'service_identifier'?: number;
    /**
     * 
     * @type {string}
     * @memberof PolicyRule
     */
    'tracking_type'?: PolicyRuleTrackingTypeEnum;
}

export const PolicyRuleAppNameEnum = {
    NoAppName: 'NO_APP_NAME',
    Facebook: 'FACEBOOK',
    FacebookMessenger: 'FACEBOOK_MESSENGER',
    Instagram: 'INSTAGRAM',
    Youtube: 'YOUTUBE',
    Google: 'GOOGLE',
    Gmail: 'GMAIL',
    GoogleDocs: 'GOOGLE_DOCS',
    Netflix: 'NETFLIX',
    Apple: 'APPLE',
    Microsoft: 'MICROSOFT',
    Reddit: 'REDDIT',
    Whatsapp: 'WHATSAPP',
    GooglePlay: 'GOOGLE_PLAY',
    Appstore: 'APPSTORE',
    Amazon: 'AMAZON',
    Wechat: 'WECHAT',
    Tiktok: 'TIKTOK',
    Twitter: 'TWITTER',
    Wikipedia: 'WIKIPEDIA',
    GoogleMaps: 'GOOGLE_MAPS',
    Yahoo: 'YAHOO',
    Imo: 'IMO'
} as const;

export type PolicyRuleAppNameEnum = typeof PolicyRuleAppNameEnum[keyof typeof PolicyRuleAppNameEnum];
export const PolicyRuleAppServiceTypeEnum = {
    NoServiceType: 'NO_SERVICE_TYPE',
    Chat: 'CHAT',
    Audio: 'AUDIO',
    Video: 'VIDEO'
} as const;

export type PolicyRuleAppServiceTypeEnum = typeof PolicyRuleAppServiceTypeEnum[keyof typeof PolicyRuleAppServiceTypeEnum];
export const PolicyRuleTrackingTypeEnum = {
    OnlyOcs: 'ONLY_OCS',
    OnlyPcrf: 'ONLY_PCRF',
    OcsAndPcrf: 'OCS_AND_PCRF',
    NoTracking: 'NO_TRACKING'
} as const;

export type PolicyRuleTrackingTypeEnum = typeof PolicyRuleTrackingTypeEnum[keyof typeof PolicyRuleTrackingTypeEnum];

/**
 * 
 * @export
 * @interface PolicyRuleConfig
 */
export interface PolicyRuleConfig {
    /**
     * 
     * @type {string}
     * @memberof PolicyRuleConfig
     */
    'app_name'?: PolicyRuleConfigAppNameEnum;
    /**
     * 
     * @type {string}
     * @memberof PolicyRuleConfig
     */
    'app_service_type'?: PolicyRuleConfigAppServiceTypeEnum;
    /**
     * 
     * @type {Array<FlowDescription>}
     * @memberof PolicyRuleConfig
     */
    'flow_list': Array<FlowDescription>;
    /**
     * List of URL targets for header enrichment
     * @type {Array<string>}
     * @memberof PolicyRuleConfig
     */
    'header_enrichment_targets'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof PolicyRuleConfig
     */
    'monitoring_key'?: string;
    /**
     * 
     * @type {number}
     * @memberof PolicyRuleConfig
     */
    'priority': number;
    /**
     * 
     * @type {number}
     * @memberof PolicyRuleConfig
     */
    'rating_group'?: number;
    /**
     * 
     * @type {RedirectInformation}
     * @memberof PolicyRuleConfig
     */
    'redirect'?: RedirectInformation;
    /**
     * 
     * @type {number}
     * @memberof PolicyRuleConfig
     */
    'service_identifier'?: number;
    /**
     * 
     * @type {string}
     * @memberof PolicyRuleConfig
     */
    'tracking_type'?: PolicyRuleConfigTrackingTypeEnum;
}

export const PolicyRuleConfigAppNameEnum = {
    NoAppName: 'NO_APP_NAME',
    Facebook: 'FACEBOOK',
    FacebookMessenger: 'FACEBOOK_MESSENGER',
    Instagram: 'INSTAGRAM',
    Youtube: 'YOUTUBE',
    Google: 'GOOGLE',
    Gmail: 'GMAIL',
    GoogleDocs: 'GOOGLE_DOCS',
    Netflix: 'NETFLIX',
    Apple: 'APPLE',
    Microsoft: 'MICROSOFT',
    Reddit: 'REDDIT',
    Whatsapp: 'WHATSAPP',
    GooglePlay: 'GOOGLE_PLAY',
    Appstore: 'APPSTORE',
    Amazon: 'AMAZON',
    Wechat: 'WECHAT',
    Tiktok: 'TIKTOK',
    Twitter: 'TWITTER',
    Wikipedia: 'WIKIPEDIA',
    GoogleMaps: 'GOOGLE_MAPS',
    Yahoo: 'YAHOO',
    Imo: 'IMO'
} as const;

export type PolicyRuleConfigAppNameEnum = typeof PolicyRuleConfigAppNameEnum[keyof typeof PolicyRuleConfigAppNameEnum];
export const PolicyRuleConfigAppServiceTypeEnum = {
    NoServiceType: 'NO_SERVICE_TYPE',
    Chat: 'CHAT',
    Audio: 'AUDIO',
    Video: 'VIDEO'
} as const;

export type PolicyRuleConfigAppServiceTypeEnum = typeof PolicyRuleConfigAppServiceTypeEnum[keyof typeof PolicyRuleConfigAppServiceTypeEnum];
export const PolicyRuleConfigTrackingTypeEnum = {
    OnlyOcs: 'ONLY_OCS',
    OnlyPcrf: 'ONLY_PCRF',
    OcsAndPcrf: 'OCS_AND_PCRF',
    NoTracking: 'NO_TRACKING'
} as const;

export type PolicyRuleConfigTrackingTypeEnum = typeof PolicyRuleConfigTrackingTypeEnum[keyof typeof PolicyRuleConfigTrackingTypeEnum];

/**
 * 
 * @export
 * @interface PromAlertConfig
 */
export interface PromAlertConfig {
    /**
     * 
     * @type {string}
     * @memberof PromAlertConfig
     */
    'alert': string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof PromAlertConfig
     */
    'annotations'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof PromAlertConfig
     */
    'expr': string;
    /**
     * 
     * @type {string}
     * @memberof PromAlertConfig
     */
    'for'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof PromAlertConfig
     */
    'labels'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface PromAlertStatus
 */
export interface PromAlertStatus {
    /**
     * 
     * @type {Array<string>}
     * @memberof PromAlertStatus
     */
    'inhibitedBy': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof PromAlertStatus
     */
    'silencedBy': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof PromAlertStatus
     */
    'state': string;
}
/**
 * 
 * @export
 * @interface PromFiringAlert
 */
export interface PromFiringAlert {
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof PromFiringAlert
     */
    'annotations': { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof PromFiringAlert
     */
    'endsAt': string;
    /**
     * 
     * @type {string}
     * @memberof PromFiringAlert
     */
    'fingerprint': string;
    /**
     * 
     * @type {string}
     * @memberof PromFiringAlert
     */
    'generatorURL'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof PromFiringAlert
     */
    'labels': { [key: string]: string; };
    /**
     * 
     * @type {GettableAlert}
     * @memberof PromFiringAlert
     */
    'receivers': GettableAlert;
    /**
     * 
     * @type {string}
     * @memberof PromFiringAlert
     */
    'startsAt': string;
    /**
     * 
     * @type {PromAlertStatus}
     * @memberof PromFiringAlert
     */
    'status': PromAlertStatus;
    /**
     * 
     * @type {string}
     * @memberof PromFiringAlert
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface PrometheusTargetMetadata
 */
export interface PrometheusTargetMetadata {
    /**
     * 
     * @type {string}
     * @memberof PrometheusTargetMetadata
     */
    'instance': string;
    /**
     * 
     * @type {string}
     * @memberof PrometheusTargetMetadata
     */
    'job': string;
}
/**
 * 
 * @export
 * @interface PrometheusTargetsMetadata
 */
export interface PrometheusTargetsMetadata {
    /**
     * 
     * @type {string}
     * @memberof PrometheusTargetsMetadata
     */
    'help': string;
    /**
     * 
     * @type {string}
     * @memberof PrometheusTargetsMetadata
     */
    'metric': string;
    /**
     * 
     * @type {PrometheusTargetMetadata}
     * @memberof PrometheusTargetsMetadata
     */
    'target': PrometheusTargetMetadata;
    /**
     * 
     * @type {string}
     * @memberof PrometheusTargetsMetadata
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof PrometheusTargetsMetadata
     */
    'unit': string;
}
/**
 * 
 * @export
 * @interface PromqlData
 */
export interface PromqlData {
    /**
     * 
     * @type {Array<PromqlMetricValue>}
     * @memberof PromqlData
     */
    'result': Array<PromqlMetricValue>;
    /**
     * 
     * @type {string}
     * @memberof PromqlData
     */
    'resultType': string;
}
/**
 * 
 * @export
 * @interface PromqlMetric
 */
export interface PromqlMetric {
    /**
     * 
     * @type {string}
     * @memberof PromqlMetric
     */
    'additionalProperties'?: string;
}
/**
 * If resultType is \'vector\' value is in the result, if \'matrix\', values is in the result
 * @export
 * @interface PromqlMetricValue
 */
export interface PromqlMetricValue {
    /**
     * 
     * @type {PromqlMetric}
     * @memberof PromqlMetricValue
     */
    'metric': PromqlMetric;
    /**
     * 
     * @type {Array<string>}
     * @memberof PromqlMetricValue
     */
    'value'?: Array<string>;
    /**
     * 
     * @type {Array<Array<string>>}
     * @memberof PromqlMetricValue
     */
    'values'?: Array<Array<string>>;
}
/**
 * 
 * @export
 * @interface PromqlReturnObject
 */
export interface PromqlReturnObject {
    /**
     * 
     * @type {PromqlData}
     * @memberof PromqlReturnObject
     */
    'data': PromqlData;
    /**
     * 
     * @type {string}
     * @memberof PromqlReturnObject
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface PushedMetric
 */
export interface PushedMetric {
    /**
     * 
     * @type {Array<LabelPair>}
     * @memberof PushedMetric
     */
    'labels'?: Array<LabelPair>;
    /**
     * 
     * @type {string}
     * @memberof PushedMetric
     */
    'metricName': string;
    /**
     * 
     * @type {string}
     * @memberof PushedMetric
     */
    'timestamp'?: string;
    /**
     * 
     * @type {number}
     * @memberof PushedMetric
     */
    'value': number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const QosClassId = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_3: 3,
    NUMBER_4: 4,
    NUMBER_5: 5,
    NUMBER_6: 6,
    NUMBER_7: 7,
    NUMBER_8: 8,
    NUMBER_9: 9,
    NUMBER_65: 65,
    NUMBER_66: 66,
    NUMBER_67: 67,
    NUMBER_70: 70,
    NUMBER_75: 75,
    NUMBER_79: 79
} as const;

export type QosClassId = typeof QosClassId[keyof typeof QosClassId];


/**
 * 
 * @export
 * @interface QosProfile
 */
export interface QosProfile {
    /**
     * 
     * @type {number}
     * @memberof QosProfile
     */
    'class_id'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof QosProfile
     */
    'preemption_capability'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof QosProfile
     */
    'preemption_vulnerability'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof QosProfile
     */
    'priority_level'?: number;
}
/**
 * built-in radius server configuration
 * @export
 * @interface RadiusConfig
 */
export interface RadiusConfig {
    /**
     * 
     * @type {string}
     * @memberof RadiusConfig
     */
    'DAE_addr'?: string;
    /**
     * 
     * @type {string}
     * @memberof RadiusConfig
     */
    'acct_addr'?: string;
    /**
     * 
     * @type {string}
     * @memberof RadiusConfig
     */
    'auth_addr'?: string;
    /**
     * 
     * @type {string}
     * @memberof RadiusConfig
     */
    'network'?: string;
    /**
     * 
     * @type {string}
     * @memberof RadiusConfig
     */
    'secret'?: string;
}
/**
 * 
 * @export
 * @interface RatingGroup
 */
export interface RatingGroup {
    /**
     * 
     * @type {number}
     * @memberof RatingGroup
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof RatingGroup
     */
    'limit_type': RatingGroupLimitTypeEnum;
}

export const RatingGroupLimitTypeEnum = {
    Finite: 'FINITE',
    InfiniteUnmetered: 'INFINITE_UNMETERED',
    InfiniteMetered: 'INFINITE_METERED'
} as const;

export type RatingGroupLimitTypeEnum = typeof RatingGroupLimitTypeEnum[keyof typeof RatingGroupLimitTypeEnum];

/**
 * 
 * @export
 * @interface RedirectInformation
 */
export interface RedirectInformation {
    /**
     * 
     * @type {string}
     * @memberof RedirectInformation
     */
    'address_type': RedirectInformationAddressTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof RedirectInformation
     */
    'server_address': string;
    /**
     * 
     * @type {string}
     * @memberof RedirectInformation
     */
    'support': RedirectInformationSupportEnum;
}

export const RedirectInformationAddressTypeEnum = {
    Ipv4: 'IPv4',
    Ipv6: 'IPv6',
    Url: 'URL',
    SipUri: 'SIP_URI'
} as const;

export type RedirectInformationAddressTypeEnum = typeof RedirectInformationAddressTypeEnum[keyof typeof RedirectInformationAddressTypeEnum];
export const RedirectInformationSupportEnum = {
    Disabled: 'DISABLED',
    Enabled: 'ENABLED'
} as const;

export type RedirectInformationSupportEnum = typeof RedirectInformationSupportEnum[keyof typeof RedirectInformationSupportEnum];

/**
 * 
 * @export
 * @interface RegistrationInfo
 */
export interface RegistrationInfo {
    /**
     * domain_name is the domain name where the stated orc8r can be accessed
     * @type {string}
     * @memberof RegistrationInfo
     */
    'domain_name': string;
    /**
     * registration_token is a token for the operator to give to the AGW; it keys to logical and network ID
     * @type {string}
     * @memberof RegistrationInfo
     */
    'registration_token': string;
    /**
     * root_ca is a certificate that access gateways (AGW) can use to handshake and communicate with the stated orc8r
     * @type {string}
     * @memberof RegistrationInfo
     */
    'root_ca': string;
}
/**
 * 
 * @export
 * @interface ReleaseChannel
 */
export interface ReleaseChannel {
    /**
     * 
     * @type {string}
     * @memberof ReleaseChannel
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ReleaseChannel
     */
    'name'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ReleaseChannel
     */
    'supported_versions': Array<string>;
}
/**
 * 
 * @export
 * @interface Route
 */
export interface Route {
    /**
     * 
     * @type {string}
     * @memberof Route
     */
    'destination_ip'?: string;
    /**
     * 
     * @type {string}
     * @memberof Route
     */
    'gateway_ip'?: string;
    /**
     * 
     * @type {string}
     * @memberof Route
     */
    'genmask'?: string;
    /**
     * 
     * @type {string}
     * @memberof Route
     */
    'network_interface_id'?: string;
}
/**
 * s6a configuration
 * @export
 * @interface S6a
 */
export interface S6a {
    /**
     * 
     * @type {Array<string>}
     * @memberof S6a
     */
    'plmn_ids'?: Array<string>;
    /**
     * 
     * @type {DiameterClientConfigs}
     * @memberof S6a
     */
    'server'?: DiameterClientConfigs;
}
/**
 * s8 configuration
 * @export
 * @interface S8
 */
export interface S8 {
    /**
     * 
     * @type {string}
     * @memberof S8
     */
    'apn_operator_suffix'?: string;
    /**
     * 
     * @type {string}
     * @memberof S8
     */
    'local_address'?: string;
    /**
     * 
     * @type {string}
     * @memberof S8
     */
    'pgw_address'?: string;
}
/**
 * SCTP Configuration of the CSFB service
 * @export
 * @interface SctpClientConfigs
 */
export interface SctpClientConfigs {
    /**
     * 
     * @type {string}
     * @memberof SctpClientConfigs
     */
    'local_address'?: string;
    /**
     * 
     * @type {string}
     * @memberof SctpClientConfigs
     */
    'server_address'?: string;
}
/**
 * health status of a specific
 * @export
 * @interface ServiceStatusHealth
 */
export interface ServiceStatusHealth {
    /**
     * 
     * @type {string}
     * @memberof ServiceStatusHealth
     */
    'health_status'?: ServiceStatusHealthHealthStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof ServiceStatusHealth
     */
    'service_state'?: ServiceStatusHealthServiceStateEnum;
}

export const ServiceStatusHealthHealthStatusEnum = {
    Healthy: 'HEALTHY',
    Unhealthy: 'UNHEALTHY'
} as const;

export type ServiceStatusHealthHealthStatusEnum = typeof ServiceStatusHealthHealthStatusEnum[keyof typeof ServiceStatusHealthHealthStatusEnum];
export const ServiceStatusHealthServiceStateEnum = {
    Available: 'AVAILABLE',
    Unavailable: 'UNAVAILABLE'
} as const;

export type ServiceStatusHealthServiceStateEnum = typeof ServiceStatusHealthServiceStateEnum[keyof typeof ServiceStatusHealthServiceStateEnum];

/**
 * 
 * @export
 * @interface SlackAction
 */
export interface SlackAction {
    /**
     * 
     * @type {SlackConfirmField}
     * @memberof SlackAction
     */
    'confirm'?: SlackConfirmField;
    /**
     * 
     * @type {string}
     * @memberof SlackAction
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof SlackAction
     */
    'style'?: string;
    /**
     * 
     * @type {string}
     * @memberof SlackAction
     */
    'text': string;
    /**
     * 
     * @type {string}
     * @memberof SlackAction
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof SlackAction
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof SlackAction
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface SlackConfirmField
 */
export interface SlackConfirmField {
    /**
     * 
     * @type {string}
     * @memberof SlackConfirmField
     */
    'dismiss_text': string;
    /**
     * 
     * @type {string}
     * @memberof SlackConfirmField
     */
    'ok_text': string;
    /**
     * 
     * @type {string}
     * @memberof SlackConfirmField
     */
    'text': string;
    /**
     * 
     * @type {string}
     * @memberof SlackConfirmField
     */
    'title': string;
}
/**
 * 
 * @export
 * @interface SlackField
 */
export interface SlackField {
    /**
     * 
     * @type {boolean}
     * @memberof SlackField
     */
    'short'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof SlackField
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof SlackField
     */
    'value': string;
}
/**
 * 
 * @export
 * @interface SlackReceiver
 */
export interface SlackReceiver {
    /**
     * 
     * @type {Array<SlackAction>}
     * @memberof SlackReceiver
     */
    'actions'?: Array<SlackAction>;
    /**
     * 
     * @type {string}
     * @memberof SlackReceiver
     */
    'api_url': string;
    /**
     * 
     * @type {string}
     * @memberof SlackReceiver
     */
    'callback_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof SlackReceiver
     */
    'channel'?: string;
    /**
     * 
     * @type {string}
     * @memberof SlackReceiver
     */
    'color'?: string;
    /**
     * 
     * @type {string}
     * @memberof SlackReceiver
     */
    'fallback'?: string;
    /**
     * 
     * @type {Array<SlackField>}
     * @memberof SlackReceiver
     */
    'fields'?: Array<SlackField>;
    /**
     * 
     * @type {string}
     * @memberof SlackReceiver
     */
    'footer'?: string;
    /**
     * 
     * @type {string}
     * @memberof SlackReceiver
     */
    'icon_emoji'?: string;
    /**
     * 
     * @type {string}
     * @memberof SlackReceiver
     */
    'icon_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof SlackReceiver
     */
    'image_url'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof SlackReceiver
     */
    'link_names'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof SlackReceiver
     */
    'pretext'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof SlackReceiver
     */
    'short_fields'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof SlackReceiver
     */
    'text'?: string;
    /**
     * 
     * @type {string}
     * @memberof SlackReceiver
     */
    'thumb_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof SlackReceiver
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof SlackReceiver
     */
    'username'?: string;
}
/**
 * 
 * @export
 * @interface SmsMessage
 */
export interface SmsMessage {
    /**
     * 
     * @type {number}
     * @memberof SmsMessage
     */
    'attempt_count': number;
    /**
     * 
     * @type {string}
     * @memberof SmsMessage
     */
    'error_status'?: string;
    /**
     * 
     * @type {string}
     * @memberof SmsMessage
     */
    'imsi': string;
    /**
     * 
     * @type {string}
     * @memberof SmsMessage
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof SmsMessage
     */
    'pk': string;
    /**
     * 
     * @type {string}
     * @memberof SmsMessage
     */
    'source_msisdn': string;
    /**
     * 
     * @type {string}
     * @memberof SmsMessage
     */
    'status': SmsMessageStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof SmsMessage
     */
    'time_created': string;
    /**
     * 
     * @type {string}
     * @memberof SmsMessage
     */
    'time_last_attempted'?: string;
}

export const SmsMessageStatusEnum = {
    Waiting: 'Waiting',
    Delivered: 'Delivered',
    Failed: 'Failed'
} as const;

export type SmsMessageStatusEnum = typeof SmsMessageStatusEnum[keyof typeof SmsMessageStatusEnum];

/**
 * State configuration
 * @export
 * @interface StateConfig
 */
export interface StateConfig {
    /**
     * Sync interval in seconds
     * @type {number}
     * @memberof StateConfig
     */
    'sync_interval'?: number;
}
/**
 * 
 * @export
 * @interface Subscriber
 */
export interface Subscriber {
    /**
     * APNs that are allowed for this subscriber
     * @type {Array<string>}
     * @memberof Subscriber
     */
    'active_apns'?: Array<string>;
    /**
     * List of base names
     * @type {Array<string>}
     * @memberof Subscriber
     */
    'active_base_names'?: Array<string>;
    /**
     * Policies which are globally active for this subscriber
     * @type {Array<string>}
     * @memberof Subscriber
     */
    'active_policies'?: Array<string>;
    /**
     * APN-specific policies for this subscriber
     * @type {{ [key: string]: Array<string>; }}
     * @memberof Subscriber
     */
    'active_policies_by_apn'?: { [key: string]: Array<string>; };
    /**
     * 
     * @type {SubscriberConfig}
     * @memberof Subscriber
     */
    'config': SubscriberConfig;
    /**
     * List of core network types.
     * @type {Array<string>}
     * @memberof Subscriber
     */
    'forbidden_network_types'?: Array<SubscriberForbiddenNetworkTypesEnum>;
    /**
     * 
     * @type {string}
     * @memberof Subscriber
     */
    'id': string;
    /**
     * 
     * @type {LteSubscription}
     * @memberof Subscriber
     */
    'lte': LteSubscription;
    /**
     * 
     * @type {SubscriberStatus}
     * @memberof Subscriber
     */
    'monitoring'?: SubscriberStatus;
    /**
     * Mobile station international subscriber directory number
     * @type {string}
     * @memberof Subscriber
     */
    'msisdn'?: string;
    /**
     * Optional name associated with the subscriber
     * @type {string}
     * @memberof Subscriber
     */
    'name'?: string;
    /**
     * 
     * @type {SubscriberState}
     * @memberof Subscriber
     */
    'state'?: SubscriberState;
}

export const SubscriberForbiddenNetworkTypesEnum = {
    Epc: 'EPC',
    _5Gc: '5GC'
} as const;

export type SubscriberForbiddenNetworkTypesEnum = typeof SubscriberForbiddenNetworkTypesEnum[keyof typeof SubscriberForbiddenNetworkTypesEnum];

/**
 * 
 * @export
 * @interface SubscriberConfig
 */
export interface SubscriberConfig {
    /**
     * List of core network types.
     * @type {Array<string>}
     * @memberof SubscriberConfig
     */
    'forbidden_network_types'?: Array<SubscriberConfigForbiddenNetworkTypesEnum>;
    /**
     * 
     * @type {LteSubscription}
     * @memberof SubscriberConfig
     */
    'lte': LteSubscription;
    /**
     * Mapping of APN ID to static IP address to allocate for the subscriber at the edge
     * @type {{ [key: string]: string; }}
     * @memberof SubscriberConfig
     */
    'static_ips'?: { [key: string]: string; };
}

export const SubscriberConfigForbiddenNetworkTypesEnum = {
    Epc: 'EPC',
    _5Gc: '5GC'
} as const;

export type SubscriberConfigForbiddenNetworkTypesEnum = typeof SubscriberConfigForbiddenNetworkTypesEnum[keyof typeof SubscriberConfigForbiddenNetworkTypesEnum];

/**
 * AGW location history for the subscriber
 * @export
 * @interface SubscriberDirectoryRecord
 */
export interface SubscriberDirectoryRecord {
    /**
     * 
     * @type {Array<string>}
     * @memberof SubscriberDirectoryRecord
     */
    'location_history': Array<string>;
}
/**
 * An IP address which has been allocated for a subscriber for a specific APN
 * @export
 * @interface SubscriberIpAllocation
 */
export interface SubscriberIpAllocation {
    /**
     * 
     * @type {string}
     * @memberof SubscriberIpAllocation
     */
    'apn': string;
    /**
     * 
     * @type {string}
     * @memberof SubscriberIpAllocation
     */
    'ip': string;
}
/**
 * EPC state for a subscriber
 * @export
 * @interface SubscriberState
 */
export interface SubscriberState {
    /**
     * 
     * @type {SubscriberDirectoryRecord}
     * @memberof SubscriberState
     */
    'directory'?: SubscriberDirectoryRecord;
    /**
     * Arbitrary untyped JSON object that represents replicated MME state
     * @type {object}
     * @memberof SubscriberState
     */
    'mme'?: object;
    /**
     * IP addresses which have been allocated for this subscriber
     * @type {Array<SubscriberIpAllocation>}
     * @memberof SubscriberState
     */
    'mobility'?: Array<SubscriberIpAllocation>;
    /**
     * Arbitrary untyped JSON object that represents replicated MME state
     * @type {object}
     * @memberof SubscriberState
     */
    's1ap'?: object;
    /**
     * Arbitrary untyped JSON object that represents replicated MME state
     * @type {object}
     * @memberof SubscriberState
     */
    'spgw'?: object;
    /**
     * Arbitrary untyped JSON object that represents replicated subscriber-related state
     * @type {object}
     * @memberof SubscriberState
     */
    'subscriber_state'?: object;
}
/**
 * Status of a subscriber device
 * @export
 * @interface SubscriberStatus
 */
export interface SubscriberStatus {
    /**
     * 
     * @type {IcmpStatus}
     * @memberof SubscriberStatus
     */
    'icmp'?: IcmpStatus;
}
/**
 * HSS Subscription Profile
 * @export
 * @interface SubscriptionProfile
 */
export interface SubscriptionProfile {
    /**
     * 
     * @type {number}
     * @memberof SubscriptionProfile
     */
    'max_dl_bit_rate'?: number;
    /**
     * 
     * @type {number}
     * @memberof SubscriptionProfile
     */
    'max_ul_bit_rate'?: number;
}
/**
 * SUCI profile for a network. These attributes are defined as per the SUCI encryption/decryption mechanisms specified in the 3GPP TS 33.501.
 * @export
 * @interface SuciProfile
 */
export interface SuciProfile {
    /**
     * HPLMN Private Key
     * @type {string}
     * @memberof SuciProfile
     */
    'home_network_private_key'?: string;
    /**
     * HPLMN Public Key
     * @type {string}
     * @memberof SuciProfile
     */
    'home_network_public_key'?: string;
    /**
     * HPLMN Public Key Identifier
     * @type {number}
     * @memberof SuciProfile
     */
    'home_network_public_key_identifier'?: number;
    /**
     * ECIES Protection scheme
     * @type {string}
     * @memberof SuciProfile
     */
    'protection_scheme'?: SuciProfileProtectionSchemeEnum;
}

export const SuciProfileProtectionSchemeEnum = {
    ProfileA: 'ProfileA',
    ProfileB: 'ProfileB'
} as const;

export type SuciProfileProtectionSchemeEnum = typeof SuciProfileProtectionSchemeEnum[keyof typeof SuciProfileProtectionSchemeEnum];

/**
 * swx configuration
 * @export
 * @interface Swx
 */
export interface Swx {
    /**
     * 
     * @type {number}
     * @memberof Swx
     */
    'cache_TTL_seconds'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Swx
     */
    'derive_unregister_realm'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof Swx
     */
    'hlr_plmn_ids'?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof Swx
     */
    'register_on_auth'?: boolean;
    /**
     * 
     * @type {DiameterClientConfigs}
     * @memberof Swx
     */
    'server'?: DiameterClientConfigs;
    /**
     * 
     * @type {Array<DiameterClientConfigs>}
     * @memberof Swx
     */
    'servers'?: Array<DiameterClientConfigs>;
    /**
     * 
     * @type {boolean}
     * @memberof Swx
     */
    'verify_authorization'?: boolean;
}
/**
 * 
 * @export
 * @interface SystemStatus
 */
export interface SystemStatus {
    /**
     * 
     * @type {number}
     * @memberof SystemStatus
     */
    'cpu_idle'?: number;
    /**
     * 
     * @type {number}
     * @memberof SystemStatus
     */
    'cpu_system'?: number;
    /**
     * 
     * @type {number}
     * @memberof SystemStatus
     */
    'cpu_user'?: number;
    /**
     * 
     * @type {Array<DiskPartition>}
     * @memberof SystemStatus
     */
    'disk_partitions'?: Array<DiskPartition>;
    /**
     * 
     * @type {number}
     * @memberof SystemStatus
     */
    'mem_available'?: number;
    /**
     * 
     * @type {number}
     * @memberof SystemStatus
     */
    'mem_free'?: number;
    /**
     * 
     * @type {number}
     * @memberof SystemStatus
     */
    'mem_total'?: number;
    /**
     * 
     * @type {number}
     * @memberof SystemStatus
     */
    'mem_used'?: number;
    /**
     * 
     * @type {number}
     * @memberof SystemStatus
     */
    'swap_free'?: number;
    /**
     * 
     * @type {number}
     * @memberof SystemStatus
     */
    'swap_total'?: number;
    /**
     * 
     * @type {number}
     * @memberof SystemStatus
     */
    'swap_used'?: number;
    /**
     * 
     * @type {number}
     * @memberof SystemStatus
     */
    'time'?: number;
    /**
     * 
     * @type {number}
     * @memberof SystemStatus
     */
    'uptime_secs'?: number;
}
/**
 * 
 * @export
 * @interface TailLogsRequest
 */
export interface TailLogsRequest {
    /**
     * 
     * @type {string}
     * @memberof TailLogsRequest
     */
    'service'?: string;
}
/**
 * 
 * @export
 * @interface Tenant
 */
export interface Tenant {
    /**
     * Unique integer identifier
     * @type {number}
     * @memberof Tenant
     */
    'id': number;
    /**
     * Name of tenant
     * @type {string}
     * @memberof Tenant
     */
    'name'?: string;
    /**
     * List of accessible networks
     * @type {Array<string>}
     * @memberof Tenant
     */
    'networks': Array<string>;
}
/**
 * 
 * @export
 * @interface TenantsTenantIdMetricsApiV1LabelLabelNameValuesGet200Response
 */
export interface TenantsTenantIdMetricsApiV1LabelLabelNameValuesGet200Response {
    /**
     * 
     * @type {Array<string>}
     * @memberof TenantsTenantIdMetricsApiV1LabelLabelNameValuesGet200Response
     */
    'data': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof TenantsTenantIdMetricsApiV1LabelLabelNameValuesGet200Response
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface Tier
 */
export interface Tier {
    /**
     * 
     * @type {Array<string>}
     * @memberof Tier
     */
    'gateways': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Tier
     */
    'id': string;
    /**
     * 
     * @type {Array<TierImage>}
     * @memberof Tier
     */
    'images': Array<TierImage>;
    /**
     * 
     * @type {string}
     * @memberof Tier
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Tier
     */
    'version': string;
}
/**
 * 
 * @export
 * @interface TierImage
 */
export interface TierImage {
    /**
     * 
     * @type {string}
     * @memberof TierImage
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof TierImage
     */
    'order': number;
}
/**
 * Configuration for externally managed eNodeb devices.
 * @export
 * @interface UnmanagedEnodebConfiguration
 */
export interface UnmanagedEnodebConfiguration {
    /**
     * 
     * @type {number}
     * @memberof UnmanagedEnodebConfiguration
     */
    'cell_id': number;
    /**
     * 
     * @type {string}
     * @memberof UnmanagedEnodebConfiguration
     */
    'ip_address': string;
    /**
     * 
     * @type {number}
     * @memberof UnmanagedEnodebConfiguration
     */
    'tac': number;
}
/**
 * The user\'s authentication info
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'username': string;
}
/**
 * 
 * @export
 * @interface UserUsernameDeleteRequest
 */
export interface UserUsernameDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof UserUsernameDeleteRequest
     */
    'password'?: string;
}
/**
 * 
 * @export
 * @interface VersionInfo
 */
export interface VersionInfo {
    /**
     * 
     * @type {string}
     * @memberof VersionInfo
     */
    'container_image_version'?: string;
    /**
     * 
     * @type {string}
     * @memberof VersionInfo
     */
    'helm_chart_version'?: string;
}
/**
 * Virtual APN Rule configuration
 * @export
 * @interface VirtualApnRule
 */
export interface VirtualApnRule {
    /**
     * Regex to match APN values
     * @type {string}
     * @memberof VirtualApnRule
     */
    'apn_filter'?: string;
    /**
     * New APN to overwrite when filter matches
     * @type {string}
     * @memberof VirtualApnRule
     */
    'apn_overwrite'?: string;
    /**
     * Regex to match ChargingCharacteristics values
     * @type {string}
     * @memberof VirtualApnRule
     */
    'charging_characteristics_filter'?: string;
}
/**
 * 
 * @export
 * @interface WebhookReceiver
 */
export interface WebhookReceiver {
    /**
     * 
     * @type {HttpConfig}
     * @memberof WebhookReceiver
     */
    'http_config'?: HttpConfig;
    /**
     * 
     * @type {boolean}
     * @memberof WebhookReceiver
     */
    'send_resolved'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof WebhookReceiver
     */
    'url': string;
}

/**
 * APNsApi - axios parameter creator
 * @export
 */
export const APNsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove an APN from the network
         * @param {string} networkId Network ID
         * @param {string} apnName Access Point Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdApnsApnNameDelete: async (networkId: string, apnName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdApnsApnNameDelete', 'networkId', networkId)
            // verify required parameter 'apnName' is not null or undefined
            assertParamExists('lteNetworkIdApnsApnNameDelete', 'apnName', apnName)
            const localVarPath = `/lte/{network_id}/apns/{apn_name}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"apn_name"}}`, encodeURIComponent(String(apnName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve the APN info
         * @param {string} networkId Network ID
         * @param {string} apnName Access Point Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdApnsApnNameGet: async (networkId: string, apnName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdApnsApnNameGet', 'networkId', networkId)
            // verify required parameter 'apnName' is not null or undefined
            assertParamExists('lteNetworkIdApnsApnNameGet', 'apnName', apnName)
            const localVarPath = `/lte/{network_id}/apns/{apn_name}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"apn_name"}}`, encodeURIComponent(String(apnName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an existing APN in the network
         * @param {string} networkId Network ID
         * @param {string} apnName Access Point Name
         * @param {Apn} apn New APN configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdApnsApnNamePut: async (networkId: string, apnName: string, apn: Apn, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdApnsApnNamePut', 'networkId', networkId)
            // verify required parameter 'apnName' is not null or undefined
            assertParamExists('lteNetworkIdApnsApnNamePut', 'apnName', apnName)
            // verify required parameter 'apn' is not null or undefined
            assertParamExists('lteNetworkIdApnsApnNamePut', 'apn', apn)
            const localVarPath = `/lte/{network_id}/apns/{apn_name}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"apn_name"}}`, encodeURIComponent(String(apnName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apn, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List APNs in the network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdApnsGet: async (networkId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdApnsGet', 'networkId', networkId)
            const localVarPath = `/lte/{network_id}/apns`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add a new APN to the network
         * @param {string} networkId Network ID
         * @param {Apn} apn New APN configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdApnsPost: async (networkId: string, apn: Apn, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdApnsPost', 'networkId', networkId)
            // verify required parameter 'apn' is not null or undefined
            assertParamExists('lteNetworkIdApnsPost', 'apn', apn)
            const localVarPath = `/lte/{network_id}/apns`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apn, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * APNsApi - functional programming interface
 * @export
 */
export const APNsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = APNsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove an APN from the network
         * @param {string} networkId Network ID
         * @param {string} apnName Access Point Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdApnsApnNameDelete(networkId: string, apnName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdApnsApnNameDelete(networkId, apnName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve the APN info
         * @param {string} networkId Network ID
         * @param {string} apnName Access Point Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdApnsApnNameGet(networkId: string, apnName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Apn>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdApnsApnNameGet(networkId, apnName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update an existing APN in the network
         * @param {string} networkId Network ID
         * @param {string} apnName Access Point Name
         * @param {Apn} apn New APN configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdApnsApnNamePut(networkId: string, apnName: string, apn: Apn, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdApnsApnNamePut(networkId, apnName, apn, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List APNs in the network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdApnsGet(networkId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: Apn; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdApnsGet(networkId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add a new APN to the network
         * @param {string} networkId Network ID
         * @param {Apn} apn New APN configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdApnsPost(networkId: string, apn: Apn, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdApnsPost(networkId, apn, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * APNsApi - factory interface
 * @export
 */
export const APNsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = APNsApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove an APN from the network
         * @param {string} networkId Network ID
         * @param {string} apnName Access Point Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdApnsApnNameDelete(networkId: string, apnName: string, options?: any): AxiosPromise<void> {
            return localVarFp.lteNetworkIdApnsApnNameDelete(networkId, apnName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve the APN info
         * @param {string} networkId Network ID
         * @param {string} apnName Access Point Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdApnsApnNameGet(networkId: string, apnName: string, options?: any): AxiosPromise<Apn> {
            return localVarFp.lteNetworkIdApnsApnNameGet(networkId, apnName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an existing APN in the network
         * @param {string} networkId Network ID
         * @param {string} apnName Access Point Name
         * @param {Apn} apn New APN configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdApnsApnNamePut(networkId: string, apnName: string, apn: Apn, options?: any): AxiosPromise<void> {
            return localVarFp.lteNetworkIdApnsApnNamePut(networkId, apnName, apn, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List APNs in the network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdApnsGet(networkId: string, options?: any): AxiosPromise<{ [key: string]: Apn; }> {
            return localVarFp.lteNetworkIdApnsGet(networkId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add a new APN to the network
         * @param {string} networkId Network ID
         * @param {Apn} apn New APN configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdApnsPost(networkId: string, apn: Apn, options?: any): AxiosPromise<void> {
            return localVarFp.lteNetworkIdApnsPost(networkId, apn, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for lteNetworkIdApnsApnNameDelete operation in APNsApi.
 * @export
 * @interface APNsApiLteNetworkIdApnsApnNameDeleteRequest
 */
export interface APNsApiLteNetworkIdApnsApnNameDeleteRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof APNsApiLteNetworkIdApnsApnNameDelete
     */
    readonly networkId: string

    /**
     * Access Point Name
     * @type {string}
     * @memberof APNsApiLteNetworkIdApnsApnNameDelete
     */
    readonly apnName: string
}

/**
 * Request parameters for lteNetworkIdApnsApnNameGet operation in APNsApi.
 * @export
 * @interface APNsApiLteNetworkIdApnsApnNameGetRequest
 */
export interface APNsApiLteNetworkIdApnsApnNameGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof APNsApiLteNetworkIdApnsApnNameGet
     */
    readonly networkId: string

    /**
     * Access Point Name
     * @type {string}
     * @memberof APNsApiLteNetworkIdApnsApnNameGet
     */
    readonly apnName: string
}

/**
 * Request parameters for lteNetworkIdApnsApnNamePut operation in APNsApi.
 * @export
 * @interface APNsApiLteNetworkIdApnsApnNamePutRequest
 */
export interface APNsApiLteNetworkIdApnsApnNamePutRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof APNsApiLteNetworkIdApnsApnNamePut
     */
    readonly networkId: string

    /**
     * Access Point Name
     * @type {string}
     * @memberof APNsApiLteNetworkIdApnsApnNamePut
     */
    readonly apnName: string

    /**
     * New APN configuration
     * @type {Apn}
     * @memberof APNsApiLteNetworkIdApnsApnNamePut
     */
    readonly apn: Apn
}

/**
 * Request parameters for lteNetworkIdApnsGet operation in APNsApi.
 * @export
 * @interface APNsApiLteNetworkIdApnsGetRequest
 */
export interface APNsApiLteNetworkIdApnsGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof APNsApiLteNetworkIdApnsGet
     */
    readonly networkId: string
}

/**
 * Request parameters for lteNetworkIdApnsPost operation in APNsApi.
 * @export
 * @interface APNsApiLteNetworkIdApnsPostRequest
 */
export interface APNsApiLteNetworkIdApnsPostRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof APNsApiLteNetworkIdApnsPost
     */
    readonly networkId: string

    /**
     * New APN configuration
     * @type {Apn}
     * @memberof APNsApiLteNetworkIdApnsPost
     */
    readonly apn: Apn
}

/**
 * APNsApi - object-oriented interface
 * @export
 * @class APNsApi
 * @extends {BaseAPI}
 */
export class APNsApi extends BaseAPI {
    /**
     * 
     * @summary Remove an APN from the network
     * @param {APNsApiLteNetworkIdApnsApnNameDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APNsApi
     */
    public lteNetworkIdApnsApnNameDelete(requestParameters: APNsApiLteNetworkIdApnsApnNameDeleteRequest, options?: AxiosRequestConfig) {
        return APNsApiFp(this.configuration).lteNetworkIdApnsApnNameDelete(requestParameters.networkId, requestParameters.apnName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve the APN info
     * @param {APNsApiLteNetworkIdApnsApnNameGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APNsApi
     */
    public lteNetworkIdApnsApnNameGet(requestParameters: APNsApiLteNetworkIdApnsApnNameGetRequest, options?: AxiosRequestConfig) {
        return APNsApiFp(this.configuration).lteNetworkIdApnsApnNameGet(requestParameters.networkId, requestParameters.apnName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an existing APN in the network
     * @param {APNsApiLteNetworkIdApnsApnNamePutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APNsApi
     */
    public lteNetworkIdApnsApnNamePut(requestParameters: APNsApiLteNetworkIdApnsApnNamePutRequest, options?: AxiosRequestConfig) {
        return APNsApiFp(this.configuration).lteNetworkIdApnsApnNamePut(requestParameters.networkId, requestParameters.apnName, requestParameters.apn, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List APNs in the network
     * @param {APNsApiLteNetworkIdApnsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APNsApi
     */
    public lteNetworkIdApnsGet(requestParameters: APNsApiLteNetworkIdApnsGetRequest, options?: AxiosRequestConfig) {
        return APNsApiFp(this.configuration).lteNetworkIdApnsGet(requestParameters.networkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add a new APN to the network
     * @param {APNsApiLteNetworkIdApnsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APNsApi
     */
    public lteNetworkIdApnsPost(requestParameters: APNsApiLteNetworkIdApnsPostRequest, options?: AxiosRequestConfig) {
        return APNsApiFp(this.configuration).lteNetworkIdApnsPost(requestParameters.networkId, requestParameters.apn, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AboutApi - axios parameter creator
 * @export
 */
export const AboutApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aboutVersionGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/about/version`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AboutApi - functional programming interface
 * @export
 */
export const AboutApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AboutApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async aboutVersionGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VersionInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.aboutVersionGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AboutApi - factory interface
 * @export
 */
export const AboutApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AboutApiFp(configuration)
    return {
        /**
         * 
         * @summary Get version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aboutVersionGet(options?: any): AxiosPromise<VersionInfo> {
            return localVarFp.aboutVersionGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AboutApi - object-oriented interface
 * @export
 * @class AboutApi
 * @extends {BaseAPI}
 */
export class AboutApi extends BaseAPI {
    /**
     * 
     * @summary Get version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AboutApi
     */
    public aboutVersionGet(options?: AxiosRequestConfig) {
        return AboutApiFp(this.configuration).aboutVersionGet(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AlertsApi - axios parameter creator
 * @export
 */
export const AlertsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary View currently firing alerts
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdAlertsGet: async (networkId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networksNetworkIdAlertsGet', 'networkId', networkId)
            const localVarPath = `/networks/{network_id}/alerts`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete an alert silencer
         * @param {string} networkId Network ID
         * @param {string} silenceId ID of silencer to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdAlertsSilenceDelete: async (networkId: string, silenceId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networksNetworkIdAlertsSilenceDelete', 'networkId', networkId)
            // verify required parameter 'silenceId' is not null or undefined
            assertParamExists('networksNetworkIdAlertsSilenceDelete', 'silenceId', silenceId)
            const localVarPath = `/networks/{network_id}/alerts/silence`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (silenceId !== undefined) {
                localVarQueryParameter['silence_id'] = silenceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary View active alert silencers
         * @param {string} networkId Network ID
         * @param {boolean} [active] Retrieve active alerts. Default true.
         * @param {boolean} [pending] Retrieve pending alerts. Default true.
         * @param {boolean} [expired] Retrieve expired alerts. Default true.
         * @param {string} [filter] {key&#x3D;\&quot;value\&quot;,} pairs to filter the silences
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdAlertsSilenceGet: async (networkId: string, active?: boolean, pending?: boolean, expired?: boolean, filter?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networksNetworkIdAlertsSilenceGet', 'networkId', networkId)
            const localVarPath = `/networks/{network_id}/alerts/silence`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (active !== undefined) {
                localVarQueryParameter['active'] = active;
            }

            if (pending !== undefined) {
                localVarQueryParameter['pending'] = pending;
            }

            if (expired !== undefined) {
                localVarQueryParameter['expired'] = expired;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new alert silencer
         * @param {string} networkId Network ID
         * @param {AlertSilencer} silencer Silencer to be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdAlertsSilencePost: async (networkId: string, silencer: AlertSilencer, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networksNetworkIdAlertsSilencePost', 'networkId', networkId)
            // verify required parameter 'silencer' is not null or undefined
            assertParamExists('networksNetworkIdAlertsSilencePost', 'silencer', silencer)
            const localVarPath = `/networks/{network_id}/alerts/silence`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(silencer, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an alerting rule
         * @param {string} networkId Network ID
         * @param {string} alertName Name of alert to be updated
         * @param {PromAlertConfig} alertConfig Alerting rule that is to be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdPrometheusAlertConfigAlertNamePut: async (networkId: string, alertName: string, alertConfig: PromAlertConfig, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networksNetworkIdPrometheusAlertConfigAlertNamePut', 'networkId', networkId)
            // verify required parameter 'alertName' is not null or undefined
            assertParamExists('networksNetworkIdPrometheusAlertConfigAlertNamePut', 'alertName', alertName)
            // verify required parameter 'alertConfig' is not null or undefined
            assertParamExists('networksNetworkIdPrometheusAlertConfigAlertNamePut', 'alertConfig', alertConfig)
            const localVarPath = `/networks/{network_id}/prometheus/alert_config/{alert_name}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"alert_name"}}`, encodeURIComponent(String(alertName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(alertConfig, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Bulk update/create alerting rules
         * @param {string} networkId Network ID
         * @param {Array<PromAlertConfig>} alertConfigs Alerting rules to be updated or created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdPrometheusAlertConfigBulkPut: async (networkId: string, alertConfigs: Array<PromAlertConfig>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networksNetworkIdPrometheusAlertConfigBulkPut', 'networkId', networkId)
            // verify required parameter 'alertConfigs' is not null or undefined
            assertParamExists('networksNetworkIdPrometheusAlertConfigBulkPut', 'alertConfigs', alertConfigs)
            const localVarPath = `/networks/{network_id}/prometheus/alert_config/bulk`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(alertConfigs, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete an alerting rule
         * @param {string} networkId Network ID
         * @param {string} alertName Name of alert to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdPrometheusAlertConfigDelete: async (networkId: string, alertName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networksNetworkIdPrometheusAlertConfigDelete', 'networkId', networkId)
            // verify required parameter 'alertName' is not null or undefined
            assertParamExists('networksNetworkIdPrometheusAlertConfigDelete', 'alertName', alertName)
            const localVarPath = `/networks/{network_id}/prometheus/alert_config`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (alertName !== undefined) {
                localVarQueryParameter['alert_name'] = alertName;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * If no query parameters are included, all alerting rules for the given network are returned.
         * @summary Retrive alerting rule configurations
         * @param {string} networkId Network ID
         * @param {string} [alertName] Name of alert to be retrieved
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdPrometheusAlertConfigGet: async (networkId: string, alertName?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networksNetworkIdPrometheusAlertConfigGet', 'networkId', networkId)
            const localVarPath = `/networks/{network_id}/prometheus/alert_config`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (alertName !== undefined) {
                localVarQueryParameter['alert_name'] = alertName;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create new alerting rule
         * @param {string} networkId Network ID
         * @param {PromAlertConfig} alertConfig Alerting rule that is to be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdPrometheusAlertConfigPost: async (networkId: string, alertConfig: PromAlertConfig, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networksNetworkIdPrometheusAlertConfigPost', 'networkId', networkId)
            // verify required parameter 'alertConfig' is not null or undefined
            assertParamExists('networksNetworkIdPrometheusAlertConfigPost', 'alertConfig', alertConfig)
            const localVarPath = `/networks/{network_id}/prometheus/alert_config`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(alertConfig, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete alert receiver
         * @param {string} networkId Network ID
         * @param {string} receiver Receiver name to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdPrometheusAlertReceiverDelete: async (networkId: string, receiver: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networksNetworkIdPrometheusAlertReceiverDelete', 'networkId', networkId)
            // verify required parameter 'receiver' is not null or undefined
            assertParamExists('networksNetworkIdPrometheusAlertReceiverDelete', 'receiver', receiver)
            const localVarPath = `/networks/{network_id}/prometheus/alert_receiver`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (receiver !== undefined) {
                localVarQueryParameter['receiver'] = receiver;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrive alert receivers
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdPrometheusAlertReceiverGet: async (networkId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networksNetworkIdPrometheusAlertReceiverGet', 'networkId', networkId)
            const localVarPath = `/networks/{network_id}/prometheus/alert_receiver`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create new alert receiver
         * @param {string} networkId Network ID
         * @param {AlertReceiverConfig} receiverConfig Alert receiver that is to be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdPrometheusAlertReceiverPost: async (networkId: string, receiverConfig: AlertReceiverConfig, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networksNetworkIdPrometheusAlertReceiverPost', 'networkId', networkId)
            // verify required parameter 'receiverConfig' is not null or undefined
            assertParamExists('networksNetworkIdPrometheusAlertReceiverPost', 'receiverConfig', receiverConfig)
            const localVarPath = `/networks/{network_id}/prometheus/alert_receiver`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(receiverConfig, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update existing alert receiver
         * @param {string} networkId Network ID
         * @param {string} receiver Name of receiver to be updated
         * @param {AlertReceiverConfig} receiverConfig Updated alert receiver
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdPrometheusAlertReceiverReceiverPut: async (networkId: string, receiver: string, receiverConfig: AlertReceiverConfig, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networksNetworkIdPrometheusAlertReceiverReceiverPut', 'networkId', networkId)
            // verify required parameter 'receiver' is not null or undefined
            assertParamExists('networksNetworkIdPrometheusAlertReceiverReceiverPut', 'receiver', receiver)
            // verify required parameter 'receiverConfig' is not null or undefined
            assertParamExists('networksNetworkIdPrometheusAlertReceiverReceiverPut', 'receiverConfig', receiverConfig)
            const localVarPath = `/networks/{network_id}/prometheus/alert_receiver/{receiver}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"receiver"}}`, encodeURIComponent(String(receiver)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(receiverConfig, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve alert routing tree
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdPrometheusAlertReceiverRouteGet: async (networkId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networksNetworkIdPrometheusAlertReceiverRouteGet', 'networkId', networkId)
            const localVarPath = `/networks/{network_id}/prometheus/alert_receiver/route`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Modify alert routing tree
         * @param {string} networkId Network ID
         * @param {AlertRoutingTree} route Alert routing tree to be used
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdPrometheusAlertReceiverRoutePost: async (networkId: string, route: AlertRoutingTree, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networksNetworkIdPrometheusAlertReceiverRoutePost', 'networkId', networkId)
            // verify required parameter 'route' is not null or undefined
            assertParamExists('networksNetworkIdPrometheusAlertReceiverRoutePost', 'route', route)
            const localVarPath = `/networks/{network_id}/prometheus/alert_receiver/route`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(route, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AlertsApi - functional programming interface
 * @export
 */
export const AlertsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AlertsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary View currently firing alerts
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksNetworkIdAlertsGet(networkId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PromFiringAlert>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksNetworkIdAlertsGet(networkId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete an alert silencer
         * @param {string} networkId Network ID
         * @param {string} silenceId ID of silencer to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksNetworkIdAlertsSilenceDelete(networkId: string, silenceId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksNetworkIdAlertsSilenceDelete(networkId, silenceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary View active alert silencers
         * @param {string} networkId Network ID
         * @param {boolean} [active] Retrieve active alerts. Default true.
         * @param {boolean} [pending] Retrieve pending alerts. Default true.
         * @param {boolean} [expired] Retrieve expired alerts. Default true.
         * @param {string} [filter] {key&#x3D;\&quot;value\&quot;,} pairs to filter the silences
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksNetworkIdAlertsSilenceGet(networkId: string, active?: boolean, pending?: boolean, expired?: boolean, filter?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GettableAlertSilencer>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksNetworkIdAlertsSilenceGet(networkId, active, pending, expired, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a new alert silencer
         * @param {string} networkId Network ID
         * @param {AlertSilencer} silencer Silencer to be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksNetworkIdAlertsSilencePost(networkId: string, silencer: AlertSilencer, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksNetworkIdAlertsSilencePost(networkId, silencer, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update an alerting rule
         * @param {string} networkId Network ID
         * @param {string} alertName Name of alert to be updated
         * @param {PromAlertConfig} alertConfig Alerting rule that is to be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksNetworkIdPrometheusAlertConfigAlertNamePut(networkId: string, alertName: string, alertConfig: PromAlertConfig, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksNetworkIdPrometheusAlertConfigAlertNamePut(networkId, alertName, alertConfig, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Bulk update/create alerting rules
         * @param {string} networkId Network ID
         * @param {Array<PromAlertConfig>} alertConfigs Alerting rules to be updated or created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksNetworkIdPrometheusAlertConfigBulkPut(networkId: string, alertConfigs: Array<PromAlertConfig>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AlertBulkUploadResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksNetworkIdPrometheusAlertConfigBulkPut(networkId, alertConfigs, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete an alerting rule
         * @param {string} networkId Network ID
         * @param {string} alertName Name of alert to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksNetworkIdPrometheusAlertConfigDelete(networkId: string, alertName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksNetworkIdPrometheusAlertConfigDelete(networkId, alertName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * If no query parameters are included, all alerting rules for the given network are returned.
         * @summary Retrive alerting rule configurations
         * @param {string} networkId Network ID
         * @param {string} [alertName] Name of alert to be retrieved
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksNetworkIdPrometheusAlertConfigGet(networkId: string, alertName?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PromAlertConfig>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksNetworkIdPrometheusAlertConfigGet(networkId, alertName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create new alerting rule
         * @param {string} networkId Network ID
         * @param {PromAlertConfig} alertConfig Alerting rule that is to be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksNetworkIdPrometheusAlertConfigPost(networkId: string, alertConfig: PromAlertConfig, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksNetworkIdPrometheusAlertConfigPost(networkId, alertConfig, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete alert receiver
         * @param {string} networkId Network ID
         * @param {string} receiver Receiver name to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksNetworkIdPrometheusAlertReceiverDelete(networkId: string, receiver: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksNetworkIdPrometheusAlertReceiverDelete(networkId, receiver, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrive alert receivers
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksNetworkIdPrometheusAlertReceiverGet(networkId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AlertReceiverConfig>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksNetworkIdPrometheusAlertReceiverGet(networkId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create new alert receiver
         * @param {string} networkId Network ID
         * @param {AlertReceiverConfig} receiverConfig Alert receiver that is to be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksNetworkIdPrometheusAlertReceiverPost(networkId: string, receiverConfig: AlertReceiverConfig, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksNetworkIdPrometheusAlertReceiverPost(networkId, receiverConfig, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update existing alert receiver
         * @param {string} networkId Network ID
         * @param {string} receiver Name of receiver to be updated
         * @param {AlertReceiverConfig} receiverConfig Updated alert receiver
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksNetworkIdPrometheusAlertReceiverReceiverPut(networkId: string, receiver: string, receiverConfig: AlertReceiverConfig, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksNetworkIdPrometheusAlertReceiverReceiverPut(networkId, receiver, receiverConfig, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve alert routing tree
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksNetworkIdPrometheusAlertReceiverRouteGet(networkId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AlertRoutingTree>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksNetworkIdPrometheusAlertReceiverRouteGet(networkId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Modify alert routing tree
         * @param {string} networkId Network ID
         * @param {AlertRoutingTree} route Alert routing tree to be used
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksNetworkIdPrometheusAlertReceiverRoutePost(networkId: string, route: AlertRoutingTree, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksNetworkIdPrometheusAlertReceiverRoutePost(networkId, route, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AlertsApi - factory interface
 * @export
 */
export const AlertsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AlertsApiFp(configuration)
    return {
        /**
         * 
         * @summary View currently firing alerts
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdAlertsGet(networkId: string, options?: any): AxiosPromise<Array<PromFiringAlert>> {
            return localVarFp.networksNetworkIdAlertsGet(networkId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete an alert silencer
         * @param {string} networkId Network ID
         * @param {string} silenceId ID of silencer to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdAlertsSilenceDelete(networkId: string, silenceId: string, options?: any): AxiosPromise<string> {
            return localVarFp.networksNetworkIdAlertsSilenceDelete(networkId, silenceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary View active alert silencers
         * @param {string} networkId Network ID
         * @param {boolean} [active] Retrieve active alerts. Default true.
         * @param {boolean} [pending] Retrieve pending alerts. Default true.
         * @param {boolean} [expired] Retrieve expired alerts. Default true.
         * @param {string} [filter] {key&#x3D;\&quot;value\&quot;,} pairs to filter the silences
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdAlertsSilenceGet(networkId: string, active?: boolean, pending?: boolean, expired?: boolean, filter?: string, options?: any): AxiosPromise<Array<GettableAlertSilencer>> {
            return localVarFp.networksNetworkIdAlertsSilenceGet(networkId, active, pending, expired, filter, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new alert silencer
         * @param {string} networkId Network ID
         * @param {AlertSilencer} silencer Silencer to be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdAlertsSilencePost(networkId: string, silencer: AlertSilencer, options?: any): AxiosPromise<string> {
            return localVarFp.networksNetworkIdAlertsSilencePost(networkId, silencer, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an alerting rule
         * @param {string} networkId Network ID
         * @param {string} alertName Name of alert to be updated
         * @param {PromAlertConfig} alertConfig Alerting rule that is to be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdPrometheusAlertConfigAlertNamePut(networkId: string, alertName: string, alertConfig: PromAlertConfig, options?: any): AxiosPromise<void> {
            return localVarFp.networksNetworkIdPrometheusAlertConfigAlertNamePut(networkId, alertName, alertConfig, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Bulk update/create alerting rules
         * @param {string} networkId Network ID
         * @param {Array<PromAlertConfig>} alertConfigs Alerting rules to be updated or created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdPrometheusAlertConfigBulkPut(networkId: string, alertConfigs: Array<PromAlertConfig>, options?: any): AxiosPromise<AlertBulkUploadResponse> {
            return localVarFp.networksNetworkIdPrometheusAlertConfigBulkPut(networkId, alertConfigs, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete an alerting rule
         * @param {string} networkId Network ID
         * @param {string} alertName Name of alert to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdPrometheusAlertConfigDelete(networkId: string, alertName: string, options?: any): AxiosPromise<void> {
            return localVarFp.networksNetworkIdPrometheusAlertConfigDelete(networkId, alertName, options).then((request) => request(axios, basePath));
        },
        /**
         * If no query parameters are included, all alerting rules for the given network are returned.
         * @summary Retrive alerting rule configurations
         * @param {string} networkId Network ID
         * @param {string} [alertName] Name of alert to be retrieved
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdPrometheusAlertConfigGet(networkId: string, alertName?: string, options?: any): AxiosPromise<Array<PromAlertConfig>> {
            return localVarFp.networksNetworkIdPrometheusAlertConfigGet(networkId, alertName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create new alerting rule
         * @param {string} networkId Network ID
         * @param {PromAlertConfig} alertConfig Alerting rule that is to be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdPrometheusAlertConfigPost(networkId: string, alertConfig: PromAlertConfig, options?: any): AxiosPromise<void> {
            return localVarFp.networksNetworkIdPrometheusAlertConfigPost(networkId, alertConfig, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete alert receiver
         * @param {string} networkId Network ID
         * @param {string} receiver Receiver name to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdPrometheusAlertReceiverDelete(networkId: string, receiver: string, options?: any): AxiosPromise<void> {
            return localVarFp.networksNetworkIdPrometheusAlertReceiverDelete(networkId, receiver, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrive alert receivers
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdPrometheusAlertReceiverGet(networkId: string, options?: any): AxiosPromise<Array<AlertReceiverConfig>> {
            return localVarFp.networksNetworkIdPrometheusAlertReceiverGet(networkId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create new alert receiver
         * @param {string} networkId Network ID
         * @param {AlertReceiverConfig} receiverConfig Alert receiver that is to be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdPrometheusAlertReceiverPost(networkId: string, receiverConfig: AlertReceiverConfig, options?: any): AxiosPromise<void> {
            return localVarFp.networksNetworkIdPrometheusAlertReceiverPost(networkId, receiverConfig, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update existing alert receiver
         * @param {string} networkId Network ID
         * @param {string} receiver Name of receiver to be updated
         * @param {AlertReceiverConfig} receiverConfig Updated alert receiver
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdPrometheusAlertReceiverReceiverPut(networkId: string, receiver: string, receiverConfig: AlertReceiverConfig, options?: any): AxiosPromise<void> {
            return localVarFp.networksNetworkIdPrometheusAlertReceiverReceiverPut(networkId, receiver, receiverConfig, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve alert routing tree
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdPrometheusAlertReceiverRouteGet(networkId: string, options?: any): AxiosPromise<AlertRoutingTree> {
            return localVarFp.networksNetworkIdPrometheusAlertReceiverRouteGet(networkId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Modify alert routing tree
         * @param {string} networkId Network ID
         * @param {AlertRoutingTree} route Alert routing tree to be used
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdPrometheusAlertReceiverRoutePost(networkId: string, route: AlertRoutingTree, options?: any): AxiosPromise<void> {
            return localVarFp.networksNetworkIdPrometheusAlertReceiverRoutePost(networkId, route, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for networksNetworkIdAlertsGet operation in AlertsApi.
 * @export
 * @interface AlertsApiNetworksNetworkIdAlertsGetRequest
 */
export interface AlertsApiNetworksNetworkIdAlertsGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof AlertsApiNetworksNetworkIdAlertsGet
     */
    readonly networkId: string
}

/**
 * Request parameters for networksNetworkIdAlertsSilenceDelete operation in AlertsApi.
 * @export
 * @interface AlertsApiNetworksNetworkIdAlertsSilenceDeleteRequest
 */
export interface AlertsApiNetworksNetworkIdAlertsSilenceDeleteRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof AlertsApiNetworksNetworkIdAlertsSilenceDelete
     */
    readonly networkId: string

    /**
     * ID of silencer to be deleted
     * @type {string}
     * @memberof AlertsApiNetworksNetworkIdAlertsSilenceDelete
     */
    readonly silenceId: string
}

/**
 * Request parameters for networksNetworkIdAlertsSilenceGet operation in AlertsApi.
 * @export
 * @interface AlertsApiNetworksNetworkIdAlertsSilenceGetRequest
 */
export interface AlertsApiNetworksNetworkIdAlertsSilenceGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof AlertsApiNetworksNetworkIdAlertsSilenceGet
     */
    readonly networkId: string

    /**
     * Retrieve active alerts. Default true.
     * @type {boolean}
     * @memberof AlertsApiNetworksNetworkIdAlertsSilenceGet
     */
    readonly active?: boolean

    /**
     * Retrieve pending alerts. Default true.
     * @type {boolean}
     * @memberof AlertsApiNetworksNetworkIdAlertsSilenceGet
     */
    readonly pending?: boolean

    /**
     * Retrieve expired alerts. Default true.
     * @type {boolean}
     * @memberof AlertsApiNetworksNetworkIdAlertsSilenceGet
     */
    readonly expired?: boolean

    /**
     * {key&#x3D;\&quot;value\&quot;,} pairs to filter the silences
     * @type {string}
     * @memberof AlertsApiNetworksNetworkIdAlertsSilenceGet
     */
    readonly filter?: string
}

/**
 * Request parameters for networksNetworkIdAlertsSilencePost operation in AlertsApi.
 * @export
 * @interface AlertsApiNetworksNetworkIdAlertsSilencePostRequest
 */
export interface AlertsApiNetworksNetworkIdAlertsSilencePostRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof AlertsApiNetworksNetworkIdAlertsSilencePost
     */
    readonly networkId: string

    /**
     * Silencer to be created
     * @type {AlertSilencer}
     * @memberof AlertsApiNetworksNetworkIdAlertsSilencePost
     */
    readonly silencer: AlertSilencer
}

/**
 * Request parameters for networksNetworkIdPrometheusAlertConfigAlertNamePut operation in AlertsApi.
 * @export
 * @interface AlertsApiNetworksNetworkIdPrometheusAlertConfigAlertNamePutRequest
 */
export interface AlertsApiNetworksNetworkIdPrometheusAlertConfigAlertNamePutRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof AlertsApiNetworksNetworkIdPrometheusAlertConfigAlertNamePut
     */
    readonly networkId: string

    /**
     * Name of alert to be updated
     * @type {string}
     * @memberof AlertsApiNetworksNetworkIdPrometheusAlertConfigAlertNamePut
     */
    readonly alertName: string

    /**
     * Alerting rule that is to be added
     * @type {PromAlertConfig}
     * @memberof AlertsApiNetworksNetworkIdPrometheusAlertConfigAlertNamePut
     */
    readonly alertConfig: PromAlertConfig
}

/**
 * Request parameters for networksNetworkIdPrometheusAlertConfigBulkPut operation in AlertsApi.
 * @export
 * @interface AlertsApiNetworksNetworkIdPrometheusAlertConfigBulkPutRequest
 */
export interface AlertsApiNetworksNetworkIdPrometheusAlertConfigBulkPutRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof AlertsApiNetworksNetworkIdPrometheusAlertConfigBulkPut
     */
    readonly networkId: string

    /**
     * Alerting rules to be updated or created
     * @type {Array<PromAlertConfig>}
     * @memberof AlertsApiNetworksNetworkIdPrometheusAlertConfigBulkPut
     */
    readonly alertConfigs: Array<PromAlertConfig>
}

/**
 * Request parameters for networksNetworkIdPrometheusAlertConfigDelete operation in AlertsApi.
 * @export
 * @interface AlertsApiNetworksNetworkIdPrometheusAlertConfigDeleteRequest
 */
export interface AlertsApiNetworksNetworkIdPrometheusAlertConfigDeleteRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof AlertsApiNetworksNetworkIdPrometheusAlertConfigDelete
     */
    readonly networkId: string

    /**
     * Name of alert to be deleted
     * @type {string}
     * @memberof AlertsApiNetworksNetworkIdPrometheusAlertConfigDelete
     */
    readonly alertName: string
}

/**
 * Request parameters for networksNetworkIdPrometheusAlertConfigGet operation in AlertsApi.
 * @export
 * @interface AlertsApiNetworksNetworkIdPrometheusAlertConfigGetRequest
 */
export interface AlertsApiNetworksNetworkIdPrometheusAlertConfigGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof AlertsApiNetworksNetworkIdPrometheusAlertConfigGet
     */
    readonly networkId: string

    /**
     * Name of alert to be retrieved
     * @type {string}
     * @memberof AlertsApiNetworksNetworkIdPrometheusAlertConfigGet
     */
    readonly alertName?: string
}

/**
 * Request parameters for networksNetworkIdPrometheusAlertConfigPost operation in AlertsApi.
 * @export
 * @interface AlertsApiNetworksNetworkIdPrometheusAlertConfigPostRequest
 */
export interface AlertsApiNetworksNetworkIdPrometheusAlertConfigPostRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof AlertsApiNetworksNetworkIdPrometheusAlertConfigPost
     */
    readonly networkId: string

    /**
     * Alerting rule that is to be added
     * @type {PromAlertConfig}
     * @memberof AlertsApiNetworksNetworkIdPrometheusAlertConfigPost
     */
    readonly alertConfig: PromAlertConfig
}

/**
 * Request parameters for networksNetworkIdPrometheusAlertReceiverDelete operation in AlertsApi.
 * @export
 * @interface AlertsApiNetworksNetworkIdPrometheusAlertReceiverDeleteRequest
 */
export interface AlertsApiNetworksNetworkIdPrometheusAlertReceiverDeleteRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof AlertsApiNetworksNetworkIdPrometheusAlertReceiverDelete
     */
    readonly networkId: string

    /**
     * Receiver name to be deleted
     * @type {string}
     * @memberof AlertsApiNetworksNetworkIdPrometheusAlertReceiverDelete
     */
    readonly receiver: string
}

/**
 * Request parameters for networksNetworkIdPrometheusAlertReceiverGet operation in AlertsApi.
 * @export
 * @interface AlertsApiNetworksNetworkIdPrometheusAlertReceiverGetRequest
 */
export interface AlertsApiNetworksNetworkIdPrometheusAlertReceiverGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof AlertsApiNetworksNetworkIdPrometheusAlertReceiverGet
     */
    readonly networkId: string
}

/**
 * Request parameters for networksNetworkIdPrometheusAlertReceiverPost operation in AlertsApi.
 * @export
 * @interface AlertsApiNetworksNetworkIdPrometheusAlertReceiverPostRequest
 */
export interface AlertsApiNetworksNetworkIdPrometheusAlertReceiverPostRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof AlertsApiNetworksNetworkIdPrometheusAlertReceiverPost
     */
    readonly networkId: string

    /**
     * Alert receiver that is to be added
     * @type {AlertReceiverConfig}
     * @memberof AlertsApiNetworksNetworkIdPrometheusAlertReceiverPost
     */
    readonly receiverConfig: AlertReceiverConfig
}

/**
 * Request parameters for networksNetworkIdPrometheusAlertReceiverReceiverPut operation in AlertsApi.
 * @export
 * @interface AlertsApiNetworksNetworkIdPrometheusAlertReceiverReceiverPutRequest
 */
export interface AlertsApiNetworksNetworkIdPrometheusAlertReceiverReceiverPutRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof AlertsApiNetworksNetworkIdPrometheusAlertReceiverReceiverPut
     */
    readonly networkId: string

    /**
     * Name of receiver to be updated
     * @type {string}
     * @memberof AlertsApiNetworksNetworkIdPrometheusAlertReceiverReceiverPut
     */
    readonly receiver: string

    /**
     * Updated alert receiver
     * @type {AlertReceiverConfig}
     * @memberof AlertsApiNetworksNetworkIdPrometheusAlertReceiverReceiverPut
     */
    readonly receiverConfig: AlertReceiverConfig
}

/**
 * Request parameters for networksNetworkIdPrometheusAlertReceiverRouteGet operation in AlertsApi.
 * @export
 * @interface AlertsApiNetworksNetworkIdPrometheusAlertReceiverRouteGetRequest
 */
export interface AlertsApiNetworksNetworkIdPrometheusAlertReceiverRouteGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof AlertsApiNetworksNetworkIdPrometheusAlertReceiverRouteGet
     */
    readonly networkId: string
}

/**
 * Request parameters for networksNetworkIdPrometheusAlertReceiverRoutePost operation in AlertsApi.
 * @export
 * @interface AlertsApiNetworksNetworkIdPrometheusAlertReceiverRoutePostRequest
 */
export interface AlertsApiNetworksNetworkIdPrometheusAlertReceiverRoutePostRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof AlertsApiNetworksNetworkIdPrometheusAlertReceiverRoutePost
     */
    readonly networkId: string

    /**
     * Alert routing tree to be used
     * @type {AlertRoutingTree}
     * @memberof AlertsApiNetworksNetworkIdPrometheusAlertReceiverRoutePost
     */
    readonly route: AlertRoutingTree
}

/**
 * AlertsApi - object-oriented interface
 * @export
 * @class AlertsApi
 * @extends {BaseAPI}
 */
export class AlertsApi extends BaseAPI {
    /**
     * 
     * @summary View currently firing alerts
     * @param {AlertsApiNetworksNetworkIdAlertsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    public networksNetworkIdAlertsGet(requestParameters: AlertsApiNetworksNetworkIdAlertsGetRequest, options?: AxiosRequestConfig) {
        return AlertsApiFp(this.configuration).networksNetworkIdAlertsGet(requestParameters.networkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete an alert silencer
     * @param {AlertsApiNetworksNetworkIdAlertsSilenceDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    public networksNetworkIdAlertsSilenceDelete(requestParameters: AlertsApiNetworksNetworkIdAlertsSilenceDeleteRequest, options?: AxiosRequestConfig) {
        return AlertsApiFp(this.configuration).networksNetworkIdAlertsSilenceDelete(requestParameters.networkId, requestParameters.silenceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary View active alert silencers
     * @param {AlertsApiNetworksNetworkIdAlertsSilenceGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    public networksNetworkIdAlertsSilenceGet(requestParameters: AlertsApiNetworksNetworkIdAlertsSilenceGetRequest, options?: AxiosRequestConfig) {
        return AlertsApiFp(this.configuration).networksNetworkIdAlertsSilenceGet(requestParameters.networkId, requestParameters.active, requestParameters.pending, requestParameters.expired, requestParameters.filter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new alert silencer
     * @param {AlertsApiNetworksNetworkIdAlertsSilencePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    public networksNetworkIdAlertsSilencePost(requestParameters: AlertsApiNetworksNetworkIdAlertsSilencePostRequest, options?: AxiosRequestConfig) {
        return AlertsApiFp(this.configuration).networksNetworkIdAlertsSilencePost(requestParameters.networkId, requestParameters.silencer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an alerting rule
     * @param {AlertsApiNetworksNetworkIdPrometheusAlertConfigAlertNamePutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    public networksNetworkIdPrometheusAlertConfigAlertNamePut(requestParameters: AlertsApiNetworksNetworkIdPrometheusAlertConfigAlertNamePutRequest, options?: AxiosRequestConfig) {
        return AlertsApiFp(this.configuration).networksNetworkIdPrometheusAlertConfigAlertNamePut(requestParameters.networkId, requestParameters.alertName, requestParameters.alertConfig, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Bulk update/create alerting rules
     * @param {AlertsApiNetworksNetworkIdPrometheusAlertConfigBulkPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    public networksNetworkIdPrometheusAlertConfigBulkPut(requestParameters: AlertsApiNetworksNetworkIdPrometheusAlertConfigBulkPutRequest, options?: AxiosRequestConfig) {
        return AlertsApiFp(this.configuration).networksNetworkIdPrometheusAlertConfigBulkPut(requestParameters.networkId, requestParameters.alertConfigs, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete an alerting rule
     * @param {AlertsApiNetworksNetworkIdPrometheusAlertConfigDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    public networksNetworkIdPrometheusAlertConfigDelete(requestParameters: AlertsApiNetworksNetworkIdPrometheusAlertConfigDeleteRequest, options?: AxiosRequestConfig) {
        return AlertsApiFp(this.configuration).networksNetworkIdPrometheusAlertConfigDelete(requestParameters.networkId, requestParameters.alertName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * If no query parameters are included, all alerting rules for the given network are returned.
     * @summary Retrive alerting rule configurations
     * @param {AlertsApiNetworksNetworkIdPrometheusAlertConfigGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    public networksNetworkIdPrometheusAlertConfigGet(requestParameters: AlertsApiNetworksNetworkIdPrometheusAlertConfigGetRequest, options?: AxiosRequestConfig) {
        return AlertsApiFp(this.configuration).networksNetworkIdPrometheusAlertConfigGet(requestParameters.networkId, requestParameters.alertName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create new alerting rule
     * @param {AlertsApiNetworksNetworkIdPrometheusAlertConfigPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    public networksNetworkIdPrometheusAlertConfigPost(requestParameters: AlertsApiNetworksNetworkIdPrometheusAlertConfigPostRequest, options?: AxiosRequestConfig) {
        return AlertsApiFp(this.configuration).networksNetworkIdPrometheusAlertConfigPost(requestParameters.networkId, requestParameters.alertConfig, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete alert receiver
     * @param {AlertsApiNetworksNetworkIdPrometheusAlertReceiverDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    public networksNetworkIdPrometheusAlertReceiverDelete(requestParameters: AlertsApiNetworksNetworkIdPrometheusAlertReceiverDeleteRequest, options?: AxiosRequestConfig) {
        return AlertsApiFp(this.configuration).networksNetworkIdPrometheusAlertReceiverDelete(requestParameters.networkId, requestParameters.receiver, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrive alert receivers
     * @param {AlertsApiNetworksNetworkIdPrometheusAlertReceiverGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    public networksNetworkIdPrometheusAlertReceiverGet(requestParameters: AlertsApiNetworksNetworkIdPrometheusAlertReceiverGetRequest, options?: AxiosRequestConfig) {
        return AlertsApiFp(this.configuration).networksNetworkIdPrometheusAlertReceiverGet(requestParameters.networkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create new alert receiver
     * @param {AlertsApiNetworksNetworkIdPrometheusAlertReceiverPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    public networksNetworkIdPrometheusAlertReceiverPost(requestParameters: AlertsApiNetworksNetworkIdPrometheusAlertReceiverPostRequest, options?: AxiosRequestConfig) {
        return AlertsApiFp(this.configuration).networksNetworkIdPrometheusAlertReceiverPost(requestParameters.networkId, requestParameters.receiverConfig, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update existing alert receiver
     * @param {AlertsApiNetworksNetworkIdPrometheusAlertReceiverReceiverPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    public networksNetworkIdPrometheusAlertReceiverReceiverPut(requestParameters: AlertsApiNetworksNetworkIdPrometheusAlertReceiverReceiverPutRequest, options?: AxiosRequestConfig) {
        return AlertsApiFp(this.configuration).networksNetworkIdPrometheusAlertReceiverReceiverPut(requestParameters.networkId, requestParameters.receiver, requestParameters.receiverConfig, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve alert routing tree
     * @param {AlertsApiNetworksNetworkIdPrometheusAlertReceiverRouteGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    public networksNetworkIdPrometheusAlertReceiverRouteGet(requestParameters: AlertsApiNetworksNetworkIdPrometheusAlertReceiverRouteGetRequest, options?: AxiosRequestConfig) {
        return AlertsApiFp(this.configuration).networksNetworkIdPrometheusAlertReceiverRouteGet(requestParameters.networkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Modify alert routing tree
     * @param {AlertsApiNetworksNetworkIdPrometheusAlertReceiverRoutePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    public networksNetworkIdPrometheusAlertReceiverRoutePost(requestParameters: AlertsApiNetworksNetworkIdPrometheusAlertReceiverRoutePostRequest, options?: AxiosRequestConfig) {
        return AlertsApiFp(this.configuration).networksNetworkIdPrometheusAlertReceiverRoutePost(requestParameters.networkId, requestParameters.route, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CallTracingApi - axios parameter creator
 * @export
 */
export const CallTracingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List all call traces for a network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdTracingGet: async (networkId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networksNetworkIdTracingGet', 'networkId', networkId)
            const localVarPath = `/networks/{network_id}/tracing`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Start a new call trace
         * @param {string} networkId Network ID
         * @param {CallTraceConfig} callTraceConfiguration Configuration of call trace to start
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdTracingPost: async (networkId: string, callTraceConfiguration: CallTraceConfig, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networksNetworkIdTracingPost', 'networkId', networkId)
            // verify required parameter 'callTraceConfiguration' is not null or undefined
            assertParamExists('networksNetworkIdTracingPost', 'callTraceConfiguration', callTraceConfiguration)
            const localVarPath = `/networks/{network_id}/tracing`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(callTraceConfiguration, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a call trace record
         * @param {string} networkId Network ID
         * @param {string} traceId Unique ID of call trace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdTracingTraceIdDelete: async (networkId: string, traceId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networksNetworkIdTracingTraceIdDelete', 'networkId', networkId)
            // verify required parameter 'traceId' is not null or undefined
            assertParamExists('networksNetworkIdTracingTraceIdDelete', 'traceId', traceId)
            const localVarPath = `/networks/{network_id}/tracing/{trace_id}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"trace_id"}}`, encodeURIComponent(String(traceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the call trace in PCAP format
         * @param {string} networkId Network ID
         * @param {string} traceId Unique ID of call trace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdTracingTraceIdDownloadGet: async (networkId: string, traceId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networksNetworkIdTracingTraceIdDownloadGet', 'networkId', networkId)
            // verify required parameter 'traceId' is not null or undefined
            assertParamExists('networksNetworkIdTracingTraceIdDownloadGet', 'traceId', traceId)
            const localVarPath = `/networks/{network_id}/tracing/{trace_id}/download`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"trace_id"}}`, encodeURIComponent(String(traceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get tracing status
         * @param {string} networkId Network ID
         * @param {string} traceId Unique ID of call trace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdTracingTraceIdGet: async (networkId: string, traceId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networksNetworkIdTracingTraceIdGet', 'networkId', networkId)
            // verify required parameter 'traceId' is not null or undefined
            assertParamExists('networksNetworkIdTracingTraceIdGet', 'traceId', traceId)
            const localVarPath = `/networks/{network_id}/tracing/{trace_id}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"trace_id"}}`, encodeURIComponent(String(traceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a call trace
         * @param {string} networkId Network ID
         * @param {string} traceId Unique ID of call trace
         * @param {MutableCallTrace} callTraceConfiguration Call trace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdTracingTraceIdPut: async (networkId: string, traceId: string, callTraceConfiguration: MutableCallTrace, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networksNetworkIdTracingTraceIdPut', 'networkId', networkId)
            // verify required parameter 'traceId' is not null or undefined
            assertParamExists('networksNetworkIdTracingTraceIdPut', 'traceId', traceId)
            // verify required parameter 'callTraceConfiguration' is not null or undefined
            assertParamExists('networksNetworkIdTracingTraceIdPut', 'callTraceConfiguration', callTraceConfiguration)
            const localVarPath = `/networks/{network_id}/tracing/{trace_id}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"trace_id"}}`, encodeURIComponent(String(traceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(callTraceConfiguration, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CallTracingApi - functional programming interface
 * @export
 */
export const CallTracingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CallTracingApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List all call traces for a network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksNetworkIdTracingGet(networkId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: CallTrace; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksNetworkIdTracingGet(networkId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Start a new call trace
         * @param {string} networkId Network ID
         * @param {CallTraceConfig} callTraceConfiguration Configuration of call trace to start
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksNetworkIdTracingPost(networkId: string, callTraceConfiguration: CallTraceConfig, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksNetworkIdTracingPost(networkId, callTraceConfiguration, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a call trace record
         * @param {string} networkId Network ID
         * @param {string} traceId Unique ID of call trace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksNetworkIdTracingTraceIdDelete(networkId: string, traceId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksNetworkIdTracingTraceIdDelete(networkId, traceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the call trace in PCAP format
         * @param {string} networkId Network ID
         * @param {string} traceId Unique ID of call trace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksNetworkIdTracingTraceIdDownloadGet(networkId: string, traceId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksNetworkIdTracingTraceIdDownloadGet(networkId, traceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get tracing status
         * @param {string} networkId Network ID
         * @param {string} traceId Unique ID of call trace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksNetworkIdTracingTraceIdGet(networkId: string, traceId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CallTrace>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksNetworkIdTracingTraceIdGet(networkId, traceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a call trace
         * @param {string} networkId Network ID
         * @param {string} traceId Unique ID of call trace
         * @param {MutableCallTrace} callTraceConfiguration Call trace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksNetworkIdTracingTraceIdPut(networkId: string, traceId: string, callTraceConfiguration: MutableCallTrace, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksNetworkIdTracingTraceIdPut(networkId, traceId, callTraceConfiguration, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CallTracingApi - factory interface
 * @export
 */
export const CallTracingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CallTracingApiFp(configuration)
    return {
        /**
         * 
         * @summary List all call traces for a network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdTracingGet(networkId: string, options?: any): AxiosPromise<{ [key: string]: CallTrace; }> {
            return localVarFp.networksNetworkIdTracingGet(networkId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Start a new call trace
         * @param {string} networkId Network ID
         * @param {CallTraceConfig} callTraceConfiguration Configuration of call trace to start
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdTracingPost(networkId: string, callTraceConfiguration: CallTraceConfig, options?: any): AxiosPromise<string> {
            return localVarFp.networksNetworkIdTracingPost(networkId, callTraceConfiguration, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a call trace record
         * @param {string} networkId Network ID
         * @param {string} traceId Unique ID of call trace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdTracingTraceIdDelete(networkId: string, traceId: string, options?: any): AxiosPromise<void> {
            return localVarFp.networksNetworkIdTracingTraceIdDelete(networkId, traceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the call trace in PCAP format
         * @param {string} networkId Network ID
         * @param {string} traceId Unique ID of call trace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdTracingTraceIdDownloadGet(networkId: string, traceId: string, options?: any): AxiosPromise<any> {
            return localVarFp.networksNetworkIdTracingTraceIdDownloadGet(networkId, traceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get tracing status
         * @param {string} networkId Network ID
         * @param {string} traceId Unique ID of call trace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdTracingTraceIdGet(networkId: string, traceId: string, options?: any): AxiosPromise<CallTrace> {
            return localVarFp.networksNetworkIdTracingTraceIdGet(networkId, traceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a call trace
         * @param {string} networkId Network ID
         * @param {string} traceId Unique ID of call trace
         * @param {MutableCallTrace} callTraceConfiguration Call trace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdTracingTraceIdPut(networkId: string, traceId: string, callTraceConfiguration: MutableCallTrace, options?: any): AxiosPromise<void> {
            return localVarFp.networksNetworkIdTracingTraceIdPut(networkId, traceId, callTraceConfiguration, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for networksNetworkIdTracingGet operation in CallTracingApi.
 * @export
 * @interface CallTracingApiNetworksNetworkIdTracingGetRequest
 */
export interface CallTracingApiNetworksNetworkIdTracingGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof CallTracingApiNetworksNetworkIdTracingGet
     */
    readonly networkId: string
}

/**
 * Request parameters for networksNetworkIdTracingPost operation in CallTracingApi.
 * @export
 * @interface CallTracingApiNetworksNetworkIdTracingPostRequest
 */
export interface CallTracingApiNetworksNetworkIdTracingPostRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof CallTracingApiNetworksNetworkIdTracingPost
     */
    readonly networkId: string

    /**
     * Configuration of call trace to start
     * @type {CallTraceConfig}
     * @memberof CallTracingApiNetworksNetworkIdTracingPost
     */
    readonly callTraceConfiguration: CallTraceConfig
}

/**
 * Request parameters for networksNetworkIdTracingTraceIdDelete operation in CallTracingApi.
 * @export
 * @interface CallTracingApiNetworksNetworkIdTracingTraceIdDeleteRequest
 */
export interface CallTracingApiNetworksNetworkIdTracingTraceIdDeleteRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof CallTracingApiNetworksNetworkIdTracingTraceIdDelete
     */
    readonly networkId: string

    /**
     * Unique ID of call trace
     * @type {string}
     * @memberof CallTracingApiNetworksNetworkIdTracingTraceIdDelete
     */
    readonly traceId: string
}

/**
 * Request parameters for networksNetworkIdTracingTraceIdDownloadGet operation in CallTracingApi.
 * @export
 * @interface CallTracingApiNetworksNetworkIdTracingTraceIdDownloadGetRequest
 */
export interface CallTracingApiNetworksNetworkIdTracingTraceIdDownloadGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof CallTracingApiNetworksNetworkIdTracingTraceIdDownloadGet
     */
    readonly networkId: string

    /**
     * Unique ID of call trace
     * @type {string}
     * @memberof CallTracingApiNetworksNetworkIdTracingTraceIdDownloadGet
     */
    readonly traceId: string
}

/**
 * Request parameters for networksNetworkIdTracingTraceIdGet operation in CallTracingApi.
 * @export
 * @interface CallTracingApiNetworksNetworkIdTracingTraceIdGetRequest
 */
export interface CallTracingApiNetworksNetworkIdTracingTraceIdGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof CallTracingApiNetworksNetworkIdTracingTraceIdGet
     */
    readonly networkId: string

    /**
     * Unique ID of call trace
     * @type {string}
     * @memberof CallTracingApiNetworksNetworkIdTracingTraceIdGet
     */
    readonly traceId: string
}

/**
 * Request parameters for networksNetworkIdTracingTraceIdPut operation in CallTracingApi.
 * @export
 * @interface CallTracingApiNetworksNetworkIdTracingTraceIdPutRequest
 */
export interface CallTracingApiNetworksNetworkIdTracingTraceIdPutRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof CallTracingApiNetworksNetworkIdTracingTraceIdPut
     */
    readonly networkId: string

    /**
     * Unique ID of call trace
     * @type {string}
     * @memberof CallTracingApiNetworksNetworkIdTracingTraceIdPut
     */
    readonly traceId: string

    /**
     * Call trace
     * @type {MutableCallTrace}
     * @memberof CallTracingApiNetworksNetworkIdTracingTraceIdPut
     */
    readonly callTraceConfiguration: MutableCallTrace
}

/**
 * CallTracingApi - object-oriented interface
 * @export
 * @class CallTracingApi
 * @extends {BaseAPI}
 */
export class CallTracingApi extends BaseAPI {
    /**
     * 
     * @summary List all call traces for a network
     * @param {CallTracingApiNetworksNetworkIdTracingGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallTracingApi
     */
    public networksNetworkIdTracingGet(requestParameters: CallTracingApiNetworksNetworkIdTracingGetRequest, options?: AxiosRequestConfig) {
        return CallTracingApiFp(this.configuration).networksNetworkIdTracingGet(requestParameters.networkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Start a new call trace
     * @param {CallTracingApiNetworksNetworkIdTracingPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallTracingApi
     */
    public networksNetworkIdTracingPost(requestParameters: CallTracingApiNetworksNetworkIdTracingPostRequest, options?: AxiosRequestConfig) {
        return CallTracingApiFp(this.configuration).networksNetworkIdTracingPost(requestParameters.networkId, requestParameters.callTraceConfiguration, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a call trace record
     * @param {CallTracingApiNetworksNetworkIdTracingTraceIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallTracingApi
     */
    public networksNetworkIdTracingTraceIdDelete(requestParameters: CallTracingApiNetworksNetworkIdTracingTraceIdDeleteRequest, options?: AxiosRequestConfig) {
        return CallTracingApiFp(this.configuration).networksNetworkIdTracingTraceIdDelete(requestParameters.networkId, requestParameters.traceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the call trace in PCAP format
     * @param {CallTracingApiNetworksNetworkIdTracingTraceIdDownloadGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallTracingApi
     */
    public networksNetworkIdTracingTraceIdDownloadGet(requestParameters: CallTracingApiNetworksNetworkIdTracingTraceIdDownloadGetRequest, options?: AxiosRequestConfig) {
        return CallTracingApiFp(this.configuration).networksNetworkIdTracingTraceIdDownloadGet(requestParameters.networkId, requestParameters.traceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get tracing status
     * @param {CallTracingApiNetworksNetworkIdTracingTraceIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallTracingApi
     */
    public networksNetworkIdTracingTraceIdGet(requestParameters: CallTracingApiNetworksNetworkIdTracingTraceIdGetRequest, options?: AxiosRequestConfig) {
        return CallTracingApiFp(this.configuration).networksNetworkIdTracingTraceIdGet(requestParameters.networkId, requestParameters.traceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a call trace
     * @param {CallTracingApiNetworksNetworkIdTracingTraceIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallTracingApi
     */
    public networksNetworkIdTracingTraceIdPut(requestParameters: CallTracingApiNetworksNetworkIdTracingTraceIdPutRequest, options?: AxiosRequestConfig) {
        return CallTracingApiFp(this.configuration).networksNetworkIdTracingTraceIdPut(requestParameters.networkId, requestParameters.traceId, requestParameters.callTraceConfiguration, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CarrierWifiGatewaysApi - axios parameter creator
 * @export
 */
export const CarrierWifiGatewaysApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get gateway carrier Wifi configuration
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cwfNetworkIdGatewaysGatewayIdCarrierWifiGet: async (networkId: string, gatewayId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('cwfNetworkIdGatewaysGatewayIdCarrierWifiGet', 'networkId', networkId)
            // verify required parameter 'gatewayId' is not null or undefined
            assertParamExists('cwfNetworkIdGatewaysGatewayIdCarrierWifiGet', 'gatewayId', gatewayId)
            const localVarPath = `/cwf/{network_id}/gateways/{gateway_id}/carrier_wifi`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"gateway_id"}}`, encodeURIComponent(String(gatewayId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update gateway carrier Wifi configuration
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {GatewayCwfConfigs} config New carrier Wifi configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cwfNetworkIdGatewaysGatewayIdCarrierWifiPut: async (networkId: string, gatewayId: string, config: GatewayCwfConfigs, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('cwfNetworkIdGatewaysGatewayIdCarrierWifiPut', 'networkId', networkId)
            // verify required parameter 'gatewayId' is not null or undefined
            assertParamExists('cwfNetworkIdGatewaysGatewayIdCarrierWifiPut', 'gatewayId', gatewayId)
            // verify required parameter 'config' is not null or undefined
            assertParamExists('cwfNetworkIdGatewaysGatewayIdCarrierWifiPut', 'config', config)
            const localVarPath = `/cwf/{network_id}/gateways/{gateway_id}/carrier_wifi`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"gateway_id"}}`, encodeURIComponent(String(gatewayId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(config, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a carrier wifi gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cwfNetworkIdGatewaysGatewayIdDelete: async (networkId: string, gatewayId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('cwfNetworkIdGatewaysGatewayIdDelete', 'networkId', networkId)
            // verify required parameter 'gatewayId' is not null or undefined
            assertParamExists('cwfNetworkIdGatewaysGatewayIdDelete', 'gatewayId', gatewayId)
            const localVarPath = `/cwf/{network_id}/gateways/{gateway_id}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"gateway_id"}}`, encodeURIComponent(String(gatewayId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the description of a carrier wifi gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cwfNetworkIdGatewaysGatewayIdDescriptionGet: async (networkId: string, gatewayId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('cwfNetworkIdGatewaysGatewayIdDescriptionGet', 'networkId', networkId)
            // verify required parameter 'gatewayId' is not null or undefined
            assertParamExists('cwfNetworkIdGatewaysGatewayIdDescriptionGet', 'gatewayId', gatewayId)
            const localVarPath = `/cwf/{network_id}/gateways/{gateway_id}/description`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"gateway_id"}}`, encodeURIComponent(String(gatewayId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the description of a carrier wifi gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {string} description 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cwfNetworkIdGatewaysGatewayIdDescriptionPut: async (networkId: string, gatewayId: string, description: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('cwfNetworkIdGatewaysGatewayIdDescriptionPut', 'networkId', networkId)
            // verify required parameter 'gatewayId' is not null or undefined
            assertParamExists('cwfNetworkIdGatewaysGatewayIdDescriptionPut', 'gatewayId', gatewayId)
            // verify required parameter 'description' is not null or undefined
            assertParamExists('cwfNetworkIdGatewaysGatewayIdDescriptionPut', 'description', description)
            const localVarPath = `/cwf/{network_id}/gateways/{gateway_id}/description`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"gateway_id"}}`, encodeURIComponent(String(gatewayId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(description, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the physical device for a carrier wifi gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cwfNetworkIdGatewaysGatewayIdDeviceGet: async (networkId: string, gatewayId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('cwfNetworkIdGatewaysGatewayIdDeviceGet', 'networkId', networkId)
            // verify required parameter 'gatewayId' is not null or undefined
            assertParamExists('cwfNetworkIdGatewaysGatewayIdDeviceGet', 'gatewayId', gatewayId)
            const localVarPath = `/cwf/{network_id}/gateways/{gateway_id}/device`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"gateway_id"}}`, encodeURIComponent(String(gatewayId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the physical device for a carrier wifi gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {GatewayDevice} device New device for the carrier wifi gateway
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cwfNetworkIdGatewaysGatewayIdDevicePut: async (networkId: string, gatewayId: string, device: GatewayDevice, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('cwfNetworkIdGatewaysGatewayIdDevicePut', 'networkId', networkId)
            // verify required parameter 'gatewayId' is not null or undefined
            assertParamExists('cwfNetworkIdGatewaysGatewayIdDevicePut', 'gatewayId', gatewayId)
            // verify required parameter 'device' is not null or undefined
            assertParamExists('cwfNetworkIdGatewaysGatewayIdDevicePut', 'device', device)
            const localVarPath = `/cwf/{network_id}/gateways/{gateway_id}/device`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"gateway_id"}}`, encodeURIComponent(String(gatewayId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(device, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a specific carrier wifi gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cwfNetworkIdGatewaysGatewayIdGet: async (networkId: string, gatewayId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('cwfNetworkIdGatewaysGatewayIdGet', 'networkId', networkId)
            // verify required parameter 'gatewayId' is not null or undefined
            assertParamExists('cwfNetworkIdGatewaysGatewayIdGet', 'gatewayId', gatewayId)
            const localVarPath = `/cwf/{network_id}/gateways/{gateway_id}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"gateway_id"}}`, encodeURIComponent(String(gatewayId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Health Status of a Carrier Wifi Gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cwfNetworkIdGatewaysGatewayIdHealthStatusGet: async (networkId: string, gatewayId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('cwfNetworkIdGatewaysGatewayIdHealthStatusGet', 'networkId', networkId)
            // verify required parameter 'gatewayId' is not null or undefined
            assertParamExists('cwfNetworkIdGatewaysGatewayIdHealthStatusGet', 'gatewayId', gatewayId)
            const localVarPath = `/cwf/{network_id}/gateways/{gateway_id}/health_status`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"gateway_id"}}`, encodeURIComponent(String(gatewayId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get magmad agent configuration
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cwfNetworkIdGatewaysGatewayIdMagmadGet: async (networkId: string, gatewayId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('cwfNetworkIdGatewaysGatewayIdMagmadGet', 'networkId', networkId)
            // verify required parameter 'gatewayId' is not null or undefined
            assertParamExists('cwfNetworkIdGatewaysGatewayIdMagmadGet', 'gatewayId', gatewayId)
            const localVarPath = `/cwf/{network_id}/gateways/{gateway_id}/magmad`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"gateway_id"}}`, encodeURIComponent(String(gatewayId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reconfigure magmad agent
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {MagmadGatewayConfigs} magmad New magmad configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cwfNetworkIdGatewaysGatewayIdMagmadPut: async (networkId: string, gatewayId: string, magmad: MagmadGatewayConfigs, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('cwfNetworkIdGatewaysGatewayIdMagmadPut', 'networkId', networkId)
            // verify required parameter 'gatewayId' is not null or undefined
            assertParamExists('cwfNetworkIdGatewaysGatewayIdMagmadPut', 'gatewayId', gatewayId)
            // verify required parameter 'magmad' is not null or undefined
            assertParamExists('cwfNetworkIdGatewaysGatewayIdMagmadPut', 'magmad', magmad)
            const localVarPath = `/cwf/{network_id}/gateways/{gateway_id}/magmad`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"gateway_id"}}`, encodeURIComponent(String(gatewayId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(magmad, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the name of a carrier wifi gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cwfNetworkIdGatewaysGatewayIdNameGet: async (networkId: string, gatewayId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('cwfNetworkIdGatewaysGatewayIdNameGet', 'networkId', networkId)
            // verify required parameter 'gatewayId' is not null or undefined
            assertParamExists('cwfNetworkIdGatewaysGatewayIdNameGet', 'gatewayId', gatewayId)
            const localVarPath = `/cwf/{network_id}/gateways/{gateway_id}/name`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"gateway_id"}}`, encodeURIComponent(String(gatewayId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the name of a carrier wifi gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cwfNetworkIdGatewaysGatewayIdNamePut: async (networkId: string, gatewayId: string, name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('cwfNetworkIdGatewaysGatewayIdNamePut', 'networkId', networkId)
            // verify required parameter 'gatewayId' is not null or undefined
            assertParamExists('cwfNetworkIdGatewaysGatewayIdNamePut', 'gatewayId', gatewayId)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('cwfNetworkIdGatewaysGatewayIdNamePut', 'name', name)
            const localVarPath = `/cwf/{network_id}/gateways/{gateway_id}/name`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"gateway_id"}}`, encodeURIComponent(String(gatewayId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(name, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an entire carrier wifi gateway record
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {MutableCwfGateway} gateway Full desired configuration of the gateway
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cwfNetworkIdGatewaysGatewayIdPut: async (networkId: string, gatewayId: string, gateway: MutableCwfGateway, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('cwfNetworkIdGatewaysGatewayIdPut', 'networkId', networkId)
            // verify required parameter 'gatewayId' is not null or undefined
            assertParamExists('cwfNetworkIdGatewaysGatewayIdPut', 'gatewayId', gatewayId)
            // verify required parameter 'gateway' is not null or undefined
            assertParamExists('cwfNetworkIdGatewaysGatewayIdPut', 'gateway', gateway)
            const localVarPath = `/cwf/{network_id}/gateways/{gateway_id}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"gateway_id"}}`, encodeURIComponent(String(gatewayId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(gateway, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the status of a gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cwfNetworkIdGatewaysGatewayIdStatusGet: async (networkId: string, gatewayId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('cwfNetworkIdGatewaysGatewayIdStatusGet', 'networkId', networkId)
            // verify required parameter 'gatewayId' is not null or undefined
            assertParamExists('cwfNetworkIdGatewaysGatewayIdStatusGet', 'gatewayId', gatewayId)
            const localVarPath = `/cwf/{network_id}/gateways/{gateway_id}/status`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"gateway_id"}}`, encodeURIComponent(String(gatewayId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the ID of the upgrade tier a gateway belongs to
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cwfNetworkIdGatewaysGatewayIdTierGet: async (networkId: string, gatewayId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('cwfNetworkIdGatewaysGatewayIdTierGet', 'networkId', networkId)
            // verify required parameter 'gatewayId' is not null or undefined
            assertParamExists('cwfNetworkIdGatewaysGatewayIdTierGet', 'gatewayId', gatewayId)
            const localVarPath = `/cwf/{network_id}/gateways/{gateway_id}/tier`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"gateway_id"}}`, encodeURIComponent(String(gatewayId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the ID of the upgrade tier a gateway belongs to
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {string} tierId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cwfNetworkIdGatewaysGatewayIdTierPut: async (networkId: string, gatewayId: string, tierId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('cwfNetworkIdGatewaysGatewayIdTierPut', 'networkId', networkId)
            // verify required parameter 'gatewayId' is not null or undefined
            assertParamExists('cwfNetworkIdGatewaysGatewayIdTierPut', 'gatewayId', gatewayId)
            // verify required parameter 'tierId' is not null or undefined
            assertParamExists('cwfNetworkIdGatewaysGatewayIdTierPut', 'tierId', tierId)
            const localVarPath = `/cwf/{network_id}/gateways/{gateway_id}/tier`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"gateway_id"}}`, encodeURIComponent(String(gatewayId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tierId, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all gateways for a carrier wifi network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cwfNetworkIdGatewaysGet: async (networkId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('cwfNetworkIdGatewaysGet', 'networkId', networkId)
            const localVarPath = `/cwf/{network_id}/gateways`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Register a new carrier wifi gateway
         * @param {string} networkId Network ID
         * @param {MutableCwfGateway} gateway Full desired configuration of the gateway
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cwfNetworkIdGatewaysPost: async (networkId: string, gateway: MutableCwfGateway, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('cwfNetworkIdGatewaysPost', 'networkId', networkId)
            // verify required parameter 'gateway' is not null or undefined
            assertParamExists('cwfNetworkIdGatewaysPost', 'gateway', gateway)
            const localVarPath = `/cwf/{network_id}/gateways`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(gateway, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CarrierWifiGatewaysApi - functional programming interface
 * @export
 */
export const CarrierWifiGatewaysApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CarrierWifiGatewaysApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get gateway carrier Wifi configuration
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cwfNetworkIdGatewaysGatewayIdCarrierWifiGet(networkId: string, gatewayId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GatewayCwfConfigs>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cwfNetworkIdGatewaysGatewayIdCarrierWifiGet(networkId, gatewayId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update gateway carrier Wifi configuration
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {GatewayCwfConfigs} config New carrier Wifi configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cwfNetworkIdGatewaysGatewayIdCarrierWifiPut(networkId: string, gatewayId: string, config: GatewayCwfConfigs, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cwfNetworkIdGatewaysGatewayIdCarrierWifiPut(networkId, gatewayId, config, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a carrier wifi gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cwfNetworkIdGatewaysGatewayIdDelete(networkId: string, gatewayId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cwfNetworkIdGatewaysGatewayIdDelete(networkId, gatewayId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the description of a carrier wifi gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cwfNetworkIdGatewaysGatewayIdDescriptionGet(networkId: string, gatewayId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cwfNetworkIdGatewaysGatewayIdDescriptionGet(networkId, gatewayId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update the description of a carrier wifi gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {string} description 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cwfNetworkIdGatewaysGatewayIdDescriptionPut(networkId: string, gatewayId: string, description: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cwfNetworkIdGatewaysGatewayIdDescriptionPut(networkId, gatewayId, description, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the physical device for a carrier wifi gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cwfNetworkIdGatewaysGatewayIdDeviceGet(networkId: string, gatewayId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GatewayDevice>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cwfNetworkIdGatewaysGatewayIdDeviceGet(networkId, gatewayId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update the physical device for a carrier wifi gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {GatewayDevice} device New device for the carrier wifi gateway
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cwfNetworkIdGatewaysGatewayIdDevicePut(networkId: string, gatewayId: string, device: GatewayDevice, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cwfNetworkIdGatewaysGatewayIdDevicePut(networkId, gatewayId, device, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a specific carrier wifi gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cwfNetworkIdGatewaysGatewayIdGet(networkId: string, gatewayId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CwfGateway>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cwfNetworkIdGatewaysGatewayIdGet(networkId, gatewayId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve Health Status of a Carrier Wifi Gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cwfNetworkIdGatewaysGatewayIdHealthStatusGet(networkId: string, gatewayId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CarrierWifiGatewayHealthStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cwfNetworkIdGatewaysGatewayIdHealthStatusGet(networkId, gatewayId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get magmad agent configuration
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cwfNetworkIdGatewaysGatewayIdMagmadGet(networkId: string, gatewayId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MagmadGatewayConfigs>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cwfNetworkIdGatewaysGatewayIdMagmadGet(networkId, gatewayId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Reconfigure magmad agent
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {MagmadGatewayConfigs} magmad New magmad configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cwfNetworkIdGatewaysGatewayIdMagmadPut(networkId: string, gatewayId: string, magmad: MagmadGatewayConfigs, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cwfNetworkIdGatewaysGatewayIdMagmadPut(networkId, gatewayId, magmad, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the name of a carrier wifi gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cwfNetworkIdGatewaysGatewayIdNameGet(networkId: string, gatewayId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cwfNetworkIdGatewaysGatewayIdNameGet(networkId, gatewayId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update the name of a carrier wifi gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cwfNetworkIdGatewaysGatewayIdNamePut(networkId: string, gatewayId: string, name: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cwfNetworkIdGatewaysGatewayIdNamePut(networkId, gatewayId, name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update an entire carrier wifi gateway record
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {MutableCwfGateway} gateway Full desired configuration of the gateway
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cwfNetworkIdGatewaysGatewayIdPut(networkId: string, gatewayId: string, gateway: MutableCwfGateway, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cwfNetworkIdGatewaysGatewayIdPut(networkId, gatewayId, gateway, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the status of a gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cwfNetworkIdGatewaysGatewayIdStatusGet(networkId: string, gatewayId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GatewayStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cwfNetworkIdGatewaysGatewayIdStatusGet(networkId, gatewayId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the ID of the upgrade tier a gateway belongs to
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cwfNetworkIdGatewaysGatewayIdTierGet(networkId: string, gatewayId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cwfNetworkIdGatewaysGatewayIdTierGet(networkId, gatewayId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update the ID of the upgrade tier a gateway belongs to
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {string} tierId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cwfNetworkIdGatewaysGatewayIdTierPut(networkId: string, gatewayId: string, tierId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cwfNetworkIdGatewaysGatewayIdTierPut(networkId, gatewayId, tierId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all gateways for a carrier wifi network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cwfNetworkIdGatewaysGet(networkId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: CwfGateway; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cwfNetworkIdGatewaysGet(networkId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Register a new carrier wifi gateway
         * @param {string} networkId Network ID
         * @param {MutableCwfGateway} gateway Full desired configuration of the gateway
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cwfNetworkIdGatewaysPost(networkId: string, gateway: MutableCwfGateway, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cwfNetworkIdGatewaysPost(networkId, gateway, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CarrierWifiGatewaysApi - factory interface
 * @export
 */
export const CarrierWifiGatewaysApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CarrierWifiGatewaysApiFp(configuration)
    return {
        /**
         * 
         * @summary Get gateway carrier Wifi configuration
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cwfNetworkIdGatewaysGatewayIdCarrierWifiGet(networkId: string, gatewayId: string, options?: any): AxiosPromise<GatewayCwfConfigs> {
            return localVarFp.cwfNetworkIdGatewaysGatewayIdCarrierWifiGet(networkId, gatewayId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update gateway carrier Wifi configuration
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {GatewayCwfConfigs} config New carrier Wifi configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cwfNetworkIdGatewaysGatewayIdCarrierWifiPut(networkId: string, gatewayId: string, config: GatewayCwfConfigs, options?: any): AxiosPromise<void> {
            return localVarFp.cwfNetworkIdGatewaysGatewayIdCarrierWifiPut(networkId, gatewayId, config, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a carrier wifi gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cwfNetworkIdGatewaysGatewayIdDelete(networkId: string, gatewayId: string, options?: any): AxiosPromise<void> {
            return localVarFp.cwfNetworkIdGatewaysGatewayIdDelete(networkId, gatewayId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the description of a carrier wifi gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cwfNetworkIdGatewaysGatewayIdDescriptionGet(networkId: string, gatewayId: string, options?: any): AxiosPromise<string> {
            return localVarFp.cwfNetworkIdGatewaysGatewayIdDescriptionGet(networkId, gatewayId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the description of a carrier wifi gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {string} description 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cwfNetworkIdGatewaysGatewayIdDescriptionPut(networkId: string, gatewayId: string, description: string, options?: any): AxiosPromise<void> {
            return localVarFp.cwfNetworkIdGatewaysGatewayIdDescriptionPut(networkId, gatewayId, description, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the physical device for a carrier wifi gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cwfNetworkIdGatewaysGatewayIdDeviceGet(networkId: string, gatewayId: string, options?: any): AxiosPromise<GatewayDevice> {
            return localVarFp.cwfNetworkIdGatewaysGatewayIdDeviceGet(networkId, gatewayId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the physical device for a carrier wifi gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {GatewayDevice} device New device for the carrier wifi gateway
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cwfNetworkIdGatewaysGatewayIdDevicePut(networkId: string, gatewayId: string, device: GatewayDevice, options?: any): AxiosPromise<void> {
            return localVarFp.cwfNetworkIdGatewaysGatewayIdDevicePut(networkId, gatewayId, device, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a specific carrier wifi gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cwfNetworkIdGatewaysGatewayIdGet(networkId: string, gatewayId: string, options?: any): AxiosPromise<CwfGateway> {
            return localVarFp.cwfNetworkIdGatewaysGatewayIdGet(networkId, gatewayId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve Health Status of a Carrier Wifi Gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cwfNetworkIdGatewaysGatewayIdHealthStatusGet(networkId: string, gatewayId: string, options?: any): AxiosPromise<CarrierWifiGatewayHealthStatus> {
            return localVarFp.cwfNetworkIdGatewaysGatewayIdHealthStatusGet(networkId, gatewayId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get magmad agent configuration
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cwfNetworkIdGatewaysGatewayIdMagmadGet(networkId: string, gatewayId: string, options?: any): AxiosPromise<MagmadGatewayConfigs> {
            return localVarFp.cwfNetworkIdGatewaysGatewayIdMagmadGet(networkId, gatewayId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reconfigure magmad agent
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {MagmadGatewayConfigs} magmad New magmad configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cwfNetworkIdGatewaysGatewayIdMagmadPut(networkId: string, gatewayId: string, magmad: MagmadGatewayConfigs, options?: any): AxiosPromise<void> {
            return localVarFp.cwfNetworkIdGatewaysGatewayIdMagmadPut(networkId, gatewayId, magmad, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the name of a carrier wifi gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cwfNetworkIdGatewaysGatewayIdNameGet(networkId: string, gatewayId: string, options?: any): AxiosPromise<string> {
            return localVarFp.cwfNetworkIdGatewaysGatewayIdNameGet(networkId, gatewayId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the name of a carrier wifi gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cwfNetworkIdGatewaysGatewayIdNamePut(networkId: string, gatewayId: string, name: string, options?: any): AxiosPromise<void> {
            return localVarFp.cwfNetworkIdGatewaysGatewayIdNamePut(networkId, gatewayId, name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an entire carrier wifi gateway record
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {MutableCwfGateway} gateway Full desired configuration of the gateway
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cwfNetworkIdGatewaysGatewayIdPut(networkId: string, gatewayId: string, gateway: MutableCwfGateway, options?: any): AxiosPromise<void> {
            return localVarFp.cwfNetworkIdGatewaysGatewayIdPut(networkId, gatewayId, gateway, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the status of a gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cwfNetworkIdGatewaysGatewayIdStatusGet(networkId: string, gatewayId: string, options?: any): AxiosPromise<GatewayStatus> {
            return localVarFp.cwfNetworkIdGatewaysGatewayIdStatusGet(networkId, gatewayId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the ID of the upgrade tier a gateway belongs to
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cwfNetworkIdGatewaysGatewayIdTierGet(networkId: string, gatewayId: string, options?: any): AxiosPromise<string> {
            return localVarFp.cwfNetworkIdGatewaysGatewayIdTierGet(networkId, gatewayId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the ID of the upgrade tier a gateway belongs to
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {string} tierId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cwfNetworkIdGatewaysGatewayIdTierPut(networkId: string, gatewayId: string, tierId: string, options?: any): AxiosPromise<void> {
            return localVarFp.cwfNetworkIdGatewaysGatewayIdTierPut(networkId, gatewayId, tierId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all gateways for a carrier wifi network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cwfNetworkIdGatewaysGet(networkId: string, options?: any): AxiosPromise<{ [key: string]: CwfGateway; }> {
            return localVarFp.cwfNetworkIdGatewaysGet(networkId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Register a new carrier wifi gateway
         * @param {string} networkId Network ID
         * @param {MutableCwfGateway} gateway Full desired configuration of the gateway
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cwfNetworkIdGatewaysPost(networkId: string, gateway: MutableCwfGateway, options?: any): AxiosPromise<void> {
            return localVarFp.cwfNetworkIdGatewaysPost(networkId, gateway, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for cwfNetworkIdGatewaysGatewayIdCarrierWifiGet operation in CarrierWifiGatewaysApi.
 * @export
 * @interface CarrierWifiGatewaysApiCwfNetworkIdGatewaysGatewayIdCarrierWifiGetRequest
 */
export interface CarrierWifiGatewaysApiCwfNetworkIdGatewaysGatewayIdCarrierWifiGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof CarrierWifiGatewaysApiCwfNetworkIdGatewaysGatewayIdCarrierWifiGet
     */
    readonly networkId: string

    /**
     * Gateway ID
     * @type {string}
     * @memberof CarrierWifiGatewaysApiCwfNetworkIdGatewaysGatewayIdCarrierWifiGet
     */
    readonly gatewayId: string
}

/**
 * Request parameters for cwfNetworkIdGatewaysGatewayIdCarrierWifiPut operation in CarrierWifiGatewaysApi.
 * @export
 * @interface CarrierWifiGatewaysApiCwfNetworkIdGatewaysGatewayIdCarrierWifiPutRequest
 */
export interface CarrierWifiGatewaysApiCwfNetworkIdGatewaysGatewayIdCarrierWifiPutRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof CarrierWifiGatewaysApiCwfNetworkIdGatewaysGatewayIdCarrierWifiPut
     */
    readonly networkId: string

    /**
     * Gateway ID
     * @type {string}
     * @memberof CarrierWifiGatewaysApiCwfNetworkIdGatewaysGatewayIdCarrierWifiPut
     */
    readonly gatewayId: string

    /**
     * New carrier Wifi configuration
     * @type {GatewayCwfConfigs}
     * @memberof CarrierWifiGatewaysApiCwfNetworkIdGatewaysGatewayIdCarrierWifiPut
     */
    readonly config: GatewayCwfConfigs
}

/**
 * Request parameters for cwfNetworkIdGatewaysGatewayIdDelete operation in CarrierWifiGatewaysApi.
 * @export
 * @interface CarrierWifiGatewaysApiCwfNetworkIdGatewaysGatewayIdDeleteRequest
 */
export interface CarrierWifiGatewaysApiCwfNetworkIdGatewaysGatewayIdDeleteRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof CarrierWifiGatewaysApiCwfNetworkIdGatewaysGatewayIdDelete
     */
    readonly networkId: string

    /**
     * Gateway ID
     * @type {string}
     * @memberof CarrierWifiGatewaysApiCwfNetworkIdGatewaysGatewayIdDelete
     */
    readonly gatewayId: string
}

/**
 * Request parameters for cwfNetworkIdGatewaysGatewayIdDescriptionGet operation in CarrierWifiGatewaysApi.
 * @export
 * @interface CarrierWifiGatewaysApiCwfNetworkIdGatewaysGatewayIdDescriptionGetRequest
 */
export interface CarrierWifiGatewaysApiCwfNetworkIdGatewaysGatewayIdDescriptionGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof CarrierWifiGatewaysApiCwfNetworkIdGatewaysGatewayIdDescriptionGet
     */
    readonly networkId: string

    /**
     * Gateway ID
     * @type {string}
     * @memberof CarrierWifiGatewaysApiCwfNetworkIdGatewaysGatewayIdDescriptionGet
     */
    readonly gatewayId: string
}

/**
 * Request parameters for cwfNetworkIdGatewaysGatewayIdDescriptionPut operation in CarrierWifiGatewaysApi.
 * @export
 * @interface CarrierWifiGatewaysApiCwfNetworkIdGatewaysGatewayIdDescriptionPutRequest
 */
export interface CarrierWifiGatewaysApiCwfNetworkIdGatewaysGatewayIdDescriptionPutRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof CarrierWifiGatewaysApiCwfNetworkIdGatewaysGatewayIdDescriptionPut
     */
    readonly networkId: string

    /**
     * Gateway ID
     * @type {string}
     * @memberof CarrierWifiGatewaysApiCwfNetworkIdGatewaysGatewayIdDescriptionPut
     */
    readonly gatewayId: string

    /**
     * 
     * @type {string}
     * @memberof CarrierWifiGatewaysApiCwfNetworkIdGatewaysGatewayIdDescriptionPut
     */
    readonly description: string
}

/**
 * Request parameters for cwfNetworkIdGatewaysGatewayIdDeviceGet operation in CarrierWifiGatewaysApi.
 * @export
 * @interface CarrierWifiGatewaysApiCwfNetworkIdGatewaysGatewayIdDeviceGetRequest
 */
export interface CarrierWifiGatewaysApiCwfNetworkIdGatewaysGatewayIdDeviceGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof CarrierWifiGatewaysApiCwfNetworkIdGatewaysGatewayIdDeviceGet
     */
    readonly networkId: string

    /**
     * Gateway ID
     * @type {string}
     * @memberof CarrierWifiGatewaysApiCwfNetworkIdGatewaysGatewayIdDeviceGet
     */
    readonly gatewayId: string
}

/**
 * Request parameters for cwfNetworkIdGatewaysGatewayIdDevicePut operation in CarrierWifiGatewaysApi.
 * @export
 * @interface CarrierWifiGatewaysApiCwfNetworkIdGatewaysGatewayIdDevicePutRequest
 */
export interface CarrierWifiGatewaysApiCwfNetworkIdGatewaysGatewayIdDevicePutRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof CarrierWifiGatewaysApiCwfNetworkIdGatewaysGatewayIdDevicePut
     */
    readonly networkId: string

    /**
     * Gateway ID
     * @type {string}
     * @memberof CarrierWifiGatewaysApiCwfNetworkIdGatewaysGatewayIdDevicePut
     */
    readonly gatewayId: string

    /**
     * New device for the carrier wifi gateway
     * @type {GatewayDevice}
     * @memberof CarrierWifiGatewaysApiCwfNetworkIdGatewaysGatewayIdDevicePut
     */
    readonly device: GatewayDevice
}

/**
 * Request parameters for cwfNetworkIdGatewaysGatewayIdGet operation in CarrierWifiGatewaysApi.
 * @export
 * @interface CarrierWifiGatewaysApiCwfNetworkIdGatewaysGatewayIdGetRequest
 */
export interface CarrierWifiGatewaysApiCwfNetworkIdGatewaysGatewayIdGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof CarrierWifiGatewaysApiCwfNetworkIdGatewaysGatewayIdGet
     */
    readonly networkId: string

    /**
     * Gateway ID
     * @type {string}
     * @memberof CarrierWifiGatewaysApiCwfNetworkIdGatewaysGatewayIdGet
     */
    readonly gatewayId: string
}

/**
 * Request parameters for cwfNetworkIdGatewaysGatewayIdHealthStatusGet operation in CarrierWifiGatewaysApi.
 * @export
 * @interface CarrierWifiGatewaysApiCwfNetworkIdGatewaysGatewayIdHealthStatusGetRequest
 */
export interface CarrierWifiGatewaysApiCwfNetworkIdGatewaysGatewayIdHealthStatusGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof CarrierWifiGatewaysApiCwfNetworkIdGatewaysGatewayIdHealthStatusGet
     */
    readonly networkId: string

    /**
     * Gateway ID
     * @type {string}
     * @memberof CarrierWifiGatewaysApiCwfNetworkIdGatewaysGatewayIdHealthStatusGet
     */
    readonly gatewayId: string
}

/**
 * Request parameters for cwfNetworkIdGatewaysGatewayIdMagmadGet operation in CarrierWifiGatewaysApi.
 * @export
 * @interface CarrierWifiGatewaysApiCwfNetworkIdGatewaysGatewayIdMagmadGetRequest
 */
export interface CarrierWifiGatewaysApiCwfNetworkIdGatewaysGatewayIdMagmadGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof CarrierWifiGatewaysApiCwfNetworkIdGatewaysGatewayIdMagmadGet
     */
    readonly networkId: string

    /**
     * Gateway ID
     * @type {string}
     * @memberof CarrierWifiGatewaysApiCwfNetworkIdGatewaysGatewayIdMagmadGet
     */
    readonly gatewayId: string
}

/**
 * Request parameters for cwfNetworkIdGatewaysGatewayIdMagmadPut operation in CarrierWifiGatewaysApi.
 * @export
 * @interface CarrierWifiGatewaysApiCwfNetworkIdGatewaysGatewayIdMagmadPutRequest
 */
export interface CarrierWifiGatewaysApiCwfNetworkIdGatewaysGatewayIdMagmadPutRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof CarrierWifiGatewaysApiCwfNetworkIdGatewaysGatewayIdMagmadPut
     */
    readonly networkId: string

    /**
     * Gateway ID
     * @type {string}
     * @memberof CarrierWifiGatewaysApiCwfNetworkIdGatewaysGatewayIdMagmadPut
     */
    readonly gatewayId: string

    /**
     * New magmad configuration
     * @type {MagmadGatewayConfigs}
     * @memberof CarrierWifiGatewaysApiCwfNetworkIdGatewaysGatewayIdMagmadPut
     */
    readonly magmad: MagmadGatewayConfigs
}

/**
 * Request parameters for cwfNetworkIdGatewaysGatewayIdNameGet operation in CarrierWifiGatewaysApi.
 * @export
 * @interface CarrierWifiGatewaysApiCwfNetworkIdGatewaysGatewayIdNameGetRequest
 */
export interface CarrierWifiGatewaysApiCwfNetworkIdGatewaysGatewayIdNameGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof CarrierWifiGatewaysApiCwfNetworkIdGatewaysGatewayIdNameGet
     */
    readonly networkId: string

    /**
     * Gateway ID
     * @type {string}
     * @memberof CarrierWifiGatewaysApiCwfNetworkIdGatewaysGatewayIdNameGet
     */
    readonly gatewayId: string
}

/**
 * Request parameters for cwfNetworkIdGatewaysGatewayIdNamePut operation in CarrierWifiGatewaysApi.
 * @export
 * @interface CarrierWifiGatewaysApiCwfNetworkIdGatewaysGatewayIdNamePutRequest
 */
export interface CarrierWifiGatewaysApiCwfNetworkIdGatewaysGatewayIdNamePutRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof CarrierWifiGatewaysApiCwfNetworkIdGatewaysGatewayIdNamePut
     */
    readonly networkId: string

    /**
     * Gateway ID
     * @type {string}
     * @memberof CarrierWifiGatewaysApiCwfNetworkIdGatewaysGatewayIdNamePut
     */
    readonly gatewayId: string

    /**
     * 
     * @type {string}
     * @memberof CarrierWifiGatewaysApiCwfNetworkIdGatewaysGatewayIdNamePut
     */
    readonly name: string
}

/**
 * Request parameters for cwfNetworkIdGatewaysGatewayIdPut operation in CarrierWifiGatewaysApi.
 * @export
 * @interface CarrierWifiGatewaysApiCwfNetworkIdGatewaysGatewayIdPutRequest
 */
export interface CarrierWifiGatewaysApiCwfNetworkIdGatewaysGatewayIdPutRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof CarrierWifiGatewaysApiCwfNetworkIdGatewaysGatewayIdPut
     */
    readonly networkId: string

    /**
     * Gateway ID
     * @type {string}
     * @memberof CarrierWifiGatewaysApiCwfNetworkIdGatewaysGatewayIdPut
     */
    readonly gatewayId: string

    /**
     * Full desired configuration of the gateway
     * @type {MutableCwfGateway}
     * @memberof CarrierWifiGatewaysApiCwfNetworkIdGatewaysGatewayIdPut
     */
    readonly gateway: MutableCwfGateway
}

/**
 * Request parameters for cwfNetworkIdGatewaysGatewayIdStatusGet operation in CarrierWifiGatewaysApi.
 * @export
 * @interface CarrierWifiGatewaysApiCwfNetworkIdGatewaysGatewayIdStatusGetRequest
 */
export interface CarrierWifiGatewaysApiCwfNetworkIdGatewaysGatewayIdStatusGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof CarrierWifiGatewaysApiCwfNetworkIdGatewaysGatewayIdStatusGet
     */
    readonly networkId: string

    /**
     * Gateway ID
     * @type {string}
     * @memberof CarrierWifiGatewaysApiCwfNetworkIdGatewaysGatewayIdStatusGet
     */
    readonly gatewayId: string
}

/**
 * Request parameters for cwfNetworkIdGatewaysGatewayIdTierGet operation in CarrierWifiGatewaysApi.
 * @export
 * @interface CarrierWifiGatewaysApiCwfNetworkIdGatewaysGatewayIdTierGetRequest
 */
export interface CarrierWifiGatewaysApiCwfNetworkIdGatewaysGatewayIdTierGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof CarrierWifiGatewaysApiCwfNetworkIdGatewaysGatewayIdTierGet
     */
    readonly networkId: string

    /**
     * Gateway ID
     * @type {string}
     * @memberof CarrierWifiGatewaysApiCwfNetworkIdGatewaysGatewayIdTierGet
     */
    readonly gatewayId: string
}

/**
 * Request parameters for cwfNetworkIdGatewaysGatewayIdTierPut operation in CarrierWifiGatewaysApi.
 * @export
 * @interface CarrierWifiGatewaysApiCwfNetworkIdGatewaysGatewayIdTierPutRequest
 */
export interface CarrierWifiGatewaysApiCwfNetworkIdGatewaysGatewayIdTierPutRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof CarrierWifiGatewaysApiCwfNetworkIdGatewaysGatewayIdTierPut
     */
    readonly networkId: string

    /**
     * Gateway ID
     * @type {string}
     * @memberof CarrierWifiGatewaysApiCwfNetworkIdGatewaysGatewayIdTierPut
     */
    readonly gatewayId: string

    /**
     * 
     * @type {string}
     * @memberof CarrierWifiGatewaysApiCwfNetworkIdGatewaysGatewayIdTierPut
     */
    readonly tierId: string
}

/**
 * Request parameters for cwfNetworkIdGatewaysGet operation in CarrierWifiGatewaysApi.
 * @export
 * @interface CarrierWifiGatewaysApiCwfNetworkIdGatewaysGetRequest
 */
export interface CarrierWifiGatewaysApiCwfNetworkIdGatewaysGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof CarrierWifiGatewaysApiCwfNetworkIdGatewaysGet
     */
    readonly networkId: string
}

/**
 * Request parameters for cwfNetworkIdGatewaysPost operation in CarrierWifiGatewaysApi.
 * @export
 * @interface CarrierWifiGatewaysApiCwfNetworkIdGatewaysPostRequest
 */
export interface CarrierWifiGatewaysApiCwfNetworkIdGatewaysPostRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof CarrierWifiGatewaysApiCwfNetworkIdGatewaysPost
     */
    readonly networkId: string

    /**
     * Full desired configuration of the gateway
     * @type {MutableCwfGateway}
     * @memberof CarrierWifiGatewaysApiCwfNetworkIdGatewaysPost
     */
    readonly gateway: MutableCwfGateway
}

/**
 * CarrierWifiGatewaysApi - object-oriented interface
 * @export
 * @class CarrierWifiGatewaysApi
 * @extends {BaseAPI}
 */
export class CarrierWifiGatewaysApi extends BaseAPI {
    /**
     * 
     * @summary Get gateway carrier Wifi configuration
     * @param {CarrierWifiGatewaysApiCwfNetworkIdGatewaysGatewayIdCarrierWifiGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CarrierWifiGatewaysApi
     */
    public cwfNetworkIdGatewaysGatewayIdCarrierWifiGet(requestParameters: CarrierWifiGatewaysApiCwfNetworkIdGatewaysGatewayIdCarrierWifiGetRequest, options?: AxiosRequestConfig) {
        return CarrierWifiGatewaysApiFp(this.configuration).cwfNetworkIdGatewaysGatewayIdCarrierWifiGet(requestParameters.networkId, requestParameters.gatewayId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update gateway carrier Wifi configuration
     * @param {CarrierWifiGatewaysApiCwfNetworkIdGatewaysGatewayIdCarrierWifiPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CarrierWifiGatewaysApi
     */
    public cwfNetworkIdGatewaysGatewayIdCarrierWifiPut(requestParameters: CarrierWifiGatewaysApiCwfNetworkIdGatewaysGatewayIdCarrierWifiPutRequest, options?: AxiosRequestConfig) {
        return CarrierWifiGatewaysApiFp(this.configuration).cwfNetworkIdGatewaysGatewayIdCarrierWifiPut(requestParameters.networkId, requestParameters.gatewayId, requestParameters.config, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a carrier wifi gateway
     * @param {CarrierWifiGatewaysApiCwfNetworkIdGatewaysGatewayIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CarrierWifiGatewaysApi
     */
    public cwfNetworkIdGatewaysGatewayIdDelete(requestParameters: CarrierWifiGatewaysApiCwfNetworkIdGatewaysGatewayIdDeleteRequest, options?: AxiosRequestConfig) {
        return CarrierWifiGatewaysApiFp(this.configuration).cwfNetworkIdGatewaysGatewayIdDelete(requestParameters.networkId, requestParameters.gatewayId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the description of a carrier wifi gateway
     * @param {CarrierWifiGatewaysApiCwfNetworkIdGatewaysGatewayIdDescriptionGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CarrierWifiGatewaysApi
     */
    public cwfNetworkIdGatewaysGatewayIdDescriptionGet(requestParameters: CarrierWifiGatewaysApiCwfNetworkIdGatewaysGatewayIdDescriptionGetRequest, options?: AxiosRequestConfig) {
        return CarrierWifiGatewaysApiFp(this.configuration).cwfNetworkIdGatewaysGatewayIdDescriptionGet(requestParameters.networkId, requestParameters.gatewayId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the description of a carrier wifi gateway
     * @param {CarrierWifiGatewaysApiCwfNetworkIdGatewaysGatewayIdDescriptionPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CarrierWifiGatewaysApi
     */
    public cwfNetworkIdGatewaysGatewayIdDescriptionPut(requestParameters: CarrierWifiGatewaysApiCwfNetworkIdGatewaysGatewayIdDescriptionPutRequest, options?: AxiosRequestConfig) {
        return CarrierWifiGatewaysApiFp(this.configuration).cwfNetworkIdGatewaysGatewayIdDescriptionPut(requestParameters.networkId, requestParameters.gatewayId, requestParameters.description, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the physical device for a carrier wifi gateway
     * @param {CarrierWifiGatewaysApiCwfNetworkIdGatewaysGatewayIdDeviceGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CarrierWifiGatewaysApi
     */
    public cwfNetworkIdGatewaysGatewayIdDeviceGet(requestParameters: CarrierWifiGatewaysApiCwfNetworkIdGatewaysGatewayIdDeviceGetRequest, options?: AxiosRequestConfig) {
        return CarrierWifiGatewaysApiFp(this.configuration).cwfNetworkIdGatewaysGatewayIdDeviceGet(requestParameters.networkId, requestParameters.gatewayId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the physical device for a carrier wifi gateway
     * @param {CarrierWifiGatewaysApiCwfNetworkIdGatewaysGatewayIdDevicePutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CarrierWifiGatewaysApi
     */
    public cwfNetworkIdGatewaysGatewayIdDevicePut(requestParameters: CarrierWifiGatewaysApiCwfNetworkIdGatewaysGatewayIdDevicePutRequest, options?: AxiosRequestConfig) {
        return CarrierWifiGatewaysApiFp(this.configuration).cwfNetworkIdGatewaysGatewayIdDevicePut(requestParameters.networkId, requestParameters.gatewayId, requestParameters.device, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a specific carrier wifi gateway
     * @param {CarrierWifiGatewaysApiCwfNetworkIdGatewaysGatewayIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CarrierWifiGatewaysApi
     */
    public cwfNetworkIdGatewaysGatewayIdGet(requestParameters: CarrierWifiGatewaysApiCwfNetworkIdGatewaysGatewayIdGetRequest, options?: AxiosRequestConfig) {
        return CarrierWifiGatewaysApiFp(this.configuration).cwfNetworkIdGatewaysGatewayIdGet(requestParameters.networkId, requestParameters.gatewayId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve Health Status of a Carrier Wifi Gateway
     * @param {CarrierWifiGatewaysApiCwfNetworkIdGatewaysGatewayIdHealthStatusGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CarrierWifiGatewaysApi
     */
    public cwfNetworkIdGatewaysGatewayIdHealthStatusGet(requestParameters: CarrierWifiGatewaysApiCwfNetworkIdGatewaysGatewayIdHealthStatusGetRequest, options?: AxiosRequestConfig) {
        return CarrierWifiGatewaysApiFp(this.configuration).cwfNetworkIdGatewaysGatewayIdHealthStatusGet(requestParameters.networkId, requestParameters.gatewayId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get magmad agent configuration
     * @param {CarrierWifiGatewaysApiCwfNetworkIdGatewaysGatewayIdMagmadGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CarrierWifiGatewaysApi
     */
    public cwfNetworkIdGatewaysGatewayIdMagmadGet(requestParameters: CarrierWifiGatewaysApiCwfNetworkIdGatewaysGatewayIdMagmadGetRequest, options?: AxiosRequestConfig) {
        return CarrierWifiGatewaysApiFp(this.configuration).cwfNetworkIdGatewaysGatewayIdMagmadGet(requestParameters.networkId, requestParameters.gatewayId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reconfigure magmad agent
     * @param {CarrierWifiGatewaysApiCwfNetworkIdGatewaysGatewayIdMagmadPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CarrierWifiGatewaysApi
     */
    public cwfNetworkIdGatewaysGatewayIdMagmadPut(requestParameters: CarrierWifiGatewaysApiCwfNetworkIdGatewaysGatewayIdMagmadPutRequest, options?: AxiosRequestConfig) {
        return CarrierWifiGatewaysApiFp(this.configuration).cwfNetworkIdGatewaysGatewayIdMagmadPut(requestParameters.networkId, requestParameters.gatewayId, requestParameters.magmad, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the name of a carrier wifi gateway
     * @param {CarrierWifiGatewaysApiCwfNetworkIdGatewaysGatewayIdNameGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CarrierWifiGatewaysApi
     */
    public cwfNetworkIdGatewaysGatewayIdNameGet(requestParameters: CarrierWifiGatewaysApiCwfNetworkIdGatewaysGatewayIdNameGetRequest, options?: AxiosRequestConfig) {
        return CarrierWifiGatewaysApiFp(this.configuration).cwfNetworkIdGatewaysGatewayIdNameGet(requestParameters.networkId, requestParameters.gatewayId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the name of a carrier wifi gateway
     * @param {CarrierWifiGatewaysApiCwfNetworkIdGatewaysGatewayIdNamePutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CarrierWifiGatewaysApi
     */
    public cwfNetworkIdGatewaysGatewayIdNamePut(requestParameters: CarrierWifiGatewaysApiCwfNetworkIdGatewaysGatewayIdNamePutRequest, options?: AxiosRequestConfig) {
        return CarrierWifiGatewaysApiFp(this.configuration).cwfNetworkIdGatewaysGatewayIdNamePut(requestParameters.networkId, requestParameters.gatewayId, requestParameters.name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an entire carrier wifi gateway record
     * @param {CarrierWifiGatewaysApiCwfNetworkIdGatewaysGatewayIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CarrierWifiGatewaysApi
     */
    public cwfNetworkIdGatewaysGatewayIdPut(requestParameters: CarrierWifiGatewaysApiCwfNetworkIdGatewaysGatewayIdPutRequest, options?: AxiosRequestConfig) {
        return CarrierWifiGatewaysApiFp(this.configuration).cwfNetworkIdGatewaysGatewayIdPut(requestParameters.networkId, requestParameters.gatewayId, requestParameters.gateway, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the status of a gateway
     * @param {CarrierWifiGatewaysApiCwfNetworkIdGatewaysGatewayIdStatusGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CarrierWifiGatewaysApi
     */
    public cwfNetworkIdGatewaysGatewayIdStatusGet(requestParameters: CarrierWifiGatewaysApiCwfNetworkIdGatewaysGatewayIdStatusGetRequest, options?: AxiosRequestConfig) {
        return CarrierWifiGatewaysApiFp(this.configuration).cwfNetworkIdGatewaysGatewayIdStatusGet(requestParameters.networkId, requestParameters.gatewayId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the ID of the upgrade tier a gateway belongs to
     * @param {CarrierWifiGatewaysApiCwfNetworkIdGatewaysGatewayIdTierGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CarrierWifiGatewaysApi
     */
    public cwfNetworkIdGatewaysGatewayIdTierGet(requestParameters: CarrierWifiGatewaysApiCwfNetworkIdGatewaysGatewayIdTierGetRequest, options?: AxiosRequestConfig) {
        return CarrierWifiGatewaysApiFp(this.configuration).cwfNetworkIdGatewaysGatewayIdTierGet(requestParameters.networkId, requestParameters.gatewayId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the ID of the upgrade tier a gateway belongs to
     * @param {CarrierWifiGatewaysApiCwfNetworkIdGatewaysGatewayIdTierPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CarrierWifiGatewaysApi
     */
    public cwfNetworkIdGatewaysGatewayIdTierPut(requestParameters: CarrierWifiGatewaysApiCwfNetworkIdGatewaysGatewayIdTierPutRequest, options?: AxiosRequestConfig) {
        return CarrierWifiGatewaysApiFp(this.configuration).cwfNetworkIdGatewaysGatewayIdTierPut(requestParameters.networkId, requestParameters.gatewayId, requestParameters.tierId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all gateways for a carrier wifi network
     * @param {CarrierWifiGatewaysApiCwfNetworkIdGatewaysGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CarrierWifiGatewaysApi
     */
    public cwfNetworkIdGatewaysGet(requestParameters: CarrierWifiGatewaysApiCwfNetworkIdGatewaysGetRequest, options?: AxiosRequestConfig) {
        return CarrierWifiGatewaysApiFp(this.configuration).cwfNetworkIdGatewaysGet(requestParameters.networkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Register a new carrier wifi gateway
     * @param {CarrierWifiGatewaysApiCwfNetworkIdGatewaysPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CarrierWifiGatewaysApi
     */
    public cwfNetworkIdGatewaysPost(requestParameters: CarrierWifiGatewaysApiCwfNetworkIdGatewaysPostRequest, options?: AxiosRequestConfig) {
        return CarrierWifiGatewaysApiFp(this.configuration).cwfNetworkIdGatewaysPost(requestParameters.networkId, requestParameters.gateway, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CarrierWifiNetworksApi - axios parameter creator
 * @export
 */
export const CarrierWifiNetworksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List all Carrier Wifi network IDs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cwfGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cwf`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Network Carrier Wifi Configs
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cwfNetworkIdCarrierWifiDelete: async (networkId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('cwfNetworkIdCarrierWifiDelete', 'networkId', networkId)
            const localVarPath = `/cwf/{network_id}/carrier_wifi`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Network Carrier Wifi Configs
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cwfNetworkIdCarrierWifiGet: async (networkId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('cwfNetworkIdCarrierWifiGet', 'networkId', networkId)
            const localVarPath = `/cwf/{network_id}/carrier_wifi`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Modify Network Carrier Wifi Configs
         * @param {string} networkId Network ID
         * @param {NetworkCarrierWifiConfigs} config Updated config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cwfNetworkIdCarrierWifiPut: async (networkId: string, config: NetworkCarrierWifiConfigs, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('cwfNetworkIdCarrierWifiPut', 'networkId', networkId)
            // verify required parameter 'config' is not null or undefined
            assertParamExists('cwfNetworkIdCarrierWifiPut', 'config', config)
            const localVarPath = `/cwf/{network_id}/carrier_wifi`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(config, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a Carrier Wifi network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cwfNetworkIdDelete: async (networkId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('cwfNetworkIdDelete', 'networkId', networkId)
            const localVarPath = `/cwf/{network_id}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get description of a Carrier Wifi network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cwfNetworkIdDescriptionGet: async (networkId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('cwfNetworkIdDescriptionGet', 'networkId', networkId)
            const localVarPath = `/cwf/{network_id}/description`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the description of a Carrier Wifi network
         * @param {string} networkId Network ID
         * @param {string} description New name for the network
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cwfNetworkIdDescriptionPut: async (networkId: string, description: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('cwfNetworkIdDescriptionPut', 'networkId', networkId)
            // verify required parameter 'description' is not null or undefined
            assertParamExists('cwfNetworkIdDescriptionPut', 'description', description)
            const localVarPath = `/cwf/{network_id}/description`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(description, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Describe a Carrier Wifi network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cwfNetworkIdGet: async (networkId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('cwfNetworkIdGet', 'networkId', networkId)
            const localVarPath = `/cwf/{network_id}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all high availability gateway pairs in Carrier Wifi network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cwfNetworkIdHaPairsGet: async (networkId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('cwfNetworkIdHaPairsGet', 'networkId', networkId)
            const localVarPath = `/cwf/{network_id}/ha_pairs`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete high availability gateway pair for Carrier Wifi network
         * @param {string} networkId Network ID
         * @param {string} haPairId HA Gateway Pair ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cwfNetworkIdHaPairsHaPairIdDelete: async (networkId: string, haPairId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('cwfNetworkIdHaPairsHaPairIdDelete', 'networkId', networkId)
            // verify required parameter 'haPairId' is not null or undefined
            assertParamExists('cwfNetworkIdHaPairsHaPairIdDelete', 'haPairId', haPairId)
            const localVarPath = `/cwf/{network_id}/ha_pairs/{ha_pair_id}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"ha_pair_id"}}`, encodeURIComponent(String(haPairId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve high availability gateway pair for Carrier Wifi network
         * @param {string} networkId Network ID
         * @param {string} haPairId HA Gateway Pair ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cwfNetworkIdHaPairsHaPairIdGet: async (networkId: string, haPairId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('cwfNetworkIdHaPairsHaPairIdGet', 'networkId', networkId)
            // verify required parameter 'haPairId' is not null or undefined
            assertParamExists('cwfNetworkIdHaPairsHaPairIdGet', 'haPairId', haPairId)
            const localVarPath = `/cwf/{network_id}/ha_pairs/{ha_pair_id}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"ha_pair_id"}}`, encodeURIComponent(String(haPairId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Modify high availability gateway pair for Carrier Wifi network
         * @param {string} networkId Network ID
         * @param {string} haPairId HA Gateway Pair ID
         * @param {MutableCwfHaPair} haPair Carrier Wifi HA gateway pair
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cwfNetworkIdHaPairsHaPairIdPut: async (networkId: string, haPairId: string, haPair: MutableCwfHaPair, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('cwfNetworkIdHaPairsHaPairIdPut', 'networkId', networkId)
            // verify required parameter 'haPairId' is not null or undefined
            assertParamExists('cwfNetworkIdHaPairsHaPairIdPut', 'haPairId', haPairId)
            // verify required parameter 'haPair' is not null or undefined
            assertParamExists('cwfNetworkIdHaPairsHaPairIdPut', 'haPair', haPair)
            const localVarPath = `/cwf/{network_id}/ha_pairs/{ha_pair_id}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"ha_pair_id"}}`, encodeURIComponent(String(haPairId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(haPair, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve status of a Carrier Wifi HA pair
         * @param {string} networkId Network ID
         * @param {string} haPairId HA Gateway Pair ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cwfNetworkIdHaPairsHaPairIdStatusGet: async (networkId: string, haPairId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('cwfNetworkIdHaPairsHaPairIdStatusGet', 'networkId', networkId)
            // verify required parameter 'haPairId' is not null or undefined
            assertParamExists('cwfNetworkIdHaPairsHaPairIdStatusGet', 'haPairId', haPairId)
            const localVarPath = `/cwf/{network_id}/ha_pairs/{ha_pair_id}/status`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"ha_pair_id"}}`, encodeURIComponent(String(haPairId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create new high availability gateway pair in Carrier Wifi network
         * @param {string} networkId Network ID
         * @param {MutableCwfHaPair} hAPair Carrier Wifi HA gateway pair
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cwfNetworkIdHaPairsPost: async (networkId: string, hAPair: MutableCwfHaPair, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('cwfNetworkIdHaPairsPost', 'networkId', networkId)
            // verify required parameter 'hAPair' is not null or undefined
            assertParamExists('cwfNetworkIdHaPairsPost', 'hAPair', hAPair)
            const localVarPath = `/cwf/{network_id}/ha_pairs`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(hAPair, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get monitored LI UEs for Carrier Wifi network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cwfNetworkIdLiUesGet: async (networkId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('cwfNetworkIdLiUesGet', 'networkId', networkId)
            const localVarPath = `/cwf/{network_id}/li_ues`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update monitored LI UEs for Carrier Wifi network
         * @param {string} networkId Network ID
         * @param {LiUes} description 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cwfNetworkIdLiUesPut: async (networkId: string, description: LiUes, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('cwfNetworkIdLiUesPut', 'networkId', networkId)
            // verify required parameter 'description' is not null or undefined
            assertParamExists('cwfNetworkIdLiUesPut', 'description', description)
            const localVarPath = `/cwf/{network_id}/li_ues`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(description, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get name of a Carrier Wifi network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cwfNetworkIdNameGet: async (networkId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('cwfNetworkIdNameGet', 'networkId', networkId)
            const localVarPath = `/cwf/{network_id}/name`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the name of a Carrier Wifi network
         * @param {string} networkId Network ID
         * @param {string} name New name for the network
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cwfNetworkIdNamePut: async (networkId: string, name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('cwfNetworkIdNamePut', 'networkId', networkId)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('cwfNetworkIdNamePut', 'name', name)
            const localVarPath = `/cwf/{network_id}/name`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(name, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an entire Carrier Wifi network
         * @param {string} networkId Network ID
         * @param {CwfNetwork} cwfNetwork Full desired configuration of the network
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cwfNetworkIdPut: async (networkId: string, cwfNetwork: CwfNetwork, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('cwfNetworkIdPut', 'networkId', networkId)
            // verify required parameter 'cwfNetwork' is not null or undefined
            assertParamExists('cwfNetworkIdPut', 'cwfNetwork', cwfNetwork)
            const localVarPath = `/cwf/{network_id}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cwfNetwork, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add a network-wide base name
         * @param {string} networkId Network ID
         * @param {string} baseName Charging Rule Base Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cwfNetworkIdSubscriberConfigBaseNamesBaseNameDelete: async (networkId: string, baseName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('cwfNetworkIdSubscriberConfigBaseNamesBaseNameDelete', 'networkId', networkId)
            // verify required parameter 'baseName' is not null or undefined
            assertParamExists('cwfNetworkIdSubscriberConfigBaseNamesBaseNameDelete', 'baseName', baseName)
            const localVarPath = `/cwf/{network_id}/subscriber_config/base_names/{base_name}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"base_name"}}`, encodeURIComponent(String(baseName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add a network-wide base name
         * @param {string} networkId Network ID
         * @param {string} baseName Charging Rule Base Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cwfNetworkIdSubscriberConfigBaseNamesBaseNamePost: async (networkId: string, baseName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('cwfNetworkIdSubscriberConfigBaseNamesBaseNamePost', 'networkId', networkId)
            // verify required parameter 'baseName' is not null or undefined
            assertParamExists('cwfNetworkIdSubscriberConfigBaseNamesBaseNamePost', 'baseName', baseName)
            const localVarPath = `/cwf/{network_id}/subscriber_config/base_names/{base_name}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"base_name"}}`, encodeURIComponent(String(baseName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get network-wide base names
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cwfNetworkIdSubscriberConfigBaseNamesGet: async (networkId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('cwfNetworkIdSubscriberConfigBaseNamesGet', 'networkId', networkId)
            const localVarPath = `/cwf/{network_id}/subscriber_config/base_names`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update network-wide base names
         * @param {string} networkId Network ID
         * @param {Array<string>} record Subscriber Config for the Network
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cwfNetworkIdSubscriberConfigBaseNamesPut: async (networkId: string, record: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('cwfNetworkIdSubscriberConfigBaseNamesPut', 'networkId', networkId)
            // verify required parameter 'record' is not null or undefined
            assertParamExists('cwfNetworkIdSubscriberConfigBaseNamesPut', 'record', record)
            const localVarPath = `/cwf/{network_id}/subscriber_config/base_names`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(record, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a network-wide subscriber config
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cwfNetworkIdSubscriberConfigGet: async (networkId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('cwfNetworkIdSubscriberConfigGet', 'networkId', networkId)
            const localVarPath = `/cwf/{network_id}/subscriber_config`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a network-wide subscriber config
         * @param {string} networkId Network ID
         * @param {NetworkSubscriberConfig} record Subscriber Config for the Network
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cwfNetworkIdSubscriberConfigPut: async (networkId: string, record: NetworkSubscriberConfig, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('cwfNetworkIdSubscriberConfigPut', 'networkId', networkId)
            // verify required parameter 'record' is not null or undefined
            assertParamExists('cwfNetworkIdSubscriberConfigPut', 'record', record)
            const localVarPath = `/cwf/{network_id}/subscriber_config`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(record, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get network-wide rule names
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cwfNetworkIdSubscriberConfigRuleNamesGet: async (networkId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('cwfNetworkIdSubscriberConfigRuleNamesGet', 'networkId', networkId)
            const localVarPath = `/cwf/{network_id}/subscriber_config/rule_names`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update network-wide rule names
         * @param {string} networkId Network ID
         * @param {Array<string>} record Subscriber Config for the Network
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cwfNetworkIdSubscriberConfigRuleNamesPut: async (networkId: string, record: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('cwfNetworkIdSubscriberConfigRuleNamesPut', 'networkId', networkId)
            // verify required parameter 'record' is not null or undefined
            assertParamExists('cwfNetworkIdSubscriberConfigRuleNamesPut', 'record', record)
            const localVarPath = `/cwf/{network_id}/subscriber_config/rule_names`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(record, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add a network-wide rule name
         * @param {string} networkId Network ID
         * @param {string} ruleId Rule Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cwfNetworkIdSubscriberConfigRuleNamesRuleIdDelete: async (networkId: string, ruleId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('cwfNetworkIdSubscriberConfigRuleNamesRuleIdDelete', 'networkId', networkId)
            // verify required parameter 'ruleId' is not null or undefined
            assertParamExists('cwfNetworkIdSubscriberConfigRuleNamesRuleIdDelete', 'ruleId', ruleId)
            const localVarPath = `/cwf/{network_id}/subscriber_config/rule_names/{rule_id}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"rule_id"}}`, encodeURIComponent(String(ruleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add a network-wide rule name
         * @param {string} networkId Network ID
         * @param {string} ruleId Rule Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cwfNetworkIdSubscriberConfigRuleNamesRuleIdPost: async (networkId: string, ruleId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('cwfNetworkIdSubscriberConfigRuleNamesRuleIdPost', 'networkId', networkId)
            // verify required parameter 'ruleId' is not null or undefined
            assertParamExists('cwfNetworkIdSubscriberConfigRuleNamesRuleIdPost', 'ruleId', ruleId)
            const localVarPath = `/cwf/{network_id}/subscriber_config/rule_names/{rule_id}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"rule_id"}}`, encodeURIComponent(String(ruleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the directory record of a subscriber
         * @param {string} networkId Network ID
         * @param {string} subscriberId Subscriber ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cwfNetworkIdSubscribersSubscriberIdDirectoryRecordGet: async (networkId: string, subscriberId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('cwfNetworkIdSubscribersSubscriberIdDirectoryRecordGet', 'networkId', networkId)
            // verify required parameter 'subscriberId' is not null or undefined
            assertParamExists('cwfNetworkIdSubscribersSubscriberIdDirectoryRecordGet', 'subscriberId', subscriberId)
            const localVarPath = `/cwf/{network_id}/subscribers/{subscriber_id}/directory_record`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"subscriber_id"}}`, encodeURIComponent(String(subscriberId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new Carrier Wifi network
         * @param {CwfNetwork} cwfNetwork Configuration of the network to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cwfPost: async (cwfNetwork: CwfNetwork, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cwfNetwork' is not null or undefined
            assertParamExists('cwfPost', 'cwfNetwork', cwfNetwork)
            const localVarPath = `/cwf`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cwfNetwork, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CarrierWifiNetworksApi - functional programming interface
 * @export
 */
export const CarrierWifiNetworksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CarrierWifiNetworksApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List all Carrier Wifi network IDs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cwfGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cwfGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete Network Carrier Wifi Configs
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cwfNetworkIdCarrierWifiDelete(networkId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cwfNetworkIdCarrierWifiDelete(networkId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve Network Carrier Wifi Configs
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cwfNetworkIdCarrierWifiGet(networkId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NetworkCarrierWifiConfigs>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cwfNetworkIdCarrierWifiGet(networkId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Modify Network Carrier Wifi Configs
         * @param {string} networkId Network ID
         * @param {NetworkCarrierWifiConfigs} config Updated config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cwfNetworkIdCarrierWifiPut(networkId: string, config: NetworkCarrierWifiConfigs, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cwfNetworkIdCarrierWifiPut(networkId, config, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a Carrier Wifi network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cwfNetworkIdDelete(networkId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cwfNetworkIdDelete(networkId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get description of a Carrier Wifi network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cwfNetworkIdDescriptionGet(networkId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cwfNetworkIdDescriptionGet(networkId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update the description of a Carrier Wifi network
         * @param {string} networkId Network ID
         * @param {string} description New name for the network
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cwfNetworkIdDescriptionPut(networkId: string, description: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cwfNetworkIdDescriptionPut(networkId, description, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Describe a Carrier Wifi network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cwfNetworkIdGet(networkId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CwfNetwork>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cwfNetworkIdGet(networkId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all high availability gateway pairs in Carrier Wifi network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cwfNetworkIdHaPairsGet(networkId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: CwfHaPair; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cwfNetworkIdHaPairsGet(networkId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete high availability gateway pair for Carrier Wifi network
         * @param {string} networkId Network ID
         * @param {string} haPairId HA Gateway Pair ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cwfNetworkIdHaPairsHaPairIdDelete(networkId: string, haPairId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cwfNetworkIdHaPairsHaPairIdDelete(networkId, haPairId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve high availability gateway pair for Carrier Wifi network
         * @param {string} networkId Network ID
         * @param {string} haPairId HA Gateway Pair ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cwfNetworkIdHaPairsHaPairIdGet(networkId: string, haPairId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CwfHaPair>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cwfNetworkIdHaPairsHaPairIdGet(networkId, haPairId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Modify high availability gateway pair for Carrier Wifi network
         * @param {string} networkId Network ID
         * @param {string} haPairId HA Gateway Pair ID
         * @param {MutableCwfHaPair} haPair Carrier Wifi HA gateway pair
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cwfNetworkIdHaPairsHaPairIdPut(networkId: string, haPairId: string, haPair: MutableCwfHaPair, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cwfNetworkIdHaPairsHaPairIdPut(networkId, haPairId, haPair, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve status of a Carrier Wifi HA pair
         * @param {string} networkId Network ID
         * @param {string} haPairId HA Gateway Pair ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cwfNetworkIdHaPairsHaPairIdStatusGet(networkId: string, haPairId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CarrierWifiHaPairStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cwfNetworkIdHaPairsHaPairIdStatusGet(networkId, haPairId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create new high availability gateway pair in Carrier Wifi network
         * @param {string} networkId Network ID
         * @param {MutableCwfHaPair} hAPair Carrier Wifi HA gateway pair
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cwfNetworkIdHaPairsPost(networkId: string, hAPair: MutableCwfHaPair, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cwfNetworkIdHaPairsPost(networkId, hAPair, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get monitored LI UEs for Carrier Wifi network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cwfNetworkIdLiUesGet(networkId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LiUes>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cwfNetworkIdLiUesGet(networkId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update monitored LI UEs for Carrier Wifi network
         * @param {string} networkId Network ID
         * @param {LiUes} description 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cwfNetworkIdLiUesPut(networkId: string, description: LiUes, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cwfNetworkIdLiUesPut(networkId, description, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get name of a Carrier Wifi network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cwfNetworkIdNameGet(networkId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cwfNetworkIdNameGet(networkId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update the name of a Carrier Wifi network
         * @param {string} networkId Network ID
         * @param {string} name New name for the network
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cwfNetworkIdNamePut(networkId: string, name: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cwfNetworkIdNamePut(networkId, name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update an entire Carrier Wifi network
         * @param {string} networkId Network ID
         * @param {CwfNetwork} cwfNetwork Full desired configuration of the network
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cwfNetworkIdPut(networkId: string, cwfNetwork: CwfNetwork, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cwfNetworkIdPut(networkId, cwfNetwork, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add a network-wide base name
         * @param {string} networkId Network ID
         * @param {string} baseName Charging Rule Base Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cwfNetworkIdSubscriberConfigBaseNamesBaseNameDelete(networkId: string, baseName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cwfNetworkIdSubscriberConfigBaseNamesBaseNameDelete(networkId, baseName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add a network-wide base name
         * @param {string} networkId Network ID
         * @param {string} baseName Charging Rule Base Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cwfNetworkIdSubscriberConfigBaseNamesBaseNamePost(networkId: string, baseName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cwfNetworkIdSubscriberConfigBaseNamesBaseNamePost(networkId, baseName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get network-wide base names
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cwfNetworkIdSubscriberConfigBaseNamesGet(networkId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cwfNetworkIdSubscriberConfigBaseNamesGet(networkId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update network-wide base names
         * @param {string} networkId Network ID
         * @param {Array<string>} record Subscriber Config for the Network
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cwfNetworkIdSubscriberConfigBaseNamesPut(networkId: string, record: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cwfNetworkIdSubscriberConfigBaseNamesPut(networkId, record, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a network-wide subscriber config
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cwfNetworkIdSubscriberConfigGet(networkId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NetworkSubscriberConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cwfNetworkIdSubscriberConfigGet(networkId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a network-wide subscriber config
         * @param {string} networkId Network ID
         * @param {NetworkSubscriberConfig} record Subscriber Config for the Network
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cwfNetworkIdSubscriberConfigPut(networkId: string, record: NetworkSubscriberConfig, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cwfNetworkIdSubscriberConfigPut(networkId, record, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get network-wide rule names
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cwfNetworkIdSubscriberConfigRuleNamesGet(networkId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cwfNetworkIdSubscriberConfigRuleNamesGet(networkId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update network-wide rule names
         * @param {string} networkId Network ID
         * @param {Array<string>} record Subscriber Config for the Network
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cwfNetworkIdSubscriberConfigRuleNamesPut(networkId: string, record: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cwfNetworkIdSubscriberConfigRuleNamesPut(networkId, record, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add a network-wide rule name
         * @param {string} networkId Network ID
         * @param {string} ruleId Rule Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cwfNetworkIdSubscriberConfigRuleNamesRuleIdDelete(networkId: string, ruleId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cwfNetworkIdSubscriberConfigRuleNamesRuleIdDelete(networkId, ruleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add a network-wide rule name
         * @param {string} networkId Network ID
         * @param {string} ruleId Rule Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cwfNetworkIdSubscriberConfigRuleNamesRuleIdPost(networkId: string, ruleId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cwfNetworkIdSubscriberConfigRuleNamesRuleIdPost(networkId, ruleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the directory record of a subscriber
         * @param {string} networkId Network ID
         * @param {string} subscriberId Subscriber ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cwfNetworkIdSubscribersSubscriberIdDirectoryRecordGet(networkId: string, subscriberId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CwfSubscriberDirectoryRecord>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cwfNetworkIdSubscribersSubscriberIdDirectoryRecordGet(networkId, subscriberId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a new Carrier Wifi network
         * @param {CwfNetwork} cwfNetwork Configuration of the network to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cwfPost(cwfNetwork: CwfNetwork, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cwfPost(cwfNetwork, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CarrierWifiNetworksApi - factory interface
 * @export
 */
export const CarrierWifiNetworksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CarrierWifiNetworksApiFp(configuration)
    return {
        /**
         * 
         * @summary List all Carrier Wifi network IDs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cwfGet(options?: any): AxiosPromise<Array<string>> {
            return localVarFp.cwfGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Network Carrier Wifi Configs
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cwfNetworkIdCarrierWifiDelete(networkId: string, options?: any): AxiosPromise<void> {
            return localVarFp.cwfNetworkIdCarrierWifiDelete(networkId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve Network Carrier Wifi Configs
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cwfNetworkIdCarrierWifiGet(networkId: string, options?: any): AxiosPromise<NetworkCarrierWifiConfigs> {
            return localVarFp.cwfNetworkIdCarrierWifiGet(networkId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Modify Network Carrier Wifi Configs
         * @param {string} networkId Network ID
         * @param {NetworkCarrierWifiConfigs} config Updated config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cwfNetworkIdCarrierWifiPut(networkId: string, config: NetworkCarrierWifiConfigs, options?: any): AxiosPromise<void> {
            return localVarFp.cwfNetworkIdCarrierWifiPut(networkId, config, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a Carrier Wifi network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cwfNetworkIdDelete(networkId: string, options?: any): AxiosPromise<void> {
            return localVarFp.cwfNetworkIdDelete(networkId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get description of a Carrier Wifi network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cwfNetworkIdDescriptionGet(networkId: string, options?: any): AxiosPromise<string> {
            return localVarFp.cwfNetworkIdDescriptionGet(networkId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the description of a Carrier Wifi network
         * @param {string} networkId Network ID
         * @param {string} description New name for the network
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cwfNetworkIdDescriptionPut(networkId: string, description: string, options?: any): AxiosPromise<void> {
            return localVarFp.cwfNetworkIdDescriptionPut(networkId, description, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Describe a Carrier Wifi network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cwfNetworkIdGet(networkId: string, options?: any): AxiosPromise<CwfNetwork> {
            return localVarFp.cwfNetworkIdGet(networkId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all high availability gateway pairs in Carrier Wifi network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cwfNetworkIdHaPairsGet(networkId: string, options?: any): AxiosPromise<{ [key: string]: CwfHaPair; }> {
            return localVarFp.cwfNetworkIdHaPairsGet(networkId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete high availability gateway pair for Carrier Wifi network
         * @param {string} networkId Network ID
         * @param {string} haPairId HA Gateway Pair ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cwfNetworkIdHaPairsHaPairIdDelete(networkId: string, haPairId: string, options?: any): AxiosPromise<void> {
            return localVarFp.cwfNetworkIdHaPairsHaPairIdDelete(networkId, haPairId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve high availability gateway pair for Carrier Wifi network
         * @param {string} networkId Network ID
         * @param {string} haPairId HA Gateway Pair ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cwfNetworkIdHaPairsHaPairIdGet(networkId: string, haPairId: string, options?: any): AxiosPromise<CwfHaPair> {
            return localVarFp.cwfNetworkIdHaPairsHaPairIdGet(networkId, haPairId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Modify high availability gateway pair for Carrier Wifi network
         * @param {string} networkId Network ID
         * @param {string} haPairId HA Gateway Pair ID
         * @param {MutableCwfHaPair} haPair Carrier Wifi HA gateway pair
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cwfNetworkIdHaPairsHaPairIdPut(networkId: string, haPairId: string, haPair: MutableCwfHaPair, options?: any): AxiosPromise<void> {
            return localVarFp.cwfNetworkIdHaPairsHaPairIdPut(networkId, haPairId, haPair, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve status of a Carrier Wifi HA pair
         * @param {string} networkId Network ID
         * @param {string} haPairId HA Gateway Pair ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cwfNetworkIdHaPairsHaPairIdStatusGet(networkId: string, haPairId: string, options?: any): AxiosPromise<CarrierWifiHaPairStatus> {
            return localVarFp.cwfNetworkIdHaPairsHaPairIdStatusGet(networkId, haPairId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create new high availability gateway pair in Carrier Wifi network
         * @param {string} networkId Network ID
         * @param {MutableCwfHaPair} hAPair Carrier Wifi HA gateway pair
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cwfNetworkIdHaPairsPost(networkId: string, hAPair: MutableCwfHaPair, options?: any): AxiosPromise<void> {
            return localVarFp.cwfNetworkIdHaPairsPost(networkId, hAPair, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get monitored LI UEs for Carrier Wifi network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cwfNetworkIdLiUesGet(networkId: string, options?: any): AxiosPromise<LiUes> {
            return localVarFp.cwfNetworkIdLiUesGet(networkId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update monitored LI UEs for Carrier Wifi network
         * @param {string} networkId Network ID
         * @param {LiUes} description 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cwfNetworkIdLiUesPut(networkId: string, description: LiUes, options?: any): AxiosPromise<void> {
            return localVarFp.cwfNetworkIdLiUesPut(networkId, description, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get name of a Carrier Wifi network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cwfNetworkIdNameGet(networkId: string, options?: any): AxiosPromise<string> {
            return localVarFp.cwfNetworkIdNameGet(networkId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the name of a Carrier Wifi network
         * @param {string} networkId Network ID
         * @param {string} name New name for the network
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cwfNetworkIdNamePut(networkId: string, name: string, options?: any): AxiosPromise<void> {
            return localVarFp.cwfNetworkIdNamePut(networkId, name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an entire Carrier Wifi network
         * @param {string} networkId Network ID
         * @param {CwfNetwork} cwfNetwork Full desired configuration of the network
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cwfNetworkIdPut(networkId: string, cwfNetwork: CwfNetwork, options?: any): AxiosPromise<void> {
            return localVarFp.cwfNetworkIdPut(networkId, cwfNetwork, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add a network-wide base name
         * @param {string} networkId Network ID
         * @param {string} baseName Charging Rule Base Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cwfNetworkIdSubscriberConfigBaseNamesBaseNameDelete(networkId: string, baseName: string, options?: any): AxiosPromise<void> {
            return localVarFp.cwfNetworkIdSubscriberConfigBaseNamesBaseNameDelete(networkId, baseName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add a network-wide base name
         * @param {string} networkId Network ID
         * @param {string} baseName Charging Rule Base Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cwfNetworkIdSubscriberConfigBaseNamesBaseNamePost(networkId: string, baseName: string, options?: any): AxiosPromise<void> {
            return localVarFp.cwfNetworkIdSubscriberConfigBaseNamesBaseNamePost(networkId, baseName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get network-wide base names
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cwfNetworkIdSubscriberConfigBaseNamesGet(networkId: string, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.cwfNetworkIdSubscriberConfigBaseNamesGet(networkId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update network-wide base names
         * @param {string} networkId Network ID
         * @param {Array<string>} record Subscriber Config for the Network
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cwfNetworkIdSubscriberConfigBaseNamesPut(networkId: string, record: Array<string>, options?: any): AxiosPromise<void> {
            return localVarFp.cwfNetworkIdSubscriberConfigBaseNamesPut(networkId, record, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a network-wide subscriber config
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cwfNetworkIdSubscriberConfigGet(networkId: string, options?: any): AxiosPromise<NetworkSubscriberConfig> {
            return localVarFp.cwfNetworkIdSubscriberConfigGet(networkId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a network-wide subscriber config
         * @param {string} networkId Network ID
         * @param {NetworkSubscriberConfig} record Subscriber Config for the Network
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cwfNetworkIdSubscriberConfigPut(networkId: string, record: NetworkSubscriberConfig, options?: any): AxiosPromise<void> {
            return localVarFp.cwfNetworkIdSubscriberConfigPut(networkId, record, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get network-wide rule names
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cwfNetworkIdSubscriberConfigRuleNamesGet(networkId: string, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.cwfNetworkIdSubscriberConfigRuleNamesGet(networkId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update network-wide rule names
         * @param {string} networkId Network ID
         * @param {Array<string>} record Subscriber Config for the Network
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cwfNetworkIdSubscriberConfigRuleNamesPut(networkId: string, record: Array<string>, options?: any): AxiosPromise<void> {
            return localVarFp.cwfNetworkIdSubscriberConfigRuleNamesPut(networkId, record, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add a network-wide rule name
         * @param {string} networkId Network ID
         * @param {string} ruleId Rule Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cwfNetworkIdSubscriberConfigRuleNamesRuleIdDelete(networkId: string, ruleId: string, options?: any): AxiosPromise<void> {
            return localVarFp.cwfNetworkIdSubscriberConfigRuleNamesRuleIdDelete(networkId, ruleId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add a network-wide rule name
         * @param {string} networkId Network ID
         * @param {string} ruleId Rule Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cwfNetworkIdSubscriberConfigRuleNamesRuleIdPost(networkId: string, ruleId: string, options?: any): AxiosPromise<void> {
            return localVarFp.cwfNetworkIdSubscriberConfigRuleNamesRuleIdPost(networkId, ruleId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the directory record of a subscriber
         * @param {string} networkId Network ID
         * @param {string} subscriberId Subscriber ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cwfNetworkIdSubscribersSubscriberIdDirectoryRecordGet(networkId: string, subscriberId: string, options?: any): AxiosPromise<CwfSubscriberDirectoryRecord> {
            return localVarFp.cwfNetworkIdSubscribersSubscriberIdDirectoryRecordGet(networkId, subscriberId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new Carrier Wifi network
         * @param {CwfNetwork} cwfNetwork Configuration of the network to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cwfPost(cwfNetwork: CwfNetwork, options?: any): AxiosPromise<void> {
            return localVarFp.cwfPost(cwfNetwork, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for cwfNetworkIdCarrierWifiDelete operation in CarrierWifiNetworksApi.
 * @export
 * @interface CarrierWifiNetworksApiCwfNetworkIdCarrierWifiDeleteRequest
 */
export interface CarrierWifiNetworksApiCwfNetworkIdCarrierWifiDeleteRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof CarrierWifiNetworksApiCwfNetworkIdCarrierWifiDelete
     */
    readonly networkId: string
}

/**
 * Request parameters for cwfNetworkIdCarrierWifiGet operation in CarrierWifiNetworksApi.
 * @export
 * @interface CarrierWifiNetworksApiCwfNetworkIdCarrierWifiGetRequest
 */
export interface CarrierWifiNetworksApiCwfNetworkIdCarrierWifiGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof CarrierWifiNetworksApiCwfNetworkIdCarrierWifiGet
     */
    readonly networkId: string
}

/**
 * Request parameters for cwfNetworkIdCarrierWifiPut operation in CarrierWifiNetworksApi.
 * @export
 * @interface CarrierWifiNetworksApiCwfNetworkIdCarrierWifiPutRequest
 */
export interface CarrierWifiNetworksApiCwfNetworkIdCarrierWifiPutRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof CarrierWifiNetworksApiCwfNetworkIdCarrierWifiPut
     */
    readonly networkId: string

    /**
     * Updated config
     * @type {NetworkCarrierWifiConfigs}
     * @memberof CarrierWifiNetworksApiCwfNetworkIdCarrierWifiPut
     */
    readonly config: NetworkCarrierWifiConfigs
}

/**
 * Request parameters for cwfNetworkIdDelete operation in CarrierWifiNetworksApi.
 * @export
 * @interface CarrierWifiNetworksApiCwfNetworkIdDeleteRequest
 */
export interface CarrierWifiNetworksApiCwfNetworkIdDeleteRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof CarrierWifiNetworksApiCwfNetworkIdDelete
     */
    readonly networkId: string
}

/**
 * Request parameters for cwfNetworkIdDescriptionGet operation in CarrierWifiNetworksApi.
 * @export
 * @interface CarrierWifiNetworksApiCwfNetworkIdDescriptionGetRequest
 */
export interface CarrierWifiNetworksApiCwfNetworkIdDescriptionGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof CarrierWifiNetworksApiCwfNetworkIdDescriptionGet
     */
    readonly networkId: string
}

/**
 * Request parameters for cwfNetworkIdDescriptionPut operation in CarrierWifiNetworksApi.
 * @export
 * @interface CarrierWifiNetworksApiCwfNetworkIdDescriptionPutRequest
 */
export interface CarrierWifiNetworksApiCwfNetworkIdDescriptionPutRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof CarrierWifiNetworksApiCwfNetworkIdDescriptionPut
     */
    readonly networkId: string

    /**
     * New name for the network
     * @type {string}
     * @memberof CarrierWifiNetworksApiCwfNetworkIdDescriptionPut
     */
    readonly description: string
}

/**
 * Request parameters for cwfNetworkIdGet operation in CarrierWifiNetworksApi.
 * @export
 * @interface CarrierWifiNetworksApiCwfNetworkIdGetRequest
 */
export interface CarrierWifiNetworksApiCwfNetworkIdGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof CarrierWifiNetworksApiCwfNetworkIdGet
     */
    readonly networkId: string
}

/**
 * Request parameters for cwfNetworkIdHaPairsGet operation in CarrierWifiNetworksApi.
 * @export
 * @interface CarrierWifiNetworksApiCwfNetworkIdHaPairsGetRequest
 */
export interface CarrierWifiNetworksApiCwfNetworkIdHaPairsGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof CarrierWifiNetworksApiCwfNetworkIdHaPairsGet
     */
    readonly networkId: string
}

/**
 * Request parameters for cwfNetworkIdHaPairsHaPairIdDelete operation in CarrierWifiNetworksApi.
 * @export
 * @interface CarrierWifiNetworksApiCwfNetworkIdHaPairsHaPairIdDeleteRequest
 */
export interface CarrierWifiNetworksApiCwfNetworkIdHaPairsHaPairIdDeleteRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof CarrierWifiNetworksApiCwfNetworkIdHaPairsHaPairIdDelete
     */
    readonly networkId: string

    /**
     * HA Gateway Pair ID
     * @type {string}
     * @memberof CarrierWifiNetworksApiCwfNetworkIdHaPairsHaPairIdDelete
     */
    readonly haPairId: string
}

/**
 * Request parameters for cwfNetworkIdHaPairsHaPairIdGet operation in CarrierWifiNetworksApi.
 * @export
 * @interface CarrierWifiNetworksApiCwfNetworkIdHaPairsHaPairIdGetRequest
 */
export interface CarrierWifiNetworksApiCwfNetworkIdHaPairsHaPairIdGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof CarrierWifiNetworksApiCwfNetworkIdHaPairsHaPairIdGet
     */
    readonly networkId: string

    /**
     * HA Gateway Pair ID
     * @type {string}
     * @memberof CarrierWifiNetworksApiCwfNetworkIdHaPairsHaPairIdGet
     */
    readonly haPairId: string
}

/**
 * Request parameters for cwfNetworkIdHaPairsHaPairIdPut operation in CarrierWifiNetworksApi.
 * @export
 * @interface CarrierWifiNetworksApiCwfNetworkIdHaPairsHaPairIdPutRequest
 */
export interface CarrierWifiNetworksApiCwfNetworkIdHaPairsHaPairIdPutRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof CarrierWifiNetworksApiCwfNetworkIdHaPairsHaPairIdPut
     */
    readonly networkId: string

    /**
     * HA Gateway Pair ID
     * @type {string}
     * @memberof CarrierWifiNetworksApiCwfNetworkIdHaPairsHaPairIdPut
     */
    readonly haPairId: string

    /**
     * Carrier Wifi HA gateway pair
     * @type {MutableCwfHaPair}
     * @memberof CarrierWifiNetworksApiCwfNetworkIdHaPairsHaPairIdPut
     */
    readonly haPair: MutableCwfHaPair
}

/**
 * Request parameters for cwfNetworkIdHaPairsHaPairIdStatusGet operation in CarrierWifiNetworksApi.
 * @export
 * @interface CarrierWifiNetworksApiCwfNetworkIdHaPairsHaPairIdStatusGetRequest
 */
export interface CarrierWifiNetworksApiCwfNetworkIdHaPairsHaPairIdStatusGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof CarrierWifiNetworksApiCwfNetworkIdHaPairsHaPairIdStatusGet
     */
    readonly networkId: string

    /**
     * HA Gateway Pair ID
     * @type {string}
     * @memberof CarrierWifiNetworksApiCwfNetworkIdHaPairsHaPairIdStatusGet
     */
    readonly haPairId: string
}

/**
 * Request parameters for cwfNetworkIdHaPairsPost operation in CarrierWifiNetworksApi.
 * @export
 * @interface CarrierWifiNetworksApiCwfNetworkIdHaPairsPostRequest
 */
export interface CarrierWifiNetworksApiCwfNetworkIdHaPairsPostRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof CarrierWifiNetworksApiCwfNetworkIdHaPairsPost
     */
    readonly networkId: string

    /**
     * Carrier Wifi HA gateway pair
     * @type {MutableCwfHaPair}
     * @memberof CarrierWifiNetworksApiCwfNetworkIdHaPairsPost
     */
    readonly hAPair: MutableCwfHaPair
}

/**
 * Request parameters for cwfNetworkIdLiUesGet operation in CarrierWifiNetworksApi.
 * @export
 * @interface CarrierWifiNetworksApiCwfNetworkIdLiUesGetRequest
 */
export interface CarrierWifiNetworksApiCwfNetworkIdLiUesGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof CarrierWifiNetworksApiCwfNetworkIdLiUesGet
     */
    readonly networkId: string
}

/**
 * Request parameters for cwfNetworkIdLiUesPut operation in CarrierWifiNetworksApi.
 * @export
 * @interface CarrierWifiNetworksApiCwfNetworkIdLiUesPutRequest
 */
export interface CarrierWifiNetworksApiCwfNetworkIdLiUesPutRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof CarrierWifiNetworksApiCwfNetworkIdLiUesPut
     */
    readonly networkId: string

    /**
     * 
     * @type {LiUes}
     * @memberof CarrierWifiNetworksApiCwfNetworkIdLiUesPut
     */
    readonly description: LiUes
}

/**
 * Request parameters for cwfNetworkIdNameGet operation in CarrierWifiNetworksApi.
 * @export
 * @interface CarrierWifiNetworksApiCwfNetworkIdNameGetRequest
 */
export interface CarrierWifiNetworksApiCwfNetworkIdNameGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof CarrierWifiNetworksApiCwfNetworkIdNameGet
     */
    readonly networkId: string
}

/**
 * Request parameters for cwfNetworkIdNamePut operation in CarrierWifiNetworksApi.
 * @export
 * @interface CarrierWifiNetworksApiCwfNetworkIdNamePutRequest
 */
export interface CarrierWifiNetworksApiCwfNetworkIdNamePutRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof CarrierWifiNetworksApiCwfNetworkIdNamePut
     */
    readonly networkId: string

    /**
     * New name for the network
     * @type {string}
     * @memberof CarrierWifiNetworksApiCwfNetworkIdNamePut
     */
    readonly name: string
}

/**
 * Request parameters for cwfNetworkIdPut operation in CarrierWifiNetworksApi.
 * @export
 * @interface CarrierWifiNetworksApiCwfNetworkIdPutRequest
 */
export interface CarrierWifiNetworksApiCwfNetworkIdPutRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof CarrierWifiNetworksApiCwfNetworkIdPut
     */
    readonly networkId: string

    /**
     * Full desired configuration of the network
     * @type {CwfNetwork}
     * @memberof CarrierWifiNetworksApiCwfNetworkIdPut
     */
    readonly cwfNetwork: CwfNetwork
}

/**
 * Request parameters for cwfNetworkIdSubscriberConfigBaseNamesBaseNameDelete operation in CarrierWifiNetworksApi.
 * @export
 * @interface CarrierWifiNetworksApiCwfNetworkIdSubscriberConfigBaseNamesBaseNameDeleteRequest
 */
export interface CarrierWifiNetworksApiCwfNetworkIdSubscriberConfigBaseNamesBaseNameDeleteRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof CarrierWifiNetworksApiCwfNetworkIdSubscriberConfigBaseNamesBaseNameDelete
     */
    readonly networkId: string

    /**
     * Charging Rule Base Name
     * @type {string}
     * @memberof CarrierWifiNetworksApiCwfNetworkIdSubscriberConfigBaseNamesBaseNameDelete
     */
    readonly baseName: string
}

/**
 * Request parameters for cwfNetworkIdSubscriberConfigBaseNamesBaseNamePost operation in CarrierWifiNetworksApi.
 * @export
 * @interface CarrierWifiNetworksApiCwfNetworkIdSubscriberConfigBaseNamesBaseNamePostRequest
 */
export interface CarrierWifiNetworksApiCwfNetworkIdSubscriberConfigBaseNamesBaseNamePostRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof CarrierWifiNetworksApiCwfNetworkIdSubscriberConfigBaseNamesBaseNamePost
     */
    readonly networkId: string

    /**
     * Charging Rule Base Name
     * @type {string}
     * @memberof CarrierWifiNetworksApiCwfNetworkIdSubscriberConfigBaseNamesBaseNamePost
     */
    readonly baseName: string
}

/**
 * Request parameters for cwfNetworkIdSubscriberConfigBaseNamesGet operation in CarrierWifiNetworksApi.
 * @export
 * @interface CarrierWifiNetworksApiCwfNetworkIdSubscriberConfigBaseNamesGetRequest
 */
export interface CarrierWifiNetworksApiCwfNetworkIdSubscriberConfigBaseNamesGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof CarrierWifiNetworksApiCwfNetworkIdSubscriberConfigBaseNamesGet
     */
    readonly networkId: string
}

/**
 * Request parameters for cwfNetworkIdSubscriberConfigBaseNamesPut operation in CarrierWifiNetworksApi.
 * @export
 * @interface CarrierWifiNetworksApiCwfNetworkIdSubscriberConfigBaseNamesPutRequest
 */
export interface CarrierWifiNetworksApiCwfNetworkIdSubscriberConfigBaseNamesPutRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof CarrierWifiNetworksApiCwfNetworkIdSubscriberConfigBaseNamesPut
     */
    readonly networkId: string

    /**
     * Subscriber Config for the Network
     * @type {Array<string>}
     * @memberof CarrierWifiNetworksApiCwfNetworkIdSubscriberConfigBaseNamesPut
     */
    readonly record: Array<string>
}

/**
 * Request parameters for cwfNetworkIdSubscriberConfigGet operation in CarrierWifiNetworksApi.
 * @export
 * @interface CarrierWifiNetworksApiCwfNetworkIdSubscriberConfigGetRequest
 */
export interface CarrierWifiNetworksApiCwfNetworkIdSubscriberConfigGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof CarrierWifiNetworksApiCwfNetworkIdSubscriberConfigGet
     */
    readonly networkId: string
}

/**
 * Request parameters for cwfNetworkIdSubscriberConfigPut operation in CarrierWifiNetworksApi.
 * @export
 * @interface CarrierWifiNetworksApiCwfNetworkIdSubscriberConfigPutRequest
 */
export interface CarrierWifiNetworksApiCwfNetworkIdSubscriberConfigPutRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof CarrierWifiNetworksApiCwfNetworkIdSubscriberConfigPut
     */
    readonly networkId: string

    /**
     * Subscriber Config for the Network
     * @type {NetworkSubscriberConfig}
     * @memberof CarrierWifiNetworksApiCwfNetworkIdSubscriberConfigPut
     */
    readonly record: NetworkSubscriberConfig
}

/**
 * Request parameters for cwfNetworkIdSubscriberConfigRuleNamesGet operation in CarrierWifiNetworksApi.
 * @export
 * @interface CarrierWifiNetworksApiCwfNetworkIdSubscriberConfigRuleNamesGetRequest
 */
export interface CarrierWifiNetworksApiCwfNetworkIdSubscriberConfigRuleNamesGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof CarrierWifiNetworksApiCwfNetworkIdSubscriberConfigRuleNamesGet
     */
    readonly networkId: string
}

/**
 * Request parameters for cwfNetworkIdSubscriberConfigRuleNamesPut operation in CarrierWifiNetworksApi.
 * @export
 * @interface CarrierWifiNetworksApiCwfNetworkIdSubscriberConfigRuleNamesPutRequest
 */
export interface CarrierWifiNetworksApiCwfNetworkIdSubscriberConfigRuleNamesPutRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof CarrierWifiNetworksApiCwfNetworkIdSubscriberConfigRuleNamesPut
     */
    readonly networkId: string

    /**
     * Subscriber Config for the Network
     * @type {Array<string>}
     * @memberof CarrierWifiNetworksApiCwfNetworkIdSubscriberConfigRuleNamesPut
     */
    readonly record: Array<string>
}

/**
 * Request parameters for cwfNetworkIdSubscriberConfigRuleNamesRuleIdDelete operation in CarrierWifiNetworksApi.
 * @export
 * @interface CarrierWifiNetworksApiCwfNetworkIdSubscriberConfigRuleNamesRuleIdDeleteRequest
 */
export interface CarrierWifiNetworksApiCwfNetworkIdSubscriberConfigRuleNamesRuleIdDeleteRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof CarrierWifiNetworksApiCwfNetworkIdSubscriberConfigRuleNamesRuleIdDelete
     */
    readonly networkId: string

    /**
     * Rule Id
     * @type {string}
     * @memberof CarrierWifiNetworksApiCwfNetworkIdSubscriberConfigRuleNamesRuleIdDelete
     */
    readonly ruleId: string
}

/**
 * Request parameters for cwfNetworkIdSubscriberConfigRuleNamesRuleIdPost operation in CarrierWifiNetworksApi.
 * @export
 * @interface CarrierWifiNetworksApiCwfNetworkIdSubscriberConfigRuleNamesRuleIdPostRequest
 */
export interface CarrierWifiNetworksApiCwfNetworkIdSubscriberConfigRuleNamesRuleIdPostRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof CarrierWifiNetworksApiCwfNetworkIdSubscriberConfigRuleNamesRuleIdPost
     */
    readonly networkId: string

    /**
     * Rule Id
     * @type {string}
     * @memberof CarrierWifiNetworksApiCwfNetworkIdSubscriberConfigRuleNamesRuleIdPost
     */
    readonly ruleId: string
}

/**
 * Request parameters for cwfNetworkIdSubscribersSubscriberIdDirectoryRecordGet operation in CarrierWifiNetworksApi.
 * @export
 * @interface CarrierWifiNetworksApiCwfNetworkIdSubscribersSubscriberIdDirectoryRecordGetRequest
 */
export interface CarrierWifiNetworksApiCwfNetworkIdSubscribersSubscriberIdDirectoryRecordGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof CarrierWifiNetworksApiCwfNetworkIdSubscribersSubscriberIdDirectoryRecordGet
     */
    readonly networkId: string

    /**
     * Subscriber ID
     * @type {string}
     * @memberof CarrierWifiNetworksApiCwfNetworkIdSubscribersSubscriberIdDirectoryRecordGet
     */
    readonly subscriberId: string
}

/**
 * Request parameters for cwfPost operation in CarrierWifiNetworksApi.
 * @export
 * @interface CarrierWifiNetworksApiCwfPostRequest
 */
export interface CarrierWifiNetworksApiCwfPostRequest {
    /**
     * Configuration of the network to create
     * @type {CwfNetwork}
     * @memberof CarrierWifiNetworksApiCwfPost
     */
    readonly cwfNetwork: CwfNetwork
}

/**
 * CarrierWifiNetworksApi - object-oriented interface
 * @export
 * @class CarrierWifiNetworksApi
 * @extends {BaseAPI}
 */
export class CarrierWifiNetworksApi extends BaseAPI {
    /**
     * 
     * @summary List all Carrier Wifi network IDs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CarrierWifiNetworksApi
     */
    public cwfGet(options?: AxiosRequestConfig) {
        return CarrierWifiNetworksApiFp(this.configuration).cwfGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Network Carrier Wifi Configs
     * @param {CarrierWifiNetworksApiCwfNetworkIdCarrierWifiDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CarrierWifiNetworksApi
     */
    public cwfNetworkIdCarrierWifiDelete(requestParameters: CarrierWifiNetworksApiCwfNetworkIdCarrierWifiDeleteRequest, options?: AxiosRequestConfig) {
        return CarrierWifiNetworksApiFp(this.configuration).cwfNetworkIdCarrierWifiDelete(requestParameters.networkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve Network Carrier Wifi Configs
     * @param {CarrierWifiNetworksApiCwfNetworkIdCarrierWifiGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CarrierWifiNetworksApi
     */
    public cwfNetworkIdCarrierWifiGet(requestParameters: CarrierWifiNetworksApiCwfNetworkIdCarrierWifiGetRequest, options?: AxiosRequestConfig) {
        return CarrierWifiNetworksApiFp(this.configuration).cwfNetworkIdCarrierWifiGet(requestParameters.networkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Modify Network Carrier Wifi Configs
     * @param {CarrierWifiNetworksApiCwfNetworkIdCarrierWifiPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CarrierWifiNetworksApi
     */
    public cwfNetworkIdCarrierWifiPut(requestParameters: CarrierWifiNetworksApiCwfNetworkIdCarrierWifiPutRequest, options?: AxiosRequestConfig) {
        return CarrierWifiNetworksApiFp(this.configuration).cwfNetworkIdCarrierWifiPut(requestParameters.networkId, requestParameters.config, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a Carrier Wifi network
     * @param {CarrierWifiNetworksApiCwfNetworkIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CarrierWifiNetworksApi
     */
    public cwfNetworkIdDelete(requestParameters: CarrierWifiNetworksApiCwfNetworkIdDeleteRequest, options?: AxiosRequestConfig) {
        return CarrierWifiNetworksApiFp(this.configuration).cwfNetworkIdDelete(requestParameters.networkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get description of a Carrier Wifi network
     * @param {CarrierWifiNetworksApiCwfNetworkIdDescriptionGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CarrierWifiNetworksApi
     */
    public cwfNetworkIdDescriptionGet(requestParameters: CarrierWifiNetworksApiCwfNetworkIdDescriptionGetRequest, options?: AxiosRequestConfig) {
        return CarrierWifiNetworksApiFp(this.configuration).cwfNetworkIdDescriptionGet(requestParameters.networkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the description of a Carrier Wifi network
     * @param {CarrierWifiNetworksApiCwfNetworkIdDescriptionPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CarrierWifiNetworksApi
     */
    public cwfNetworkIdDescriptionPut(requestParameters: CarrierWifiNetworksApiCwfNetworkIdDescriptionPutRequest, options?: AxiosRequestConfig) {
        return CarrierWifiNetworksApiFp(this.configuration).cwfNetworkIdDescriptionPut(requestParameters.networkId, requestParameters.description, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Describe a Carrier Wifi network
     * @param {CarrierWifiNetworksApiCwfNetworkIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CarrierWifiNetworksApi
     */
    public cwfNetworkIdGet(requestParameters: CarrierWifiNetworksApiCwfNetworkIdGetRequest, options?: AxiosRequestConfig) {
        return CarrierWifiNetworksApiFp(this.configuration).cwfNetworkIdGet(requestParameters.networkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all high availability gateway pairs in Carrier Wifi network
     * @param {CarrierWifiNetworksApiCwfNetworkIdHaPairsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CarrierWifiNetworksApi
     */
    public cwfNetworkIdHaPairsGet(requestParameters: CarrierWifiNetworksApiCwfNetworkIdHaPairsGetRequest, options?: AxiosRequestConfig) {
        return CarrierWifiNetworksApiFp(this.configuration).cwfNetworkIdHaPairsGet(requestParameters.networkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete high availability gateway pair for Carrier Wifi network
     * @param {CarrierWifiNetworksApiCwfNetworkIdHaPairsHaPairIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CarrierWifiNetworksApi
     */
    public cwfNetworkIdHaPairsHaPairIdDelete(requestParameters: CarrierWifiNetworksApiCwfNetworkIdHaPairsHaPairIdDeleteRequest, options?: AxiosRequestConfig) {
        return CarrierWifiNetworksApiFp(this.configuration).cwfNetworkIdHaPairsHaPairIdDelete(requestParameters.networkId, requestParameters.haPairId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve high availability gateway pair for Carrier Wifi network
     * @param {CarrierWifiNetworksApiCwfNetworkIdHaPairsHaPairIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CarrierWifiNetworksApi
     */
    public cwfNetworkIdHaPairsHaPairIdGet(requestParameters: CarrierWifiNetworksApiCwfNetworkIdHaPairsHaPairIdGetRequest, options?: AxiosRequestConfig) {
        return CarrierWifiNetworksApiFp(this.configuration).cwfNetworkIdHaPairsHaPairIdGet(requestParameters.networkId, requestParameters.haPairId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Modify high availability gateway pair for Carrier Wifi network
     * @param {CarrierWifiNetworksApiCwfNetworkIdHaPairsHaPairIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CarrierWifiNetworksApi
     */
    public cwfNetworkIdHaPairsHaPairIdPut(requestParameters: CarrierWifiNetworksApiCwfNetworkIdHaPairsHaPairIdPutRequest, options?: AxiosRequestConfig) {
        return CarrierWifiNetworksApiFp(this.configuration).cwfNetworkIdHaPairsHaPairIdPut(requestParameters.networkId, requestParameters.haPairId, requestParameters.haPair, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve status of a Carrier Wifi HA pair
     * @param {CarrierWifiNetworksApiCwfNetworkIdHaPairsHaPairIdStatusGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CarrierWifiNetworksApi
     */
    public cwfNetworkIdHaPairsHaPairIdStatusGet(requestParameters: CarrierWifiNetworksApiCwfNetworkIdHaPairsHaPairIdStatusGetRequest, options?: AxiosRequestConfig) {
        return CarrierWifiNetworksApiFp(this.configuration).cwfNetworkIdHaPairsHaPairIdStatusGet(requestParameters.networkId, requestParameters.haPairId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create new high availability gateway pair in Carrier Wifi network
     * @param {CarrierWifiNetworksApiCwfNetworkIdHaPairsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CarrierWifiNetworksApi
     */
    public cwfNetworkIdHaPairsPost(requestParameters: CarrierWifiNetworksApiCwfNetworkIdHaPairsPostRequest, options?: AxiosRequestConfig) {
        return CarrierWifiNetworksApiFp(this.configuration).cwfNetworkIdHaPairsPost(requestParameters.networkId, requestParameters.hAPair, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get monitored LI UEs for Carrier Wifi network
     * @param {CarrierWifiNetworksApiCwfNetworkIdLiUesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CarrierWifiNetworksApi
     */
    public cwfNetworkIdLiUesGet(requestParameters: CarrierWifiNetworksApiCwfNetworkIdLiUesGetRequest, options?: AxiosRequestConfig) {
        return CarrierWifiNetworksApiFp(this.configuration).cwfNetworkIdLiUesGet(requestParameters.networkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update monitored LI UEs for Carrier Wifi network
     * @param {CarrierWifiNetworksApiCwfNetworkIdLiUesPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CarrierWifiNetworksApi
     */
    public cwfNetworkIdLiUesPut(requestParameters: CarrierWifiNetworksApiCwfNetworkIdLiUesPutRequest, options?: AxiosRequestConfig) {
        return CarrierWifiNetworksApiFp(this.configuration).cwfNetworkIdLiUesPut(requestParameters.networkId, requestParameters.description, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get name of a Carrier Wifi network
     * @param {CarrierWifiNetworksApiCwfNetworkIdNameGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CarrierWifiNetworksApi
     */
    public cwfNetworkIdNameGet(requestParameters: CarrierWifiNetworksApiCwfNetworkIdNameGetRequest, options?: AxiosRequestConfig) {
        return CarrierWifiNetworksApiFp(this.configuration).cwfNetworkIdNameGet(requestParameters.networkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the name of a Carrier Wifi network
     * @param {CarrierWifiNetworksApiCwfNetworkIdNamePutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CarrierWifiNetworksApi
     */
    public cwfNetworkIdNamePut(requestParameters: CarrierWifiNetworksApiCwfNetworkIdNamePutRequest, options?: AxiosRequestConfig) {
        return CarrierWifiNetworksApiFp(this.configuration).cwfNetworkIdNamePut(requestParameters.networkId, requestParameters.name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an entire Carrier Wifi network
     * @param {CarrierWifiNetworksApiCwfNetworkIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CarrierWifiNetworksApi
     */
    public cwfNetworkIdPut(requestParameters: CarrierWifiNetworksApiCwfNetworkIdPutRequest, options?: AxiosRequestConfig) {
        return CarrierWifiNetworksApiFp(this.configuration).cwfNetworkIdPut(requestParameters.networkId, requestParameters.cwfNetwork, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add a network-wide base name
     * @param {CarrierWifiNetworksApiCwfNetworkIdSubscriberConfigBaseNamesBaseNameDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CarrierWifiNetworksApi
     */
    public cwfNetworkIdSubscriberConfigBaseNamesBaseNameDelete(requestParameters: CarrierWifiNetworksApiCwfNetworkIdSubscriberConfigBaseNamesBaseNameDeleteRequest, options?: AxiosRequestConfig) {
        return CarrierWifiNetworksApiFp(this.configuration).cwfNetworkIdSubscriberConfigBaseNamesBaseNameDelete(requestParameters.networkId, requestParameters.baseName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add a network-wide base name
     * @param {CarrierWifiNetworksApiCwfNetworkIdSubscriberConfigBaseNamesBaseNamePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CarrierWifiNetworksApi
     */
    public cwfNetworkIdSubscriberConfigBaseNamesBaseNamePost(requestParameters: CarrierWifiNetworksApiCwfNetworkIdSubscriberConfigBaseNamesBaseNamePostRequest, options?: AxiosRequestConfig) {
        return CarrierWifiNetworksApiFp(this.configuration).cwfNetworkIdSubscriberConfigBaseNamesBaseNamePost(requestParameters.networkId, requestParameters.baseName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get network-wide base names
     * @param {CarrierWifiNetworksApiCwfNetworkIdSubscriberConfigBaseNamesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CarrierWifiNetworksApi
     */
    public cwfNetworkIdSubscriberConfigBaseNamesGet(requestParameters: CarrierWifiNetworksApiCwfNetworkIdSubscriberConfigBaseNamesGetRequest, options?: AxiosRequestConfig) {
        return CarrierWifiNetworksApiFp(this.configuration).cwfNetworkIdSubscriberConfigBaseNamesGet(requestParameters.networkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update network-wide base names
     * @param {CarrierWifiNetworksApiCwfNetworkIdSubscriberConfigBaseNamesPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CarrierWifiNetworksApi
     */
    public cwfNetworkIdSubscriberConfigBaseNamesPut(requestParameters: CarrierWifiNetworksApiCwfNetworkIdSubscriberConfigBaseNamesPutRequest, options?: AxiosRequestConfig) {
        return CarrierWifiNetworksApiFp(this.configuration).cwfNetworkIdSubscriberConfigBaseNamesPut(requestParameters.networkId, requestParameters.record, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a network-wide subscriber config
     * @param {CarrierWifiNetworksApiCwfNetworkIdSubscriberConfigGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CarrierWifiNetworksApi
     */
    public cwfNetworkIdSubscriberConfigGet(requestParameters: CarrierWifiNetworksApiCwfNetworkIdSubscriberConfigGetRequest, options?: AxiosRequestConfig) {
        return CarrierWifiNetworksApiFp(this.configuration).cwfNetworkIdSubscriberConfigGet(requestParameters.networkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a network-wide subscriber config
     * @param {CarrierWifiNetworksApiCwfNetworkIdSubscriberConfigPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CarrierWifiNetworksApi
     */
    public cwfNetworkIdSubscriberConfigPut(requestParameters: CarrierWifiNetworksApiCwfNetworkIdSubscriberConfigPutRequest, options?: AxiosRequestConfig) {
        return CarrierWifiNetworksApiFp(this.configuration).cwfNetworkIdSubscriberConfigPut(requestParameters.networkId, requestParameters.record, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get network-wide rule names
     * @param {CarrierWifiNetworksApiCwfNetworkIdSubscriberConfigRuleNamesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CarrierWifiNetworksApi
     */
    public cwfNetworkIdSubscriberConfigRuleNamesGet(requestParameters: CarrierWifiNetworksApiCwfNetworkIdSubscriberConfigRuleNamesGetRequest, options?: AxiosRequestConfig) {
        return CarrierWifiNetworksApiFp(this.configuration).cwfNetworkIdSubscriberConfigRuleNamesGet(requestParameters.networkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update network-wide rule names
     * @param {CarrierWifiNetworksApiCwfNetworkIdSubscriberConfigRuleNamesPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CarrierWifiNetworksApi
     */
    public cwfNetworkIdSubscriberConfigRuleNamesPut(requestParameters: CarrierWifiNetworksApiCwfNetworkIdSubscriberConfigRuleNamesPutRequest, options?: AxiosRequestConfig) {
        return CarrierWifiNetworksApiFp(this.configuration).cwfNetworkIdSubscriberConfigRuleNamesPut(requestParameters.networkId, requestParameters.record, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add a network-wide rule name
     * @param {CarrierWifiNetworksApiCwfNetworkIdSubscriberConfigRuleNamesRuleIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CarrierWifiNetworksApi
     */
    public cwfNetworkIdSubscriberConfigRuleNamesRuleIdDelete(requestParameters: CarrierWifiNetworksApiCwfNetworkIdSubscriberConfigRuleNamesRuleIdDeleteRequest, options?: AxiosRequestConfig) {
        return CarrierWifiNetworksApiFp(this.configuration).cwfNetworkIdSubscriberConfigRuleNamesRuleIdDelete(requestParameters.networkId, requestParameters.ruleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add a network-wide rule name
     * @param {CarrierWifiNetworksApiCwfNetworkIdSubscriberConfigRuleNamesRuleIdPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CarrierWifiNetworksApi
     */
    public cwfNetworkIdSubscriberConfigRuleNamesRuleIdPost(requestParameters: CarrierWifiNetworksApiCwfNetworkIdSubscriberConfigRuleNamesRuleIdPostRequest, options?: AxiosRequestConfig) {
        return CarrierWifiNetworksApiFp(this.configuration).cwfNetworkIdSubscriberConfigRuleNamesRuleIdPost(requestParameters.networkId, requestParameters.ruleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the directory record of a subscriber
     * @param {CarrierWifiNetworksApiCwfNetworkIdSubscribersSubscriberIdDirectoryRecordGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CarrierWifiNetworksApi
     */
    public cwfNetworkIdSubscribersSubscriberIdDirectoryRecordGet(requestParameters: CarrierWifiNetworksApiCwfNetworkIdSubscribersSubscriberIdDirectoryRecordGetRequest, options?: AxiosRequestConfig) {
        return CarrierWifiNetworksApiFp(this.configuration).cwfNetworkIdSubscribersSubscriberIdDirectoryRecordGet(requestParameters.networkId, requestParameters.subscriberId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new Carrier Wifi network
     * @param {CarrierWifiNetworksApiCwfPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CarrierWifiNetworksApi
     */
    public cwfPost(requestParameters: CarrierWifiNetworksApiCwfPostRequest, options?: AxiosRequestConfig) {
        return CarrierWifiNetworksApiFp(this.configuration).cwfPost(requestParameters.cwfNetwork, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CbsdsApi - axios parameter creator
 * @export
 */
export const CbsdsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete CBSD from LTE network
         * @param {string} networkId Network ID
         * @param {number} cbsdId CBSD ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dpNetworkIdCbsdsCbsdIdDelete: async (networkId: string, cbsdId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('dpNetworkIdCbsdsCbsdIdDelete', 'networkId', networkId)
            // verify required parameter 'cbsdId' is not null or undefined
            assertParamExists('dpNetworkIdCbsdsCbsdIdDelete', 'cbsdId', cbsdId)
            const localVarPath = `/dp/{network_id}/cbsds/{cbsd_id}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"cbsd_id"}}`, encodeURIComponent(String(cbsdId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Force deregistration in SAS of given CBSD
         * @param {string} networkId Network ID
         * @param {number} cbsdId CBSD ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dpNetworkIdCbsdsCbsdIdDeregisterPost: async (networkId: string, cbsdId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('dpNetworkIdCbsdsCbsdIdDeregisterPost', 'networkId', networkId)
            // verify required parameter 'cbsdId' is not null or undefined
            assertParamExists('dpNetworkIdCbsdsCbsdIdDeregisterPost', 'cbsdId', cbsdId)
            const localVarPath = `/dp/{network_id}/cbsds/{cbsd_id}/deregister`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"cbsd_id"}}`, encodeURIComponent(String(cbsdId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve CBSD from LTE network
         * @param {string} networkId Network ID
         * @param {number} cbsdId CBSD ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dpNetworkIdCbsdsCbsdIdGet: async (networkId: string, cbsdId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('dpNetworkIdCbsdsCbsdIdGet', 'networkId', networkId)
            // verify required parameter 'cbsdId' is not null or undefined
            assertParamExists('dpNetworkIdCbsdsCbsdIdGet', 'cbsdId', cbsdId)
            const localVarPath = `/dp/{network_id}/cbsds/{cbsd_id}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"cbsd_id"}}`, encodeURIComponent(String(cbsdId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update CBSD in LTE network
         * @param {string} networkId Network ID
         * @param {number} cbsdId CBSD ID
         * @param {MutableCbsd} cbsd CBSD
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dpNetworkIdCbsdsCbsdIdPut: async (networkId: string, cbsdId: number, cbsd: MutableCbsd, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('dpNetworkIdCbsdsCbsdIdPut', 'networkId', networkId)
            // verify required parameter 'cbsdId' is not null or undefined
            assertParamExists('dpNetworkIdCbsdsCbsdIdPut', 'cbsdId', cbsdId)
            // verify required parameter 'cbsd' is not null or undefined
            assertParamExists('dpNetworkIdCbsdsCbsdIdPut', 'cbsd', cbsd)
            const localVarPath = `/dp/{network_id}/cbsds/{cbsd_id}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"cbsd_id"}}`, encodeURIComponent(String(cbsdId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cbsd, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Force relinquish all grants in SAS of given CBSD
         * @param {string} networkId Network ID
         * @param {number} cbsdId CBSD ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dpNetworkIdCbsdsCbsdIdRelinquishPost: async (networkId: string, cbsdId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('dpNetworkIdCbsdsCbsdIdRelinquishPost', 'networkId', networkId)
            // verify required parameter 'cbsdId' is not null or undefined
            assertParamExists('dpNetworkIdCbsdsCbsdIdRelinquishPost', 'cbsdId', cbsdId)
            const localVarPath = `/dp/{network_id}/cbsds/{cbsd_id}/relinquish`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"cbsd_id"}}`, encodeURIComponent(String(cbsdId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all CBSDs in LTE network
         * @param {string} networkId Network ID
         * @param {number} [offset] Start index for pagination
         * @param {number} [limit] Number of record to return
         * @param {string} [serialNumber] serial number of cbsd
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dpNetworkIdCbsdsGet: async (networkId: string, offset?: number, limit?: number, serialNumber?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('dpNetworkIdCbsdsGet', 'networkId', networkId)
            const localVarPath = `/dp/{network_id}/cbsds`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (serialNumber !== undefined) {
                localVarQueryParameter['serial_number'] = serialNumber;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create new cbsd
         * @param {string} networkId Network ID
         * @param {MutableCbsd} cbsd CBSD
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dpNetworkIdCbsdsPost: async (networkId: string, cbsd: MutableCbsd, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('dpNetworkIdCbsdsPost', 'networkId', networkId)
            // verify required parameter 'cbsd' is not null or undefined
            assertParamExists('dpNetworkIdCbsdsPost', 'cbsd', cbsd)
            const localVarPath = `/dp/{network_id}/cbsds`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cbsd, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CbsdsApi - functional programming interface
 * @export
 */
export const CbsdsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CbsdsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete CBSD from LTE network
         * @param {string} networkId Network ID
         * @param {number} cbsdId CBSD ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dpNetworkIdCbsdsCbsdIdDelete(networkId: string, cbsdId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dpNetworkIdCbsdsCbsdIdDelete(networkId, cbsdId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Force deregistration in SAS of given CBSD
         * @param {string} networkId Network ID
         * @param {number} cbsdId CBSD ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dpNetworkIdCbsdsCbsdIdDeregisterPost(networkId: string, cbsdId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dpNetworkIdCbsdsCbsdIdDeregisterPost(networkId, cbsdId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve CBSD from LTE network
         * @param {string} networkId Network ID
         * @param {number} cbsdId CBSD ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dpNetworkIdCbsdsCbsdIdGet(networkId: string, cbsdId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Cbsd>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dpNetworkIdCbsdsCbsdIdGet(networkId, cbsdId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update CBSD in LTE network
         * @param {string} networkId Network ID
         * @param {number} cbsdId CBSD ID
         * @param {MutableCbsd} cbsd CBSD
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dpNetworkIdCbsdsCbsdIdPut(networkId: string, cbsdId: number, cbsd: MutableCbsd, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dpNetworkIdCbsdsCbsdIdPut(networkId, cbsdId, cbsd, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Force relinquish all grants in SAS of given CBSD
         * @param {string} networkId Network ID
         * @param {number} cbsdId CBSD ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dpNetworkIdCbsdsCbsdIdRelinquishPost(networkId: string, cbsdId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dpNetworkIdCbsdsCbsdIdRelinquishPost(networkId, cbsdId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all CBSDs in LTE network
         * @param {string} networkId Network ID
         * @param {number} [offset] Start index for pagination
         * @param {number} [limit] Number of record to return
         * @param {string} [serialNumber] serial number of cbsd
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dpNetworkIdCbsdsGet(networkId: string, offset?: number, limit?: number, serialNumber?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedCbsds>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dpNetworkIdCbsdsGet(networkId, offset, limit, serialNumber, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create new cbsd
         * @param {string} networkId Network ID
         * @param {MutableCbsd} cbsd CBSD
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dpNetworkIdCbsdsPost(networkId: string, cbsd: MutableCbsd, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dpNetworkIdCbsdsPost(networkId, cbsd, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CbsdsApi - factory interface
 * @export
 */
export const CbsdsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CbsdsApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete CBSD from LTE network
         * @param {string} networkId Network ID
         * @param {number} cbsdId CBSD ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dpNetworkIdCbsdsCbsdIdDelete(networkId: string, cbsdId: number, options?: any): AxiosPromise<void> {
            return localVarFp.dpNetworkIdCbsdsCbsdIdDelete(networkId, cbsdId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Force deregistration in SAS of given CBSD
         * @param {string} networkId Network ID
         * @param {number} cbsdId CBSD ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dpNetworkIdCbsdsCbsdIdDeregisterPost(networkId: string, cbsdId: number, options?: any): AxiosPromise<void> {
            return localVarFp.dpNetworkIdCbsdsCbsdIdDeregisterPost(networkId, cbsdId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve CBSD from LTE network
         * @param {string} networkId Network ID
         * @param {number} cbsdId CBSD ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dpNetworkIdCbsdsCbsdIdGet(networkId: string, cbsdId: number, options?: any): AxiosPromise<Cbsd> {
            return localVarFp.dpNetworkIdCbsdsCbsdIdGet(networkId, cbsdId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update CBSD in LTE network
         * @param {string} networkId Network ID
         * @param {number} cbsdId CBSD ID
         * @param {MutableCbsd} cbsd CBSD
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dpNetworkIdCbsdsCbsdIdPut(networkId: string, cbsdId: number, cbsd: MutableCbsd, options?: any): AxiosPromise<void> {
            return localVarFp.dpNetworkIdCbsdsCbsdIdPut(networkId, cbsdId, cbsd, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Force relinquish all grants in SAS of given CBSD
         * @param {string} networkId Network ID
         * @param {number} cbsdId CBSD ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dpNetworkIdCbsdsCbsdIdRelinquishPost(networkId: string, cbsdId: number, options?: any): AxiosPromise<void> {
            return localVarFp.dpNetworkIdCbsdsCbsdIdRelinquishPost(networkId, cbsdId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all CBSDs in LTE network
         * @param {string} networkId Network ID
         * @param {number} [offset] Start index for pagination
         * @param {number} [limit] Number of record to return
         * @param {string} [serialNumber] serial number of cbsd
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dpNetworkIdCbsdsGet(networkId: string, offset?: number, limit?: number, serialNumber?: string, options?: any): AxiosPromise<PaginatedCbsds> {
            return localVarFp.dpNetworkIdCbsdsGet(networkId, offset, limit, serialNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create new cbsd
         * @param {string} networkId Network ID
         * @param {MutableCbsd} cbsd CBSD
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dpNetworkIdCbsdsPost(networkId: string, cbsd: MutableCbsd, options?: any): AxiosPromise<void> {
            return localVarFp.dpNetworkIdCbsdsPost(networkId, cbsd, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for dpNetworkIdCbsdsCbsdIdDelete operation in CbsdsApi.
 * @export
 * @interface CbsdsApiDpNetworkIdCbsdsCbsdIdDeleteRequest
 */
export interface CbsdsApiDpNetworkIdCbsdsCbsdIdDeleteRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof CbsdsApiDpNetworkIdCbsdsCbsdIdDelete
     */
    readonly networkId: string

    /**
     * CBSD ID
     * @type {number}
     * @memberof CbsdsApiDpNetworkIdCbsdsCbsdIdDelete
     */
    readonly cbsdId: number
}

/**
 * Request parameters for dpNetworkIdCbsdsCbsdIdDeregisterPost operation in CbsdsApi.
 * @export
 * @interface CbsdsApiDpNetworkIdCbsdsCbsdIdDeregisterPostRequest
 */
export interface CbsdsApiDpNetworkIdCbsdsCbsdIdDeregisterPostRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof CbsdsApiDpNetworkIdCbsdsCbsdIdDeregisterPost
     */
    readonly networkId: string

    /**
     * CBSD ID
     * @type {number}
     * @memberof CbsdsApiDpNetworkIdCbsdsCbsdIdDeregisterPost
     */
    readonly cbsdId: number
}

/**
 * Request parameters for dpNetworkIdCbsdsCbsdIdGet operation in CbsdsApi.
 * @export
 * @interface CbsdsApiDpNetworkIdCbsdsCbsdIdGetRequest
 */
export interface CbsdsApiDpNetworkIdCbsdsCbsdIdGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof CbsdsApiDpNetworkIdCbsdsCbsdIdGet
     */
    readonly networkId: string

    /**
     * CBSD ID
     * @type {number}
     * @memberof CbsdsApiDpNetworkIdCbsdsCbsdIdGet
     */
    readonly cbsdId: number
}

/**
 * Request parameters for dpNetworkIdCbsdsCbsdIdPut operation in CbsdsApi.
 * @export
 * @interface CbsdsApiDpNetworkIdCbsdsCbsdIdPutRequest
 */
export interface CbsdsApiDpNetworkIdCbsdsCbsdIdPutRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof CbsdsApiDpNetworkIdCbsdsCbsdIdPut
     */
    readonly networkId: string

    /**
     * CBSD ID
     * @type {number}
     * @memberof CbsdsApiDpNetworkIdCbsdsCbsdIdPut
     */
    readonly cbsdId: number

    /**
     * CBSD
     * @type {MutableCbsd}
     * @memberof CbsdsApiDpNetworkIdCbsdsCbsdIdPut
     */
    readonly cbsd: MutableCbsd
}

/**
 * Request parameters for dpNetworkIdCbsdsCbsdIdRelinquishPost operation in CbsdsApi.
 * @export
 * @interface CbsdsApiDpNetworkIdCbsdsCbsdIdRelinquishPostRequest
 */
export interface CbsdsApiDpNetworkIdCbsdsCbsdIdRelinquishPostRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof CbsdsApiDpNetworkIdCbsdsCbsdIdRelinquishPost
     */
    readonly networkId: string

    /**
     * CBSD ID
     * @type {number}
     * @memberof CbsdsApiDpNetworkIdCbsdsCbsdIdRelinquishPost
     */
    readonly cbsdId: number
}

/**
 * Request parameters for dpNetworkIdCbsdsGet operation in CbsdsApi.
 * @export
 * @interface CbsdsApiDpNetworkIdCbsdsGetRequest
 */
export interface CbsdsApiDpNetworkIdCbsdsGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof CbsdsApiDpNetworkIdCbsdsGet
     */
    readonly networkId: string

    /**
     * Start index for pagination
     * @type {number}
     * @memberof CbsdsApiDpNetworkIdCbsdsGet
     */
    readonly offset?: number

    /**
     * Number of record to return
     * @type {number}
     * @memberof CbsdsApiDpNetworkIdCbsdsGet
     */
    readonly limit?: number

    /**
     * serial number of cbsd
     * @type {string}
     * @memberof CbsdsApiDpNetworkIdCbsdsGet
     */
    readonly serialNumber?: string
}

/**
 * Request parameters for dpNetworkIdCbsdsPost operation in CbsdsApi.
 * @export
 * @interface CbsdsApiDpNetworkIdCbsdsPostRequest
 */
export interface CbsdsApiDpNetworkIdCbsdsPostRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof CbsdsApiDpNetworkIdCbsdsPost
     */
    readonly networkId: string

    /**
     * CBSD
     * @type {MutableCbsd}
     * @memberof CbsdsApiDpNetworkIdCbsdsPost
     */
    readonly cbsd: MutableCbsd
}

/**
 * CbsdsApi - object-oriented interface
 * @export
 * @class CbsdsApi
 * @extends {BaseAPI}
 */
export class CbsdsApi extends BaseAPI {
    /**
     * 
     * @summary Delete CBSD from LTE network
     * @param {CbsdsApiDpNetworkIdCbsdsCbsdIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CbsdsApi
     */
    public dpNetworkIdCbsdsCbsdIdDelete(requestParameters: CbsdsApiDpNetworkIdCbsdsCbsdIdDeleteRequest, options?: AxiosRequestConfig) {
        return CbsdsApiFp(this.configuration).dpNetworkIdCbsdsCbsdIdDelete(requestParameters.networkId, requestParameters.cbsdId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Force deregistration in SAS of given CBSD
     * @param {CbsdsApiDpNetworkIdCbsdsCbsdIdDeregisterPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CbsdsApi
     */
    public dpNetworkIdCbsdsCbsdIdDeregisterPost(requestParameters: CbsdsApiDpNetworkIdCbsdsCbsdIdDeregisterPostRequest, options?: AxiosRequestConfig) {
        return CbsdsApiFp(this.configuration).dpNetworkIdCbsdsCbsdIdDeregisterPost(requestParameters.networkId, requestParameters.cbsdId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve CBSD from LTE network
     * @param {CbsdsApiDpNetworkIdCbsdsCbsdIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CbsdsApi
     */
    public dpNetworkIdCbsdsCbsdIdGet(requestParameters: CbsdsApiDpNetworkIdCbsdsCbsdIdGetRequest, options?: AxiosRequestConfig) {
        return CbsdsApiFp(this.configuration).dpNetworkIdCbsdsCbsdIdGet(requestParameters.networkId, requestParameters.cbsdId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update CBSD in LTE network
     * @param {CbsdsApiDpNetworkIdCbsdsCbsdIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CbsdsApi
     */
    public dpNetworkIdCbsdsCbsdIdPut(requestParameters: CbsdsApiDpNetworkIdCbsdsCbsdIdPutRequest, options?: AxiosRequestConfig) {
        return CbsdsApiFp(this.configuration).dpNetworkIdCbsdsCbsdIdPut(requestParameters.networkId, requestParameters.cbsdId, requestParameters.cbsd, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Force relinquish all grants in SAS of given CBSD
     * @param {CbsdsApiDpNetworkIdCbsdsCbsdIdRelinquishPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CbsdsApi
     */
    public dpNetworkIdCbsdsCbsdIdRelinquishPost(requestParameters: CbsdsApiDpNetworkIdCbsdsCbsdIdRelinquishPostRequest, options?: AxiosRequestConfig) {
        return CbsdsApiFp(this.configuration).dpNetworkIdCbsdsCbsdIdRelinquishPost(requestParameters.networkId, requestParameters.cbsdId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all CBSDs in LTE network
     * @param {CbsdsApiDpNetworkIdCbsdsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CbsdsApi
     */
    public dpNetworkIdCbsdsGet(requestParameters: CbsdsApiDpNetworkIdCbsdsGetRequest, options?: AxiosRequestConfig) {
        return CbsdsApiFp(this.configuration).dpNetworkIdCbsdsGet(requestParameters.networkId, requestParameters.offset, requestParameters.limit, requestParameters.serialNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create new cbsd
     * @param {CbsdsApiDpNetworkIdCbsdsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CbsdsApi
     */
    public dpNetworkIdCbsdsPost(requestParameters: CbsdsApiDpNetworkIdCbsdsPostRequest, options?: AxiosRequestConfig) {
        return CbsdsApiFp(this.configuration).dpNetworkIdCbsdsPost(requestParameters.networkId, requestParameters.cbsd, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CommandsApi - axios parameter creator
 * @export
 */
export const CommandsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Execute generic command on gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {GenericCommandParams} parameters Parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdGatewaysGatewayIdCommandGenericPost: async (networkId: string, gatewayId: string, parameters: GenericCommandParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networksNetworkIdGatewaysGatewayIdCommandGenericPost', 'networkId', networkId)
            // verify required parameter 'gatewayId' is not null or undefined
            assertParamExists('networksNetworkIdGatewaysGatewayIdCommandGenericPost', 'gatewayId', gatewayId)
            // verify required parameter 'parameters' is not null or undefined
            assertParamExists('networksNetworkIdGatewaysGatewayIdCommandGenericPost', 'parameters', parameters)
            const localVarPath = `/networks/{network_id}/gateways/{gateway_id}/command/generic`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"gateway_id"}}`, encodeURIComponent(String(gatewayId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(parameters, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Ping host(s) from gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {PingRequest} pingRequest Ping request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdGatewaysGatewayIdCommandPingPost: async (networkId: string, gatewayId: string, pingRequest: PingRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networksNetworkIdGatewaysGatewayIdCommandPingPost', 'networkId', networkId)
            // verify required parameter 'gatewayId' is not null or undefined
            assertParamExists('networksNetworkIdGatewaysGatewayIdCommandPingPost', 'gatewayId', gatewayId)
            // verify required parameter 'pingRequest' is not null or undefined
            assertParamExists('networksNetworkIdGatewaysGatewayIdCommandPingPost', 'pingRequest', pingRequest)
            const localVarPath = `/networks/{network_id}/gateways/{gateway_id}/command/ping`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"gateway_id"}}`, encodeURIComponent(String(gatewayId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pingRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reboot gateway device
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdGatewaysGatewayIdCommandRebootPost: async (networkId: string, gatewayId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networksNetworkIdGatewaysGatewayIdCommandRebootPost', 'networkId', networkId)
            // verify required parameter 'gatewayId' is not null or undefined
            assertParamExists('networksNetworkIdGatewaysGatewayIdCommandRebootPost', 'gatewayId', gatewayId)
            const localVarPath = `/networks/{network_id}/gateways/{gateway_id}/command/reboot`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"gateway_id"}}`, encodeURIComponent(String(gatewayId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Restart gateway services
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {Array<string>} services Services
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdGatewaysGatewayIdCommandRestartServicesPost: async (networkId: string, gatewayId: string, services: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networksNetworkIdGatewaysGatewayIdCommandRestartServicesPost', 'networkId', networkId)
            // verify required parameter 'gatewayId' is not null or undefined
            assertParamExists('networksNetworkIdGatewaysGatewayIdCommandRestartServicesPost', 'gatewayId', gatewayId)
            // verify required parameter 'services' is not null or undefined
            assertParamExists('networksNetworkIdGatewaysGatewayIdCommandRestartServicesPost', 'services', services)
            const localVarPath = `/networks/{network_id}/gateways/{gateway_id}/command/restart_services`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"gateway_id"}}`, encodeURIComponent(String(gatewayId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(services, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CommandsApi - functional programming interface
 * @export
 */
export const CommandsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CommandsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Execute generic command on gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {GenericCommandParams} parameters Parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksNetworkIdGatewaysGatewayIdCommandGenericPost(networkId: string, gatewayId: string, parameters: GenericCommandParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericCommandResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksNetworkIdGatewaysGatewayIdCommandGenericPost(networkId, gatewayId, parameters, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Ping host(s) from gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {PingRequest} pingRequest Ping request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksNetworkIdGatewaysGatewayIdCommandPingPost(networkId: string, gatewayId: string, pingRequest: PingRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PingResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksNetworkIdGatewaysGatewayIdCommandPingPost(networkId, gatewayId, pingRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Reboot gateway device
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksNetworkIdGatewaysGatewayIdCommandRebootPost(networkId: string, gatewayId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksNetworkIdGatewaysGatewayIdCommandRebootPost(networkId, gatewayId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Restart gateway services
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {Array<string>} services Services
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksNetworkIdGatewaysGatewayIdCommandRestartServicesPost(networkId: string, gatewayId: string, services: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksNetworkIdGatewaysGatewayIdCommandRestartServicesPost(networkId, gatewayId, services, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CommandsApi - factory interface
 * @export
 */
export const CommandsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CommandsApiFp(configuration)
    return {
        /**
         * 
         * @summary Execute generic command on gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {GenericCommandParams} parameters Parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdGatewaysGatewayIdCommandGenericPost(networkId: string, gatewayId: string, parameters: GenericCommandParams, options?: any): AxiosPromise<GenericCommandResponse> {
            return localVarFp.networksNetworkIdGatewaysGatewayIdCommandGenericPost(networkId, gatewayId, parameters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Ping host(s) from gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {PingRequest} pingRequest Ping request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdGatewaysGatewayIdCommandPingPost(networkId: string, gatewayId: string, pingRequest: PingRequest, options?: any): AxiosPromise<PingResponse> {
            return localVarFp.networksNetworkIdGatewaysGatewayIdCommandPingPost(networkId, gatewayId, pingRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reboot gateway device
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdGatewaysGatewayIdCommandRebootPost(networkId: string, gatewayId: string, options?: any): AxiosPromise<void> {
            return localVarFp.networksNetworkIdGatewaysGatewayIdCommandRebootPost(networkId, gatewayId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Restart gateway services
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {Array<string>} services Services
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdGatewaysGatewayIdCommandRestartServicesPost(networkId: string, gatewayId: string, services: Array<string>, options?: any): AxiosPromise<void> {
            return localVarFp.networksNetworkIdGatewaysGatewayIdCommandRestartServicesPost(networkId, gatewayId, services, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for networksNetworkIdGatewaysGatewayIdCommandGenericPost operation in CommandsApi.
 * @export
 * @interface CommandsApiNetworksNetworkIdGatewaysGatewayIdCommandGenericPostRequest
 */
export interface CommandsApiNetworksNetworkIdGatewaysGatewayIdCommandGenericPostRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof CommandsApiNetworksNetworkIdGatewaysGatewayIdCommandGenericPost
     */
    readonly networkId: string

    /**
     * Gateway ID
     * @type {string}
     * @memberof CommandsApiNetworksNetworkIdGatewaysGatewayIdCommandGenericPost
     */
    readonly gatewayId: string

    /**
     * Parameters
     * @type {GenericCommandParams}
     * @memberof CommandsApiNetworksNetworkIdGatewaysGatewayIdCommandGenericPost
     */
    readonly parameters: GenericCommandParams
}

/**
 * Request parameters for networksNetworkIdGatewaysGatewayIdCommandPingPost operation in CommandsApi.
 * @export
 * @interface CommandsApiNetworksNetworkIdGatewaysGatewayIdCommandPingPostRequest
 */
export interface CommandsApiNetworksNetworkIdGatewaysGatewayIdCommandPingPostRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof CommandsApiNetworksNetworkIdGatewaysGatewayIdCommandPingPost
     */
    readonly networkId: string

    /**
     * Gateway ID
     * @type {string}
     * @memberof CommandsApiNetworksNetworkIdGatewaysGatewayIdCommandPingPost
     */
    readonly gatewayId: string

    /**
     * Ping request
     * @type {PingRequest}
     * @memberof CommandsApiNetworksNetworkIdGatewaysGatewayIdCommandPingPost
     */
    readonly pingRequest: PingRequest
}

/**
 * Request parameters for networksNetworkIdGatewaysGatewayIdCommandRebootPost operation in CommandsApi.
 * @export
 * @interface CommandsApiNetworksNetworkIdGatewaysGatewayIdCommandRebootPostRequest
 */
export interface CommandsApiNetworksNetworkIdGatewaysGatewayIdCommandRebootPostRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof CommandsApiNetworksNetworkIdGatewaysGatewayIdCommandRebootPost
     */
    readonly networkId: string

    /**
     * Gateway ID
     * @type {string}
     * @memberof CommandsApiNetworksNetworkIdGatewaysGatewayIdCommandRebootPost
     */
    readonly gatewayId: string
}

/**
 * Request parameters for networksNetworkIdGatewaysGatewayIdCommandRestartServicesPost operation in CommandsApi.
 * @export
 * @interface CommandsApiNetworksNetworkIdGatewaysGatewayIdCommandRestartServicesPostRequest
 */
export interface CommandsApiNetworksNetworkIdGatewaysGatewayIdCommandRestartServicesPostRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof CommandsApiNetworksNetworkIdGatewaysGatewayIdCommandRestartServicesPost
     */
    readonly networkId: string

    /**
     * Gateway ID
     * @type {string}
     * @memberof CommandsApiNetworksNetworkIdGatewaysGatewayIdCommandRestartServicesPost
     */
    readonly gatewayId: string

    /**
     * Services
     * @type {Array<string>}
     * @memberof CommandsApiNetworksNetworkIdGatewaysGatewayIdCommandRestartServicesPost
     */
    readonly services: Array<string>
}

/**
 * CommandsApi - object-oriented interface
 * @export
 * @class CommandsApi
 * @extends {BaseAPI}
 */
export class CommandsApi extends BaseAPI {
    /**
     * 
     * @summary Execute generic command on gateway
     * @param {CommandsApiNetworksNetworkIdGatewaysGatewayIdCommandGenericPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommandsApi
     */
    public networksNetworkIdGatewaysGatewayIdCommandGenericPost(requestParameters: CommandsApiNetworksNetworkIdGatewaysGatewayIdCommandGenericPostRequest, options?: AxiosRequestConfig) {
        return CommandsApiFp(this.configuration).networksNetworkIdGatewaysGatewayIdCommandGenericPost(requestParameters.networkId, requestParameters.gatewayId, requestParameters.parameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Ping host(s) from gateway
     * @param {CommandsApiNetworksNetworkIdGatewaysGatewayIdCommandPingPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommandsApi
     */
    public networksNetworkIdGatewaysGatewayIdCommandPingPost(requestParameters: CommandsApiNetworksNetworkIdGatewaysGatewayIdCommandPingPostRequest, options?: AxiosRequestConfig) {
        return CommandsApiFp(this.configuration).networksNetworkIdGatewaysGatewayIdCommandPingPost(requestParameters.networkId, requestParameters.gatewayId, requestParameters.pingRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reboot gateway device
     * @param {CommandsApiNetworksNetworkIdGatewaysGatewayIdCommandRebootPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommandsApi
     */
    public networksNetworkIdGatewaysGatewayIdCommandRebootPost(requestParameters: CommandsApiNetworksNetworkIdGatewaysGatewayIdCommandRebootPostRequest, options?: AxiosRequestConfig) {
        return CommandsApiFp(this.configuration).networksNetworkIdGatewaysGatewayIdCommandRebootPost(requestParameters.networkId, requestParameters.gatewayId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Restart gateway services
     * @param {CommandsApiNetworksNetworkIdGatewaysGatewayIdCommandRestartServicesPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommandsApi
     */
    public networksNetworkIdGatewaysGatewayIdCommandRestartServicesPost(requestParameters: CommandsApiNetworksNetworkIdGatewaysGatewayIdCommandRestartServicesPostRequest, options?: AxiosRequestConfig) {
        return CommandsApiFp(this.configuration).networksNetworkIdGatewaysGatewayIdCommandRestartServicesPost(requestParameters.networkId, requestParameters.gatewayId, requestParameters.services, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Mock API path so the YAML passes spec
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fooGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/foo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Mock API path so the YAML passes spec
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fooGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fooGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * 
         * @summary Mock API path so the YAML passes spec
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fooGet(options?: any): AxiosPromise<number> {
            return localVarFp.fooGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @summary Mock API path so the YAML passes spec
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public fooGet(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).fooGet(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EnodeBsApi - axios parameter creator
 * @export
 */
export const EnodeBsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Unregister an enodeB
         * @param {string} networkId Network ID
         * @param {string} enodebSerial EnodeB serial number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdEnodebsEnodebSerialDelete: async (networkId: string, enodebSerial: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdEnodebsEnodebSerialDelete', 'networkId', networkId)
            // verify required parameter 'enodebSerial' is not null or undefined
            assertParamExists('lteNetworkIdEnodebsEnodebSerialDelete', 'enodebSerial', enodebSerial)
            const localVarPath = `/lte/{network_id}/enodebs/{enodeb_serial}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"enodeb_serial"}}`, encodeURIComponent(String(enodebSerial)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a specific enodeB configuration
         * @param {string} networkId Network ID
         * @param {string} enodebSerial EnodeB serial number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdEnodebsEnodebSerialGet: async (networkId: string, enodebSerial: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdEnodebsEnodebSerialGet', 'networkId', networkId)
            // verify required parameter 'enodebSerial' is not null or undefined
            assertParamExists('lteNetworkIdEnodebsEnodebSerialGet', 'enodebSerial', enodebSerial)
            const localVarPath = `/lte/{network_id}/enodebs/{enodeb_serial}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"enodeb_serial"}}`, encodeURIComponent(String(enodebSerial)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an enodeB\'s configuration
         * @param {string} networkId Network ID
         * @param {string} enodebSerial EnodeB serial number
         * @param {Enodeb} enodeb Desired configuration of the enodeB
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdEnodebsEnodebSerialPut: async (networkId: string, enodebSerial: string, enodeb: Enodeb, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdEnodebsEnodebSerialPut', 'networkId', networkId)
            // verify required parameter 'enodebSerial' is not null or undefined
            assertParamExists('lteNetworkIdEnodebsEnodebSerialPut', 'enodebSerial', enodebSerial)
            // verify required parameter 'enodeb' is not null or undefined
            assertParamExists('lteNetworkIdEnodebsEnodebSerialPut', 'enodeb', enodeb)
            const localVarPath = `/lte/{network_id}/enodebs/{enodeb_serial}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"enodeb_serial"}}`, encodeURIComponent(String(enodebSerial)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(enodeb, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve reported state from enodeb device
         * @param {string} networkId Network ID
         * @param {string} enodebSerial EnodeB serial number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdEnodebsEnodebSerialStateGet: async (networkId: string, enodebSerial: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdEnodebsEnodebSerialStateGet', 'networkId', networkId)
            // verify required parameter 'enodebSerial' is not null or undefined
            assertParamExists('lteNetworkIdEnodebsEnodebSerialStateGet', 'enodebSerial', enodebSerial)
            const localVarPath = `/lte/{network_id}/enodebs/{enodeb_serial}/state`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"enodeb_serial"}}`, encodeURIComponent(String(enodebSerial)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all enodeBs in the network
         * @param {string} networkId Network ID
         * @param {number} [pageSize] Maximum number of entities to return
         * @param {string} [pageToken] Opaque page token for paginated requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdEnodebsGet: async (networkId: string, pageSize?: number, pageToken?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdEnodebsGet', 'networkId', networkId)
            const localVarPath = `/lte/{network_id}/enodebs`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = pageToken;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Register a new enodeB
         * @param {string} networkId Network ID
         * @param {Enodeb} enodeb Configuration of the enodeB
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdEnodebsPost: async (networkId: string, enodeb: Enodeb, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdEnodebsPost', 'networkId', networkId)
            // verify required parameter 'enodeb' is not null or undefined
            assertParamExists('lteNetworkIdEnodebsPost', 'enodeb', enodeb)
            const localVarPath = `/lte/{network_id}/enodebs`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(enodeb, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EnodeBsApi - functional programming interface
 * @export
 */
export const EnodeBsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EnodeBsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Unregister an enodeB
         * @param {string} networkId Network ID
         * @param {string} enodebSerial EnodeB serial number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdEnodebsEnodebSerialDelete(networkId: string, enodebSerial: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdEnodebsEnodebSerialDelete(networkId, enodebSerial, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve a specific enodeB configuration
         * @param {string} networkId Network ID
         * @param {string} enodebSerial EnodeB serial number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdEnodebsEnodebSerialGet(networkId: string, enodebSerial: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Enodeb>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdEnodebsEnodebSerialGet(networkId, enodebSerial, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update an enodeB\'s configuration
         * @param {string} networkId Network ID
         * @param {string} enodebSerial EnodeB serial number
         * @param {Enodeb} enodeb Desired configuration of the enodeB
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdEnodebsEnodebSerialPut(networkId: string, enodebSerial: string, enodeb: Enodeb, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdEnodebsEnodebSerialPut(networkId, enodebSerial, enodeb, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve reported state from enodeb device
         * @param {string} networkId Network ID
         * @param {string} enodebSerial EnodeB serial number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdEnodebsEnodebSerialStateGet(networkId: string, enodebSerial: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnodebState>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdEnodebsEnodebSerialStateGet(networkId, enodebSerial, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all enodeBs in the network
         * @param {string} networkId Network ID
         * @param {number} [pageSize] Maximum number of entities to return
         * @param {string} [pageToken] Opaque page token for paginated requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdEnodebsGet(networkId: string, pageSize?: number, pageToken?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedEnodebs>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdEnodebsGet(networkId, pageSize, pageToken, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Register a new enodeB
         * @param {string} networkId Network ID
         * @param {Enodeb} enodeb Configuration of the enodeB
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdEnodebsPost(networkId: string, enodeb: Enodeb, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdEnodebsPost(networkId, enodeb, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EnodeBsApi - factory interface
 * @export
 */
export const EnodeBsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EnodeBsApiFp(configuration)
    return {
        /**
         * 
         * @summary Unregister an enodeB
         * @param {string} networkId Network ID
         * @param {string} enodebSerial EnodeB serial number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdEnodebsEnodebSerialDelete(networkId: string, enodebSerial: string, options?: any): AxiosPromise<void> {
            return localVarFp.lteNetworkIdEnodebsEnodebSerialDelete(networkId, enodebSerial, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a specific enodeB configuration
         * @param {string} networkId Network ID
         * @param {string} enodebSerial EnodeB serial number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdEnodebsEnodebSerialGet(networkId: string, enodebSerial: string, options?: any): AxiosPromise<Enodeb> {
            return localVarFp.lteNetworkIdEnodebsEnodebSerialGet(networkId, enodebSerial, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an enodeB\'s configuration
         * @param {string} networkId Network ID
         * @param {string} enodebSerial EnodeB serial number
         * @param {Enodeb} enodeb Desired configuration of the enodeB
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdEnodebsEnodebSerialPut(networkId: string, enodebSerial: string, enodeb: Enodeb, options?: any): AxiosPromise<void> {
            return localVarFp.lteNetworkIdEnodebsEnodebSerialPut(networkId, enodebSerial, enodeb, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve reported state from enodeb device
         * @param {string} networkId Network ID
         * @param {string} enodebSerial EnodeB serial number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdEnodebsEnodebSerialStateGet(networkId: string, enodebSerial: string, options?: any): AxiosPromise<EnodebState> {
            return localVarFp.lteNetworkIdEnodebsEnodebSerialStateGet(networkId, enodebSerial, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all enodeBs in the network
         * @param {string} networkId Network ID
         * @param {number} [pageSize] Maximum number of entities to return
         * @param {string} [pageToken] Opaque page token for paginated requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdEnodebsGet(networkId: string, pageSize?: number, pageToken?: string, options?: any): AxiosPromise<PaginatedEnodebs> {
            return localVarFp.lteNetworkIdEnodebsGet(networkId, pageSize, pageToken, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Register a new enodeB
         * @param {string} networkId Network ID
         * @param {Enodeb} enodeb Configuration of the enodeB
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdEnodebsPost(networkId: string, enodeb: Enodeb, options?: any): AxiosPromise<void> {
            return localVarFp.lteNetworkIdEnodebsPost(networkId, enodeb, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for lteNetworkIdEnodebsEnodebSerialDelete operation in EnodeBsApi.
 * @export
 * @interface EnodeBsApiLteNetworkIdEnodebsEnodebSerialDeleteRequest
 */
export interface EnodeBsApiLteNetworkIdEnodebsEnodebSerialDeleteRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof EnodeBsApiLteNetworkIdEnodebsEnodebSerialDelete
     */
    readonly networkId: string

    /**
     * EnodeB serial number
     * @type {string}
     * @memberof EnodeBsApiLteNetworkIdEnodebsEnodebSerialDelete
     */
    readonly enodebSerial: string
}

/**
 * Request parameters for lteNetworkIdEnodebsEnodebSerialGet operation in EnodeBsApi.
 * @export
 * @interface EnodeBsApiLteNetworkIdEnodebsEnodebSerialGetRequest
 */
export interface EnodeBsApiLteNetworkIdEnodebsEnodebSerialGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof EnodeBsApiLteNetworkIdEnodebsEnodebSerialGet
     */
    readonly networkId: string

    /**
     * EnodeB serial number
     * @type {string}
     * @memberof EnodeBsApiLteNetworkIdEnodebsEnodebSerialGet
     */
    readonly enodebSerial: string
}

/**
 * Request parameters for lteNetworkIdEnodebsEnodebSerialPut operation in EnodeBsApi.
 * @export
 * @interface EnodeBsApiLteNetworkIdEnodebsEnodebSerialPutRequest
 */
export interface EnodeBsApiLteNetworkIdEnodebsEnodebSerialPutRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof EnodeBsApiLteNetworkIdEnodebsEnodebSerialPut
     */
    readonly networkId: string

    /**
     * EnodeB serial number
     * @type {string}
     * @memberof EnodeBsApiLteNetworkIdEnodebsEnodebSerialPut
     */
    readonly enodebSerial: string

    /**
     * Desired configuration of the enodeB
     * @type {Enodeb}
     * @memberof EnodeBsApiLteNetworkIdEnodebsEnodebSerialPut
     */
    readonly enodeb: Enodeb
}

/**
 * Request parameters for lteNetworkIdEnodebsEnodebSerialStateGet operation in EnodeBsApi.
 * @export
 * @interface EnodeBsApiLteNetworkIdEnodebsEnodebSerialStateGetRequest
 */
export interface EnodeBsApiLteNetworkIdEnodebsEnodebSerialStateGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof EnodeBsApiLteNetworkIdEnodebsEnodebSerialStateGet
     */
    readonly networkId: string

    /**
     * EnodeB serial number
     * @type {string}
     * @memberof EnodeBsApiLteNetworkIdEnodebsEnodebSerialStateGet
     */
    readonly enodebSerial: string
}

/**
 * Request parameters for lteNetworkIdEnodebsGet operation in EnodeBsApi.
 * @export
 * @interface EnodeBsApiLteNetworkIdEnodebsGetRequest
 */
export interface EnodeBsApiLteNetworkIdEnodebsGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof EnodeBsApiLteNetworkIdEnodebsGet
     */
    readonly networkId: string

    /**
     * Maximum number of entities to return
     * @type {number}
     * @memberof EnodeBsApiLteNetworkIdEnodebsGet
     */
    readonly pageSize?: number

    /**
     * Opaque page token for paginated requests
     * @type {string}
     * @memberof EnodeBsApiLteNetworkIdEnodebsGet
     */
    readonly pageToken?: string
}

/**
 * Request parameters for lteNetworkIdEnodebsPost operation in EnodeBsApi.
 * @export
 * @interface EnodeBsApiLteNetworkIdEnodebsPostRequest
 */
export interface EnodeBsApiLteNetworkIdEnodebsPostRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof EnodeBsApiLteNetworkIdEnodebsPost
     */
    readonly networkId: string

    /**
     * Configuration of the enodeB
     * @type {Enodeb}
     * @memberof EnodeBsApiLteNetworkIdEnodebsPost
     */
    readonly enodeb: Enodeb
}

/**
 * EnodeBsApi - object-oriented interface
 * @export
 * @class EnodeBsApi
 * @extends {BaseAPI}
 */
export class EnodeBsApi extends BaseAPI {
    /**
     * 
     * @summary Unregister an enodeB
     * @param {EnodeBsApiLteNetworkIdEnodebsEnodebSerialDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnodeBsApi
     */
    public lteNetworkIdEnodebsEnodebSerialDelete(requestParameters: EnodeBsApiLteNetworkIdEnodebsEnodebSerialDeleteRequest, options?: AxiosRequestConfig) {
        return EnodeBsApiFp(this.configuration).lteNetworkIdEnodebsEnodebSerialDelete(requestParameters.networkId, requestParameters.enodebSerial, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a specific enodeB configuration
     * @param {EnodeBsApiLteNetworkIdEnodebsEnodebSerialGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnodeBsApi
     */
    public lteNetworkIdEnodebsEnodebSerialGet(requestParameters: EnodeBsApiLteNetworkIdEnodebsEnodebSerialGetRequest, options?: AxiosRequestConfig) {
        return EnodeBsApiFp(this.configuration).lteNetworkIdEnodebsEnodebSerialGet(requestParameters.networkId, requestParameters.enodebSerial, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an enodeB\'s configuration
     * @param {EnodeBsApiLteNetworkIdEnodebsEnodebSerialPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnodeBsApi
     */
    public lteNetworkIdEnodebsEnodebSerialPut(requestParameters: EnodeBsApiLteNetworkIdEnodebsEnodebSerialPutRequest, options?: AxiosRequestConfig) {
        return EnodeBsApiFp(this.configuration).lteNetworkIdEnodebsEnodebSerialPut(requestParameters.networkId, requestParameters.enodebSerial, requestParameters.enodeb, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve reported state from enodeb device
     * @param {EnodeBsApiLteNetworkIdEnodebsEnodebSerialStateGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnodeBsApi
     */
    public lteNetworkIdEnodebsEnodebSerialStateGet(requestParameters: EnodeBsApiLteNetworkIdEnodebsEnodebSerialStateGetRequest, options?: AxiosRequestConfig) {
        return EnodeBsApiFp(this.configuration).lteNetworkIdEnodebsEnodebSerialStateGet(requestParameters.networkId, requestParameters.enodebSerial, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all enodeBs in the network
     * @param {EnodeBsApiLteNetworkIdEnodebsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnodeBsApi
     */
    public lteNetworkIdEnodebsGet(requestParameters: EnodeBsApiLteNetworkIdEnodebsGetRequest, options?: AxiosRequestConfig) {
        return EnodeBsApiFp(this.configuration).lteNetworkIdEnodebsGet(requestParameters.networkId, requestParameters.pageSize, requestParameters.pageToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Register a new enodeB
     * @param {EnodeBsApiLteNetworkIdEnodebsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnodeBsApi
     */
    public lteNetworkIdEnodebsPost(requestParameters: EnodeBsApiLteNetworkIdEnodebsPostRequest, options?: AxiosRequestConfig) {
        return EnodeBsApiFp(this.configuration).lteNetworkIdEnodebsPost(requestParameters.networkId, requestParameters.enodeb, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EventsApi - axios parameter creator
 * @export
 */
export const EventsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get a count of events that match the query
         * @param {string} networkId Network ID
         * @param {string} [streams] Comma-separated list of streams to query
         * @param {string} [events] Comma-separated list of event types to query
         * @param {string} [tags] Comma-separated list of tags to query
         * @param {string} [hwIds] Comma-separated list of hardware IDs to query
         * @param {string} [start] Start time for the query, in RFC3339 or ISO8601 format
         * @param {string} [end] End time for the query, in RFC3339 or ISO8601 format
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsNetworkIdAboutCountGet: async (networkId: string, streams?: string, events?: string, tags?: string, hwIds?: string, start?: string, end?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('eventsNetworkIdAboutCountGet', 'networkId', networkId)
            const localVarPath = `/events/{network_id}/about/count`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (streams !== undefined) {
                localVarQueryParameter['streams'] = streams;
            }

            if (events !== undefined) {
                localVarQueryParameter['events'] = events;
            }

            if (tags !== undefined) {
                localVarQueryParameter['tags'] = tags;
            }

            if (hwIds !== undefined) {
                localVarQueryParameter['hw_ids'] = hwIds;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = end;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Query events
         * @param {string} networkId Network ID
         * @param {string} [streams] Comma-separated list of streams to query
         * @param {string} [events] Comma-separated list of event types to query
         * @param {string} [tags] Comma-separated list of tags to query
         * @param {string} [hwIds] Comma-separated list of hardware IDs to query
         * @param {string} [from] Index to start the query from
         * @param {string} [size] Maximum size to limit the query result to. This defaults to 50
         * @param {string} [start] Start time for the query, in RFC3339 or ISO8601 format
         * @param {string} [end] End time for the query, in RFC3339 or ISO8601 format
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsNetworkIdGet: async (networkId: string, streams?: string, events?: string, tags?: string, hwIds?: string, from?: string, size?: string, start?: string, end?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('eventsNetworkIdGet', 'networkId', networkId)
            const localVarPath = `/events/{network_id}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (streams !== undefined) {
                localVarQueryParameter['streams'] = streams;
            }

            if (events !== undefined) {
                localVarQueryParameter['events'] = events;
            }

            if (tags !== undefined) {
                localVarQueryParameter['tags'] = tags;
            }

            if (hwIds !== undefined) {
                localVarQueryParameter['hw_ids'] = hwIds;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = end;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Query events logged by services
         * @param {string} networkId Network ID
         * @param {string} streamName The user-specified string to categorize events
         * @param {string} [eventType] The type of event to filter the query with.
         * @param {string} [hardwareId] The hardware ID to filter the query with.
         * @param {string} [tag] The event tag to filter the query with.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsNetworkIdStreamNameGet: async (networkId: string, streamName: string, eventType?: string, hardwareId?: string, tag?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('eventsNetworkIdStreamNameGet', 'networkId', networkId)
            // verify required parameter 'streamName' is not null or undefined
            assertParamExists('eventsNetworkIdStreamNameGet', 'streamName', streamName)
            const localVarPath = `/events/{network_id}/{stream_name}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"stream_name"}}`, encodeURIComponent(String(streamName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (eventType !== undefined) {
                localVarQueryParameter['event_type'] = eventType;
            }

            if (hardwareId !== undefined) {
                localVarQueryParameter['hardware_id'] = hardwareId;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventsApi - functional programming interface
 * @export
 */
export const EventsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EventsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get a count of events that match the query
         * @param {string} networkId Network ID
         * @param {string} [streams] Comma-separated list of streams to query
         * @param {string} [events] Comma-separated list of event types to query
         * @param {string} [tags] Comma-separated list of tags to query
         * @param {string} [hwIds] Comma-separated list of hardware IDs to query
         * @param {string} [start] Start time for the query, in RFC3339 or ISO8601 format
         * @param {string} [end] End time for the query, in RFC3339 or ISO8601 format
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eventsNetworkIdAboutCountGet(networkId: string, streams?: string, events?: string, tags?: string, hwIds?: string, start?: string, end?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eventsNetworkIdAboutCountGet(networkId, streams, events, tags, hwIds, start, end, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Query events
         * @param {string} networkId Network ID
         * @param {string} [streams] Comma-separated list of streams to query
         * @param {string} [events] Comma-separated list of event types to query
         * @param {string} [tags] Comma-separated list of tags to query
         * @param {string} [hwIds] Comma-separated list of hardware IDs to query
         * @param {string} [from] Index to start the query from
         * @param {string} [size] Maximum size to limit the query result to. This defaults to 50
         * @param {string} [start] Start time for the query, in RFC3339 or ISO8601 format
         * @param {string} [end] End time for the query, in RFC3339 or ISO8601 format
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eventsNetworkIdGet(networkId: string, streams?: string, events?: string, tags?: string, hwIds?: string, from?: string, size?: string, start?: string, end?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Event>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eventsNetworkIdGet(networkId, streams, events, tags, hwIds, from, size, start, end, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Query events logged by services
         * @param {string} networkId Network ID
         * @param {string} streamName The user-specified string to categorize events
         * @param {string} [eventType] The type of event to filter the query with.
         * @param {string} [hardwareId] The hardware ID to filter the query with.
         * @param {string} [tag] The event tag to filter the query with.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eventsNetworkIdStreamNameGet(networkId: string, streamName: string, eventType?: string, hardwareId?: string, tag?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Event>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eventsNetworkIdStreamNameGet(networkId, streamName, eventType, hardwareId, tag, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EventsApi - factory interface
 * @export
 */
export const EventsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EventsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get a count of events that match the query
         * @param {string} networkId Network ID
         * @param {string} [streams] Comma-separated list of streams to query
         * @param {string} [events] Comma-separated list of event types to query
         * @param {string} [tags] Comma-separated list of tags to query
         * @param {string} [hwIds] Comma-separated list of hardware IDs to query
         * @param {string} [start] Start time for the query, in RFC3339 or ISO8601 format
         * @param {string} [end] End time for the query, in RFC3339 or ISO8601 format
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsNetworkIdAboutCountGet(networkId: string, streams?: string, events?: string, tags?: string, hwIds?: string, start?: string, end?: string, options?: any): AxiosPromise<number> {
            return localVarFp.eventsNetworkIdAboutCountGet(networkId, streams, events, tags, hwIds, start, end, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Query events
         * @param {string} networkId Network ID
         * @param {string} [streams] Comma-separated list of streams to query
         * @param {string} [events] Comma-separated list of event types to query
         * @param {string} [tags] Comma-separated list of tags to query
         * @param {string} [hwIds] Comma-separated list of hardware IDs to query
         * @param {string} [from] Index to start the query from
         * @param {string} [size] Maximum size to limit the query result to. This defaults to 50
         * @param {string} [start] Start time for the query, in RFC3339 or ISO8601 format
         * @param {string} [end] End time for the query, in RFC3339 or ISO8601 format
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsNetworkIdGet(networkId: string, streams?: string, events?: string, tags?: string, hwIds?: string, from?: string, size?: string, start?: string, end?: string, options?: any): AxiosPromise<Array<Event>> {
            return localVarFp.eventsNetworkIdGet(networkId, streams, events, tags, hwIds, from, size, start, end, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Query events logged by services
         * @param {string} networkId Network ID
         * @param {string} streamName The user-specified string to categorize events
         * @param {string} [eventType] The type of event to filter the query with.
         * @param {string} [hardwareId] The hardware ID to filter the query with.
         * @param {string} [tag] The event tag to filter the query with.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsNetworkIdStreamNameGet(networkId: string, streamName: string, eventType?: string, hardwareId?: string, tag?: string, options?: any): AxiosPromise<Array<Event>> {
            return localVarFp.eventsNetworkIdStreamNameGet(networkId, streamName, eventType, hardwareId, tag, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for eventsNetworkIdAboutCountGet operation in EventsApi.
 * @export
 * @interface EventsApiEventsNetworkIdAboutCountGetRequest
 */
export interface EventsApiEventsNetworkIdAboutCountGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof EventsApiEventsNetworkIdAboutCountGet
     */
    readonly networkId: string

    /**
     * Comma-separated list of streams to query
     * @type {string}
     * @memberof EventsApiEventsNetworkIdAboutCountGet
     */
    readonly streams?: string

    /**
     * Comma-separated list of event types to query
     * @type {string}
     * @memberof EventsApiEventsNetworkIdAboutCountGet
     */
    readonly events?: string

    /**
     * Comma-separated list of tags to query
     * @type {string}
     * @memberof EventsApiEventsNetworkIdAboutCountGet
     */
    readonly tags?: string

    /**
     * Comma-separated list of hardware IDs to query
     * @type {string}
     * @memberof EventsApiEventsNetworkIdAboutCountGet
     */
    readonly hwIds?: string

    /**
     * Start time for the query, in RFC3339 or ISO8601 format
     * @type {string}
     * @memberof EventsApiEventsNetworkIdAboutCountGet
     */
    readonly start?: string

    /**
     * End time for the query, in RFC3339 or ISO8601 format
     * @type {string}
     * @memberof EventsApiEventsNetworkIdAboutCountGet
     */
    readonly end?: string
}

/**
 * Request parameters for eventsNetworkIdGet operation in EventsApi.
 * @export
 * @interface EventsApiEventsNetworkIdGetRequest
 */
export interface EventsApiEventsNetworkIdGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof EventsApiEventsNetworkIdGet
     */
    readonly networkId: string

    /**
     * Comma-separated list of streams to query
     * @type {string}
     * @memberof EventsApiEventsNetworkIdGet
     */
    readonly streams?: string

    /**
     * Comma-separated list of event types to query
     * @type {string}
     * @memberof EventsApiEventsNetworkIdGet
     */
    readonly events?: string

    /**
     * Comma-separated list of tags to query
     * @type {string}
     * @memberof EventsApiEventsNetworkIdGet
     */
    readonly tags?: string

    /**
     * Comma-separated list of hardware IDs to query
     * @type {string}
     * @memberof EventsApiEventsNetworkIdGet
     */
    readonly hwIds?: string

    /**
     * Index to start the query from
     * @type {string}
     * @memberof EventsApiEventsNetworkIdGet
     */
    readonly from?: string

    /**
     * Maximum size to limit the query result to. This defaults to 50
     * @type {string}
     * @memberof EventsApiEventsNetworkIdGet
     */
    readonly size?: string

    /**
     * Start time for the query, in RFC3339 or ISO8601 format
     * @type {string}
     * @memberof EventsApiEventsNetworkIdGet
     */
    readonly start?: string

    /**
     * End time for the query, in RFC3339 or ISO8601 format
     * @type {string}
     * @memberof EventsApiEventsNetworkIdGet
     */
    readonly end?: string
}

/**
 * Request parameters for eventsNetworkIdStreamNameGet operation in EventsApi.
 * @export
 * @interface EventsApiEventsNetworkIdStreamNameGetRequest
 */
export interface EventsApiEventsNetworkIdStreamNameGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof EventsApiEventsNetworkIdStreamNameGet
     */
    readonly networkId: string

    /**
     * The user-specified string to categorize events
     * @type {string}
     * @memberof EventsApiEventsNetworkIdStreamNameGet
     */
    readonly streamName: string

    /**
     * The type of event to filter the query with.
     * @type {string}
     * @memberof EventsApiEventsNetworkIdStreamNameGet
     */
    readonly eventType?: string

    /**
     * The hardware ID to filter the query with.
     * @type {string}
     * @memberof EventsApiEventsNetworkIdStreamNameGet
     */
    readonly hardwareId?: string

    /**
     * The event tag to filter the query with.
     * @type {string}
     * @memberof EventsApiEventsNetworkIdStreamNameGet
     */
    readonly tag?: string
}

/**
 * EventsApi - object-oriented interface
 * @export
 * @class EventsApi
 * @extends {BaseAPI}
 */
export class EventsApi extends BaseAPI {
    /**
     * 
     * @summary Get a count of events that match the query
     * @param {EventsApiEventsNetworkIdAboutCountGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public eventsNetworkIdAboutCountGet(requestParameters: EventsApiEventsNetworkIdAboutCountGetRequest, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).eventsNetworkIdAboutCountGet(requestParameters.networkId, requestParameters.streams, requestParameters.events, requestParameters.tags, requestParameters.hwIds, requestParameters.start, requestParameters.end, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Query events
     * @param {EventsApiEventsNetworkIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public eventsNetworkIdGet(requestParameters: EventsApiEventsNetworkIdGetRequest, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).eventsNetworkIdGet(requestParameters.networkId, requestParameters.streams, requestParameters.events, requestParameters.tags, requestParameters.hwIds, requestParameters.from, requestParameters.size, requestParameters.start, requestParameters.end, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Query events logged by services
     * @param {EventsApiEventsNetworkIdStreamNameGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public eventsNetworkIdStreamNameGet(requestParameters: EventsApiEventsNetworkIdStreamNameGetRequest, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).eventsNetworkIdStreamNameGet(requestParameters.networkId, requestParameters.streamName, requestParameters.eventType, requestParameters.hardwareId, requestParameters.tag, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FederatedLTENetworksApi - axios parameter creator
 * @export
 */
export const FederatedLTENetworksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List all federated LTE network IDs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fegLteGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/feg_lte`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a federated LTE network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fegLteNetworkIdDelete: async (networkId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('fegLteNetworkIdDelete', 'networkId', networkId)
            const localVarPath = `/feg_lte/{network_id}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Network FeG Configs
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fegLteNetworkIdFederationDelete: async (networkId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('fegLteNetworkIdFederationDelete', 'networkId', networkId)
            const localVarPath = `/feg_lte/{network_id}/federation`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Network FeG Configs
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fegLteNetworkIdFederationGet: async (networkId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('fegLteNetworkIdFederationGet', 'networkId', networkId)
            const localVarPath = `/feg_lte/{network_id}/federation`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create or Modify Network FeG Configs
         * @param {string} networkId Network ID
         * @param {FederatedNetworkConfigs} config Updated config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fegLteNetworkIdFederationPut: async (networkId: string, config: FederatedNetworkConfigs, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('fegLteNetworkIdFederationPut', 'networkId', networkId)
            // verify required parameter 'config' is not null or undefined
            assertParamExists('fegLteNetworkIdFederationPut', 'config', config)
            const localVarPath = `/feg_lte/{network_id}/federation`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(config, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Describe a federated LTE network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fegLteNetworkIdGet: async (networkId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('fegLteNetworkIdGet', 'networkId', networkId)
            const localVarPath = `/feg_lte/{network_id}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an entire federated LTE network
         * @param {string} networkId Network ID
         * @param {FegLteNetwork} lteNetwork Full desired configuration of the network
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fegLteNetworkIdPut: async (networkId: string, lteNetwork: FegLteNetwork, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('fegLteNetworkIdPut', 'networkId', networkId)
            // verify required parameter 'lteNetwork' is not null or undefined
            assertParamExists('fegLteNetworkIdPut', 'lteNetwork', lteNetwork)
            const localVarPath = `/feg_lte/{network_id}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(lteNetwork, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add a network-wide base name
         * @param {string} networkId Network ID
         * @param {string} baseName Charging Rule Base Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fegLteNetworkIdSubscriberConfigBaseNamesBaseNameDelete: async (networkId: string, baseName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('fegLteNetworkIdSubscriberConfigBaseNamesBaseNameDelete', 'networkId', networkId)
            // verify required parameter 'baseName' is not null or undefined
            assertParamExists('fegLteNetworkIdSubscriberConfigBaseNamesBaseNameDelete', 'baseName', baseName)
            const localVarPath = `/feg_lte/{network_id}/subscriber_config/base_names/{base_name}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"base_name"}}`, encodeURIComponent(String(baseName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add a network-wide base name
         * @param {string} networkId Network ID
         * @param {string} baseName Charging Rule Base Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fegLteNetworkIdSubscriberConfigBaseNamesBaseNamePost: async (networkId: string, baseName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('fegLteNetworkIdSubscriberConfigBaseNamesBaseNamePost', 'networkId', networkId)
            // verify required parameter 'baseName' is not null or undefined
            assertParamExists('fegLteNetworkIdSubscriberConfigBaseNamesBaseNamePost', 'baseName', baseName)
            const localVarPath = `/feg_lte/{network_id}/subscriber_config/base_names/{base_name}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"base_name"}}`, encodeURIComponent(String(baseName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get network-wide base names
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fegLteNetworkIdSubscriberConfigBaseNamesGet: async (networkId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('fegLteNetworkIdSubscriberConfigBaseNamesGet', 'networkId', networkId)
            const localVarPath = `/feg_lte/{network_id}/subscriber_config/base_names`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update network-wide base names
         * @param {string} networkId Network ID
         * @param {Array<string>} record Subscriber Config for the Network
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fegLteNetworkIdSubscriberConfigBaseNamesPut: async (networkId: string, record: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('fegLteNetworkIdSubscriberConfigBaseNamesPut', 'networkId', networkId)
            // verify required parameter 'record' is not null or undefined
            assertParamExists('fegLteNetworkIdSubscriberConfigBaseNamesPut', 'record', record)
            const localVarPath = `/feg_lte/{network_id}/subscriber_config/base_names`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(record, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a network-wide subscriber config
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fegLteNetworkIdSubscriberConfigGet: async (networkId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('fegLteNetworkIdSubscriberConfigGet', 'networkId', networkId)
            const localVarPath = `/feg_lte/{network_id}/subscriber_config`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a network-wide subscriber config
         * @param {string} networkId Network ID
         * @param {NetworkSubscriberConfig} record Subscriber Config for the Network
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fegLteNetworkIdSubscriberConfigPut: async (networkId: string, record: NetworkSubscriberConfig, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('fegLteNetworkIdSubscriberConfigPut', 'networkId', networkId)
            // verify required parameter 'record' is not null or undefined
            assertParamExists('fegLteNetworkIdSubscriberConfigPut', 'record', record)
            const localVarPath = `/feg_lte/{network_id}/subscriber_config`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(record, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get network-wide rule names
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fegLteNetworkIdSubscriberConfigRuleNamesGet: async (networkId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('fegLteNetworkIdSubscriberConfigRuleNamesGet', 'networkId', networkId)
            const localVarPath = `/feg_lte/{network_id}/subscriber_config/rule_names`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update network-wide rule names
         * @param {string} networkId Network ID
         * @param {Array<string>} record Subscriber Config for the Network
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fegLteNetworkIdSubscriberConfigRuleNamesPut: async (networkId: string, record: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('fegLteNetworkIdSubscriberConfigRuleNamesPut', 'networkId', networkId)
            // verify required parameter 'record' is not null or undefined
            assertParamExists('fegLteNetworkIdSubscriberConfigRuleNamesPut', 'record', record)
            const localVarPath = `/feg_lte/{network_id}/subscriber_config/rule_names`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(record, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add a network-wide rule name
         * @param {string} networkId Network ID
         * @param {string} ruleId Rule Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fegLteNetworkIdSubscriberConfigRuleNamesRuleIdDelete: async (networkId: string, ruleId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('fegLteNetworkIdSubscriberConfigRuleNamesRuleIdDelete', 'networkId', networkId)
            // verify required parameter 'ruleId' is not null or undefined
            assertParamExists('fegLteNetworkIdSubscriberConfigRuleNamesRuleIdDelete', 'ruleId', ruleId)
            const localVarPath = `/feg_lte/{network_id}/subscriber_config/rule_names/{rule_id}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"rule_id"}}`, encodeURIComponent(String(ruleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add a network-wide rule name
         * @param {string} networkId Network ID
         * @param {string} ruleId Rule Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fegLteNetworkIdSubscriberConfigRuleNamesRuleIdPost: async (networkId: string, ruleId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('fegLteNetworkIdSubscriberConfigRuleNamesRuleIdPost', 'networkId', networkId)
            // verify required parameter 'ruleId' is not null or undefined
            assertParamExists('fegLteNetworkIdSubscriberConfigRuleNamesRuleIdPost', 'ruleId', ruleId)
            const localVarPath = `/feg_lte/{network_id}/subscriber_config/rule_names/{rule_id}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"rule_id"}}`, encodeURIComponent(String(ruleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new federated LTE network
         * @param {FegLteNetwork} lteNetwork Configuration of the network to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fegLtePost: async (lteNetwork: FegLteNetwork, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'lteNetwork' is not null or undefined
            assertParamExists('fegLtePost', 'lteNetwork', lteNetwork)
            const localVarPath = `/feg_lte`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(lteNetwork, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FederatedLTENetworksApi - functional programming interface
 * @export
 */
export const FederatedLTENetworksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FederatedLTENetworksApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List all federated LTE network IDs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fegLteGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fegLteGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a federated LTE network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fegLteNetworkIdDelete(networkId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fegLteNetworkIdDelete(networkId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete Network FeG Configs
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fegLteNetworkIdFederationDelete(networkId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fegLteNetworkIdFederationDelete(networkId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve Network FeG Configs
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fegLteNetworkIdFederationGet(networkId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FederatedNetworkConfigs>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fegLteNetworkIdFederationGet(networkId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create or Modify Network FeG Configs
         * @param {string} networkId Network ID
         * @param {FederatedNetworkConfigs} config Updated config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fegLteNetworkIdFederationPut(networkId: string, config: FederatedNetworkConfigs, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fegLteNetworkIdFederationPut(networkId, config, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Describe a federated LTE network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fegLteNetworkIdGet(networkId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FegLteNetwork>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fegLteNetworkIdGet(networkId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update an entire federated LTE network
         * @param {string} networkId Network ID
         * @param {FegLteNetwork} lteNetwork Full desired configuration of the network
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fegLteNetworkIdPut(networkId: string, lteNetwork: FegLteNetwork, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fegLteNetworkIdPut(networkId, lteNetwork, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add a network-wide base name
         * @param {string} networkId Network ID
         * @param {string} baseName Charging Rule Base Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fegLteNetworkIdSubscriberConfigBaseNamesBaseNameDelete(networkId: string, baseName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fegLteNetworkIdSubscriberConfigBaseNamesBaseNameDelete(networkId, baseName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add a network-wide base name
         * @param {string} networkId Network ID
         * @param {string} baseName Charging Rule Base Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fegLteNetworkIdSubscriberConfigBaseNamesBaseNamePost(networkId: string, baseName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fegLteNetworkIdSubscriberConfigBaseNamesBaseNamePost(networkId, baseName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get network-wide base names
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fegLteNetworkIdSubscriberConfigBaseNamesGet(networkId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fegLteNetworkIdSubscriberConfigBaseNamesGet(networkId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update network-wide base names
         * @param {string} networkId Network ID
         * @param {Array<string>} record Subscriber Config for the Network
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fegLteNetworkIdSubscriberConfigBaseNamesPut(networkId: string, record: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fegLteNetworkIdSubscriberConfigBaseNamesPut(networkId, record, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a network-wide subscriber config
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fegLteNetworkIdSubscriberConfigGet(networkId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NetworkSubscriberConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fegLteNetworkIdSubscriberConfigGet(networkId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a network-wide subscriber config
         * @param {string} networkId Network ID
         * @param {NetworkSubscriberConfig} record Subscriber Config for the Network
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fegLteNetworkIdSubscriberConfigPut(networkId: string, record: NetworkSubscriberConfig, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fegLteNetworkIdSubscriberConfigPut(networkId, record, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get network-wide rule names
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fegLteNetworkIdSubscriberConfigRuleNamesGet(networkId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fegLteNetworkIdSubscriberConfigRuleNamesGet(networkId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update network-wide rule names
         * @param {string} networkId Network ID
         * @param {Array<string>} record Subscriber Config for the Network
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fegLteNetworkIdSubscriberConfigRuleNamesPut(networkId: string, record: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fegLteNetworkIdSubscriberConfigRuleNamesPut(networkId, record, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add a network-wide rule name
         * @param {string} networkId Network ID
         * @param {string} ruleId Rule Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fegLteNetworkIdSubscriberConfigRuleNamesRuleIdDelete(networkId: string, ruleId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fegLteNetworkIdSubscriberConfigRuleNamesRuleIdDelete(networkId, ruleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add a network-wide rule name
         * @param {string} networkId Network ID
         * @param {string} ruleId Rule Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fegLteNetworkIdSubscriberConfigRuleNamesRuleIdPost(networkId: string, ruleId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fegLteNetworkIdSubscriberConfigRuleNamesRuleIdPost(networkId, ruleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a new federated LTE network
         * @param {FegLteNetwork} lteNetwork Configuration of the network to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fegLtePost(lteNetwork: FegLteNetwork, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fegLtePost(lteNetwork, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FederatedLTENetworksApi - factory interface
 * @export
 */
export const FederatedLTENetworksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FederatedLTENetworksApiFp(configuration)
    return {
        /**
         * 
         * @summary List all federated LTE network IDs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fegLteGet(options?: any): AxiosPromise<Array<string>> {
            return localVarFp.fegLteGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a federated LTE network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fegLteNetworkIdDelete(networkId: string, options?: any): AxiosPromise<void> {
            return localVarFp.fegLteNetworkIdDelete(networkId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Network FeG Configs
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fegLteNetworkIdFederationDelete(networkId: string, options?: any): AxiosPromise<void> {
            return localVarFp.fegLteNetworkIdFederationDelete(networkId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve Network FeG Configs
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fegLteNetworkIdFederationGet(networkId: string, options?: any): AxiosPromise<FederatedNetworkConfigs> {
            return localVarFp.fegLteNetworkIdFederationGet(networkId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create or Modify Network FeG Configs
         * @param {string} networkId Network ID
         * @param {FederatedNetworkConfigs} config Updated config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fegLteNetworkIdFederationPut(networkId: string, config: FederatedNetworkConfigs, options?: any): AxiosPromise<void> {
            return localVarFp.fegLteNetworkIdFederationPut(networkId, config, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Describe a federated LTE network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fegLteNetworkIdGet(networkId: string, options?: any): AxiosPromise<FegLteNetwork> {
            return localVarFp.fegLteNetworkIdGet(networkId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an entire federated LTE network
         * @param {string} networkId Network ID
         * @param {FegLteNetwork} lteNetwork Full desired configuration of the network
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fegLteNetworkIdPut(networkId: string, lteNetwork: FegLteNetwork, options?: any): AxiosPromise<void> {
            return localVarFp.fegLteNetworkIdPut(networkId, lteNetwork, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add a network-wide base name
         * @param {string} networkId Network ID
         * @param {string} baseName Charging Rule Base Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fegLteNetworkIdSubscriberConfigBaseNamesBaseNameDelete(networkId: string, baseName: string, options?: any): AxiosPromise<void> {
            return localVarFp.fegLteNetworkIdSubscriberConfigBaseNamesBaseNameDelete(networkId, baseName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add a network-wide base name
         * @param {string} networkId Network ID
         * @param {string} baseName Charging Rule Base Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fegLteNetworkIdSubscriberConfigBaseNamesBaseNamePost(networkId: string, baseName: string, options?: any): AxiosPromise<void> {
            return localVarFp.fegLteNetworkIdSubscriberConfigBaseNamesBaseNamePost(networkId, baseName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get network-wide base names
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fegLteNetworkIdSubscriberConfigBaseNamesGet(networkId: string, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.fegLteNetworkIdSubscriberConfigBaseNamesGet(networkId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update network-wide base names
         * @param {string} networkId Network ID
         * @param {Array<string>} record Subscriber Config for the Network
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fegLteNetworkIdSubscriberConfigBaseNamesPut(networkId: string, record: Array<string>, options?: any): AxiosPromise<void> {
            return localVarFp.fegLteNetworkIdSubscriberConfigBaseNamesPut(networkId, record, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a network-wide subscriber config
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fegLteNetworkIdSubscriberConfigGet(networkId: string, options?: any): AxiosPromise<NetworkSubscriberConfig> {
            return localVarFp.fegLteNetworkIdSubscriberConfigGet(networkId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a network-wide subscriber config
         * @param {string} networkId Network ID
         * @param {NetworkSubscriberConfig} record Subscriber Config for the Network
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fegLteNetworkIdSubscriberConfigPut(networkId: string, record: NetworkSubscriberConfig, options?: any): AxiosPromise<void> {
            return localVarFp.fegLteNetworkIdSubscriberConfigPut(networkId, record, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get network-wide rule names
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fegLteNetworkIdSubscriberConfigRuleNamesGet(networkId: string, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.fegLteNetworkIdSubscriberConfigRuleNamesGet(networkId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update network-wide rule names
         * @param {string} networkId Network ID
         * @param {Array<string>} record Subscriber Config for the Network
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fegLteNetworkIdSubscriberConfigRuleNamesPut(networkId: string, record: Array<string>, options?: any): AxiosPromise<void> {
            return localVarFp.fegLteNetworkIdSubscriberConfigRuleNamesPut(networkId, record, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add a network-wide rule name
         * @param {string} networkId Network ID
         * @param {string} ruleId Rule Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fegLteNetworkIdSubscriberConfigRuleNamesRuleIdDelete(networkId: string, ruleId: string, options?: any): AxiosPromise<void> {
            return localVarFp.fegLteNetworkIdSubscriberConfigRuleNamesRuleIdDelete(networkId, ruleId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add a network-wide rule name
         * @param {string} networkId Network ID
         * @param {string} ruleId Rule Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fegLteNetworkIdSubscriberConfigRuleNamesRuleIdPost(networkId: string, ruleId: string, options?: any): AxiosPromise<void> {
            return localVarFp.fegLteNetworkIdSubscriberConfigRuleNamesRuleIdPost(networkId, ruleId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new federated LTE network
         * @param {FegLteNetwork} lteNetwork Configuration of the network to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fegLtePost(lteNetwork: FegLteNetwork, options?: any): AxiosPromise<void> {
            return localVarFp.fegLtePost(lteNetwork, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for fegLteNetworkIdDelete operation in FederatedLTENetworksApi.
 * @export
 * @interface FederatedLTENetworksApiFegLteNetworkIdDeleteRequest
 */
export interface FederatedLTENetworksApiFegLteNetworkIdDeleteRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof FederatedLTENetworksApiFegLteNetworkIdDelete
     */
    readonly networkId: string
}

/**
 * Request parameters for fegLteNetworkIdFederationDelete operation in FederatedLTENetworksApi.
 * @export
 * @interface FederatedLTENetworksApiFegLteNetworkIdFederationDeleteRequest
 */
export interface FederatedLTENetworksApiFegLteNetworkIdFederationDeleteRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof FederatedLTENetworksApiFegLteNetworkIdFederationDelete
     */
    readonly networkId: string
}

/**
 * Request parameters for fegLteNetworkIdFederationGet operation in FederatedLTENetworksApi.
 * @export
 * @interface FederatedLTENetworksApiFegLteNetworkIdFederationGetRequest
 */
export interface FederatedLTENetworksApiFegLteNetworkIdFederationGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof FederatedLTENetworksApiFegLteNetworkIdFederationGet
     */
    readonly networkId: string
}

/**
 * Request parameters for fegLteNetworkIdFederationPut operation in FederatedLTENetworksApi.
 * @export
 * @interface FederatedLTENetworksApiFegLteNetworkIdFederationPutRequest
 */
export interface FederatedLTENetworksApiFegLteNetworkIdFederationPutRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof FederatedLTENetworksApiFegLteNetworkIdFederationPut
     */
    readonly networkId: string

    /**
     * Updated config
     * @type {FederatedNetworkConfigs}
     * @memberof FederatedLTENetworksApiFegLteNetworkIdFederationPut
     */
    readonly config: FederatedNetworkConfigs
}

/**
 * Request parameters for fegLteNetworkIdGet operation in FederatedLTENetworksApi.
 * @export
 * @interface FederatedLTENetworksApiFegLteNetworkIdGetRequest
 */
export interface FederatedLTENetworksApiFegLteNetworkIdGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof FederatedLTENetworksApiFegLteNetworkIdGet
     */
    readonly networkId: string
}

/**
 * Request parameters for fegLteNetworkIdPut operation in FederatedLTENetworksApi.
 * @export
 * @interface FederatedLTENetworksApiFegLteNetworkIdPutRequest
 */
export interface FederatedLTENetworksApiFegLteNetworkIdPutRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof FederatedLTENetworksApiFegLteNetworkIdPut
     */
    readonly networkId: string

    /**
     * Full desired configuration of the network
     * @type {FegLteNetwork}
     * @memberof FederatedLTENetworksApiFegLteNetworkIdPut
     */
    readonly lteNetwork: FegLteNetwork
}

/**
 * Request parameters for fegLteNetworkIdSubscriberConfigBaseNamesBaseNameDelete operation in FederatedLTENetworksApi.
 * @export
 * @interface FederatedLTENetworksApiFegLteNetworkIdSubscriberConfigBaseNamesBaseNameDeleteRequest
 */
export interface FederatedLTENetworksApiFegLteNetworkIdSubscriberConfigBaseNamesBaseNameDeleteRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof FederatedLTENetworksApiFegLteNetworkIdSubscriberConfigBaseNamesBaseNameDelete
     */
    readonly networkId: string

    /**
     * Charging Rule Base Name
     * @type {string}
     * @memberof FederatedLTENetworksApiFegLteNetworkIdSubscriberConfigBaseNamesBaseNameDelete
     */
    readonly baseName: string
}

/**
 * Request parameters for fegLteNetworkIdSubscriberConfigBaseNamesBaseNamePost operation in FederatedLTENetworksApi.
 * @export
 * @interface FederatedLTENetworksApiFegLteNetworkIdSubscriberConfigBaseNamesBaseNamePostRequest
 */
export interface FederatedLTENetworksApiFegLteNetworkIdSubscriberConfigBaseNamesBaseNamePostRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof FederatedLTENetworksApiFegLteNetworkIdSubscriberConfigBaseNamesBaseNamePost
     */
    readonly networkId: string

    /**
     * Charging Rule Base Name
     * @type {string}
     * @memberof FederatedLTENetworksApiFegLteNetworkIdSubscriberConfigBaseNamesBaseNamePost
     */
    readonly baseName: string
}

/**
 * Request parameters for fegLteNetworkIdSubscriberConfigBaseNamesGet operation in FederatedLTENetworksApi.
 * @export
 * @interface FederatedLTENetworksApiFegLteNetworkIdSubscriberConfigBaseNamesGetRequest
 */
export interface FederatedLTENetworksApiFegLteNetworkIdSubscriberConfigBaseNamesGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof FederatedLTENetworksApiFegLteNetworkIdSubscriberConfigBaseNamesGet
     */
    readonly networkId: string
}

/**
 * Request parameters for fegLteNetworkIdSubscriberConfigBaseNamesPut operation in FederatedLTENetworksApi.
 * @export
 * @interface FederatedLTENetworksApiFegLteNetworkIdSubscriberConfigBaseNamesPutRequest
 */
export interface FederatedLTENetworksApiFegLteNetworkIdSubscriberConfigBaseNamesPutRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof FederatedLTENetworksApiFegLteNetworkIdSubscriberConfigBaseNamesPut
     */
    readonly networkId: string

    /**
     * Subscriber Config for the Network
     * @type {Array<string>}
     * @memberof FederatedLTENetworksApiFegLteNetworkIdSubscriberConfigBaseNamesPut
     */
    readonly record: Array<string>
}

/**
 * Request parameters for fegLteNetworkIdSubscriberConfigGet operation in FederatedLTENetworksApi.
 * @export
 * @interface FederatedLTENetworksApiFegLteNetworkIdSubscriberConfigGetRequest
 */
export interface FederatedLTENetworksApiFegLteNetworkIdSubscriberConfigGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof FederatedLTENetworksApiFegLteNetworkIdSubscriberConfigGet
     */
    readonly networkId: string
}

/**
 * Request parameters for fegLteNetworkIdSubscriberConfigPut operation in FederatedLTENetworksApi.
 * @export
 * @interface FederatedLTENetworksApiFegLteNetworkIdSubscriberConfigPutRequest
 */
export interface FederatedLTENetworksApiFegLteNetworkIdSubscriberConfigPutRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof FederatedLTENetworksApiFegLteNetworkIdSubscriberConfigPut
     */
    readonly networkId: string

    /**
     * Subscriber Config for the Network
     * @type {NetworkSubscriberConfig}
     * @memberof FederatedLTENetworksApiFegLteNetworkIdSubscriberConfigPut
     */
    readonly record: NetworkSubscriberConfig
}

/**
 * Request parameters for fegLteNetworkIdSubscriberConfigRuleNamesGet operation in FederatedLTENetworksApi.
 * @export
 * @interface FederatedLTENetworksApiFegLteNetworkIdSubscriberConfigRuleNamesGetRequest
 */
export interface FederatedLTENetworksApiFegLteNetworkIdSubscriberConfigRuleNamesGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof FederatedLTENetworksApiFegLteNetworkIdSubscriberConfigRuleNamesGet
     */
    readonly networkId: string
}

/**
 * Request parameters for fegLteNetworkIdSubscriberConfigRuleNamesPut operation in FederatedLTENetworksApi.
 * @export
 * @interface FederatedLTENetworksApiFegLteNetworkIdSubscriberConfigRuleNamesPutRequest
 */
export interface FederatedLTENetworksApiFegLteNetworkIdSubscriberConfigRuleNamesPutRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof FederatedLTENetworksApiFegLteNetworkIdSubscriberConfigRuleNamesPut
     */
    readonly networkId: string

    /**
     * Subscriber Config for the Network
     * @type {Array<string>}
     * @memberof FederatedLTENetworksApiFegLteNetworkIdSubscriberConfigRuleNamesPut
     */
    readonly record: Array<string>
}

/**
 * Request parameters for fegLteNetworkIdSubscriberConfigRuleNamesRuleIdDelete operation in FederatedLTENetworksApi.
 * @export
 * @interface FederatedLTENetworksApiFegLteNetworkIdSubscriberConfigRuleNamesRuleIdDeleteRequest
 */
export interface FederatedLTENetworksApiFegLteNetworkIdSubscriberConfigRuleNamesRuleIdDeleteRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof FederatedLTENetworksApiFegLteNetworkIdSubscriberConfigRuleNamesRuleIdDelete
     */
    readonly networkId: string

    /**
     * Rule Id
     * @type {string}
     * @memberof FederatedLTENetworksApiFegLteNetworkIdSubscriberConfigRuleNamesRuleIdDelete
     */
    readonly ruleId: string
}

/**
 * Request parameters for fegLteNetworkIdSubscriberConfigRuleNamesRuleIdPost operation in FederatedLTENetworksApi.
 * @export
 * @interface FederatedLTENetworksApiFegLteNetworkIdSubscriberConfigRuleNamesRuleIdPostRequest
 */
export interface FederatedLTENetworksApiFegLteNetworkIdSubscriberConfigRuleNamesRuleIdPostRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof FederatedLTENetworksApiFegLteNetworkIdSubscriberConfigRuleNamesRuleIdPost
     */
    readonly networkId: string

    /**
     * Rule Id
     * @type {string}
     * @memberof FederatedLTENetworksApiFegLteNetworkIdSubscriberConfigRuleNamesRuleIdPost
     */
    readonly ruleId: string
}

/**
 * Request parameters for fegLtePost operation in FederatedLTENetworksApi.
 * @export
 * @interface FederatedLTENetworksApiFegLtePostRequest
 */
export interface FederatedLTENetworksApiFegLtePostRequest {
    /**
     * Configuration of the network to create
     * @type {FegLteNetwork}
     * @memberof FederatedLTENetworksApiFegLtePost
     */
    readonly lteNetwork: FegLteNetwork
}

/**
 * FederatedLTENetworksApi - object-oriented interface
 * @export
 * @class FederatedLTENetworksApi
 * @extends {BaseAPI}
 */
export class FederatedLTENetworksApi extends BaseAPI {
    /**
     * 
     * @summary List all federated LTE network IDs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FederatedLTENetworksApi
     */
    public fegLteGet(options?: AxiosRequestConfig) {
        return FederatedLTENetworksApiFp(this.configuration).fegLteGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a federated LTE network
     * @param {FederatedLTENetworksApiFegLteNetworkIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FederatedLTENetworksApi
     */
    public fegLteNetworkIdDelete(requestParameters: FederatedLTENetworksApiFegLteNetworkIdDeleteRequest, options?: AxiosRequestConfig) {
        return FederatedLTENetworksApiFp(this.configuration).fegLteNetworkIdDelete(requestParameters.networkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Network FeG Configs
     * @param {FederatedLTENetworksApiFegLteNetworkIdFederationDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FederatedLTENetworksApi
     */
    public fegLteNetworkIdFederationDelete(requestParameters: FederatedLTENetworksApiFegLteNetworkIdFederationDeleteRequest, options?: AxiosRequestConfig) {
        return FederatedLTENetworksApiFp(this.configuration).fegLteNetworkIdFederationDelete(requestParameters.networkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve Network FeG Configs
     * @param {FederatedLTENetworksApiFegLteNetworkIdFederationGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FederatedLTENetworksApi
     */
    public fegLteNetworkIdFederationGet(requestParameters: FederatedLTENetworksApiFegLteNetworkIdFederationGetRequest, options?: AxiosRequestConfig) {
        return FederatedLTENetworksApiFp(this.configuration).fegLteNetworkIdFederationGet(requestParameters.networkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create or Modify Network FeG Configs
     * @param {FederatedLTENetworksApiFegLteNetworkIdFederationPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FederatedLTENetworksApi
     */
    public fegLteNetworkIdFederationPut(requestParameters: FederatedLTENetworksApiFegLteNetworkIdFederationPutRequest, options?: AxiosRequestConfig) {
        return FederatedLTENetworksApiFp(this.configuration).fegLteNetworkIdFederationPut(requestParameters.networkId, requestParameters.config, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Describe a federated LTE network
     * @param {FederatedLTENetworksApiFegLteNetworkIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FederatedLTENetworksApi
     */
    public fegLteNetworkIdGet(requestParameters: FederatedLTENetworksApiFegLteNetworkIdGetRequest, options?: AxiosRequestConfig) {
        return FederatedLTENetworksApiFp(this.configuration).fegLteNetworkIdGet(requestParameters.networkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an entire federated LTE network
     * @param {FederatedLTENetworksApiFegLteNetworkIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FederatedLTENetworksApi
     */
    public fegLteNetworkIdPut(requestParameters: FederatedLTENetworksApiFegLteNetworkIdPutRequest, options?: AxiosRequestConfig) {
        return FederatedLTENetworksApiFp(this.configuration).fegLteNetworkIdPut(requestParameters.networkId, requestParameters.lteNetwork, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add a network-wide base name
     * @param {FederatedLTENetworksApiFegLteNetworkIdSubscriberConfigBaseNamesBaseNameDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FederatedLTENetworksApi
     */
    public fegLteNetworkIdSubscriberConfigBaseNamesBaseNameDelete(requestParameters: FederatedLTENetworksApiFegLteNetworkIdSubscriberConfigBaseNamesBaseNameDeleteRequest, options?: AxiosRequestConfig) {
        return FederatedLTENetworksApiFp(this.configuration).fegLteNetworkIdSubscriberConfigBaseNamesBaseNameDelete(requestParameters.networkId, requestParameters.baseName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add a network-wide base name
     * @param {FederatedLTENetworksApiFegLteNetworkIdSubscriberConfigBaseNamesBaseNamePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FederatedLTENetworksApi
     */
    public fegLteNetworkIdSubscriberConfigBaseNamesBaseNamePost(requestParameters: FederatedLTENetworksApiFegLteNetworkIdSubscriberConfigBaseNamesBaseNamePostRequest, options?: AxiosRequestConfig) {
        return FederatedLTENetworksApiFp(this.configuration).fegLteNetworkIdSubscriberConfigBaseNamesBaseNamePost(requestParameters.networkId, requestParameters.baseName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get network-wide base names
     * @param {FederatedLTENetworksApiFegLteNetworkIdSubscriberConfigBaseNamesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FederatedLTENetworksApi
     */
    public fegLteNetworkIdSubscriberConfigBaseNamesGet(requestParameters: FederatedLTENetworksApiFegLteNetworkIdSubscriberConfigBaseNamesGetRequest, options?: AxiosRequestConfig) {
        return FederatedLTENetworksApiFp(this.configuration).fegLteNetworkIdSubscriberConfigBaseNamesGet(requestParameters.networkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update network-wide base names
     * @param {FederatedLTENetworksApiFegLteNetworkIdSubscriberConfigBaseNamesPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FederatedLTENetworksApi
     */
    public fegLteNetworkIdSubscriberConfigBaseNamesPut(requestParameters: FederatedLTENetworksApiFegLteNetworkIdSubscriberConfigBaseNamesPutRequest, options?: AxiosRequestConfig) {
        return FederatedLTENetworksApiFp(this.configuration).fegLteNetworkIdSubscriberConfigBaseNamesPut(requestParameters.networkId, requestParameters.record, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a network-wide subscriber config
     * @param {FederatedLTENetworksApiFegLteNetworkIdSubscriberConfigGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FederatedLTENetworksApi
     */
    public fegLteNetworkIdSubscriberConfigGet(requestParameters: FederatedLTENetworksApiFegLteNetworkIdSubscriberConfigGetRequest, options?: AxiosRequestConfig) {
        return FederatedLTENetworksApiFp(this.configuration).fegLteNetworkIdSubscriberConfigGet(requestParameters.networkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a network-wide subscriber config
     * @param {FederatedLTENetworksApiFegLteNetworkIdSubscriberConfigPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FederatedLTENetworksApi
     */
    public fegLteNetworkIdSubscriberConfigPut(requestParameters: FederatedLTENetworksApiFegLteNetworkIdSubscriberConfigPutRequest, options?: AxiosRequestConfig) {
        return FederatedLTENetworksApiFp(this.configuration).fegLteNetworkIdSubscriberConfigPut(requestParameters.networkId, requestParameters.record, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get network-wide rule names
     * @param {FederatedLTENetworksApiFegLteNetworkIdSubscriberConfigRuleNamesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FederatedLTENetworksApi
     */
    public fegLteNetworkIdSubscriberConfigRuleNamesGet(requestParameters: FederatedLTENetworksApiFegLteNetworkIdSubscriberConfigRuleNamesGetRequest, options?: AxiosRequestConfig) {
        return FederatedLTENetworksApiFp(this.configuration).fegLteNetworkIdSubscriberConfigRuleNamesGet(requestParameters.networkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update network-wide rule names
     * @param {FederatedLTENetworksApiFegLteNetworkIdSubscriberConfigRuleNamesPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FederatedLTENetworksApi
     */
    public fegLteNetworkIdSubscriberConfigRuleNamesPut(requestParameters: FederatedLTENetworksApiFegLteNetworkIdSubscriberConfigRuleNamesPutRequest, options?: AxiosRequestConfig) {
        return FederatedLTENetworksApiFp(this.configuration).fegLteNetworkIdSubscriberConfigRuleNamesPut(requestParameters.networkId, requestParameters.record, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add a network-wide rule name
     * @param {FederatedLTENetworksApiFegLteNetworkIdSubscriberConfigRuleNamesRuleIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FederatedLTENetworksApi
     */
    public fegLteNetworkIdSubscriberConfigRuleNamesRuleIdDelete(requestParameters: FederatedLTENetworksApiFegLteNetworkIdSubscriberConfigRuleNamesRuleIdDeleteRequest, options?: AxiosRequestConfig) {
        return FederatedLTENetworksApiFp(this.configuration).fegLteNetworkIdSubscriberConfigRuleNamesRuleIdDelete(requestParameters.networkId, requestParameters.ruleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add a network-wide rule name
     * @param {FederatedLTENetworksApiFegLteNetworkIdSubscriberConfigRuleNamesRuleIdPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FederatedLTENetworksApi
     */
    public fegLteNetworkIdSubscriberConfigRuleNamesRuleIdPost(requestParameters: FederatedLTENetworksApiFegLteNetworkIdSubscriberConfigRuleNamesRuleIdPostRequest, options?: AxiosRequestConfig) {
        return FederatedLTENetworksApiFp(this.configuration).fegLteNetworkIdSubscriberConfigRuleNamesRuleIdPost(requestParameters.networkId, requestParameters.ruleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new federated LTE network
     * @param {FederatedLTENetworksApiFegLtePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FederatedLTENetworksApi
     */
    public fegLtePost(requestParameters: FederatedLTENetworksApiFegLtePostRequest, options?: AxiosRequestConfig) {
        return FederatedLTENetworksApiFp(this.configuration).fegLtePost(requestParameters.lteNetwork, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FederationGatewaysApi - axios parameter creator
 * @export
 */
export const FederationGatewaysApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete a federation gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fegNetworkIdGatewaysGatewayIdDelete: async (networkId: string, gatewayId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('fegNetworkIdGatewaysGatewayIdDelete', 'networkId', networkId)
            // verify required parameter 'gatewayId' is not null or undefined
            assertParamExists('fegNetworkIdGatewaysGatewayIdDelete', 'gatewayId', gatewayId)
            const localVarPath = `/feg/{network_id}/gateways/{gateway_id}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"gateway_id"}}`, encodeURIComponent(String(gatewayId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Gateway Federation Configs
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fegNetworkIdGatewaysGatewayIdFederationDelete: async (networkId: string, gatewayId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('fegNetworkIdGatewaysGatewayIdFederationDelete', 'networkId', networkId)
            // verify required parameter 'gatewayId' is not null or undefined
            assertParamExists('fegNetworkIdGatewaysGatewayIdFederationDelete', 'gatewayId', gatewayId)
            const localVarPath = `/feg/{network_id}/gateways/{gateway_id}/federation`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"gateway_id"}}`, encodeURIComponent(String(gatewayId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Gateway Federation Configs
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fegNetworkIdGatewaysGatewayIdFederationGet: async (networkId: string, gatewayId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('fegNetworkIdGatewaysGatewayIdFederationGet', 'networkId', networkId)
            // verify required parameter 'gatewayId' is not null or undefined
            assertParamExists('fegNetworkIdGatewaysGatewayIdFederationGet', 'gatewayId', gatewayId)
            const localVarPath = `/feg/{network_id}/gateways/{gateway_id}/federation`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"gateway_id"}}`, encodeURIComponent(String(gatewayId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Gateway Federation Configs
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {GatewayFederationConfigs} config New config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fegNetworkIdGatewaysGatewayIdFederationPost: async (networkId: string, gatewayId: string, config: GatewayFederationConfigs, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('fegNetworkIdGatewaysGatewayIdFederationPost', 'networkId', networkId)
            // verify required parameter 'gatewayId' is not null or undefined
            assertParamExists('fegNetworkIdGatewaysGatewayIdFederationPost', 'gatewayId', gatewayId)
            // verify required parameter 'config' is not null or undefined
            assertParamExists('fegNetworkIdGatewaysGatewayIdFederationPost', 'config', config)
            const localVarPath = `/feg/{network_id}/gateways/{gateway_id}/federation`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"gateway_id"}}`, encodeURIComponent(String(gatewayId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(config, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Modify Gateway Federation Configs
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {GatewayFederationConfigs} config Updated config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fegNetworkIdGatewaysGatewayIdFederationPut: async (networkId: string, gatewayId: string, config: GatewayFederationConfigs, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('fegNetworkIdGatewaysGatewayIdFederationPut', 'networkId', networkId)
            // verify required parameter 'gatewayId' is not null or undefined
            assertParamExists('fegNetworkIdGatewaysGatewayIdFederationPut', 'gatewayId', gatewayId)
            // verify required parameter 'config' is not null or undefined
            assertParamExists('fegNetworkIdGatewaysGatewayIdFederationPut', 'config', config)
            const localVarPath = `/feg/{network_id}/gateways/{gateway_id}/federation`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"gateway_id"}}`, encodeURIComponent(String(gatewayId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(config, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a specific federation gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fegNetworkIdGatewaysGatewayIdGet: async (networkId: string, gatewayId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('fegNetworkIdGatewaysGatewayIdGet', 'networkId', networkId)
            // verify required parameter 'gatewayId' is not null or undefined
            assertParamExists('fegNetworkIdGatewaysGatewayIdGet', 'gatewayId', gatewayId)
            const localVarPath = `/feg/{network_id}/gateways/{gateway_id}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"gateway_id"}}`, encodeURIComponent(String(gatewayId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Health Status of a Federation Gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fegNetworkIdGatewaysGatewayIdHealthStatusGet: async (networkId: string, gatewayId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('fegNetworkIdGatewaysGatewayIdHealthStatusGet', 'networkId', networkId)
            // verify required parameter 'gatewayId' is not null or undefined
            assertParamExists('fegNetworkIdGatewaysGatewayIdHealthStatusGet', 'gatewayId', gatewayId)
            const localVarPath = `/feg/{network_id}/gateways/{gateway_id}/health_status`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"gateway_id"}}`, encodeURIComponent(String(gatewayId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an entire federation gateway record
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {MutableFederationGateway} gateway Full desired configuration of the gateway
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fegNetworkIdGatewaysGatewayIdPut: async (networkId: string, gatewayId: string, gateway: MutableFederationGateway, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('fegNetworkIdGatewaysGatewayIdPut', 'networkId', networkId)
            // verify required parameter 'gatewayId' is not null or undefined
            assertParamExists('fegNetworkIdGatewaysGatewayIdPut', 'gatewayId', gatewayId)
            // verify required parameter 'gateway' is not null or undefined
            assertParamExists('fegNetworkIdGatewaysGatewayIdPut', 'gateway', gateway)
            const localVarPath = `/feg/{network_id}/gateways/{gateway_id}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"gateway_id"}}`, encodeURIComponent(String(gatewayId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(gateway, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all gateways for a federation network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fegNetworkIdGatewaysGet: async (networkId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('fegNetworkIdGatewaysGet', 'networkId', networkId)
            const localVarPath = `/feg/{network_id}/gateways`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Register a new federation gateway
         * @param {string} networkId Network ID
         * @param {MutableFederationGateway} gateway Full desired configuration of the gateway
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fegNetworkIdGatewaysPost: async (networkId: string, gateway: MutableFederationGateway, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('fegNetworkIdGatewaysPost', 'networkId', networkId)
            // verify required parameter 'gateway' is not null or undefined
            assertParamExists('fegNetworkIdGatewaysPost', 'gateway', gateway)
            const localVarPath = `/feg/{network_id}/gateways`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(gateway, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FederationGatewaysApi - functional programming interface
 * @export
 */
export const FederationGatewaysApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FederationGatewaysApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete a federation gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fegNetworkIdGatewaysGatewayIdDelete(networkId: string, gatewayId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fegNetworkIdGatewaysGatewayIdDelete(networkId, gatewayId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete Gateway Federation Configs
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fegNetworkIdGatewaysGatewayIdFederationDelete(networkId: string, gatewayId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fegNetworkIdGatewaysGatewayIdFederationDelete(networkId, gatewayId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve Gateway Federation Configs
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fegNetworkIdGatewaysGatewayIdFederationGet(networkId: string, gatewayId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GatewayFederationConfigs>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fegNetworkIdGatewaysGatewayIdFederationGet(networkId, gatewayId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create Gateway Federation Configs
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {GatewayFederationConfigs} config New config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fegNetworkIdGatewaysGatewayIdFederationPost(networkId: string, gatewayId: string, config: GatewayFederationConfigs, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fegNetworkIdGatewaysGatewayIdFederationPost(networkId, gatewayId, config, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Modify Gateway Federation Configs
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {GatewayFederationConfigs} config Updated config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fegNetworkIdGatewaysGatewayIdFederationPut(networkId: string, gatewayId: string, config: GatewayFederationConfigs, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fegNetworkIdGatewaysGatewayIdFederationPut(networkId, gatewayId, config, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a specific federation gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fegNetworkIdGatewaysGatewayIdGet(networkId: string, gatewayId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FederationGateway>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fegNetworkIdGatewaysGatewayIdGet(networkId, gatewayId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve Health Status of a Federation Gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fegNetworkIdGatewaysGatewayIdHealthStatusGet(networkId: string, gatewayId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FederationGatewayHealthStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fegNetworkIdGatewaysGatewayIdHealthStatusGet(networkId, gatewayId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update an entire federation gateway record
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {MutableFederationGateway} gateway Full desired configuration of the gateway
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fegNetworkIdGatewaysGatewayIdPut(networkId: string, gatewayId: string, gateway: MutableFederationGateway, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fegNetworkIdGatewaysGatewayIdPut(networkId, gatewayId, gateway, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all gateways for a federation network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fegNetworkIdGatewaysGet(networkId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: FederationGateway; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fegNetworkIdGatewaysGet(networkId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Register a new federation gateway
         * @param {string} networkId Network ID
         * @param {MutableFederationGateway} gateway Full desired configuration of the gateway
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fegNetworkIdGatewaysPost(networkId: string, gateway: MutableFederationGateway, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fegNetworkIdGatewaysPost(networkId, gateway, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FederationGatewaysApi - factory interface
 * @export
 */
export const FederationGatewaysApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FederationGatewaysApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete a federation gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fegNetworkIdGatewaysGatewayIdDelete(networkId: string, gatewayId: string, options?: any): AxiosPromise<void> {
            return localVarFp.fegNetworkIdGatewaysGatewayIdDelete(networkId, gatewayId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Gateway Federation Configs
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fegNetworkIdGatewaysGatewayIdFederationDelete(networkId: string, gatewayId: string, options?: any): AxiosPromise<void> {
            return localVarFp.fegNetworkIdGatewaysGatewayIdFederationDelete(networkId, gatewayId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve Gateway Federation Configs
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fegNetworkIdGatewaysGatewayIdFederationGet(networkId: string, gatewayId: string, options?: any): AxiosPromise<GatewayFederationConfigs> {
            return localVarFp.fegNetworkIdGatewaysGatewayIdFederationGet(networkId, gatewayId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create Gateway Federation Configs
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {GatewayFederationConfigs} config New config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fegNetworkIdGatewaysGatewayIdFederationPost(networkId: string, gatewayId: string, config: GatewayFederationConfigs, options?: any): AxiosPromise<void> {
            return localVarFp.fegNetworkIdGatewaysGatewayIdFederationPost(networkId, gatewayId, config, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Modify Gateway Federation Configs
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {GatewayFederationConfigs} config Updated config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fegNetworkIdGatewaysGatewayIdFederationPut(networkId: string, gatewayId: string, config: GatewayFederationConfigs, options?: any): AxiosPromise<void> {
            return localVarFp.fegNetworkIdGatewaysGatewayIdFederationPut(networkId, gatewayId, config, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a specific federation gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fegNetworkIdGatewaysGatewayIdGet(networkId: string, gatewayId: string, options?: any): AxiosPromise<FederationGateway> {
            return localVarFp.fegNetworkIdGatewaysGatewayIdGet(networkId, gatewayId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve Health Status of a Federation Gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fegNetworkIdGatewaysGatewayIdHealthStatusGet(networkId: string, gatewayId: string, options?: any): AxiosPromise<FederationGatewayHealthStatus> {
            return localVarFp.fegNetworkIdGatewaysGatewayIdHealthStatusGet(networkId, gatewayId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an entire federation gateway record
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {MutableFederationGateway} gateway Full desired configuration of the gateway
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fegNetworkIdGatewaysGatewayIdPut(networkId: string, gatewayId: string, gateway: MutableFederationGateway, options?: any): AxiosPromise<void> {
            return localVarFp.fegNetworkIdGatewaysGatewayIdPut(networkId, gatewayId, gateway, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all gateways for a federation network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fegNetworkIdGatewaysGet(networkId: string, options?: any): AxiosPromise<{ [key: string]: FederationGateway; }> {
            return localVarFp.fegNetworkIdGatewaysGet(networkId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Register a new federation gateway
         * @param {string} networkId Network ID
         * @param {MutableFederationGateway} gateway Full desired configuration of the gateway
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fegNetworkIdGatewaysPost(networkId: string, gateway: MutableFederationGateway, options?: any): AxiosPromise<void> {
            return localVarFp.fegNetworkIdGatewaysPost(networkId, gateway, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for fegNetworkIdGatewaysGatewayIdDelete operation in FederationGatewaysApi.
 * @export
 * @interface FederationGatewaysApiFegNetworkIdGatewaysGatewayIdDeleteRequest
 */
export interface FederationGatewaysApiFegNetworkIdGatewaysGatewayIdDeleteRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof FederationGatewaysApiFegNetworkIdGatewaysGatewayIdDelete
     */
    readonly networkId: string

    /**
     * Gateway ID
     * @type {string}
     * @memberof FederationGatewaysApiFegNetworkIdGatewaysGatewayIdDelete
     */
    readonly gatewayId: string
}

/**
 * Request parameters for fegNetworkIdGatewaysGatewayIdFederationDelete operation in FederationGatewaysApi.
 * @export
 * @interface FederationGatewaysApiFegNetworkIdGatewaysGatewayIdFederationDeleteRequest
 */
export interface FederationGatewaysApiFegNetworkIdGatewaysGatewayIdFederationDeleteRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof FederationGatewaysApiFegNetworkIdGatewaysGatewayIdFederationDelete
     */
    readonly networkId: string

    /**
     * Gateway ID
     * @type {string}
     * @memberof FederationGatewaysApiFegNetworkIdGatewaysGatewayIdFederationDelete
     */
    readonly gatewayId: string
}

/**
 * Request parameters for fegNetworkIdGatewaysGatewayIdFederationGet operation in FederationGatewaysApi.
 * @export
 * @interface FederationGatewaysApiFegNetworkIdGatewaysGatewayIdFederationGetRequest
 */
export interface FederationGatewaysApiFegNetworkIdGatewaysGatewayIdFederationGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof FederationGatewaysApiFegNetworkIdGatewaysGatewayIdFederationGet
     */
    readonly networkId: string

    /**
     * Gateway ID
     * @type {string}
     * @memberof FederationGatewaysApiFegNetworkIdGatewaysGatewayIdFederationGet
     */
    readonly gatewayId: string
}

/**
 * Request parameters for fegNetworkIdGatewaysGatewayIdFederationPost operation in FederationGatewaysApi.
 * @export
 * @interface FederationGatewaysApiFegNetworkIdGatewaysGatewayIdFederationPostRequest
 */
export interface FederationGatewaysApiFegNetworkIdGatewaysGatewayIdFederationPostRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof FederationGatewaysApiFegNetworkIdGatewaysGatewayIdFederationPost
     */
    readonly networkId: string

    /**
     * Gateway ID
     * @type {string}
     * @memberof FederationGatewaysApiFegNetworkIdGatewaysGatewayIdFederationPost
     */
    readonly gatewayId: string

    /**
     * New config
     * @type {GatewayFederationConfigs}
     * @memberof FederationGatewaysApiFegNetworkIdGatewaysGatewayIdFederationPost
     */
    readonly config: GatewayFederationConfigs
}

/**
 * Request parameters for fegNetworkIdGatewaysGatewayIdFederationPut operation in FederationGatewaysApi.
 * @export
 * @interface FederationGatewaysApiFegNetworkIdGatewaysGatewayIdFederationPutRequest
 */
export interface FederationGatewaysApiFegNetworkIdGatewaysGatewayIdFederationPutRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof FederationGatewaysApiFegNetworkIdGatewaysGatewayIdFederationPut
     */
    readonly networkId: string

    /**
     * Gateway ID
     * @type {string}
     * @memberof FederationGatewaysApiFegNetworkIdGatewaysGatewayIdFederationPut
     */
    readonly gatewayId: string

    /**
     * Updated config
     * @type {GatewayFederationConfigs}
     * @memberof FederationGatewaysApiFegNetworkIdGatewaysGatewayIdFederationPut
     */
    readonly config: GatewayFederationConfigs
}

/**
 * Request parameters for fegNetworkIdGatewaysGatewayIdGet operation in FederationGatewaysApi.
 * @export
 * @interface FederationGatewaysApiFegNetworkIdGatewaysGatewayIdGetRequest
 */
export interface FederationGatewaysApiFegNetworkIdGatewaysGatewayIdGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof FederationGatewaysApiFegNetworkIdGatewaysGatewayIdGet
     */
    readonly networkId: string

    /**
     * Gateway ID
     * @type {string}
     * @memberof FederationGatewaysApiFegNetworkIdGatewaysGatewayIdGet
     */
    readonly gatewayId: string
}

/**
 * Request parameters for fegNetworkIdGatewaysGatewayIdHealthStatusGet operation in FederationGatewaysApi.
 * @export
 * @interface FederationGatewaysApiFegNetworkIdGatewaysGatewayIdHealthStatusGetRequest
 */
export interface FederationGatewaysApiFegNetworkIdGatewaysGatewayIdHealthStatusGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof FederationGatewaysApiFegNetworkIdGatewaysGatewayIdHealthStatusGet
     */
    readonly networkId: string

    /**
     * Gateway ID
     * @type {string}
     * @memberof FederationGatewaysApiFegNetworkIdGatewaysGatewayIdHealthStatusGet
     */
    readonly gatewayId: string
}

/**
 * Request parameters for fegNetworkIdGatewaysGatewayIdPut operation in FederationGatewaysApi.
 * @export
 * @interface FederationGatewaysApiFegNetworkIdGatewaysGatewayIdPutRequest
 */
export interface FederationGatewaysApiFegNetworkIdGatewaysGatewayIdPutRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof FederationGatewaysApiFegNetworkIdGatewaysGatewayIdPut
     */
    readonly networkId: string

    /**
     * Gateway ID
     * @type {string}
     * @memberof FederationGatewaysApiFegNetworkIdGatewaysGatewayIdPut
     */
    readonly gatewayId: string

    /**
     * Full desired configuration of the gateway
     * @type {MutableFederationGateway}
     * @memberof FederationGatewaysApiFegNetworkIdGatewaysGatewayIdPut
     */
    readonly gateway: MutableFederationGateway
}

/**
 * Request parameters for fegNetworkIdGatewaysGet operation in FederationGatewaysApi.
 * @export
 * @interface FederationGatewaysApiFegNetworkIdGatewaysGetRequest
 */
export interface FederationGatewaysApiFegNetworkIdGatewaysGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof FederationGatewaysApiFegNetworkIdGatewaysGet
     */
    readonly networkId: string
}

/**
 * Request parameters for fegNetworkIdGatewaysPost operation in FederationGatewaysApi.
 * @export
 * @interface FederationGatewaysApiFegNetworkIdGatewaysPostRequest
 */
export interface FederationGatewaysApiFegNetworkIdGatewaysPostRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof FederationGatewaysApiFegNetworkIdGatewaysPost
     */
    readonly networkId: string

    /**
     * Full desired configuration of the gateway
     * @type {MutableFederationGateway}
     * @memberof FederationGatewaysApiFegNetworkIdGatewaysPost
     */
    readonly gateway: MutableFederationGateway
}

/**
 * FederationGatewaysApi - object-oriented interface
 * @export
 * @class FederationGatewaysApi
 * @extends {BaseAPI}
 */
export class FederationGatewaysApi extends BaseAPI {
    /**
     * 
     * @summary Delete a federation gateway
     * @param {FederationGatewaysApiFegNetworkIdGatewaysGatewayIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FederationGatewaysApi
     */
    public fegNetworkIdGatewaysGatewayIdDelete(requestParameters: FederationGatewaysApiFegNetworkIdGatewaysGatewayIdDeleteRequest, options?: AxiosRequestConfig) {
        return FederationGatewaysApiFp(this.configuration).fegNetworkIdGatewaysGatewayIdDelete(requestParameters.networkId, requestParameters.gatewayId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Gateway Federation Configs
     * @param {FederationGatewaysApiFegNetworkIdGatewaysGatewayIdFederationDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FederationGatewaysApi
     */
    public fegNetworkIdGatewaysGatewayIdFederationDelete(requestParameters: FederationGatewaysApiFegNetworkIdGatewaysGatewayIdFederationDeleteRequest, options?: AxiosRequestConfig) {
        return FederationGatewaysApiFp(this.configuration).fegNetworkIdGatewaysGatewayIdFederationDelete(requestParameters.networkId, requestParameters.gatewayId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve Gateway Federation Configs
     * @param {FederationGatewaysApiFegNetworkIdGatewaysGatewayIdFederationGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FederationGatewaysApi
     */
    public fegNetworkIdGatewaysGatewayIdFederationGet(requestParameters: FederationGatewaysApiFegNetworkIdGatewaysGatewayIdFederationGetRequest, options?: AxiosRequestConfig) {
        return FederationGatewaysApiFp(this.configuration).fegNetworkIdGatewaysGatewayIdFederationGet(requestParameters.networkId, requestParameters.gatewayId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create Gateway Federation Configs
     * @param {FederationGatewaysApiFegNetworkIdGatewaysGatewayIdFederationPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FederationGatewaysApi
     */
    public fegNetworkIdGatewaysGatewayIdFederationPost(requestParameters: FederationGatewaysApiFegNetworkIdGatewaysGatewayIdFederationPostRequest, options?: AxiosRequestConfig) {
        return FederationGatewaysApiFp(this.configuration).fegNetworkIdGatewaysGatewayIdFederationPost(requestParameters.networkId, requestParameters.gatewayId, requestParameters.config, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Modify Gateway Federation Configs
     * @param {FederationGatewaysApiFegNetworkIdGatewaysGatewayIdFederationPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FederationGatewaysApi
     */
    public fegNetworkIdGatewaysGatewayIdFederationPut(requestParameters: FederationGatewaysApiFegNetworkIdGatewaysGatewayIdFederationPutRequest, options?: AxiosRequestConfig) {
        return FederationGatewaysApiFp(this.configuration).fegNetworkIdGatewaysGatewayIdFederationPut(requestParameters.networkId, requestParameters.gatewayId, requestParameters.config, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a specific federation gateway
     * @param {FederationGatewaysApiFegNetworkIdGatewaysGatewayIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FederationGatewaysApi
     */
    public fegNetworkIdGatewaysGatewayIdGet(requestParameters: FederationGatewaysApiFegNetworkIdGatewaysGatewayIdGetRequest, options?: AxiosRequestConfig) {
        return FederationGatewaysApiFp(this.configuration).fegNetworkIdGatewaysGatewayIdGet(requestParameters.networkId, requestParameters.gatewayId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve Health Status of a Federation Gateway
     * @param {FederationGatewaysApiFegNetworkIdGatewaysGatewayIdHealthStatusGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FederationGatewaysApi
     */
    public fegNetworkIdGatewaysGatewayIdHealthStatusGet(requestParameters: FederationGatewaysApiFegNetworkIdGatewaysGatewayIdHealthStatusGetRequest, options?: AxiosRequestConfig) {
        return FederationGatewaysApiFp(this.configuration).fegNetworkIdGatewaysGatewayIdHealthStatusGet(requestParameters.networkId, requestParameters.gatewayId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an entire federation gateway record
     * @param {FederationGatewaysApiFegNetworkIdGatewaysGatewayIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FederationGatewaysApi
     */
    public fegNetworkIdGatewaysGatewayIdPut(requestParameters: FederationGatewaysApiFegNetworkIdGatewaysGatewayIdPutRequest, options?: AxiosRequestConfig) {
        return FederationGatewaysApiFp(this.configuration).fegNetworkIdGatewaysGatewayIdPut(requestParameters.networkId, requestParameters.gatewayId, requestParameters.gateway, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all gateways for a federation network
     * @param {FederationGatewaysApiFegNetworkIdGatewaysGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FederationGatewaysApi
     */
    public fegNetworkIdGatewaysGet(requestParameters: FederationGatewaysApiFegNetworkIdGatewaysGetRequest, options?: AxiosRequestConfig) {
        return FederationGatewaysApiFp(this.configuration).fegNetworkIdGatewaysGet(requestParameters.networkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Register a new federation gateway
     * @param {FederationGatewaysApiFegNetworkIdGatewaysPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FederationGatewaysApi
     */
    public fegNetworkIdGatewaysPost(requestParameters: FederationGatewaysApiFegNetworkIdGatewaysPostRequest, options?: AxiosRequestConfig) {
        return FederationGatewaysApiFp(this.configuration).fegNetworkIdGatewaysPost(requestParameters.networkId, requestParameters.gateway, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FederationNetworksApi - axios parameter creator
 * @export
 */
export const FederationNetworksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List all federation network IDs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fegGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/feg`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve HA cluster status of a Federation Network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fegNetworkIdClusterStatusGet: async (networkId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('fegNetworkIdClusterStatusGet', 'networkId', networkId)
            const localVarPath = `/feg/{network_id}/cluster_status`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a federation network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fegNetworkIdDelete: async (networkId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('fegNetworkIdDelete', 'networkId', networkId)
            const localVarPath = `/feg/{network_id}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Network Federation Configs
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fegNetworkIdFederationDelete: async (networkId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('fegNetworkIdFederationDelete', 'networkId', networkId)
            const localVarPath = `/feg/{network_id}/federation`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Network Federation Configs
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fegNetworkIdFederationGet: async (networkId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('fegNetworkIdFederationGet', 'networkId', networkId)
            const localVarPath = `/feg/{network_id}/federation`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create or Modify Network Federation Configs
         * @param {string} networkId Network ID
         * @param {NetworkFederationConfigs} config Updated config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fegNetworkIdFederationPut: async (networkId: string, config: NetworkFederationConfigs, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('fegNetworkIdFederationPut', 'networkId', networkId)
            // verify required parameter 'config' is not null or undefined
            assertParamExists('fegNetworkIdFederationPut', 'config', config)
            const localVarPath = `/feg/{network_id}/federation`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(config, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Describe a federation network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fegNetworkIdGet: async (networkId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('fegNetworkIdGet', 'networkId', networkId)
            const localVarPath = `/feg/{network_id}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an entire federation network
         * @param {string} networkId Network ID
         * @param {FegNetwork} fegNetwork Full desired configuration of the network
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fegNetworkIdPut: async (networkId: string, fegNetwork: FegNetwork, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('fegNetworkIdPut', 'networkId', networkId)
            // verify required parameter 'fegNetwork' is not null or undefined
            assertParamExists('fegNetworkIdPut', 'fegNetwork', fegNetwork)
            const localVarPath = `/feg/{network_id}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(fegNetwork, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add a network-wide base name
         * @param {string} networkId Network ID
         * @param {string} baseName Charging Rule Base Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fegNetworkIdSubscriberConfigBaseNamesBaseNameDelete: async (networkId: string, baseName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('fegNetworkIdSubscriberConfigBaseNamesBaseNameDelete', 'networkId', networkId)
            // verify required parameter 'baseName' is not null or undefined
            assertParamExists('fegNetworkIdSubscriberConfigBaseNamesBaseNameDelete', 'baseName', baseName)
            const localVarPath = `/feg/{network_id}/subscriber_config/base_names/{base_name}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"base_name"}}`, encodeURIComponent(String(baseName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add a network-wide base name
         * @param {string} networkId Network ID
         * @param {string} baseName Charging Rule Base Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fegNetworkIdSubscriberConfigBaseNamesBaseNamePost: async (networkId: string, baseName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('fegNetworkIdSubscriberConfigBaseNamesBaseNamePost', 'networkId', networkId)
            // verify required parameter 'baseName' is not null or undefined
            assertParamExists('fegNetworkIdSubscriberConfigBaseNamesBaseNamePost', 'baseName', baseName)
            const localVarPath = `/feg/{network_id}/subscriber_config/base_names/{base_name}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"base_name"}}`, encodeURIComponent(String(baseName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get network-wide base names
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fegNetworkIdSubscriberConfigBaseNamesGet: async (networkId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('fegNetworkIdSubscriberConfigBaseNamesGet', 'networkId', networkId)
            const localVarPath = `/feg/{network_id}/subscriber_config/base_names`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update network-wide base names
         * @param {string} networkId Network ID
         * @param {Array<string>} record Subscriber Config for the Network
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fegNetworkIdSubscriberConfigBaseNamesPut: async (networkId: string, record: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('fegNetworkIdSubscriberConfigBaseNamesPut', 'networkId', networkId)
            // verify required parameter 'record' is not null or undefined
            assertParamExists('fegNetworkIdSubscriberConfigBaseNamesPut', 'record', record)
            const localVarPath = `/feg/{network_id}/subscriber_config/base_names`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(record, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a network-wide subscriber config
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fegNetworkIdSubscriberConfigGet: async (networkId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('fegNetworkIdSubscriberConfigGet', 'networkId', networkId)
            const localVarPath = `/feg/{network_id}/subscriber_config`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a network-wide subscriber config
         * @param {string} networkId Network ID
         * @param {NetworkSubscriberConfig} record Subscriber Config for the Network
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fegNetworkIdSubscriberConfigPut: async (networkId: string, record: NetworkSubscriberConfig, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('fegNetworkIdSubscriberConfigPut', 'networkId', networkId)
            // verify required parameter 'record' is not null or undefined
            assertParamExists('fegNetworkIdSubscriberConfigPut', 'record', record)
            const localVarPath = `/feg/{network_id}/subscriber_config`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(record, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get network-wide rule names
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fegNetworkIdSubscriberConfigRuleNamesGet: async (networkId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('fegNetworkIdSubscriberConfigRuleNamesGet', 'networkId', networkId)
            const localVarPath = `/feg/{network_id}/subscriber_config/rule_names`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update network-wide rule names
         * @param {string} networkId Network ID
         * @param {Array<string>} record Subscriber Config for the Network
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fegNetworkIdSubscriberConfigRuleNamesPut: async (networkId: string, record: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('fegNetworkIdSubscriberConfigRuleNamesPut', 'networkId', networkId)
            // verify required parameter 'record' is not null or undefined
            assertParamExists('fegNetworkIdSubscriberConfigRuleNamesPut', 'record', record)
            const localVarPath = `/feg/{network_id}/subscriber_config/rule_names`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(record, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add a network-wide rule name
         * @param {string} networkId Network ID
         * @param {string} ruleId Rule Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fegNetworkIdSubscriberConfigRuleNamesRuleIdDelete: async (networkId: string, ruleId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('fegNetworkIdSubscriberConfigRuleNamesRuleIdDelete', 'networkId', networkId)
            // verify required parameter 'ruleId' is not null or undefined
            assertParamExists('fegNetworkIdSubscriberConfigRuleNamesRuleIdDelete', 'ruleId', ruleId)
            const localVarPath = `/feg/{network_id}/subscriber_config/rule_names/{rule_id}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"rule_id"}}`, encodeURIComponent(String(ruleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add a network-wide rule name
         * @param {string} networkId Network ID
         * @param {string} ruleId Rule Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fegNetworkIdSubscriberConfigRuleNamesRuleIdPost: async (networkId: string, ruleId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('fegNetworkIdSubscriberConfigRuleNamesRuleIdPost', 'networkId', networkId)
            // verify required parameter 'ruleId' is not null or undefined
            assertParamExists('fegNetworkIdSubscriberConfigRuleNamesRuleIdPost', 'ruleId', ruleId)
            const localVarPath = `/feg/{network_id}/subscriber_config/rule_names/{rule_id}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"rule_id"}}`, encodeURIComponent(String(ruleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new federation network
         * @param {FegNetwork} fegNetwork Configuration of the network to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fegPost: async (fegNetwork: FegNetwork, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fegNetwork' is not null or undefined
            assertParamExists('fegPost', 'fegNetwork', fegNetwork)
            const localVarPath = `/feg`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(fegNetwork, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FederationNetworksApi - functional programming interface
 * @export
 */
export const FederationNetworksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FederationNetworksApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List all federation network IDs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fegGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fegGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve HA cluster status of a Federation Network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fegNetworkIdClusterStatusGet(networkId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FederationNetworkClusterStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fegNetworkIdClusterStatusGet(networkId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a federation network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fegNetworkIdDelete(networkId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fegNetworkIdDelete(networkId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete Network Federation Configs
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fegNetworkIdFederationDelete(networkId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fegNetworkIdFederationDelete(networkId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve Network Federation Configs
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fegNetworkIdFederationGet(networkId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NetworkFederationConfigs>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fegNetworkIdFederationGet(networkId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create or Modify Network Federation Configs
         * @param {string} networkId Network ID
         * @param {NetworkFederationConfigs} config Updated config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fegNetworkIdFederationPut(networkId: string, config: NetworkFederationConfigs, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fegNetworkIdFederationPut(networkId, config, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Describe a federation network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fegNetworkIdGet(networkId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FegNetwork>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fegNetworkIdGet(networkId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update an entire federation network
         * @param {string} networkId Network ID
         * @param {FegNetwork} fegNetwork Full desired configuration of the network
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fegNetworkIdPut(networkId: string, fegNetwork: FegNetwork, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fegNetworkIdPut(networkId, fegNetwork, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add a network-wide base name
         * @param {string} networkId Network ID
         * @param {string} baseName Charging Rule Base Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fegNetworkIdSubscriberConfigBaseNamesBaseNameDelete(networkId: string, baseName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fegNetworkIdSubscriberConfigBaseNamesBaseNameDelete(networkId, baseName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add a network-wide base name
         * @param {string} networkId Network ID
         * @param {string} baseName Charging Rule Base Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fegNetworkIdSubscriberConfigBaseNamesBaseNamePost(networkId: string, baseName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fegNetworkIdSubscriberConfigBaseNamesBaseNamePost(networkId, baseName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get network-wide base names
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fegNetworkIdSubscriberConfigBaseNamesGet(networkId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fegNetworkIdSubscriberConfigBaseNamesGet(networkId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update network-wide base names
         * @param {string} networkId Network ID
         * @param {Array<string>} record Subscriber Config for the Network
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fegNetworkIdSubscriberConfigBaseNamesPut(networkId: string, record: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fegNetworkIdSubscriberConfigBaseNamesPut(networkId, record, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a network-wide subscriber config
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fegNetworkIdSubscriberConfigGet(networkId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NetworkSubscriberConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fegNetworkIdSubscriberConfigGet(networkId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a network-wide subscriber config
         * @param {string} networkId Network ID
         * @param {NetworkSubscriberConfig} record Subscriber Config for the Network
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fegNetworkIdSubscriberConfigPut(networkId: string, record: NetworkSubscriberConfig, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fegNetworkIdSubscriberConfigPut(networkId, record, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get network-wide rule names
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fegNetworkIdSubscriberConfigRuleNamesGet(networkId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fegNetworkIdSubscriberConfigRuleNamesGet(networkId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update network-wide rule names
         * @param {string} networkId Network ID
         * @param {Array<string>} record Subscriber Config for the Network
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fegNetworkIdSubscriberConfigRuleNamesPut(networkId: string, record: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fegNetworkIdSubscriberConfigRuleNamesPut(networkId, record, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add a network-wide rule name
         * @param {string} networkId Network ID
         * @param {string} ruleId Rule Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fegNetworkIdSubscriberConfigRuleNamesRuleIdDelete(networkId: string, ruleId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fegNetworkIdSubscriberConfigRuleNamesRuleIdDelete(networkId, ruleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add a network-wide rule name
         * @param {string} networkId Network ID
         * @param {string} ruleId Rule Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fegNetworkIdSubscriberConfigRuleNamesRuleIdPost(networkId: string, ruleId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fegNetworkIdSubscriberConfigRuleNamesRuleIdPost(networkId, ruleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a new federation network
         * @param {FegNetwork} fegNetwork Configuration of the network to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fegPost(fegNetwork: FegNetwork, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fegPost(fegNetwork, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FederationNetworksApi - factory interface
 * @export
 */
export const FederationNetworksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FederationNetworksApiFp(configuration)
    return {
        /**
         * 
         * @summary List all federation network IDs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fegGet(options?: any): AxiosPromise<Array<string>> {
            return localVarFp.fegGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve HA cluster status of a Federation Network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fegNetworkIdClusterStatusGet(networkId: string, options?: any): AxiosPromise<FederationNetworkClusterStatus> {
            return localVarFp.fegNetworkIdClusterStatusGet(networkId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a federation network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fegNetworkIdDelete(networkId: string, options?: any): AxiosPromise<void> {
            return localVarFp.fegNetworkIdDelete(networkId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Network Federation Configs
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fegNetworkIdFederationDelete(networkId: string, options?: any): AxiosPromise<void> {
            return localVarFp.fegNetworkIdFederationDelete(networkId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve Network Federation Configs
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fegNetworkIdFederationGet(networkId: string, options?: any): AxiosPromise<NetworkFederationConfigs> {
            return localVarFp.fegNetworkIdFederationGet(networkId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create or Modify Network Federation Configs
         * @param {string} networkId Network ID
         * @param {NetworkFederationConfigs} config Updated config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fegNetworkIdFederationPut(networkId: string, config: NetworkFederationConfigs, options?: any): AxiosPromise<void> {
            return localVarFp.fegNetworkIdFederationPut(networkId, config, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Describe a federation network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fegNetworkIdGet(networkId: string, options?: any): AxiosPromise<FegNetwork> {
            return localVarFp.fegNetworkIdGet(networkId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an entire federation network
         * @param {string} networkId Network ID
         * @param {FegNetwork} fegNetwork Full desired configuration of the network
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fegNetworkIdPut(networkId: string, fegNetwork: FegNetwork, options?: any): AxiosPromise<void> {
            return localVarFp.fegNetworkIdPut(networkId, fegNetwork, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add a network-wide base name
         * @param {string} networkId Network ID
         * @param {string} baseName Charging Rule Base Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fegNetworkIdSubscriberConfigBaseNamesBaseNameDelete(networkId: string, baseName: string, options?: any): AxiosPromise<void> {
            return localVarFp.fegNetworkIdSubscriberConfigBaseNamesBaseNameDelete(networkId, baseName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add a network-wide base name
         * @param {string} networkId Network ID
         * @param {string} baseName Charging Rule Base Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fegNetworkIdSubscriberConfigBaseNamesBaseNamePost(networkId: string, baseName: string, options?: any): AxiosPromise<void> {
            return localVarFp.fegNetworkIdSubscriberConfigBaseNamesBaseNamePost(networkId, baseName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get network-wide base names
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fegNetworkIdSubscriberConfigBaseNamesGet(networkId: string, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.fegNetworkIdSubscriberConfigBaseNamesGet(networkId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update network-wide base names
         * @param {string} networkId Network ID
         * @param {Array<string>} record Subscriber Config for the Network
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fegNetworkIdSubscriberConfigBaseNamesPut(networkId: string, record: Array<string>, options?: any): AxiosPromise<void> {
            return localVarFp.fegNetworkIdSubscriberConfigBaseNamesPut(networkId, record, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a network-wide subscriber config
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fegNetworkIdSubscriberConfigGet(networkId: string, options?: any): AxiosPromise<NetworkSubscriberConfig> {
            return localVarFp.fegNetworkIdSubscriberConfigGet(networkId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a network-wide subscriber config
         * @param {string} networkId Network ID
         * @param {NetworkSubscriberConfig} record Subscriber Config for the Network
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fegNetworkIdSubscriberConfigPut(networkId: string, record: NetworkSubscriberConfig, options?: any): AxiosPromise<void> {
            return localVarFp.fegNetworkIdSubscriberConfigPut(networkId, record, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get network-wide rule names
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fegNetworkIdSubscriberConfigRuleNamesGet(networkId: string, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.fegNetworkIdSubscriberConfigRuleNamesGet(networkId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update network-wide rule names
         * @param {string} networkId Network ID
         * @param {Array<string>} record Subscriber Config for the Network
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fegNetworkIdSubscriberConfigRuleNamesPut(networkId: string, record: Array<string>, options?: any): AxiosPromise<void> {
            return localVarFp.fegNetworkIdSubscriberConfigRuleNamesPut(networkId, record, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add a network-wide rule name
         * @param {string} networkId Network ID
         * @param {string} ruleId Rule Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fegNetworkIdSubscriberConfigRuleNamesRuleIdDelete(networkId: string, ruleId: string, options?: any): AxiosPromise<void> {
            return localVarFp.fegNetworkIdSubscriberConfigRuleNamesRuleIdDelete(networkId, ruleId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add a network-wide rule name
         * @param {string} networkId Network ID
         * @param {string} ruleId Rule Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fegNetworkIdSubscriberConfigRuleNamesRuleIdPost(networkId: string, ruleId: string, options?: any): AxiosPromise<void> {
            return localVarFp.fegNetworkIdSubscriberConfigRuleNamesRuleIdPost(networkId, ruleId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new federation network
         * @param {FegNetwork} fegNetwork Configuration of the network to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fegPost(fegNetwork: FegNetwork, options?: any): AxiosPromise<void> {
            return localVarFp.fegPost(fegNetwork, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for fegNetworkIdClusterStatusGet operation in FederationNetworksApi.
 * @export
 * @interface FederationNetworksApiFegNetworkIdClusterStatusGetRequest
 */
export interface FederationNetworksApiFegNetworkIdClusterStatusGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof FederationNetworksApiFegNetworkIdClusterStatusGet
     */
    readonly networkId: string
}

/**
 * Request parameters for fegNetworkIdDelete operation in FederationNetworksApi.
 * @export
 * @interface FederationNetworksApiFegNetworkIdDeleteRequest
 */
export interface FederationNetworksApiFegNetworkIdDeleteRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof FederationNetworksApiFegNetworkIdDelete
     */
    readonly networkId: string
}

/**
 * Request parameters for fegNetworkIdFederationDelete operation in FederationNetworksApi.
 * @export
 * @interface FederationNetworksApiFegNetworkIdFederationDeleteRequest
 */
export interface FederationNetworksApiFegNetworkIdFederationDeleteRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof FederationNetworksApiFegNetworkIdFederationDelete
     */
    readonly networkId: string
}

/**
 * Request parameters for fegNetworkIdFederationGet operation in FederationNetworksApi.
 * @export
 * @interface FederationNetworksApiFegNetworkIdFederationGetRequest
 */
export interface FederationNetworksApiFegNetworkIdFederationGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof FederationNetworksApiFegNetworkIdFederationGet
     */
    readonly networkId: string
}

/**
 * Request parameters for fegNetworkIdFederationPut operation in FederationNetworksApi.
 * @export
 * @interface FederationNetworksApiFegNetworkIdFederationPutRequest
 */
export interface FederationNetworksApiFegNetworkIdFederationPutRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof FederationNetworksApiFegNetworkIdFederationPut
     */
    readonly networkId: string

    /**
     * Updated config
     * @type {NetworkFederationConfigs}
     * @memberof FederationNetworksApiFegNetworkIdFederationPut
     */
    readonly config: NetworkFederationConfigs
}

/**
 * Request parameters for fegNetworkIdGet operation in FederationNetworksApi.
 * @export
 * @interface FederationNetworksApiFegNetworkIdGetRequest
 */
export interface FederationNetworksApiFegNetworkIdGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof FederationNetworksApiFegNetworkIdGet
     */
    readonly networkId: string
}

/**
 * Request parameters for fegNetworkIdPut operation in FederationNetworksApi.
 * @export
 * @interface FederationNetworksApiFegNetworkIdPutRequest
 */
export interface FederationNetworksApiFegNetworkIdPutRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof FederationNetworksApiFegNetworkIdPut
     */
    readonly networkId: string

    /**
     * Full desired configuration of the network
     * @type {FegNetwork}
     * @memberof FederationNetworksApiFegNetworkIdPut
     */
    readonly fegNetwork: FegNetwork
}

/**
 * Request parameters for fegNetworkIdSubscriberConfigBaseNamesBaseNameDelete operation in FederationNetworksApi.
 * @export
 * @interface FederationNetworksApiFegNetworkIdSubscriberConfigBaseNamesBaseNameDeleteRequest
 */
export interface FederationNetworksApiFegNetworkIdSubscriberConfigBaseNamesBaseNameDeleteRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof FederationNetworksApiFegNetworkIdSubscriberConfigBaseNamesBaseNameDelete
     */
    readonly networkId: string

    /**
     * Charging Rule Base Name
     * @type {string}
     * @memberof FederationNetworksApiFegNetworkIdSubscriberConfigBaseNamesBaseNameDelete
     */
    readonly baseName: string
}

/**
 * Request parameters for fegNetworkIdSubscriberConfigBaseNamesBaseNamePost operation in FederationNetworksApi.
 * @export
 * @interface FederationNetworksApiFegNetworkIdSubscriberConfigBaseNamesBaseNamePostRequest
 */
export interface FederationNetworksApiFegNetworkIdSubscriberConfigBaseNamesBaseNamePostRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof FederationNetworksApiFegNetworkIdSubscriberConfigBaseNamesBaseNamePost
     */
    readonly networkId: string

    /**
     * Charging Rule Base Name
     * @type {string}
     * @memberof FederationNetworksApiFegNetworkIdSubscriberConfigBaseNamesBaseNamePost
     */
    readonly baseName: string
}

/**
 * Request parameters for fegNetworkIdSubscriberConfigBaseNamesGet operation in FederationNetworksApi.
 * @export
 * @interface FederationNetworksApiFegNetworkIdSubscriberConfigBaseNamesGetRequest
 */
export interface FederationNetworksApiFegNetworkIdSubscriberConfigBaseNamesGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof FederationNetworksApiFegNetworkIdSubscriberConfigBaseNamesGet
     */
    readonly networkId: string
}

/**
 * Request parameters for fegNetworkIdSubscriberConfigBaseNamesPut operation in FederationNetworksApi.
 * @export
 * @interface FederationNetworksApiFegNetworkIdSubscriberConfigBaseNamesPutRequest
 */
export interface FederationNetworksApiFegNetworkIdSubscriberConfigBaseNamesPutRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof FederationNetworksApiFegNetworkIdSubscriberConfigBaseNamesPut
     */
    readonly networkId: string

    /**
     * Subscriber Config for the Network
     * @type {Array<string>}
     * @memberof FederationNetworksApiFegNetworkIdSubscriberConfigBaseNamesPut
     */
    readonly record: Array<string>
}

/**
 * Request parameters for fegNetworkIdSubscriberConfigGet operation in FederationNetworksApi.
 * @export
 * @interface FederationNetworksApiFegNetworkIdSubscriberConfigGetRequest
 */
export interface FederationNetworksApiFegNetworkIdSubscriberConfigGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof FederationNetworksApiFegNetworkIdSubscriberConfigGet
     */
    readonly networkId: string
}

/**
 * Request parameters for fegNetworkIdSubscriberConfigPut operation in FederationNetworksApi.
 * @export
 * @interface FederationNetworksApiFegNetworkIdSubscriberConfigPutRequest
 */
export interface FederationNetworksApiFegNetworkIdSubscriberConfigPutRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof FederationNetworksApiFegNetworkIdSubscriberConfigPut
     */
    readonly networkId: string

    /**
     * Subscriber Config for the Network
     * @type {NetworkSubscriberConfig}
     * @memberof FederationNetworksApiFegNetworkIdSubscriberConfigPut
     */
    readonly record: NetworkSubscriberConfig
}

/**
 * Request parameters for fegNetworkIdSubscriberConfigRuleNamesGet operation in FederationNetworksApi.
 * @export
 * @interface FederationNetworksApiFegNetworkIdSubscriberConfigRuleNamesGetRequest
 */
export interface FederationNetworksApiFegNetworkIdSubscriberConfigRuleNamesGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof FederationNetworksApiFegNetworkIdSubscriberConfigRuleNamesGet
     */
    readonly networkId: string
}

/**
 * Request parameters for fegNetworkIdSubscriberConfigRuleNamesPut operation in FederationNetworksApi.
 * @export
 * @interface FederationNetworksApiFegNetworkIdSubscriberConfigRuleNamesPutRequest
 */
export interface FederationNetworksApiFegNetworkIdSubscriberConfigRuleNamesPutRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof FederationNetworksApiFegNetworkIdSubscriberConfigRuleNamesPut
     */
    readonly networkId: string

    /**
     * Subscriber Config for the Network
     * @type {Array<string>}
     * @memberof FederationNetworksApiFegNetworkIdSubscriberConfigRuleNamesPut
     */
    readonly record: Array<string>
}

/**
 * Request parameters for fegNetworkIdSubscriberConfigRuleNamesRuleIdDelete operation in FederationNetworksApi.
 * @export
 * @interface FederationNetworksApiFegNetworkIdSubscriberConfigRuleNamesRuleIdDeleteRequest
 */
export interface FederationNetworksApiFegNetworkIdSubscriberConfigRuleNamesRuleIdDeleteRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof FederationNetworksApiFegNetworkIdSubscriberConfigRuleNamesRuleIdDelete
     */
    readonly networkId: string

    /**
     * Rule Id
     * @type {string}
     * @memberof FederationNetworksApiFegNetworkIdSubscriberConfigRuleNamesRuleIdDelete
     */
    readonly ruleId: string
}

/**
 * Request parameters for fegNetworkIdSubscriberConfigRuleNamesRuleIdPost operation in FederationNetworksApi.
 * @export
 * @interface FederationNetworksApiFegNetworkIdSubscriberConfigRuleNamesRuleIdPostRequest
 */
export interface FederationNetworksApiFegNetworkIdSubscriberConfigRuleNamesRuleIdPostRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof FederationNetworksApiFegNetworkIdSubscriberConfigRuleNamesRuleIdPost
     */
    readonly networkId: string

    /**
     * Rule Id
     * @type {string}
     * @memberof FederationNetworksApiFegNetworkIdSubscriberConfigRuleNamesRuleIdPost
     */
    readonly ruleId: string
}

/**
 * Request parameters for fegPost operation in FederationNetworksApi.
 * @export
 * @interface FederationNetworksApiFegPostRequest
 */
export interface FederationNetworksApiFegPostRequest {
    /**
     * Configuration of the network to create
     * @type {FegNetwork}
     * @memberof FederationNetworksApiFegPost
     */
    readonly fegNetwork: FegNetwork
}

/**
 * FederationNetworksApi - object-oriented interface
 * @export
 * @class FederationNetworksApi
 * @extends {BaseAPI}
 */
export class FederationNetworksApi extends BaseAPI {
    /**
     * 
     * @summary List all federation network IDs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FederationNetworksApi
     */
    public fegGet(options?: AxiosRequestConfig) {
        return FederationNetworksApiFp(this.configuration).fegGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve HA cluster status of a Federation Network
     * @param {FederationNetworksApiFegNetworkIdClusterStatusGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FederationNetworksApi
     */
    public fegNetworkIdClusterStatusGet(requestParameters: FederationNetworksApiFegNetworkIdClusterStatusGetRequest, options?: AxiosRequestConfig) {
        return FederationNetworksApiFp(this.configuration).fegNetworkIdClusterStatusGet(requestParameters.networkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a federation network
     * @param {FederationNetworksApiFegNetworkIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FederationNetworksApi
     */
    public fegNetworkIdDelete(requestParameters: FederationNetworksApiFegNetworkIdDeleteRequest, options?: AxiosRequestConfig) {
        return FederationNetworksApiFp(this.configuration).fegNetworkIdDelete(requestParameters.networkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Network Federation Configs
     * @param {FederationNetworksApiFegNetworkIdFederationDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FederationNetworksApi
     */
    public fegNetworkIdFederationDelete(requestParameters: FederationNetworksApiFegNetworkIdFederationDeleteRequest, options?: AxiosRequestConfig) {
        return FederationNetworksApiFp(this.configuration).fegNetworkIdFederationDelete(requestParameters.networkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve Network Federation Configs
     * @param {FederationNetworksApiFegNetworkIdFederationGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FederationNetworksApi
     */
    public fegNetworkIdFederationGet(requestParameters: FederationNetworksApiFegNetworkIdFederationGetRequest, options?: AxiosRequestConfig) {
        return FederationNetworksApiFp(this.configuration).fegNetworkIdFederationGet(requestParameters.networkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create or Modify Network Federation Configs
     * @param {FederationNetworksApiFegNetworkIdFederationPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FederationNetworksApi
     */
    public fegNetworkIdFederationPut(requestParameters: FederationNetworksApiFegNetworkIdFederationPutRequest, options?: AxiosRequestConfig) {
        return FederationNetworksApiFp(this.configuration).fegNetworkIdFederationPut(requestParameters.networkId, requestParameters.config, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Describe a federation network
     * @param {FederationNetworksApiFegNetworkIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FederationNetworksApi
     */
    public fegNetworkIdGet(requestParameters: FederationNetworksApiFegNetworkIdGetRequest, options?: AxiosRequestConfig) {
        return FederationNetworksApiFp(this.configuration).fegNetworkIdGet(requestParameters.networkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an entire federation network
     * @param {FederationNetworksApiFegNetworkIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FederationNetworksApi
     */
    public fegNetworkIdPut(requestParameters: FederationNetworksApiFegNetworkIdPutRequest, options?: AxiosRequestConfig) {
        return FederationNetworksApiFp(this.configuration).fegNetworkIdPut(requestParameters.networkId, requestParameters.fegNetwork, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add a network-wide base name
     * @param {FederationNetworksApiFegNetworkIdSubscriberConfigBaseNamesBaseNameDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FederationNetworksApi
     */
    public fegNetworkIdSubscriberConfigBaseNamesBaseNameDelete(requestParameters: FederationNetworksApiFegNetworkIdSubscriberConfigBaseNamesBaseNameDeleteRequest, options?: AxiosRequestConfig) {
        return FederationNetworksApiFp(this.configuration).fegNetworkIdSubscriberConfigBaseNamesBaseNameDelete(requestParameters.networkId, requestParameters.baseName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add a network-wide base name
     * @param {FederationNetworksApiFegNetworkIdSubscriberConfigBaseNamesBaseNamePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FederationNetworksApi
     */
    public fegNetworkIdSubscriberConfigBaseNamesBaseNamePost(requestParameters: FederationNetworksApiFegNetworkIdSubscriberConfigBaseNamesBaseNamePostRequest, options?: AxiosRequestConfig) {
        return FederationNetworksApiFp(this.configuration).fegNetworkIdSubscriberConfigBaseNamesBaseNamePost(requestParameters.networkId, requestParameters.baseName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get network-wide base names
     * @param {FederationNetworksApiFegNetworkIdSubscriberConfigBaseNamesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FederationNetworksApi
     */
    public fegNetworkIdSubscriberConfigBaseNamesGet(requestParameters: FederationNetworksApiFegNetworkIdSubscriberConfigBaseNamesGetRequest, options?: AxiosRequestConfig) {
        return FederationNetworksApiFp(this.configuration).fegNetworkIdSubscriberConfigBaseNamesGet(requestParameters.networkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update network-wide base names
     * @param {FederationNetworksApiFegNetworkIdSubscriberConfigBaseNamesPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FederationNetworksApi
     */
    public fegNetworkIdSubscriberConfigBaseNamesPut(requestParameters: FederationNetworksApiFegNetworkIdSubscriberConfigBaseNamesPutRequest, options?: AxiosRequestConfig) {
        return FederationNetworksApiFp(this.configuration).fegNetworkIdSubscriberConfigBaseNamesPut(requestParameters.networkId, requestParameters.record, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a network-wide subscriber config
     * @param {FederationNetworksApiFegNetworkIdSubscriberConfigGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FederationNetworksApi
     */
    public fegNetworkIdSubscriberConfigGet(requestParameters: FederationNetworksApiFegNetworkIdSubscriberConfigGetRequest, options?: AxiosRequestConfig) {
        return FederationNetworksApiFp(this.configuration).fegNetworkIdSubscriberConfigGet(requestParameters.networkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a network-wide subscriber config
     * @param {FederationNetworksApiFegNetworkIdSubscriberConfigPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FederationNetworksApi
     */
    public fegNetworkIdSubscriberConfigPut(requestParameters: FederationNetworksApiFegNetworkIdSubscriberConfigPutRequest, options?: AxiosRequestConfig) {
        return FederationNetworksApiFp(this.configuration).fegNetworkIdSubscriberConfigPut(requestParameters.networkId, requestParameters.record, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get network-wide rule names
     * @param {FederationNetworksApiFegNetworkIdSubscriberConfigRuleNamesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FederationNetworksApi
     */
    public fegNetworkIdSubscriberConfigRuleNamesGet(requestParameters: FederationNetworksApiFegNetworkIdSubscriberConfigRuleNamesGetRequest, options?: AxiosRequestConfig) {
        return FederationNetworksApiFp(this.configuration).fegNetworkIdSubscriberConfigRuleNamesGet(requestParameters.networkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update network-wide rule names
     * @param {FederationNetworksApiFegNetworkIdSubscriberConfigRuleNamesPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FederationNetworksApi
     */
    public fegNetworkIdSubscriberConfigRuleNamesPut(requestParameters: FederationNetworksApiFegNetworkIdSubscriberConfigRuleNamesPutRequest, options?: AxiosRequestConfig) {
        return FederationNetworksApiFp(this.configuration).fegNetworkIdSubscriberConfigRuleNamesPut(requestParameters.networkId, requestParameters.record, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add a network-wide rule name
     * @param {FederationNetworksApiFegNetworkIdSubscriberConfigRuleNamesRuleIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FederationNetworksApi
     */
    public fegNetworkIdSubscriberConfigRuleNamesRuleIdDelete(requestParameters: FederationNetworksApiFegNetworkIdSubscriberConfigRuleNamesRuleIdDeleteRequest, options?: AxiosRequestConfig) {
        return FederationNetworksApiFp(this.configuration).fegNetworkIdSubscriberConfigRuleNamesRuleIdDelete(requestParameters.networkId, requestParameters.ruleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add a network-wide rule name
     * @param {FederationNetworksApiFegNetworkIdSubscriberConfigRuleNamesRuleIdPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FederationNetworksApi
     */
    public fegNetworkIdSubscriberConfigRuleNamesRuleIdPost(requestParameters: FederationNetworksApiFegNetworkIdSubscriberConfigRuleNamesRuleIdPostRequest, options?: AxiosRequestConfig) {
        return FederationNetworksApiFp(this.configuration).fegNetworkIdSubscriberConfigRuleNamesRuleIdPost(requestParameters.networkId, requestParameters.ruleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new federation network
     * @param {FederationNetworksApiFegPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FederationNetworksApi
     */
    public fegPost(requestParameters: FederationNetworksApiFegPostRequest, options?: AxiosRequestConfig) {
        return FederationNetworksApiFp(this.configuration).fegPost(requestParameters.fegNetwork, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * GatewaysApi - axios parameter creator
 * @export
 */
export const GatewaysApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete a gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdGatewaysGatewayIdDelete: async (networkId: string, gatewayId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networksNetworkIdGatewaysGatewayIdDelete', 'networkId', networkId)
            // verify required parameter 'gatewayId' is not null or undefined
            assertParamExists('networksNetworkIdGatewaysGatewayIdDelete', 'gatewayId', gatewayId)
            const localVarPath = `/networks/{network_id}/gateways/{gateway_id}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"gateway_id"}}`, encodeURIComponent(String(gatewayId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the description of a gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdGatewaysGatewayIdDescriptionGet: async (networkId: string, gatewayId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networksNetworkIdGatewaysGatewayIdDescriptionGet', 'networkId', networkId)
            // verify required parameter 'gatewayId' is not null or undefined
            assertParamExists('networksNetworkIdGatewaysGatewayIdDescriptionGet', 'gatewayId', gatewayId)
            const localVarPath = `/networks/{network_id}/gateways/{gateway_id}/description`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"gateway_id"}}`, encodeURIComponent(String(gatewayId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the description of a gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {string} description 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdGatewaysGatewayIdDescriptionPut: async (networkId: string, gatewayId: string, description: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networksNetworkIdGatewaysGatewayIdDescriptionPut', 'networkId', networkId)
            // verify required parameter 'gatewayId' is not null or undefined
            assertParamExists('networksNetworkIdGatewaysGatewayIdDescriptionPut', 'gatewayId', gatewayId)
            // verify required parameter 'description' is not null or undefined
            assertParamExists('networksNetworkIdGatewaysGatewayIdDescriptionPut', 'description', description)
            const localVarPath = `/networks/{network_id}/gateways/{gateway_id}/description`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"gateway_id"}}`, encodeURIComponent(String(gatewayId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(description, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the physical device for a gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdGatewaysGatewayIdDeviceGet: async (networkId: string, gatewayId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networksNetworkIdGatewaysGatewayIdDeviceGet', 'networkId', networkId)
            // verify required parameter 'gatewayId' is not null or undefined
            assertParamExists('networksNetworkIdGatewaysGatewayIdDeviceGet', 'gatewayId', gatewayId)
            const localVarPath = `/networks/{network_id}/gateways/{gateway_id}/device`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"gateway_id"}}`, encodeURIComponent(String(gatewayId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the physical device for a gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {GatewayDevice} device New device for the gateway
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdGatewaysGatewayIdDevicePut: async (networkId: string, gatewayId: string, device: GatewayDevice, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networksNetworkIdGatewaysGatewayIdDevicePut', 'networkId', networkId)
            // verify required parameter 'gatewayId' is not null or undefined
            assertParamExists('networksNetworkIdGatewaysGatewayIdDevicePut', 'gatewayId', gatewayId)
            // verify required parameter 'device' is not null or undefined
            assertParamExists('networksNetworkIdGatewaysGatewayIdDevicePut', 'device', device)
            const localVarPath = `/networks/{network_id}/gateways/{gateway_id}/device`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"gateway_id"}}`, encodeURIComponent(String(gatewayId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(device, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a specific gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdGatewaysGatewayIdGet: async (networkId: string, gatewayId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networksNetworkIdGatewaysGatewayIdGet', 'networkId', networkId)
            // verify required parameter 'gatewayId' is not null or undefined
            assertParamExists('networksNetworkIdGatewaysGatewayIdGet', 'gatewayId', gatewayId)
            const localVarPath = `/networks/{network_id}/gateways/{gateway_id}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"gateway_id"}}`, encodeURIComponent(String(gatewayId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get magmad agent configuration
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdGatewaysGatewayIdMagmadGet: async (networkId: string, gatewayId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networksNetworkIdGatewaysGatewayIdMagmadGet', 'networkId', networkId)
            // verify required parameter 'gatewayId' is not null or undefined
            assertParamExists('networksNetworkIdGatewaysGatewayIdMagmadGet', 'gatewayId', gatewayId)
            const localVarPath = `/networks/{network_id}/gateways/{gateway_id}/magmad`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"gateway_id"}}`, encodeURIComponent(String(gatewayId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reconfigure magmad agent
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {MagmadGatewayConfigs} magmad New magmad configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdGatewaysGatewayIdMagmadPut: async (networkId: string, gatewayId: string, magmad: MagmadGatewayConfigs, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networksNetworkIdGatewaysGatewayIdMagmadPut', 'networkId', networkId)
            // verify required parameter 'gatewayId' is not null or undefined
            assertParamExists('networksNetworkIdGatewaysGatewayIdMagmadPut', 'gatewayId', gatewayId)
            // verify required parameter 'magmad' is not null or undefined
            assertParamExists('networksNetworkIdGatewaysGatewayIdMagmadPut', 'magmad', magmad)
            const localVarPath = `/networks/{network_id}/gateways/{gateway_id}/magmad`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"gateway_id"}}`, encodeURIComponent(String(gatewayId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(magmad, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the name of a gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdGatewaysGatewayIdNameGet: async (networkId: string, gatewayId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networksNetworkIdGatewaysGatewayIdNameGet', 'networkId', networkId)
            // verify required parameter 'gatewayId' is not null or undefined
            assertParamExists('networksNetworkIdGatewaysGatewayIdNameGet', 'gatewayId', gatewayId)
            const localVarPath = `/networks/{network_id}/gateways/{gateway_id}/name`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"gateway_id"}}`, encodeURIComponent(String(gatewayId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the name of a gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdGatewaysGatewayIdNamePut: async (networkId: string, gatewayId: string, name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networksNetworkIdGatewaysGatewayIdNamePut', 'networkId', networkId)
            // verify required parameter 'gatewayId' is not null or undefined
            assertParamExists('networksNetworkIdGatewaysGatewayIdNamePut', 'gatewayId', gatewayId)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('networksNetworkIdGatewaysGatewayIdNamePut', 'name', name)
            const localVarPath = `/networks/{network_id}/gateways/{gateway_id}/name`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"gateway_id"}}`, encodeURIComponent(String(gatewayId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(name, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an entire gateway record
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {MagmadGateway} gateway Full desired configuration of the gateway
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdGatewaysGatewayIdPut: async (networkId: string, gatewayId: string, gateway: MagmadGateway, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networksNetworkIdGatewaysGatewayIdPut', 'networkId', networkId)
            // verify required parameter 'gatewayId' is not null or undefined
            assertParamExists('networksNetworkIdGatewaysGatewayIdPut', 'gatewayId', gatewayId)
            // verify required parameter 'gateway' is not null or undefined
            assertParamExists('networksNetworkIdGatewaysGatewayIdPut', 'gateway', gateway)
            const localVarPath = `/networks/{network_id}/gateways/{gateway_id}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"gateway_id"}}`, encodeURIComponent(String(gatewayId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(gateway, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the status of a gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdGatewaysGatewayIdStatusGet: async (networkId: string, gatewayId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networksNetworkIdGatewaysGatewayIdStatusGet', 'networkId', networkId)
            // verify required parameter 'gatewayId' is not null or undefined
            assertParamExists('networksNetworkIdGatewaysGatewayIdStatusGet', 'gatewayId', gatewayId)
            const localVarPath = `/networks/{network_id}/gateways/{gateway_id}/status`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"gateway_id"}}`, encodeURIComponent(String(gatewayId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the ID of the upgrade tier a gateway belongs to
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdGatewaysGatewayIdTierGet: async (networkId: string, gatewayId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networksNetworkIdGatewaysGatewayIdTierGet', 'networkId', networkId)
            // verify required parameter 'gatewayId' is not null or undefined
            assertParamExists('networksNetworkIdGatewaysGatewayIdTierGet', 'gatewayId', gatewayId)
            const localVarPath = `/networks/{network_id}/gateways/{gateway_id}/tier`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"gateway_id"}}`, encodeURIComponent(String(gatewayId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the ID of the upgrade tier a gateway belongs to
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {string} tierId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdGatewaysGatewayIdTierPut: async (networkId: string, gatewayId: string, tierId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networksNetworkIdGatewaysGatewayIdTierPut', 'networkId', networkId)
            // verify required parameter 'gatewayId' is not null or undefined
            assertParamExists('networksNetworkIdGatewaysGatewayIdTierPut', 'gatewayId', gatewayId)
            // verify required parameter 'tierId' is not null or undefined
            assertParamExists('networksNetworkIdGatewaysGatewayIdTierPut', 'tierId', tierId)
            const localVarPath = `/networks/{network_id}/gateways/{gateway_id}/tier`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"gateway_id"}}`, encodeURIComponent(String(gatewayId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tierId, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all gateways for a network
         * @param {string} networkId Network ID
         * @param {number} [pageSize] Maximum number of entities to return
         * @param {string} [pageToken] Opaque page token for paginated requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdGatewaysGet: async (networkId: string, pageSize?: number, pageToken?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networksNetworkIdGatewaysGet', 'networkId', networkId)
            const localVarPath = `/networks/{network_id}/gateways`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = pageToken;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Register a new gateway
         * @param {string} networkId Network ID
         * @param {MagmadGateway} gateway Full desired configuration of the gateway
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdGatewaysPost: async (networkId: string, gateway: MagmadGateway, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networksNetworkIdGatewaysPost', 'networkId', networkId)
            // verify required parameter 'gateway' is not null or undefined
            assertParamExists('networksNetworkIdGatewaysPost', 'gateway', gateway)
            const localVarPath = `/networks/{network_id}/gateways`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(gateway, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GatewaysApi - functional programming interface
 * @export
 */
export const GatewaysApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GatewaysApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete a gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksNetworkIdGatewaysGatewayIdDelete(networkId: string, gatewayId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksNetworkIdGatewaysGatewayIdDelete(networkId, gatewayId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the description of a gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksNetworkIdGatewaysGatewayIdDescriptionGet(networkId: string, gatewayId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksNetworkIdGatewaysGatewayIdDescriptionGet(networkId, gatewayId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update the description of a gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {string} description 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksNetworkIdGatewaysGatewayIdDescriptionPut(networkId: string, gatewayId: string, description: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksNetworkIdGatewaysGatewayIdDescriptionPut(networkId, gatewayId, description, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the physical device for a gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksNetworkIdGatewaysGatewayIdDeviceGet(networkId: string, gatewayId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GatewayDevice>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksNetworkIdGatewaysGatewayIdDeviceGet(networkId, gatewayId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update the physical device for a gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {GatewayDevice} device New device for the gateway
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksNetworkIdGatewaysGatewayIdDevicePut(networkId: string, gatewayId: string, device: GatewayDevice, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksNetworkIdGatewaysGatewayIdDevicePut(networkId, gatewayId, device, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a specific gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksNetworkIdGatewaysGatewayIdGet(networkId: string, gatewayId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MagmadGateway>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksNetworkIdGatewaysGatewayIdGet(networkId, gatewayId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get magmad agent configuration
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksNetworkIdGatewaysGatewayIdMagmadGet(networkId: string, gatewayId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MagmadGatewayConfigs>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksNetworkIdGatewaysGatewayIdMagmadGet(networkId, gatewayId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Reconfigure magmad agent
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {MagmadGatewayConfigs} magmad New magmad configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksNetworkIdGatewaysGatewayIdMagmadPut(networkId: string, gatewayId: string, magmad: MagmadGatewayConfigs, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksNetworkIdGatewaysGatewayIdMagmadPut(networkId, gatewayId, magmad, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the name of a gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksNetworkIdGatewaysGatewayIdNameGet(networkId: string, gatewayId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksNetworkIdGatewaysGatewayIdNameGet(networkId, gatewayId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update the name of a gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksNetworkIdGatewaysGatewayIdNamePut(networkId: string, gatewayId: string, name: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksNetworkIdGatewaysGatewayIdNamePut(networkId, gatewayId, name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update an entire gateway record
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {MagmadGateway} gateway Full desired configuration of the gateway
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksNetworkIdGatewaysGatewayIdPut(networkId: string, gatewayId: string, gateway: MagmadGateway, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksNetworkIdGatewaysGatewayIdPut(networkId, gatewayId, gateway, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the status of a gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksNetworkIdGatewaysGatewayIdStatusGet(networkId: string, gatewayId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GatewayStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksNetworkIdGatewaysGatewayIdStatusGet(networkId, gatewayId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the ID of the upgrade tier a gateway belongs to
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksNetworkIdGatewaysGatewayIdTierGet(networkId: string, gatewayId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksNetworkIdGatewaysGatewayIdTierGet(networkId, gatewayId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update the ID of the upgrade tier a gateway belongs to
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {string} tierId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksNetworkIdGatewaysGatewayIdTierPut(networkId: string, gatewayId: string, tierId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksNetworkIdGatewaysGatewayIdTierPut(networkId, gatewayId, tierId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all gateways for a network
         * @param {string} networkId Network ID
         * @param {number} [pageSize] Maximum number of entities to return
         * @param {string} [pageToken] Opaque page token for paginated requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksNetworkIdGatewaysGet(networkId: string, pageSize?: number, pageToken?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedGateways>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksNetworkIdGatewaysGet(networkId, pageSize, pageToken, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Register a new gateway
         * @param {string} networkId Network ID
         * @param {MagmadGateway} gateway Full desired configuration of the gateway
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksNetworkIdGatewaysPost(networkId: string, gateway: MagmadGateway, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksNetworkIdGatewaysPost(networkId, gateway, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * GatewaysApi - factory interface
 * @export
 */
export const GatewaysApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GatewaysApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete a gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdGatewaysGatewayIdDelete(networkId: string, gatewayId: string, options?: any): AxiosPromise<void> {
            return localVarFp.networksNetworkIdGatewaysGatewayIdDelete(networkId, gatewayId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the description of a gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdGatewaysGatewayIdDescriptionGet(networkId: string, gatewayId: string, options?: any): AxiosPromise<string> {
            return localVarFp.networksNetworkIdGatewaysGatewayIdDescriptionGet(networkId, gatewayId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the description of a gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {string} description 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdGatewaysGatewayIdDescriptionPut(networkId: string, gatewayId: string, description: string, options?: any): AxiosPromise<void> {
            return localVarFp.networksNetworkIdGatewaysGatewayIdDescriptionPut(networkId, gatewayId, description, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the physical device for a gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdGatewaysGatewayIdDeviceGet(networkId: string, gatewayId: string, options?: any): AxiosPromise<GatewayDevice> {
            return localVarFp.networksNetworkIdGatewaysGatewayIdDeviceGet(networkId, gatewayId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the physical device for a gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {GatewayDevice} device New device for the gateway
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdGatewaysGatewayIdDevicePut(networkId: string, gatewayId: string, device: GatewayDevice, options?: any): AxiosPromise<void> {
            return localVarFp.networksNetworkIdGatewaysGatewayIdDevicePut(networkId, gatewayId, device, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a specific gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdGatewaysGatewayIdGet(networkId: string, gatewayId: string, options?: any): AxiosPromise<MagmadGateway> {
            return localVarFp.networksNetworkIdGatewaysGatewayIdGet(networkId, gatewayId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get magmad agent configuration
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdGatewaysGatewayIdMagmadGet(networkId: string, gatewayId: string, options?: any): AxiosPromise<MagmadGatewayConfigs> {
            return localVarFp.networksNetworkIdGatewaysGatewayIdMagmadGet(networkId, gatewayId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reconfigure magmad agent
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {MagmadGatewayConfigs} magmad New magmad configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdGatewaysGatewayIdMagmadPut(networkId: string, gatewayId: string, magmad: MagmadGatewayConfigs, options?: any): AxiosPromise<void> {
            return localVarFp.networksNetworkIdGatewaysGatewayIdMagmadPut(networkId, gatewayId, magmad, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the name of a gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdGatewaysGatewayIdNameGet(networkId: string, gatewayId: string, options?: any): AxiosPromise<string> {
            return localVarFp.networksNetworkIdGatewaysGatewayIdNameGet(networkId, gatewayId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the name of a gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdGatewaysGatewayIdNamePut(networkId: string, gatewayId: string, name: string, options?: any): AxiosPromise<void> {
            return localVarFp.networksNetworkIdGatewaysGatewayIdNamePut(networkId, gatewayId, name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an entire gateway record
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {MagmadGateway} gateway Full desired configuration of the gateway
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdGatewaysGatewayIdPut(networkId: string, gatewayId: string, gateway: MagmadGateway, options?: any): AxiosPromise<void> {
            return localVarFp.networksNetworkIdGatewaysGatewayIdPut(networkId, gatewayId, gateway, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the status of a gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdGatewaysGatewayIdStatusGet(networkId: string, gatewayId: string, options?: any): AxiosPromise<GatewayStatus> {
            return localVarFp.networksNetworkIdGatewaysGatewayIdStatusGet(networkId, gatewayId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the ID of the upgrade tier a gateway belongs to
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdGatewaysGatewayIdTierGet(networkId: string, gatewayId: string, options?: any): AxiosPromise<string> {
            return localVarFp.networksNetworkIdGatewaysGatewayIdTierGet(networkId, gatewayId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the ID of the upgrade tier a gateway belongs to
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {string} tierId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdGatewaysGatewayIdTierPut(networkId: string, gatewayId: string, tierId: string, options?: any): AxiosPromise<void> {
            return localVarFp.networksNetworkIdGatewaysGatewayIdTierPut(networkId, gatewayId, tierId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all gateways for a network
         * @param {string} networkId Network ID
         * @param {number} [pageSize] Maximum number of entities to return
         * @param {string} [pageToken] Opaque page token for paginated requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdGatewaysGet(networkId: string, pageSize?: number, pageToken?: string, options?: any): AxiosPromise<PaginatedGateways> {
            return localVarFp.networksNetworkIdGatewaysGet(networkId, pageSize, pageToken, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Register a new gateway
         * @param {string} networkId Network ID
         * @param {MagmadGateway} gateway Full desired configuration of the gateway
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdGatewaysPost(networkId: string, gateway: MagmadGateway, options?: any): AxiosPromise<void> {
            return localVarFp.networksNetworkIdGatewaysPost(networkId, gateway, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for networksNetworkIdGatewaysGatewayIdDelete operation in GatewaysApi.
 * @export
 * @interface GatewaysApiNetworksNetworkIdGatewaysGatewayIdDeleteRequest
 */
export interface GatewaysApiNetworksNetworkIdGatewaysGatewayIdDeleteRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof GatewaysApiNetworksNetworkIdGatewaysGatewayIdDelete
     */
    readonly networkId: string

    /**
     * Gateway ID
     * @type {string}
     * @memberof GatewaysApiNetworksNetworkIdGatewaysGatewayIdDelete
     */
    readonly gatewayId: string
}

/**
 * Request parameters for networksNetworkIdGatewaysGatewayIdDescriptionGet operation in GatewaysApi.
 * @export
 * @interface GatewaysApiNetworksNetworkIdGatewaysGatewayIdDescriptionGetRequest
 */
export interface GatewaysApiNetworksNetworkIdGatewaysGatewayIdDescriptionGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof GatewaysApiNetworksNetworkIdGatewaysGatewayIdDescriptionGet
     */
    readonly networkId: string

    /**
     * Gateway ID
     * @type {string}
     * @memberof GatewaysApiNetworksNetworkIdGatewaysGatewayIdDescriptionGet
     */
    readonly gatewayId: string
}

/**
 * Request parameters for networksNetworkIdGatewaysGatewayIdDescriptionPut operation in GatewaysApi.
 * @export
 * @interface GatewaysApiNetworksNetworkIdGatewaysGatewayIdDescriptionPutRequest
 */
export interface GatewaysApiNetworksNetworkIdGatewaysGatewayIdDescriptionPutRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof GatewaysApiNetworksNetworkIdGatewaysGatewayIdDescriptionPut
     */
    readonly networkId: string

    /**
     * Gateway ID
     * @type {string}
     * @memberof GatewaysApiNetworksNetworkIdGatewaysGatewayIdDescriptionPut
     */
    readonly gatewayId: string

    /**
     * 
     * @type {string}
     * @memberof GatewaysApiNetworksNetworkIdGatewaysGatewayIdDescriptionPut
     */
    readonly description: string
}

/**
 * Request parameters for networksNetworkIdGatewaysGatewayIdDeviceGet operation in GatewaysApi.
 * @export
 * @interface GatewaysApiNetworksNetworkIdGatewaysGatewayIdDeviceGetRequest
 */
export interface GatewaysApiNetworksNetworkIdGatewaysGatewayIdDeviceGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof GatewaysApiNetworksNetworkIdGatewaysGatewayIdDeviceGet
     */
    readonly networkId: string

    /**
     * Gateway ID
     * @type {string}
     * @memberof GatewaysApiNetworksNetworkIdGatewaysGatewayIdDeviceGet
     */
    readonly gatewayId: string
}

/**
 * Request parameters for networksNetworkIdGatewaysGatewayIdDevicePut operation in GatewaysApi.
 * @export
 * @interface GatewaysApiNetworksNetworkIdGatewaysGatewayIdDevicePutRequest
 */
export interface GatewaysApiNetworksNetworkIdGatewaysGatewayIdDevicePutRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof GatewaysApiNetworksNetworkIdGatewaysGatewayIdDevicePut
     */
    readonly networkId: string

    /**
     * Gateway ID
     * @type {string}
     * @memberof GatewaysApiNetworksNetworkIdGatewaysGatewayIdDevicePut
     */
    readonly gatewayId: string

    /**
     * New device for the gateway
     * @type {GatewayDevice}
     * @memberof GatewaysApiNetworksNetworkIdGatewaysGatewayIdDevicePut
     */
    readonly device: GatewayDevice
}

/**
 * Request parameters for networksNetworkIdGatewaysGatewayIdGet operation in GatewaysApi.
 * @export
 * @interface GatewaysApiNetworksNetworkIdGatewaysGatewayIdGetRequest
 */
export interface GatewaysApiNetworksNetworkIdGatewaysGatewayIdGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof GatewaysApiNetworksNetworkIdGatewaysGatewayIdGet
     */
    readonly networkId: string

    /**
     * Gateway ID
     * @type {string}
     * @memberof GatewaysApiNetworksNetworkIdGatewaysGatewayIdGet
     */
    readonly gatewayId: string
}

/**
 * Request parameters for networksNetworkIdGatewaysGatewayIdMagmadGet operation in GatewaysApi.
 * @export
 * @interface GatewaysApiNetworksNetworkIdGatewaysGatewayIdMagmadGetRequest
 */
export interface GatewaysApiNetworksNetworkIdGatewaysGatewayIdMagmadGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof GatewaysApiNetworksNetworkIdGatewaysGatewayIdMagmadGet
     */
    readonly networkId: string

    /**
     * Gateway ID
     * @type {string}
     * @memberof GatewaysApiNetworksNetworkIdGatewaysGatewayIdMagmadGet
     */
    readonly gatewayId: string
}

/**
 * Request parameters for networksNetworkIdGatewaysGatewayIdMagmadPut operation in GatewaysApi.
 * @export
 * @interface GatewaysApiNetworksNetworkIdGatewaysGatewayIdMagmadPutRequest
 */
export interface GatewaysApiNetworksNetworkIdGatewaysGatewayIdMagmadPutRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof GatewaysApiNetworksNetworkIdGatewaysGatewayIdMagmadPut
     */
    readonly networkId: string

    /**
     * Gateway ID
     * @type {string}
     * @memberof GatewaysApiNetworksNetworkIdGatewaysGatewayIdMagmadPut
     */
    readonly gatewayId: string

    /**
     * New magmad configuration
     * @type {MagmadGatewayConfigs}
     * @memberof GatewaysApiNetworksNetworkIdGatewaysGatewayIdMagmadPut
     */
    readonly magmad: MagmadGatewayConfigs
}

/**
 * Request parameters for networksNetworkIdGatewaysGatewayIdNameGet operation in GatewaysApi.
 * @export
 * @interface GatewaysApiNetworksNetworkIdGatewaysGatewayIdNameGetRequest
 */
export interface GatewaysApiNetworksNetworkIdGatewaysGatewayIdNameGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof GatewaysApiNetworksNetworkIdGatewaysGatewayIdNameGet
     */
    readonly networkId: string

    /**
     * Gateway ID
     * @type {string}
     * @memberof GatewaysApiNetworksNetworkIdGatewaysGatewayIdNameGet
     */
    readonly gatewayId: string
}

/**
 * Request parameters for networksNetworkIdGatewaysGatewayIdNamePut operation in GatewaysApi.
 * @export
 * @interface GatewaysApiNetworksNetworkIdGatewaysGatewayIdNamePutRequest
 */
export interface GatewaysApiNetworksNetworkIdGatewaysGatewayIdNamePutRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof GatewaysApiNetworksNetworkIdGatewaysGatewayIdNamePut
     */
    readonly networkId: string

    /**
     * Gateway ID
     * @type {string}
     * @memberof GatewaysApiNetworksNetworkIdGatewaysGatewayIdNamePut
     */
    readonly gatewayId: string

    /**
     * 
     * @type {string}
     * @memberof GatewaysApiNetworksNetworkIdGatewaysGatewayIdNamePut
     */
    readonly name: string
}

/**
 * Request parameters for networksNetworkIdGatewaysGatewayIdPut operation in GatewaysApi.
 * @export
 * @interface GatewaysApiNetworksNetworkIdGatewaysGatewayIdPutRequest
 */
export interface GatewaysApiNetworksNetworkIdGatewaysGatewayIdPutRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof GatewaysApiNetworksNetworkIdGatewaysGatewayIdPut
     */
    readonly networkId: string

    /**
     * Gateway ID
     * @type {string}
     * @memberof GatewaysApiNetworksNetworkIdGatewaysGatewayIdPut
     */
    readonly gatewayId: string

    /**
     * Full desired configuration of the gateway
     * @type {MagmadGateway}
     * @memberof GatewaysApiNetworksNetworkIdGatewaysGatewayIdPut
     */
    readonly gateway: MagmadGateway
}

/**
 * Request parameters for networksNetworkIdGatewaysGatewayIdStatusGet operation in GatewaysApi.
 * @export
 * @interface GatewaysApiNetworksNetworkIdGatewaysGatewayIdStatusGetRequest
 */
export interface GatewaysApiNetworksNetworkIdGatewaysGatewayIdStatusGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof GatewaysApiNetworksNetworkIdGatewaysGatewayIdStatusGet
     */
    readonly networkId: string

    /**
     * Gateway ID
     * @type {string}
     * @memberof GatewaysApiNetworksNetworkIdGatewaysGatewayIdStatusGet
     */
    readonly gatewayId: string
}

/**
 * Request parameters for networksNetworkIdGatewaysGatewayIdTierGet operation in GatewaysApi.
 * @export
 * @interface GatewaysApiNetworksNetworkIdGatewaysGatewayIdTierGetRequest
 */
export interface GatewaysApiNetworksNetworkIdGatewaysGatewayIdTierGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof GatewaysApiNetworksNetworkIdGatewaysGatewayIdTierGet
     */
    readonly networkId: string

    /**
     * Gateway ID
     * @type {string}
     * @memberof GatewaysApiNetworksNetworkIdGatewaysGatewayIdTierGet
     */
    readonly gatewayId: string
}

/**
 * Request parameters for networksNetworkIdGatewaysGatewayIdTierPut operation in GatewaysApi.
 * @export
 * @interface GatewaysApiNetworksNetworkIdGatewaysGatewayIdTierPutRequest
 */
export interface GatewaysApiNetworksNetworkIdGatewaysGatewayIdTierPutRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof GatewaysApiNetworksNetworkIdGatewaysGatewayIdTierPut
     */
    readonly networkId: string

    /**
     * Gateway ID
     * @type {string}
     * @memberof GatewaysApiNetworksNetworkIdGatewaysGatewayIdTierPut
     */
    readonly gatewayId: string

    /**
     * 
     * @type {string}
     * @memberof GatewaysApiNetworksNetworkIdGatewaysGatewayIdTierPut
     */
    readonly tierId: string
}

/**
 * Request parameters for networksNetworkIdGatewaysGet operation in GatewaysApi.
 * @export
 * @interface GatewaysApiNetworksNetworkIdGatewaysGetRequest
 */
export interface GatewaysApiNetworksNetworkIdGatewaysGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof GatewaysApiNetworksNetworkIdGatewaysGet
     */
    readonly networkId: string

    /**
     * Maximum number of entities to return
     * @type {number}
     * @memberof GatewaysApiNetworksNetworkIdGatewaysGet
     */
    readonly pageSize?: number

    /**
     * Opaque page token for paginated requests
     * @type {string}
     * @memberof GatewaysApiNetworksNetworkIdGatewaysGet
     */
    readonly pageToken?: string
}

/**
 * Request parameters for networksNetworkIdGatewaysPost operation in GatewaysApi.
 * @export
 * @interface GatewaysApiNetworksNetworkIdGatewaysPostRequest
 */
export interface GatewaysApiNetworksNetworkIdGatewaysPostRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof GatewaysApiNetworksNetworkIdGatewaysPost
     */
    readonly networkId: string

    /**
     * Full desired configuration of the gateway
     * @type {MagmadGateway}
     * @memberof GatewaysApiNetworksNetworkIdGatewaysPost
     */
    readonly gateway: MagmadGateway
}

/**
 * GatewaysApi - object-oriented interface
 * @export
 * @class GatewaysApi
 * @extends {BaseAPI}
 */
export class GatewaysApi extends BaseAPI {
    /**
     * 
     * @summary Delete a gateway
     * @param {GatewaysApiNetworksNetworkIdGatewaysGatewayIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GatewaysApi
     */
    public networksNetworkIdGatewaysGatewayIdDelete(requestParameters: GatewaysApiNetworksNetworkIdGatewaysGatewayIdDeleteRequest, options?: AxiosRequestConfig) {
        return GatewaysApiFp(this.configuration).networksNetworkIdGatewaysGatewayIdDelete(requestParameters.networkId, requestParameters.gatewayId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the description of a gateway
     * @param {GatewaysApiNetworksNetworkIdGatewaysGatewayIdDescriptionGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GatewaysApi
     */
    public networksNetworkIdGatewaysGatewayIdDescriptionGet(requestParameters: GatewaysApiNetworksNetworkIdGatewaysGatewayIdDescriptionGetRequest, options?: AxiosRequestConfig) {
        return GatewaysApiFp(this.configuration).networksNetworkIdGatewaysGatewayIdDescriptionGet(requestParameters.networkId, requestParameters.gatewayId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the description of a gateway
     * @param {GatewaysApiNetworksNetworkIdGatewaysGatewayIdDescriptionPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GatewaysApi
     */
    public networksNetworkIdGatewaysGatewayIdDescriptionPut(requestParameters: GatewaysApiNetworksNetworkIdGatewaysGatewayIdDescriptionPutRequest, options?: AxiosRequestConfig) {
        return GatewaysApiFp(this.configuration).networksNetworkIdGatewaysGatewayIdDescriptionPut(requestParameters.networkId, requestParameters.gatewayId, requestParameters.description, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the physical device for a gateway
     * @param {GatewaysApiNetworksNetworkIdGatewaysGatewayIdDeviceGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GatewaysApi
     */
    public networksNetworkIdGatewaysGatewayIdDeviceGet(requestParameters: GatewaysApiNetworksNetworkIdGatewaysGatewayIdDeviceGetRequest, options?: AxiosRequestConfig) {
        return GatewaysApiFp(this.configuration).networksNetworkIdGatewaysGatewayIdDeviceGet(requestParameters.networkId, requestParameters.gatewayId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the physical device for a gateway
     * @param {GatewaysApiNetworksNetworkIdGatewaysGatewayIdDevicePutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GatewaysApi
     */
    public networksNetworkIdGatewaysGatewayIdDevicePut(requestParameters: GatewaysApiNetworksNetworkIdGatewaysGatewayIdDevicePutRequest, options?: AxiosRequestConfig) {
        return GatewaysApiFp(this.configuration).networksNetworkIdGatewaysGatewayIdDevicePut(requestParameters.networkId, requestParameters.gatewayId, requestParameters.device, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a specific gateway
     * @param {GatewaysApiNetworksNetworkIdGatewaysGatewayIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GatewaysApi
     */
    public networksNetworkIdGatewaysGatewayIdGet(requestParameters: GatewaysApiNetworksNetworkIdGatewaysGatewayIdGetRequest, options?: AxiosRequestConfig) {
        return GatewaysApiFp(this.configuration).networksNetworkIdGatewaysGatewayIdGet(requestParameters.networkId, requestParameters.gatewayId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get magmad agent configuration
     * @param {GatewaysApiNetworksNetworkIdGatewaysGatewayIdMagmadGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GatewaysApi
     */
    public networksNetworkIdGatewaysGatewayIdMagmadGet(requestParameters: GatewaysApiNetworksNetworkIdGatewaysGatewayIdMagmadGetRequest, options?: AxiosRequestConfig) {
        return GatewaysApiFp(this.configuration).networksNetworkIdGatewaysGatewayIdMagmadGet(requestParameters.networkId, requestParameters.gatewayId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reconfigure magmad agent
     * @param {GatewaysApiNetworksNetworkIdGatewaysGatewayIdMagmadPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GatewaysApi
     */
    public networksNetworkIdGatewaysGatewayIdMagmadPut(requestParameters: GatewaysApiNetworksNetworkIdGatewaysGatewayIdMagmadPutRequest, options?: AxiosRequestConfig) {
        return GatewaysApiFp(this.configuration).networksNetworkIdGatewaysGatewayIdMagmadPut(requestParameters.networkId, requestParameters.gatewayId, requestParameters.magmad, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the name of a gateway
     * @param {GatewaysApiNetworksNetworkIdGatewaysGatewayIdNameGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GatewaysApi
     */
    public networksNetworkIdGatewaysGatewayIdNameGet(requestParameters: GatewaysApiNetworksNetworkIdGatewaysGatewayIdNameGetRequest, options?: AxiosRequestConfig) {
        return GatewaysApiFp(this.configuration).networksNetworkIdGatewaysGatewayIdNameGet(requestParameters.networkId, requestParameters.gatewayId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the name of a gateway
     * @param {GatewaysApiNetworksNetworkIdGatewaysGatewayIdNamePutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GatewaysApi
     */
    public networksNetworkIdGatewaysGatewayIdNamePut(requestParameters: GatewaysApiNetworksNetworkIdGatewaysGatewayIdNamePutRequest, options?: AxiosRequestConfig) {
        return GatewaysApiFp(this.configuration).networksNetworkIdGatewaysGatewayIdNamePut(requestParameters.networkId, requestParameters.gatewayId, requestParameters.name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an entire gateway record
     * @param {GatewaysApiNetworksNetworkIdGatewaysGatewayIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GatewaysApi
     */
    public networksNetworkIdGatewaysGatewayIdPut(requestParameters: GatewaysApiNetworksNetworkIdGatewaysGatewayIdPutRequest, options?: AxiosRequestConfig) {
        return GatewaysApiFp(this.configuration).networksNetworkIdGatewaysGatewayIdPut(requestParameters.networkId, requestParameters.gatewayId, requestParameters.gateway, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the status of a gateway
     * @param {GatewaysApiNetworksNetworkIdGatewaysGatewayIdStatusGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GatewaysApi
     */
    public networksNetworkIdGatewaysGatewayIdStatusGet(requestParameters: GatewaysApiNetworksNetworkIdGatewaysGatewayIdStatusGetRequest, options?: AxiosRequestConfig) {
        return GatewaysApiFp(this.configuration).networksNetworkIdGatewaysGatewayIdStatusGet(requestParameters.networkId, requestParameters.gatewayId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the ID of the upgrade tier a gateway belongs to
     * @param {GatewaysApiNetworksNetworkIdGatewaysGatewayIdTierGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GatewaysApi
     */
    public networksNetworkIdGatewaysGatewayIdTierGet(requestParameters: GatewaysApiNetworksNetworkIdGatewaysGatewayIdTierGetRequest, options?: AxiosRequestConfig) {
        return GatewaysApiFp(this.configuration).networksNetworkIdGatewaysGatewayIdTierGet(requestParameters.networkId, requestParameters.gatewayId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the ID of the upgrade tier a gateway belongs to
     * @param {GatewaysApiNetworksNetworkIdGatewaysGatewayIdTierPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GatewaysApi
     */
    public networksNetworkIdGatewaysGatewayIdTierPut(requestParameters: GatewaysApiNetworksNetworkIdGatewaysGatewayIdTierPutRequest, options?: AxiosRequestConfig) {
        return GatewaysApiFp(this.configuration).networksNetworkIdGatewaysGatewayIdTierPut(requestParameters.networkId, requestParameters.gatewayId, requestParameters.tierId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all gateways for a network
     * @param {GatewaysApiNetworksNetworkIdGatewaysGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GatewaysApi
     */
    public networksNetworkIdGatewaysGet(requestParameters: GatewaysApiNetworksNetworkIdGatewaysGetRequest, options?: AxiosRequestConfig) {
        return GatewaysApiFp(this.configuration).networksNetworkIdGatewaysGet(requestParameters.networkId, requestParameters.pageSize, requestParameters.pageToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Register a new gateway
     * @param {GatewaysApiNetworksNetworkIdGatewaysPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GatewaysApi
     */
    public networksNetworkIdGatewaysPost(requestParameters: GatewaysApiNetworksNetworkIdGatewaysPostRequest, options?: AxiosRequestConfig) {
        return GatewaysApiFp(this.configuration).networksNetworkIdGatewaysPost(requestParameters.networkId, requestParameters.gateway, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * LTEGatewaysApi - axios parameter creator
 * @export
 */
export const LTEGatewaysApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get DNS configuration of LTE gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdGatewaysGatewayIdCellularDnsGet: async (networkId: string, gatewayId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdGatewaysGatewayIdCellularDnsGet', 'networkId', networkId)
            // verify required parameter 'gatewayId' is not null or undefined
            assertParamExists('lteNetworkIdGatewaysGatewayIdCellularDnsGet', 'gatewayId', gatewayId)
            const localVarPath = `/lte/{network_id}/gateways/{gateway_id}/cellular/dns`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"gateway_id"}}`, encodeURIComponent(String(gatewayId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update DNS configuration of LTE gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {GatewayDnsConfigs} config New DNS configuration for the gateway
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdGatewaysGatewayIdCellularDnsPut: async (networkId: string, gatewayId: string, config: GatewayDnsConfigs, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdGatewaysGatewayIdCellularDnsPut', 'networkId', networkId)
            // verify required parameter 'gatewayId' is not null or undefined
            assertParamExists('lteNetworkIdGatewaysGatewayIdCellularDnsPut', 'gatewayId', gatewayId)
            // verify required parameter 'config' is not null or undefined
            assertParamExists('lteNetworkIdGatewaysGatewayIdCellularDnsPut', 'config', config)
            const localVarPath = `/lte/{network_id}/gateways/{gateway_id}/cellular/dns`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"gateway_id"}}`, encodeURIComponent(String(gatewayId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(config, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the DNS config records for LTE gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdGatewaysGatewayIdCellularDnsRecordsGet: async (networkId: string, gatewayId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdGatewaysGatewayIdCellularDnsRecordsGet', 'networkId', networkId)
            // verify required parameter 'gatewayId' is not null or undefined
            assertParamExists('lteNetworkIdGatewaysGatewayIdCellularDnsRecordsGet', 'gatewayId', gatewayId)
            const localVarPath = `/lte/{network_id}/gateways/{gateway_id}/cellular/dns/records`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"gateway_id"}}`, encodeURIComponent(String(gatewayId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Change all the DNS records for LTE gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {Array<DnsConfigRecord>} records Custom DNS records for the gateway
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdGatewaysGatewayIdCellularDnsRecordsPut: async (networkId: string, gatewayId: string, records: Array<DnsConfigRecord>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdGatewaysGatewayIdCellularDnsRecordsPut', 'networkId', networkId)
            // verify required parameter 'gatewayId' is not null or undefined
            assertParamExists('lteNetworkIdGatewaysGatewayIdCellularDnsRecordsPut', 'gatewayId', gatewayId)
            // verify required parameter 'records' is not null or undefined
            assertParamExists('lteNetworkIdGatewaysGatewayIdCellularDnsRecordsPut', 'records', records)
            const localVarPath = `/lte/{network_id}/gateways/{gateway_id}/cellular/dns/records`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"gateway_id"}}`, encodeURIComponent(String(gatewayId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(records, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get gateway EPC configuration
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdGatewaysGatewayIdCellularEpcGet: async (networkId: string, gatewayId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdGatewaysGatewayIdCellularEpcGet', 'networkId', networkId)
            // verify required parameter 'gatewayId' is not null or undefined
            assertParamExists('lteNetworkIdGatewaysGatewayIdCellularEpcGet', 'gatewayId', gatewayId)
            const localVarPath = `/lte/{network_id}/gateways/{gateway_id}/cellular/epc`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"gateway_id"}}`, encodeURIComponent(String(gatewayId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update gateway EPC configuration
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {GatewayEpcConfigs} config New EPC configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdGatewaysGatewayIdCellularEpcPut: async (networkId: string, gatewayId: string, config: GatewayEpcConfigs, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdGatewaysGatewayIdCellularEpcPut', 'networkId', networkId)
            // verify required parameter 'gatewayId' is not null or undefined
            assertParamExists('lteNetworkIdGatewaysGatewayIdCellularEpcPut', 'gatewayId', gatewayId)
            // verify required parameter 'config' is not null or undefined
            assertParamExists('lteNetworkIdGatewaysGatewayIdCellularEpcPut', 'config', config)
            const localVarPath = `/lte/{network_id}/gateways/{gateway_id}/cellular/epc`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"gateway_id"}}`, encodeURIComponent(String(gatewayId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(config, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get gateway cellular configuration
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdGatewaysGatewayIdCellularGet: async (networkId: string, gatewayId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdGatewaysGatewayIdCellularGet', 'networkId', networkId)
            // verify required parameter 'gatewayId' is not null or undefined
            assertParamExists('lteNetworkIdGatewaysGatewayIdCellularGet', 'gatewayId', gatewayId)
            const localVarPath = `/lte/{network_id}/gateways/{gateway_id}/cellular`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"gateway_id"}}`, encodeURIComponent(String(gatewayId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get gateway NGC configuration
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdGatewaysGatewayIdCellularNgcGet: async (networkId: string, gatewayId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdGatewaysGatewayIdCellularNgcGet', 'networkId', networkId)
            // verify required parameter 'gatewayId' is not null or undefined
            assertParamExists('lteNetworkIdGatewaysGatewayIdCellularNgcGet', 'gatewayId', gatewayId)
            const localVarPath = `/lte/{network_id}/gateways/{gateway_id}/cellular/ngc`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"gateway_id"}}`, encodeURIComponent(String(gatewayId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update gateway NGC configuration
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {GatewayNgcConfigs} config New NGC configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdGatewaysGatewayIdCellularNgcPut: async (networkId: string, gatewayId: string, config: GatewayNgcConfigs, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdGatewaysGatewayIdCellularNgcPut', 'networkId', networkId)
            // verify required parameter 'gatewayId' is not null or undefined
            assertParamExists('lteNetworkIdGatewaysGatewayIdCellularNgcPut', 'gatewayId', gatewayId)
            // verify required parameter 'config' is not null or undefined
            assertParamExists('lteNetworkIdGatewaysGatewayIdCellularNgcPut', 'config', config)
            const localVarPath = `/lte/{network_id}/gateways/{gateway_id}/cellular/ngc`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"gateway_id"}}`, encodeURIComponent(String(gatewayId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(config, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get gateway Non-EPS configuration
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdGatewaysGatewayIdCellularNonEpsGet: async (networkId: string, gatewayId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdGatewaysGatewayIdCellularNonEpsGet', 'networkId', networkId)
            // verify required parameter 'gatewayId' is not null or undefined
            assertParamExists('lteNetworkIdGatewaysGatewayIdCellularNonEpsGet', 'gatewayId', gatewayId)
            const localVarPath = `/lte/{network_id}/gateways/{gateway_id}/cellular/non_eps`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"gateway_id"}}`, encodeURIComponent(String(gatewayId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update gateway Non-EPS configuration
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {GatewayNonEpsConfigs} config New Non-EPS configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdGatewaysGatewayIdCellularNonEpsPut: async (networkId: string, gatewayId: string, config: GatewayNonEpsConfigs, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdGatewaysGatewayIdCellularNonEpsPut', 'networkId', networkId)
            // verify required parameter 'gatewayId' is not null or undefined
            assertParamExists('lteNetworkIdGatewaysGatewayIdCellularNonEpsPut', 'gatewayId', gatewayId)
            // verify required parameter 'config' is not null or undefined
            assertParamExists('lteNetworkIdGatewaysGatewayIdCellularNonEpsPut', 'config', config)
            const localVarPath = `/lte/{network_id}/gateways/{gateway_id}/cellular/non_eps`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"gateway_id"}}`, encodeURIComponent(String(gatewayId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(config, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the gateway pool records for LTE gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdGatewaysGatewayIdCellularPoolingGet: async (networkId: string, gatewayId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdGatewaysGatewayIdCellularPoolingGet', 'networkId', networkId)
            // verify required parameter 'gatewayId' is not null or undefined
            assertParamExists('lteNetworkIdGatewaysGatewayIdCellularPoolingGet', 'gatewayId', gatewayId)
            const localVarPath = `/lte/{network_id}/gateways/{gateway_id}/cellular/pooling`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"gateway_id"}}`, encodeURIComponent(String(gatewayId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Change all the gateway pool records for LTE gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {Array<CellularGatewayPoolRecord>} resource Gateway pool records for gateway
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdGatewaysGatewayIdCellularPoolingPut: async (networkId: string, gatewayId: string, resource: Array<CellularGatewayPoolRecord>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdGatewaysGatewayIdCellularPoolingPut', 'networkId', networkId)
            // verify required parameter 'gatewayId' is not null or undefined
            assertParamExists('lteNetworkIdGatewaysGatewayIdCellularPoolingPut', 'gatewayId', gatewayId)
            // verify required parameter 'resource' is not null or undefined
            assertParamExists('lteNetworkIdGatewaysGatewayIdCellularPoolingPut', 'resource', resource)
            const localVarPath = `/lte/{network_id}/gateways/{gateway_id}/cellular/pooling`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"gateway_id"}}`, encodeURIComponent(String(gatewayId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(resource, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update gateway cellular configuration
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {GatewayCellularConfigs} config New cellular configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdGatewaysGatewayIdCellularPut: async (networkId: string, gatewayId: string, config: GatewayCellularConfigs, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdGatewaysGatewayIdCellularPut', 'networkId', networkId)
            // verify required parameter 'gatewayId' is not null or undefined
            assertParamExists('lteNetworkIdGatewaysGatewayIdCellularPut', 'gatewayId', gatewayId)
            // verify required parameter 'config' is not null or undefined
            assertParamExists('lteNetworkIdGatewaysGatewayIdCellularPut', 'config', config)
            const localVarPath = `/lte/{network_id}/gateways/{gateway_id}/cellular`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"gateway_id"}}`, encodeURIComponent(String(gatewayId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(config, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get gateway RAN configuration
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdGatewaysGatewayIdCellularRanGet: async (networkId: string, gatewayId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdGatewaysGatewayIdCellularRanGet', 'networkId', networkId)
            // verify required parameter 'gatewayId' is not null or undefined
            assertParamExists('lteNetworkIdGatewaysGatewayIdCellularRanGet', 'gatewayId', gatewayId)
            const localVarPath = `/lte/{network_id}/gateways/{gateway_id}/cellular/ran`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"gateway_id"}}`, encodeURIComponent(String(gatewayId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update gateway RAN configuration
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {GatewayRanConfigs} config New RAN configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdGatewaysGatewayIdCellularRanPut: async (networkId: string, gatewayId: string, config: GatewayRanConfigs, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdGatewaysGatewayIdCellularRanPut', 'networkId', networkId)
            // verify required parameter 'gatewayId' is not null or undefined
            assertParamExists('lteNetworkIdGatewaysGatewayIdCellularRanPut', 'gatewayId', gatewayId)
            // verify required parameter 'config' is not null or undefined
            assertParamExists('lteNetworkIdGatewaysGatewayIdCellularRanPut', 'config', config)
            const localVarPath = `/lte/{network_id}/gateways/{gateway_id}/cellular/ran`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"gateway_id"}}`, encodeURIComponent(String(gatewayId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(config, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove an enodeB from the connected devices list
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {string} serial 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdGatewaysGatewayIdConnectedEnodebSerialsDelete: async (networkId: string, gatewayId: string, serial: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdGatewaysGatewayIdConnectedEnodebSerialsDelete', 'networkId', networkId)
            // verify required parameter 'gatewayId' is not null or undefined
            assertParamExists('lteNetworkIdGatewaysGatewayIdConnectedEnodebSerialsDelete', 'gatewayId', gatewayId)
            // verify required parameter 'serial' is not null or undefined
            assertParamExists('lteNetworkIdGatewaysGatewayIdConnectedEnodebSerialsDelete', 'serial', serial)
            const localVarPath = `/lte/{network_id}/gateways/{gateway_id}/connected_enodeb_serials`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"gateway_id"}}`, encodeURIComponent(String(gatewayId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(serial, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the SNs of all enodeBs connected to a gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdGatewaysGatewayIdConnectedEnodebSerialsGet: async (networkId: string, gatewayId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdGatewaysGatewayIdConnectedEnodebSerialsGet', 'networkId', networkId)
            // verify required parameter 'gatewayId' is not null or undefined
            assertParamExists('lteNetworkIdGatewaysGatewayIdConnectedEnodebSerialsGet', 'gatewayId', gatewayId)
            const localVarPath = `/lte/{network_id}/gateways/{gateway_id}/connected_enodeb_serials`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"gateway_id"}}`, encodeURIComponent(String(gatewayId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add a new connected enodeB to a gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {string} serial 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdGatewaysGatewayIdConnectedEnodebSerialsPost: async (networkId: string, gatewayId: string, serial: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdGatewaysGatewayIdConnectedEnodebSerialsPost', 'networkId', networkId)
            // verify required parameter 'gatewayId' is not null or undefined
            assertParamExists('lteNetworkIdGatewaysGatewayIdConnectedEnodebSerialsPost', 'gatewayId', gatewayId)
            // verify required parameter 'serial' is not null or undefined
            assertParamExists('lteNetworkIdGatewaysGatewayIdConnectedEnodebSerialsPost', 'serial', serial)
            const localVarPath = `/lte/{network_id}/gateways/{gateway_id}/connected_enodeb_serials`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"gateway_id"}}`, encodeURIComponent(String(gatewayId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(serial, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the set of connected enodeBs
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {Array<string>} serials 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdGatewaysGatewayIdConnectedEnodebSerialsPut: async (networkId: string, gatewayId: string, serials: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdGatewaysGatewayIdConnectedEnodebSerialsPut', 'networkId', networkId)
            // verify required parameter 'gatewayId' is not null or undefined
            assertParamExists('lteNetworkIdGatewaysGatewayIdConnectedEnodebSerialsPut', 'gatewayId', gatewayId)
            // verify required parameter 'serials' is not null or undefined
            assertParamExists('lteNetworkIdGatewaysGatewayIdConnectedEnodebSerialsPut', 'serials', serials)
            const localVarPath = `/lte/{network_id}/gateways/{gateway_id}/connected_enodeb_serials`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"gateway_id"}}`, encodeURIComponent(String(gatewayId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(serials, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete an LTE gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdGatewaysGatewayIdDelete: async (networkId: string, gatewayId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdGatewaysGatewayIdDelete', 'networkId', networkId)
            // verify required parameter 'gatewayId' is not null or undefined
            assertParamExists('lteNetworkIdGatewaysGatewayIdDelete', 'gatewayId', gatewayId)
            const localVarPath = `/lte/{network_id}/gateways/{gateway_id}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"gateway_id"}}`, encodeURIComponent(String(gatewayId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the description of an LTE gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdGatewaysGatewayIdDescriptionGet: async (networkId: string, gatewayId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdGatewaysGatewayIdDescriptionGet', 'networkId', networkId)
            // verify required parameter 'gatewayId' is not null or undefined
            assertParamExists('lteNetworkIdGatewaysGatewayIdDescriptionGet', 'gatewayId', gatewayId)
            const localVarPath = `/lte/{network_id}/gateways/{gateway_id}/description`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"gateway_id"}}`, encodeURIComponent(String(gatewayId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the description of an LTE gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {string} description 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdGatewaysGatewayIdDescriptionPut: async (networkId: string, gatewayId: string, description: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdGatewaysGatewayIdDescriptionPut', 'networkId', networkId)
            // verify required parameter 'gatewayId' is not null or undefined
            assertParamExists('lteNetworkIdGatewaysGatewayIdDescriptionPut', 'gatewayId', gatewayId)
            // verify required parameter 'description' is not null or undefined
            assertParamExists('lteNetworkIdGatewaysGatewayIdDescriptionPut', 'description', description)
            const localVarPath = `/lte/{network_id}/gateways/{gateway_id}/description`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"gateway_id"}}`, encodeURIComponent(String(gatewayId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(description, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the physical device for an LTE gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdGatewaysGatewayIdDeviceGet: async (networkId: string, gatewayId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdGatewaysGatewayIdDeviceGet', 'networkId', networkId)
            // verify required parameter 'gatewayId' is not null or undefined
            assertParamExists('lteNetworkIdGatewaysGatewayIdDeviceGet', 'gatewayId', gatewayId)
            const localVarPath = `/lte/{network_id}/gateways/{gateway_id}/device`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"gateway_id"}}`, encodeURIComponent(String(gatewayId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the physical device for an LTE gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {GatewayDevice} device New device for the LTE gateway
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdGatewaysGatewayIdDevicePut: async (networkId: string, gatewayId: string, device: GatewayDevice, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdGatewaysGatewayIdDevicePut', 'networkId', networkId)
            // verify required parameter 'gatewayId' is not null or undefined
            assertParamExists('lteNetworkIdGatewaysGatewayIdDevicePut', 'gatewayId', gatewayId)
            // verify required parameter 'device' is not null or undefined
            assertParamExists('lteNetworkIdGatewaysGatewayIdDevicePut', 'device', device)
            const localVarPath = `/lte/{network_id}/gateways/{gateway_id}/device`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"gateway_id"}}`, encodeURIComponent(String(gatewayId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(device, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a specific LTE gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdGatewaysGatewayIdGet: async (networkId: string, gatewayId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdGatewaysGatewayIdGet', 'networkId', networkId)
            // verify required parameter 'gatewayId' is not null or undefined
            assertParamExists('lteNetworkIdGatewaysGatewayIdGet', 'gatewayId', gatewayId)
            const localVarPath = `/lte/{network_id}/gateways/{gateway_id}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"gateway_id"}}`, encodeURIComponent(String(gatewayId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get magmad agent configuration
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdGatewaysGatewayIdMagmadGet: async (networkId: string, gatewayId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdGatewaysGatewayIdMagmadGet', 'networkId', networkId)
            // verify required parameter 'gatewayId' is not null or undefined
            assertParamExists('lteNetworkIdGatewaysGatewayIdMagmadGet', 'gatewayId', gatewayId)
            const localVarPath = `/lte/{network_id}/gateways/{gateway_id}/magmad`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"gateway_id"}}`, encodeURIComponent(String(gatewayId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reconfigure magmad agent
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {MagmadGatewayConfigs} magmad New magmad configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdGatewaysGatewayIdMagmadPut: async (networkId: string, gatewayId: string, magmad: MagmadGatewayConfigs, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdGatewaysGatewayIdMagmadPut', 'networkId', networkId)
            // verify required parameter 'gatewayId' is not null or undefined
            assertParamExists('lteNetworkIdGatewaysGatewayIdMagmadPut', 'gatewayId', gatewayId)
            // verify required parameter 'magmad' is not null or undefined
            assertParamExists('lteNetworkIdGatewaysGatewayIdMagmadPut', 'magmad', magmad)
            const localVarPath = `/lte/{network_id}/gateways/{gateway_id}/magmad`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"gateway_id"}}`, encodeURIComponent(String(gatewayId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(magmad, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the name of an LTE gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdGatewaysGatewayIdNameGet: async (networkId: string, gatewayId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdGatewaysGatewayIdNameGet', 'networkId', networkId)
            // verify required parameter 'gatewayId' is not null or undefined
            assertParamExists('lteNetworkIdGatewaysGatewayIdNameGet', 'gatewayId', gatewayId)
            const localVarPath = `/lte/{network_id}/gateways/{gateway_id}/name`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"gateway_id"}}`, encodeURIComponent(String(gatewayId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the name of an LTE gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdGatewaysGatewayIdNamePut: async (networkId: string, gatewayId: string, name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdGatewaysGatewayIdNamePut', 'networkId', networkId)
            // verify required parameter 'gatewayId' is not null or undefined
            assertParamExists('lteNetworkIdGatewaysGatewayIdNamePut', 'gatewayId', gatewayId)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('lteNetworkIdGatewaysGatewayIdNamePut', 'name', name)
            const localVarPath = `/lte/{network_id}/gateways/{gateway_id}/name`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"gateway_id"}}`, encodeURIComponent(String(gatewayId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(name, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an entire LTE gateway record
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {MutableLteGateway} gateway Full desired configuration of the gateway
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdGatewaysGatewayIdPut: async (networkId: string, gatewayId: string, gateway: MutableLteGateway, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdGatewaysGatewayIdPut', 'networkId', networkId)
            // verify required parameter 'gatewayId' is not null or undefined
            assertParamExists('lteNetworkIdGatewaysGatewayIdPut', 'gatewayId', gatewayId)
            // verify required parameter 'gateway' is not null or undefined
            assertParamExists('lteNetworkIdGatewaysGatewayIdPut', 'gateway', gateway)
            const localVarPath = `/lte/{network_id}/gateways/{gateway_id}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"gateway_id"}}`, encodeURIComponent(String(gatewayId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(gateway, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the status of a gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdGatewaysGatewayIdStatusGet: async (networkId: string, gatewayId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdGatewaysGatewayIdStatusGet', 'networkId', networkId)
            // verify required parameter 'gatewayId' is not null or undefined
            assertParamExists('lteNetworkIdGatewaysGatewayIdStatusGet', 'gatewayId', gatewayId)
            const localVarPath = `/lte/{network_id}/gateways/{gateway_id}/status`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"gateway_id"}}`, encodeURIComponent(String(gatewayId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the ID of the upgrade tier a gateway belongs to
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdGatewaysGatewayIdTierGet: async (networkId: string, gatewayId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdGatewaysGatewayIdTierGet', 'networkId', networkId)
            // verify required parameter 'gatewayId' is not null or undefined
            assertParamExists('lteNetworkIdGatewaysGatewayIdTierGet', 'gatewayId', gatewayId)
            const localVarPath = `/lte/{network_id}/gateways/{gateway_id}/tier`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"gateway_id"}}`, encodeURIComponent(String(gatewayId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the ID of the upgrade tier a gateway belongs to
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {string} tierId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdGatewaysGatewayIdTierPut: async (networkId: string, gatewayId: string, tierId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdGatewaysGatewayIdTierPut', 'networkId', networkId)
            // verify required parameter 'gatewayId' is not null or undefined
            assertParamExists('lteNetworkIdGatewaysGatewayIdTierPut', 'gatewayId', gatewayId)
            // verify required parameter 'tierId' is not null or undefined
            assertParamExists('lteNetworkIdGatewaysGatewayIdTierPut', 'tierId', tierId)
            const localVarPath = `/lte/{network_id}/gateways/{gateway_id}/tier`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"gateway_id"}}`, encodeURIComponent(String(gatewayId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tierId, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the gateway VPN configuration
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdGatewaysGatewayIdVpnGet: async (networkId: string, gatewayId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdGatewaysGatewayIdVpnGet', 'networkId', networkId)
            // verify required parameter 'gatewayId' is not null or undefined
            assertParamExists('lteNetworkIdGatewaysGatewayIdVpnGet', 'gatewayId', gatewayId)
            const localVarPath = `/lte/{network_id}/gateways/{gateway_id}/vpn`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"gateway_id"}}`, encodeURIComponent(String(gatewayId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the gateway VPN configuration
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {GatewayVpnConfigs} config New VPN configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdGatewaysGatewayIdVpnPut: async (networkId: string, gatewayId: string, config: GatewayVpnConfigs, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdGatewaysGatewayIdVpnPut', 'networkId', networkId)
            // verify required parameter 'gatewayId' is not null or undefined
            assertParamExists('lteNetworkIdGatewaysGatewayIdVpnPut', 'gatewayId', gatewayId)
            // verify required parameter 'config' is not null or undefined
            assertParamExists('lteNetworkIdGatewaysGatewayIdVpnPut', 'config', config)
            const localVarPath = `/lte/{network_id}/gateways/{gateway_id}/vpn`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"gateway_id"}}`, encodeURIComponent(String(gatewayId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(config, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all gateways for an LTE network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdGatewaysGet: async (networkId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdGatewaysGet', 'networkId', networkId)
            const localVarPath = `/lte/{network_id}/gateways`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Register a new LTE gateway
         * @param {string} networkId Network ID
         * @param {MutableLteGateway} gateway Full desired configuration of the gateway
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdGatewaysPost: async (networkId: string, gateway: MutableLteGateway, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdGatewaysPost', 'networkId', networkId)
            // verify required parameter 'gateway' is not null or undefined
            assertParamExists('lteNetworkIdGatewaysPost', 'gateway', gateway)
            const localVarPath = `/lte/{network_id}/gateways`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(gateway, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LTEGatewaysApi - functional programming interface
 * @export
 */
export const LTEGatewaysApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LTEGatewaysApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get DNS configuration of LTE gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdGatewaysGatewayIdCellularDnsGet(networkId: string, gatewayId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GatewayDnsConfigs>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdGatewaysGatewayIdCellularDnsGet(networkId, gatewayId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update DNS configuration of LTE gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {GatewayDnsConfigs} config New DNS configuration for the gateway
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdGatewaysGatewayIdCellularDnsPut(networkId: string, gatewayId: string, config: GatewayDnsConfigs, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdGatewaysGatewayIdCellularDnsPut(networkId, gatewayId, config, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the DNS config records for LTE gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdGatewaysGatewayIdCellularDnsRecordsGet(networkId: string, gatewayId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DnsConfigRecord>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdGatewaysGatewayIdCellularDnsRecordsGet(networkId, gatewayId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Change all the DNS records for LTE gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {Array<DnsConfigRecord>} records Custom DNS records for the gateway
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdGatewaysGatewayIdCellularDnsRecordsPut(networkId: string, gatewayId: string, records: Array<DnsConfigRecord>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdGatewaysGatewayIdCellularDnsRecordsPut(networkId, gatewayId, records, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get gateway EPC configuration
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdGatewaysGatewayIdCellularEpcGet(networkId: string, gatewayId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GatewayEpcConfigs>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdGatewaysGatewayIdCellularEpcGet(networkId, gatewayId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update gateway EPC configuration
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {GatewayEpcConfigs} config New EPC configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdGatewaysGatewayIdCellularEpcPut(networkId: string, gatewayId: string, config: GatewayEpcConfigs, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdGatewaysGatewayIdCellularEpcPut(networkId, gatewayId, config, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get gateway cellular configuration
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdGatewaysGatewayIdCellularGet(networkId: string, gatewayId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GatewayCellularConfigs>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdGatewaysGatewayIdCellularGet(networkId, gatewayId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get gateway NGC configuration
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdGatewaysGatewayIdCellularNgcGet(networkId: string, gatewayId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GatewayNgcConfigs>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdGatewaysGatewayIdCellularNgcGet(networkId, gatewayId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update gateway NGC configuration
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {GatewayNgcConfigs} config New NGC configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdGatewaysGatewayIdCellularNgcPut(networkId: string, gatewayId: string, config: GatewayNgcConfigs, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdGatewaysGatewayIdCellularNgcPut(networkId, gatewayId, config, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get gateway Non-EPS configuration
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdGatewaysGatewayIdCellularNonEpsGet(networkId: string, gatewayId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GatewayNonEpsConfigs>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdGatewaysGatewayIdCellularNonEpsGet(networkId, gatewayId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update gateway Non-EPS configuration
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {GatewayNonEpsConfigs} config New Non-EPS configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdGatewaysGatewayIdCellularNonEpsPut(networkId: string, gatewayId: string, config: GatewayNonEpsConfigs, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdGatewaysGatewayIdCellularNonEpsPut(networkId, gatewayId, config, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the gateway pool records for LTE gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdGatewaysGatewayIdCellularPoolingGet(networkId: string, gatewayId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CellularGatewayPoolRecord>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdGatewaysGatewayIdCellularPoolingGet(networkId, gatewayId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Change all the gateway pool records for LTE gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {Array<CellularGatewayPoolRecord>} resource Gateway pool records for gateway
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdGatewaysGatewayIdCellularPoolingPut(networkId: string, gatewayId: string, resource: Array<CellularGatewayPoolRecord>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdGatewaysGatewayIdCellularPoolingPut(networkId, gatewayId, resource, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update gateway cellular configuration
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {GatewayCellularConfigs} config New cellular configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdGatewaysGatewayIdCellularPut(networkId: string, gatewayId: string, config: GatewayCellularConfigs, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdGatewaysGatewayIdCellularPut(networkId, gatewayId, config, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get gateway RAN configuration
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdGatewaysGatewayIdCellularRanGet(networkId: string, gatewayId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GatewayRanConfigs>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdGatewaysGatewayIdCellularRanGet(networkId, gatewayId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update gateway RAN configuration
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {GatewayRanConfigs} config New RAN configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdGatewaysGatewayIdCellularRanPut(networkId: string, gatewayId: string, config: GatewayRanConfigs, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdGatewaysGatewayIdCellularRanPut(networkId, gatewayId, config, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove an enodeB from the connected devices list
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {string} serial 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdGatewaysGatewayIdConnectedEnodebSerialsDelete(networkId: string, gatewayId: string, serial: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdGatewaysGatewayIdConnectedEnodebSerialsDelete(networkId, gatewayId, serial, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the SNs of all enodeBs connected to a gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdGatewaysGatewayIdConnectedEnodebSerialsGet(networkId: string, gatewayId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdGatewaysGatewayIdConnectedEnodebSerialsGet(networkId, gatewayId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add a new connected enodeB to a gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {string} serial 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdGatewaysGatewayIdConnectedEnodebSerialsPost(networkId: string, gatewayId: string, serial: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdGatewaysGatewayIdConnectedEnodebSerialsPost(networkId, gatewayId, serial, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update the set of connected enodeBs
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {Array<string>} serials 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdGatewaysGatewayIdConnectedEnodebSerialsPut(networkId: string, gatewayId: string, serials: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdGatewaysGatewayIdConnectedEnodebSerialsPut(networkId, gatewayId, serials, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete an LTE gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdGatewaysGatewayIdDelete(networkId: string, gatewayId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdGatewaysGatewayIdDelete(networkId, gatewayId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the description of an LTE gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdGatewaysGatewayIdDescriptionGet(networkId: string, gatewayId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdGatewaysGatewayIdDescriptionGet(networkId, gatewayId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update the description of an LTE gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {string} description 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdGatewaysGatewayIdDescriptionPut(networkId: string, gatewayId: string, description: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdGatewaysGatewayIdDescriptionPut(networkId, gatewayId, description, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the physical device for an LTE gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdGatewaysGatewayIdDeviceGet(networkId: string, gatewayId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GatewayDevice>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdGatewaysGatewayIdDeviceGet(networkId, gatewayId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update the physical device for an LTE gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {GatewayDevice} device New device for the LTE gateway
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdGatewaysGatewayIdDevicePut(networkId: string, gatewayId: string, device: GatewayDevice, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdGatewaysGatewayIdDevicePut(networkId, gatewayId, device, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a specific LTE gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdGatewaysGatewayIdGet(networkId: string, gatewayId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LteGateway>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdGatewaysGatewayIdGet(networkId, gatewayId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get magmad agent configuration
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdGatewaysGatewayIdMagmadGet(networkId: string, gatewayId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MagmadGatewayConfigs>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdGatewaysGatewayIdMagmadGet(networkId, gatewayId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Reconfigure magmad agent
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {MagmadGatewayConfigs} magmad New magmad configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdGatewaysGatewayIdMagmadPut(networkId: string, gatewayId: string, magmad: MagmadGatewayConfigs, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdGatewaysGatewayIdMagmadPut(networkId, gatewayId, magmad, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the name of an LTE gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdGatewaysGatewayIdNameGet(networkId: string, gatewayId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdGatewaysGatewayIdNameGet(networkId, gatewayId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update the name of an LTE gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdGatewaysGatewayIdNamePut(networkId: string, gatewayId: string, name: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdGatewaysGatewayIdNamePut(networkId, gatewayId, name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update an entire LTE gateway record
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {MutableLteGateway} gateway Full desired configuration of the gateway
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdGatewaysGatewayIdPut(networkId: string, gatewayId: string, gateway: MutableLteGateway, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdGatewaysGatewayIdPut(networkId, gatewayId, gateway, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the status of a gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdGatewaysGatewayIdStatusGet(networkId: string, gatewayId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GatewayStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdGatewaysGatewayIdStatusGet(networkId, gatewayId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the ID of the upgrade tier a gateway belongs to
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdGatewaysGatewayIdTierGet(networkId: string, gatewayId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdGatewaysGatewayIdTierGet(networkId, gatewayId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update the ID of the upgrade tier a gateway belongs to
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {string} tierId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdGatewaysGatewayIdTierPut(networkId: string, gatewayId: string, tierId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdGatewaysGatewayIdTierPut(networkId, gatewayId, tierId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the gateway VPN configuration
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdGatewaysGatewayIdVpnGet(networkId: string, gatewayId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GatewayVpnConfigs>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdGatewaysGatewayIdVpnGet(networkId, gatewayId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update the gateway VPN configuration
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {GatewayVpnConfigs} config New VPN configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdGatewaysGatewayIdVpnPut(networkId: string, gatewayId: string, config: GatewayVpnConfigs, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdGatewaysGatewayIdVpnPut(networkId, gatewayId, config, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all gateways for an LTE network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdGatewaysGet(networkId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: LteGateway; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdGatewaysGet(networkId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Register a new LTE gateway
         * @param {string} networkId Network ID
         * @param {MutableLteGateway} gateway Full desired configuration of the gateway
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdGatewaysPost(networkId: string, gateway: MutableLteGateway, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdGatewaysPost(networkId, gateway, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * LTEGatewaysApi - factory interface
 * @export
 */
export const LTEGatewaysApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LTEGatewaysApiFp(configuration)
    return {
        /**
         * 
         * @summary Get DNS configuration of LTE gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdGatewaysGatewayIdCellularDnsGet(networkId: string, gatewayId: string, options?: any): AxiosPromise<GatewayDnsConfigs> {
            return localVarFp.lteNetworkIdGatewaysGatewayIdCellularDnsGet(networkId, gatewayId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update DNS configuration of LTE gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {GatewayDnsConfigs} config New DNS configuration for the gateway
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdGatewaysGatewayIdCellularDnsPut(networkId: string, gatewayId: string, config: GatewayDnsConfigs, options?: any): AxiosPromise<void> {
            return localVarFp.lteNetworkIdGatewaysGatewayIdCellularDnsPut(networkId, gatewayId, config, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the DNS config records for LTE gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdGatewaysGatewayIdCellularDnsRecordsGet(networkId: string, gatewayId: string, options?: any): AxiosPromise<Array<DnsConfigRecord>> {
            return localVarFp.lteNetworkIdGatewaysGatewayIdCellularDnsRecordsGet(networkId, gatewayId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Change all the DNS records for LTE gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {Array<DnsConfigRecord>} records Custom DNS records for the gateway
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdGatewaysGatewayIdCellularDnsRecordsPut(networkId: string, gatewayId: string, records: Array<DnsConfigRecord>, options?: any): AxiosPromise<void> {
            return localVarFp.lteNetworkIdGatewaysGatewayIdCellularDnsRecordsPut(networkId, gatewayId, records, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get gateway EPC configuration
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdGatewaysGatewayIdCellularEpcGet(networkId: string, gatewayId: string, options?: any): AxiosPromise<GatewayEpcConfigs> {
            return localVarFp.lteNetworkIdGatewaysGatewayIdCellularEpcGet(networkId, gatewayId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update gateway EPC configuration
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {GatewayEpcConfigs} config New EPC configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdGatewaysGatewayIdCellularEpcPut(networkId: string, gatewayId: string, config: GatewayEpcConfigs, options?: any): AxiosPromise<void> {
            return localVarFp.lteNetworkIdGatewaysGatewayIdCellularEpcPut(networkId, gatewayId, config, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get gateway cellular configuration
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdGatewaysGatewayIdCellularGet(networkId: string, gatewayId: string, options?: any): AxiosPromise<GatewayCellularConfigs> {
            return localVarFp.lteNetworkIdGatewaysGatewayIdCellularGet(networkId, gatewayId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get gateway NGC configuration
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdGatewaysGatewayIdCellularNgcGet(networkId: string, gatewayId: string, options?: any): AxiosPromise<GatewayNgcConfigs> {
            return localVarFp.lteNetworkIdGatewaysGatewayIdCellularNgcGet(networkId, gatewayId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update gateway NGC configuration
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {GatewayNgcConfigs} config New NGC configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdGatewaysGatewayIdCellularNgcPut(networkId: string, gatewayId: string, config: GatewayNgcConfigs, options?: any): AxiosPromise<void> {
            return localVarFp.lteNetworkIdGatewaysGatewayIdCellularNgcPut(networkId, gatewayId, config, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get gateway Non-EPS configuration
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdGatewaysGatewayIdCellularNonEpsGet(networkId: string, gatewayId: string, options?: any): AxiosPromise<GatewayNonEpsConfigs> {
            return localVarFp.lteNetworkIdGatewaysGatewayIdCellularNonEpsGet(networkId, gatewayId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update gateway Non-EPS configuration
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {GatewayNonEpsConfigs} config New Non-EPS configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdGatewaysGatewayIdCellularNonEpsPut(networkId: string, gatewayId: string, config: GatewayNonEpsConfigs, options?: any): AxiosPromise<void> {
            return localVarFp.lteNetworkIdGatewaysGatewayIdCellularNonEpsPut(networkId, gatewayId, config, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the gateway pool records for LTE gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdGatewaysGatewayIdCellularPoolingGet(networkId: string, gatewayId: string, options?: any): AxiosPromise<Array<CellularGatewayPoolRecord>> {
            return localVarFp.lteNetworkIdGatewaysGatewayIdCellularPoolingGet(networkId, gatewayId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Change all the gateway pool records for LTE gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {Array<CellularGatewayPoolRecord>} resource Gateway pool records for gateway
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdGatewaysGatewayIdCellularPoolingPut(networkId: string, gatewayId: string, resource: Array<CellularGatewayPoolRecord>, options?: any): AxiosPromise<void> {
            return localVarFp.lteNetworkIdGatewaysGatewayIdCellularPoolingPut(networkId, gatewayId, resource, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update gateway cellular configuration
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {GatewayCellularConfigs} config New cellular configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdGatewaysGatewayIdCellularPut(networkId: string, gatewayId: string, config: GatewayCellularConfigs, options?: any): AxiosPromise<void> {
            return localVarFp.lteNetworkIdGatewaysGatewayIdCellularPut(networkId, gatewayId, config, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get gateway RAN configuration
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdGatewaysGatewayIdCellularRanGet(networkId: string, gatewayId: string, options?: any): AxiosPromise<GatewayRanConfigs> {
            return localVarFp.lteNetworkIdGatewaysGatewayIdCellularRanGet(networkId, gatewayId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update gateway RAN configuration
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {GatewayRanConfigs} config New RAN configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdGatewaysGatewayIdCellularRanPut(networkId: string, gatewayId: string, config: GatewayRanConfigs, options?: any): AxiosPromise<void> {
            return localVarFp.lteNetworkIdGatewaysGatewayIdCellularRanPut(networkId, gatewayId, config, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove an enodeB from the connected devices list
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {string} serial 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdGatewaysGatewayIdConnectedEnodebSerialsDelete(networkId: string, gatewayId: string, serial: string, options?: any): AxiosPromise<void> {
            return localVarFp.lteNetworkIdGatewaysGatewayIdConnectedEnodebSerialsDelete(networkId, gatewayId, serial, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the SNs of all enodeBs connected to a gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdGatewaysGatewayIdConnectedEnodebSerialsGet(networkId: string, gatewayId: string, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.lteNetworkIdGatewaysGatewayIdConnectedEnodebSerialsGet(networkId, gatewayId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add a new connected enodeB to a gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {string} serial 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdGatewaysGatewayIdConnectedEnodebSerialsPost(networkId: string, gatewayId: string, serial: string, options?: any): AxiosPromise<void> {
            return localVarFp.lteNetworkIdGatewaysGatewayIdConnectedEnodebSerialsPost(networkId, gatewayId, serial, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the set of connected enodeBs
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {Array<string>} serials 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdGatewaysGatewayIdConnectedEnodebSerialsPut(networkId: string, gatewayId: string, serials: Array<string>, options?: any): AxiosPromise<void> {
            return localVarFp.lteNetworkIdGatewaysGatewayIdConnectedEnodebSerialsPut(networkId, gatewayId, serials, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete an LTE gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdGatewaysGatewayIdDelete(networkId: string, gatewayId: string, options?: any): AxiosPromise<void> {
            return localVarFp.lteNetworkIdGatewaysGatewayIdDelete(networkId, gatewayId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the description of an LTE gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdGatewaysGatewayIdDescriptionGet(networkId: string, gatewayId: string, options?: any): AxiosPromise<string> {
            return localVarFp.lteNetworkIdGatewaysGatewayIdDescriptionGet(networkId, gatewayId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the description of an LTE gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {string} description 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdGatewaysGatewayIdDescriptionPut(networkId: string, gatewayId: string, description: string, options?: any): AxiosPromise<void> {
            return localVarFp.lteNetworkIdGatewaysGatewayIdDescriptionPut(networkId, gatewayId, description, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the physical device for an LTE gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdGatewaysGatewayIdDeviceGet(networkId: string, gatewayId: string, options?: any): AxiosPromise<GatewayDevice> {
            return localVarFp.lteNetworkIdGatewaysGatewayIdDeviceGet(networkId, gatewayId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the physical device for an LTE gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {GatewayDevice} device New device for the LTE gateway
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdGatewaysGatewayIdDevicePut(networkId: string, gatewayId: string, device: GatewayDevice, options?: any): AxiosPromise<void> {
            return localVarFp.lteNetworkIdGatewaysGatewayIdDevicePut(networkId, gatewayId, device, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a specific LTE gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdGatewaysGatewayIdGet(networkId: string, gatewayId: string, options?: any): AxiosPromise<LteGateway> {
            return localVarFp.lteNetworkIdGatewaysGatewayIdGet(networkId, gatewayId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get magmad agent configuration
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdGatewaysGatewayIdMagmadGet(networkId: string, gatewayId: string, options?: any): AxiosPromise<MagmadGatewayConfigs> {
            return localVarFp.lteNetworkIdGatewaysGatewayIdMagmadGet(networkId, gatewayId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reconfigure magmad agent
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {MagmadGatewayConfigs} magmad New magmad configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdGatewaysGatewayIdMagmadPut(networkId: string, gatewayId: string, magmad: MagmadGatewayConfigs, options?: any): AxiosPromise<void> {
            return localVarFp.lteNetworkIdGatewaysGatewayIdMagmadPut(networkId, gatewayId, magmad, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the name of an LTE gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdGatewaysGatewayIdNameGet(networkId: string, gatewayId: string, options?: any): AxiosPromise<string> {
            return localVarFp.lteNetworkIdGatewaysGatewayIdNameGet(networkId, gatewayId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the name of an LTE gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdGatewaysGatewayIdNamePut(networkId: string, gatewayId: string, name: string, options?: any): AxiosPromise<void> {
            return localVarFp.lteNetworkIdGatewaysGatewayIdNamePut(networkId, gatewayId, name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an entire LTE gateway record
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {MutableLteGateway} gateway Full desired configuration of the gateway
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdGatewaysGatewayIdPut(networkId: string, gatewayId: string, gateway: MutableLteGateway, options?: any): AxiosPromise<void> {
            return localVarFp.lteNetworkIdGatewaysGatewayIdPut(networkId, gatewayId, gateway, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the status of a gateway
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdGatewaysGatewayIdStatusGet(networkId: string, gatewayId: string, options?: any): AxiosPromise<GatewayStatus> {
            return localVarFp.lteNetworkIdGatewaysGatewayIdStatusGet(networkId, gatewayId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the ID of the upgrade tier a gateway belongs to
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdGatewaysGatewayIdTierGet(networkId: string, gatewayId: string, options?: any): AxiosPromise<string> {
            return localVarFp.lteNetworkIdGatewaysGatewayIdTierGet(networkId, gatewayId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the ID of the upgrade tier a gateway belongs to
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {string} tierId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdGatewaysGatewayIdTierPut(networkId: string, gatewayId: string, tierId: string, options?: any): AxiosPromise<void> {
            return localVarFp.lteNetworkIdGatewaysGatewayIdTierPut(networkId, gatewayId, tierId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the gateway VPN configuration
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdGatewaysGatewayIdVpnGet(networkId: string, gatewayId: string, options?: any): AxiosPromise<GatewayVpnConfigs> {
            return localVarFp.lteNetworkIdGatewaysGatewayIdVpnGet(networkId, gatewayId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the gateway VPN configuration
         * @param {string} networkId Network ID
         * @param {string} gatewayId Gateway ID
         * @param {GatewayVpnConfigs} config New VPN configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdGatewaysGatewayIdVpnPut(networkId: string, gatewayId: string, config: GatewayVpnConfigs, options?: any): AxiosPromise<void> {
            return localVarFp.lteNetworkIdGatewaysGatewayIdVpnPut(networkId, gatewayId, config, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all gateways for an LTE network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdGatewaysGet(networkId: string, options?: any): AxiosPromise<{ [key: string]: LteGateway; }> {
            return localVarFp.lteNetworkIdGatewaysGet(networkId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Register a new LTE gateway
         * @param {string} networkId Network ID
         * @param {MutableLteGateway} gateway Full desired configuration of the gateway
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdGatewaysPost(networkId: string, gateway: MutableLteGateway, options?: any): AxiosPromise<void> {
            return localVarFp.lteNetworkIdGatewaysPost(networkId, gateway, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for lteNetworkIdGatewaysGatewayIdCellularDnsGet operation in LTEGatewaysApi.
 * @export
 * @interface LTEGatewaysApiLteNetworkIdGatewaysGatewayIdCellularDnsGetRequest
 */
export interface LTEGatewaysApiLteNetworkIdGatewaysGatewayIdCellularDnsGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof LTEGatewaysApiLteNetworkIdGatewaysGatewayIdCellularDnsGet
     */
    readonly networkId: string

    /**
     * Gateway ID
     * @type {string}
     * @memberof LTEGatewaysApiLteNetworkIdGatewaysGatewayIdCellularDnsGet
     */
    readonly gatewayId: string
}

/**
 * Request parameters for lteNetworkIdGatewaysGatewayIdCellularDnsPut operation in LTEGatewaysApi.
 * @export
 * @interface LTEGatewaysApiLteNetworkIdGatewaysGatewayIdCellularDnsPutRequest
 */
export interface LTEGatewaysApiLteNetworkIdGatewaysGatewayIdCellularDnsPutRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof LTEGatewaysApiLteNetworkIdGatewaysGatewayIdCellularDnsPut
     */
    readonly networkId: string

    /**
     * Gateway ID
     * @type {string}
     * @memberof LTEGatewaysApiLteNetworkIdGatewaysGatewayIdCellularDnsPut
     */
    readonly gatewayId: string

    /**
     * New DNS configuration for the gateway
     * @type {GatewayDnsConfigs}
     * @memberof LTEGatewaysApiLteNetworkIdGatewaysGatewayIdCellularDnsPut
     */
    readonly config: GatewayDnsConfigs
}

/**
 * Request parameters for lteNetworkIdGatewaysGatewayIdCellularDnsRecordsGet operation in LTEGatewaysApi.
 * @export
 * @interface LTEGatewaysApiLteNetworkIdGatewaysGatewayIdCellularDnsRecordsGetRequest
 */
export interface LTEGatewaysApiLteNetworkIdGatewaysGatewayIdCellularDnsRecordsGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof LTEGatewaysApiLteNetworkIdGatewaysGatewayIdCellularDnsRecordsGet
     */
    readonly networkId: string

    /**
     * Gateway ID
     * @type {string}
     * @memberof LTEGatewaysApiLteNetworkIdGatewaysGatewayIdCellularDnsRecordsGet
     */
    readonly gatewayId: string
}

/**
 * Request parameters for lteNetworkIdGatewaysGatewayIdCellularDnsRecordsPut operation in LTEGatewaysApi.
 * @export
 * @interface LTEGatewaysApiLteNetworkIdGatewaysGatewayIdCellularDnsRecordsPutRequest
 */
export interface LTEGatewaysApiLteNetworkIdGatewaysGatewayIdCellularDnsRecordsPutRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof LTEGatewaysApiLteNetworkIdGatewaysGatewayIdCellularDnsRecordsPut
     */
    readonly networkId: string

    /**
     * Gateway ID
     * @type {string}
     * @memberof LTEGatewaysApiLteNetworkIdGatewaysGatewayIdCellularDnsRecordsPut
     */
    readonly gatewayId: string

    /**
     * Custom DNS records for the gateway
     * @type {Array<DnsConfigRecord>}
     * @memberof LTEGatewaysApiLteNetworkIdGatewaysGatewayIdCellularDnsRecordsPut
     */
    readonly records: Array<DnsConfigRecord>
}

/**
 * Request parameters for lteNetworkIdGatewaysGatewayIdCellularEpcGet operation in LTEGatewaysApi.
 * @export
 * @interface LTEGatewaysApiLteNetworkIdGatewaysGatewayIdCellularEpcGetRequest
 */
export interface LTEGatewaysApiLteNetworkIdGatewaysGatewayIdCellularEpcGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof LTEGatewaysApiLteNetworkIdGatewaysGatewayIdCellularEpcGet
     */
    readonly networkId: string

    /**
     * Gateway ID
     * @type {string}
     * @memberof LTEGatewaysApiLteNetworkIdGatewaysGatewayIdCellularEpcGet
     */
    readonly gatewayId: string
}

/**
 * Request parameters for lteNetworkIdGatewaysGatewayIdCellularEpcPut operation in LTEGatewaysApi.
 * @export
 * @interface LTEGatewaysApiLteNetworkIdGatewaysGatewayIdCellularEpcPutRequest
 */
export interface LTEGatewaysApiLteNetworkIdGatewaysGatewayIdCellularEpcPutRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof LTEGatewaysApiLteNetworkIdGatewaysGatewayIdCellularEpcPut
     */
    readonly networkId: string

    /**
     * Gateway ID
     * @type {string}
     * @memberof LTEGatewaysApiLteNetworkIdGatewaysGatewayIdCellularEpcPut
     */
    readonly gatewayId: string

    /**
     * New EPC configuration
     * @type {GatewayEpcConfigs}
     * @memberof LTEGatewaysApiLteNetworkIdGatewaysGatewayIdCellularEpcPut
     */
    readonly config: GatewayEpcConfigs
}

/**
 * Request parameters for lteNetworkIdGatewaysGatewayIdCellularGet operation in LTEGatewaysApi.
 * @export
 * @interface LTEGatewaysApiLteNetworkIdGatewaysGatewayIdCellularGetRequest
 */
export interface LTEGatewaysApiLteNetworkIdGatewaysGatewayIdCellularGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof LTEGatewaysApiLteNetworkIdGatewaysGatewayIdCellularGet
     */
    readonly networkId: string

    /**
     * Gateway ID
     * @type {string}
     * @memberof LTEGatewaysApiLteNetworkIdGatewaysGatewayIdCellularGet
     */
    readonly gatewayId: string
}

/**
 * Request parameters for lteNetworkIdGatewaysGatewayIdCellularNgcGet operation in LTEGatewaysApi.
 * @export
 * @interface LTEGatewaysApiLteNetworkIdGatewaysGatewayIdCellularNgcGetRequest
 */
export interface LTEGatewaysApiLteNetworkIdGatewaysGatewayIdCellularNgcGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof LTEGatewaysApiLteNetworkIdGatewaysGatewayIdCellularNgcGet
     */
    readonly networkId: string

    /**
     * Gateway ID
     * @type {string}
     * @memberof LTEGatewaysApiLteNetworkIdGatewaysGatewayIdCellularNgcGet
     */
    readonly gatewayId: string
}

/**
 * Request parameters for lteNetworkIdGatewaysGatewayIdCellularNgcPut operation in LTEGatewaysApi.
 * @export
 * @interface LTEGatewaysApiLteNetworkIdGatewaysGatewayIdCellularNgcPutRequest
 */
export interface LTEGatewaysApiLteNetworkIdGatewaysGatewayIdCellularNgcPutRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof LTEGatewaysApiLteNetworkIdGatewaysGatewayIdCellularNgcPut
     */
    readonly networkId: string

    /**
     * Gateway ID
     * @type {string}
     * @memberof LTEGatewaysApiLteNetworkIdGatewaysGatewayIdCellularNgcPut
     */
    readonly gatewayId: string

    /**
     * New NGC configuration
     * @type {GatewayNgcConfigs}
     * @memberof LTEGatewaysApiLteNetworkIdGatewaysGatewayIdCellularNgcPut
     */
    readonly config: GatewayNgcConfigs
}

/**
 * Request parameters for lteNetworkIdGatewaysGatewayIdCellularNonEpsGet operation in LTEGatewaysApi.
 * @export
 * @interface LTEGatewaysApiLteNetworkIdGatewaysGatewayIdCellularNonEpsGetRequest
 */
export interface LTEGatewaysApiLteNetworkIdGatewaysGatewayIdCellularNonEpsGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof LTEGatewaysApiLteNetworkIdGatewaysGatewayIdCellularNonEpsGet
     */
    readonly networkId: string

    /**
     * Gateway ID
     * @type {string}
     * @memberof LTEGatewaysApiLteNetworkIdGatewaysGatewayIdCellularNonEpsGet
     */
    readonly gatewayId: string
}

/**
 * Request parameters for lteNetworkIdGatewaysGatewayIdCellularNonEpsPut operation in LTEGatewaysApi.
 * @export
 * @interface LTEGatewaysApiLteNetworkIdGatewaysGatewayIdCellularNonEpsPutRequest
 */
export interface LTEGatewaysApiLteNetworkIdGatewaysGatewayIdCellularNonEpsPutRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof LTEGatewaysApiLteNetworkIdGatewaysGatewayIdCellularNonEpsPut
     */
    readonly networkId: string

    /**
     * Gateway ID
     * @type {string}
     * @memberof LTEGatewaysApiLteNetworkIdGatewaysGatewayIdCellularNonEpsPut
     */
    readonly gatewayId: string

    /**
     * New Non-EPS configuration
     * @type {GatewayNonEpsConfigs}
     * @memberof LTEGatewaysApiLteNetworkIdGatewaysGatewayIdCellularNonEpsPut
     */
    readonly config: GatewayNonEpsConfigs
}

/**
 * Request parameters for lteNetworkIdGatewaysGatewayIdCellularPoolingGet operation in LTEGatewaysApi.
 * @export
 * @interface LTEGatewaysApiLteNetworkIdGatewaysGatewayIdCellularPoolingGetRequest
 */
export interface LTEGatewaysApiLteNetworkIdGatewaysGatewayIdCellularPoolingGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof LTEGatewaysApiLteNetworkIdGatewaysGatewayIdCellularPoolingGet
     */
    readonly networkId: string

    /**
     * Gateway ID
     * @type {string}
     * @memberof LTEGatewaysApiLteNetworkIdGatewaysGatewayIdCellularPoolingGet
     */
    readonly gatewayId: string
}

/**
 * Request parameters for lteNetworkIdGatewaysGatewayIdCellularPoolingPut operation in LTEGatewaysApi.
 * @export
 * @interface LTEGatewaysApiLteNetworkIdGatewaysGatewayIdCellularPoolingPutRequest
 */
export interface LTEGatewaysApiLteNetworkIdGatewaysGatewayIdCellularPoolingPutRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof LTEGatewaysApiLteNetworkIdGatewaysGatewayIdCellularPoolingPut
     */
    readonly networkId: string

    /**
     * Gateway ID
     * @type {string}
     * @memberof LTEGatewaysApiLteNetworkIdGatewaysGatewayIdCellularPoolingPut
     */
    readonly gatewayId: string

    /**
     * Gateway pool records for gateway
     * @type {Array<CellularGatewayPoolRecord>}
     * @memberof LTEGatewaysApiLteNetworkIdGatewaysGatewayIdCellularPoolingPut
     */
    readonly resource: Array<CellularGatewayPoolRecord>
}

/**
 * Request parameters for lteNetworkIdGatewaysGatewayIdCellularPut operation in LTEGatewaysApi.
 * @export
 * @interface LTEGatewaysApiLteNetworkIdGatewaysGatewayIdCellularPutRequest
 */
export interface LTEGatewaysApiLteNetworkIdGatewaysGatewayIdCellularPutRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof LTEGatewaysApiLteNetworkIdGatewaysGatewayIdCellularPut
     */
    readonly networkId: string

    /**
     * Gateway ID
     * @type {string}
     * @memberof LTEGatewaysApiLteNetworkIdGatewaysGatewayIdCellularPut
     */
    readonly gatewayId: string

    /**
     * New cellular configuration
     * @type {GatewayCellularConfigs}
     * @memberof LTEGatewaysApiLteNetworkIdGatewaysGatewayIdCellularPut
     */
    readonly config: GatewayCellularConfigs
}

/**
 * Request parameters for lteNetworkIdGatewaysGatewayIdCellularRanGet operation in LTEGatewaysApi.
 * @export
 * @interface LTEGatewaysApiLteNetworkIdGatewaysGatewayIdCellularRanGetRequest
 */
export interface LTEGatewaysApiLteNetworkIdGatewaysGatewayIdCellularRanGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof LTEGatewaysApiLteNetworkIdGatewaysGatewayIdCellularRanGet
     */
    readonly networkId: string

    /**
     * Gateway ID
     * @type {string}
     * @memberof LTEGatewaysApiLteNetworkIdGatewaysGatewayIdCellularRanGet
     */
    readonly gatewayId: string
}

/**
 * Request parameters for lteNetworkIdGatewaysGatewayIdCellularRanPut operation in LTEGatewaysApi.
 * @export
 * @interface LTEGatewaysApiLteNetworkIdGatewaysGatewayIdCellularRanPutRequest
 */
export interface LTEGatewaysApiLteNetworkIdGatewaysGatewayIdCellularRanPutRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof LTEGatewaysApiLteNetworkIdGatewaysGatewayIdCellularRanPut
     */
    readonly networkId: string

    /**
     * Gateway ID
     * @type {string}
     * @memberof LTEGatewaysApiLteNetworkIdGatewaysGatewayIdCellularRanPut
     */
    readonly gatewayId: string

    /**
     * New RAN configuration
     * @type {GatewayRanConfigs}
     * @memberof LTEGatewaysApiLteNetworkIdGatewaysGatewayIdCellularRanPut
     */
    readonly config: GatewayRanConfigs
}

/**
 * Request parameters for lteNetworkIdGatewaysGatewayIdConnectedEnodebSerialsDelete operation in LTEGatewaysApi.
 * @export
 * @interface LTEGatewaysApiLteNetworkIdGatewaysGatewayIdConnectedEnodebSerialsDeleteRequest
 */
export interface LTEGatewaysApiLteNetworkIdGatewaysGatewayIdConnectedEnodebSerialsDeleteRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof LTEGatewaysApiLteNetworkIdGatewaysGatewayIdConnectedEnodebSerialsDelete
     */
    readonly networkId: string

    /**
     * Gateway ID
     * @type {string}
     * @memberof LTEGatewaysApiLteNetworkIdGatewaysGatewayIdConnectedEnodebSerialsDelete
     */
    readonly gatewayId: string

    /**
     * 
     * @type {string}
     * @memberof LTEGatewaysApiLteNetworkIdGatewaysGatewayIdConnectedEnodebSerialsDelete
     */
    readonly serial: string
}

/**
 * Request parameters for lteNetworkIdGatewaysGatewayIdConnectedEnodebSerialsGet operation in LTEGatewaysApi.
 * @export
 * @interface LTEGatewaysApiLteNetworkIdGatewaysGatewayIdConnectedEnodebSerialsGetRequest
 */
export interface LTEGatewaysApiLteNetworkIdGatewaysGatewayIdConnectedEnodebSerialsGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof LTEGatewaysApiLteNetworkIdGatewaysGatewayIdConnectedEnodebSerialsGet
     */
    readonly networkId: string

    /**
     * Gateway ID
     * @type {string}
     * @memberof LTEGatewaysApiLteNetworkIdGatewaysGatewayIdConnectedEnodebSerialsGet
     */
    readonly gatewayId: string
}

/**
 * Request parameters for lteNetworkIdGatewaysGatewayIdConnectedEnodebSerialsPost operation in LTEGatewaysApi.
 * @export
 * @interface LTEGatewaysApiLteNetworkIdGatewaysGatewayIdConnectedEnodebSerialsPostRequest
 */
export interface LTEGatewaysApiLteNetworkIdGatewaysGatewayIdConnectedEnodebSerialsPostRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof LTEGatewaysApiLteNetworkIdGatewaysGatewayIdConnectedEnodebSerialsPost
     */
    readonly networkId: string

    /**
     * Gateway ID
     * @type {string}
     * @memberof LTEGatewaysApiLteNetworkIdGatewaysGatewayIdConnectedEnodebSerialsPost
     */
    readonly gatewayId: string

    /**
     * 
     * @type {string}
     * @memberof LTEGatewaysApiLteNetworkIdGatewaysGatewayIdConnectedEnodebSerialsPost
     */
    readonly serial: string
}

/**
 * Request parameters for lteNetworkIdGatewaysGatewayIdConnectedEnodebSerialsPut operation in LTEGatewaysApi.
 * @export
 * @interface LTEGatewaysApiLteNetworkIdGatewaysGatewayIdConnectedEnodebSerialsPutRequest
 */
export interface LTEGatewaysApiLteNetworkIdGatewaysGatewayIdConnectedEnodebSerialsPutRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof LTEGatewaysApiLteNetworkIdGatewaysGatewayIdConnectedEnodebSerialsPut
     */
    readonly networkId: string

    /**
     * Gateway ID
     * @type {string}
     * @memberof LTEGatewaysApiLteNetworkIdGatewaysGatewayIdConnectedEnodebSerialsPut
     */
    readonly gatewayId: string

    /**
     * 
     * @type {Array<string>}
     * @memberof LTEGatewaysApiLteNetworkIdGatewaysGatewayIdConnectedEnodebSerialsPut
     */
    readonly serials: Array<string>
}

/**
 * Request parameters for lteNetworkIdGatewaysGatewayIdDelete operation in LTEGatewaysApi.
 * @export
 * @interface LTEGatewaysApiLteNetworkIdGatewaysGatewayIdDeleteRequest
 */
export interface LTEGatewaysApiLteNetworkIdGatewaysGatewayIdDeleteRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof LTEGatewaysApiLteNetworkIdGatewaysGatewayIdDelete
     */
    readonly networkId: string

    /**
     * Gateway ID
     * @type {string}
     * @memberof LTEGatewaysApiLteNetworkIdGatewaysGatewayIdDelete
     */
    readonly gatewayId: string
}

/**
 * Request parameters for lteNetworkIdGatewaysGatewayIdDescriptionGet operation in LTEGatewaysApi.
 * @export
 * @interface LTEGatewaysApiLteNetworkIdGatewaysGatewayIdDescriptionGetRequest
 */
export interface LTEGatewaysApiLteNetworkIdGatewaysGatewayIdDescriptionGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof LTEGatewaysApiLteNetworkIdGatewaysGatewayIdDescriptionGet
     */
    readonly networkId: string

    /**
     * Gateway ID
     * @type {string}
     * @memberof LTEGatewaysApiLteNetworkIdGatewaysGatewayIdDescriptionGet
     */
    readonly gatewayId: string
}

/**
 * Request parameters for lteNetworkIdGatewaysGatewayIdDescriptionPut operation in LTEGatewaysApi.
 * @export
 * @interface LTEGatewaysApiLteNetworkIdGatewaysGatewayIdDescriptionPutRequest
 */
export interface LTEGatewaysApiLteNetworkIdGatewaysGatewayIdDescriptionPutRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof LTEGatewaysApiLteNetworkIdGatewaysGatewayIdDescriptionPut
     */
    readonly networkId: string

    /**
     * Gateway ID
     * @type {string}
     * @memberof LTEGatewaysApiLteNetworkIdGatewaysGatewayIdDescriptionPut
     */
    readonly gatewayId: string

    /**
     * 
     * @type {string}
     * @memberof LTEGatewaysApiLteNetworkIdGatewaysGatewayIdDescriptionPut
     */
    readonly description: string
}

/**
 * Request parameters for lteNetworkIdGatewaysGatewayIdDeviceGet operation in LTEGatewaysApi.
 * @export
 * @interface LTEGatewaysApiLteNetworkIdGatewaysGatewayIdDeviceGetRequest
 */
export interface LTEGatewaysApiLteNetworkIdGatewaysGatewayIdDeviceGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof LTEGatewaysApiLteNetworkIdGatewaysGatewayIdDeviceGet
     */
    readonly networkId: string

    /**
     * Gateway ID
     * @type {string}
     * @memberof LTEGatewaysApiLteNetworkIdGatewaysGatewayIdDeviceGet
     */
    readonly gatewayId: string
}

/**
 * Request parameters for lteNetworkIdGatewaysGatewayIdDevicePut operation in LTEGatewaysApi.
 * @export
 * @interface LTEGatewaysApiLteNetworkIdGatewaysGatewayIdDevicePutRequest
 */
export interface LTEGatewaysApiLteNetworkIdGatewaysGatewayIdDevicePutRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof LTEGatewaysApiLteNetworkIdGatewaysGatewayIdDevicePut
     */
    readonly networkId: string

    /**
     * Gateway ID
     * @type {string}
     * @memberof LTEGatewaysApiLteNetworkIdGatewaysGatewayIdDevicePut
     */
    readonly gatewayId: string

    /**
     * New device for the LTE gateway
     * @type {GatewayDevice}
     * @memberof LTEGatewaysApiLteNetworkIdGatewaysGatewayIdDevicePut
     */
    readonly device: GatewayDevice
}

/**
 * Request parameters for lteNetworkIdGatewaysGatewayIdGet operation in LTEGatewaysApi.
 * @export
 * @interface LTEGatewaysApiLteNetworkIdGatewaysGatewayIdGetRequest
 */
export interface LTEGatewaysApiLteNetworkIdGatewaysGatewayIdGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof LTEGatewaysApiLteNetworkIdGatewaysGatewayIdGet
     */
    readonly networkId: string

    /**
     * Gateway ID
     * @type {string}
     * @memberof LTEGatewaysApiLteNetworkIdGatewaysGatewayIdGet
     */
    readonly gatewayId: string
}

/**
 * Request parameters for lteNetworkIdGatewaysGatewayIdMagmadGet operation in LTEGatewaysApi.
 * @export
 * @interface LTEGatewaysApiLteNetworkIdGatewaysGatewayIdMagmadGetRequest
 */
export interface LTEGatewaysApiLteNetworkIdGatewaysGatewayIdMagmadGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof LTEGatewaysApiLteNetworkIdGatewaysGatewayIdMagmadGet
     */
    readonly networkId: string

    /**
     * Gateway ID
     * @type {string}
     * @memberof LTEGatewaysApiLteNetworkIdGatewaysGatewayIdMagmadGet
     */
    readonly gatewayId: string
}

/**
 * Request parameters for lteNetworkIdGatewaysGatewayIdMagmadPut operation in LTEGatewaysApi.
 * @export
 * @interface LTEGatewaysApiLteNetworkIdGatewaysGatewayIdMagmadPutRequest
 */
export interface LTEGatewaysApiLteNetworkIdGatewaysGatewayIdMagmadPutRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof LTEGatewaysApiLteNetworkIdGatewaysGatewayIdMagmadPut
     */
    readonly networkId: string

    /**
     * Gateway ID
     * @type {string}
     * @memberof LTEGatewaysApiLteNetworkIdGatewaysGatewayIdMagmadPut
     */
    readonly gatewayId: string

    /**
     * New magmad configuration
     * @type {MagmadGatewayConfigs}
     * @memberof LTEGatewaysApiLteNetworkIdGatewaysGatewayIdMagmadPut
     */
    readonly magmad: MagmadGatewayConfigs
}

/**
 * Request parameters for lteNetworkIdGatewaysGatewayIdNameGet operation in LTEGatewaysApi.
 * @export
 * @interface LTEGatewaysApiLteNetworkIdGatewaysGatewayIdNameGetRequest
 */
export interface LTEGatewaysApiLteNetworkIdGatewaysGatewayIdNameGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof LTEGatewaysApiLteNetworkIdGatewaysGatewayIdNameGet
     */
    readonly networkId: string

    /**
     * Gateway ID
     * @type {string}
     * @memberof LTEGatewaysApiLteNetworkIdGatewaysGatewayIdNameGet
     */
    readonly gatewayId: string
}

/**
 * Request parameters for lteNetworkIdGatewaysGatewayIdNamePut operation in LTEGatewaysApi.
 * @export
 * @interface LTEGatewaysApiLteNetworkIdGatewaysGatewayIdNamePutRequest
 */
export interface LTEGatewaysApiLteNetworkIdGatewaysGatewayIdNamePutRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof LTEGatewaysApiLteNetworkIdGatewaysGatewayIdNamePut
     */
    readonly networkId: string

    /**
     * Gateway ID
     * @type {string}
     * @memberof LTEGatewaysApiLteNetworkIdGatewaysGatewayIdNamePut
     */
    readonly gatewayId: string

    /**
     * 
     * @type {string}
     * @memberof LTEGatewaysApiLteNetworkIdGatewaysGatewayIdNamePut
     */
    readonly name: string
}

/**
 * Request parameters for lteNetworkIdGatewaysGatewayIdPut operation in LTEGatewaysApi.
 * @export
 * @interface LTEGatewaysApiLteNetworkIdGatewaysGatewayIdPutRequest
 */
export interface LTEGatewaysApiLteNetworkIdGatewaysGatewayIdPutRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof LTEGatewaysApiLteNetworkIdGatewaysGatewayIdPut
     */
    readonly networkId: string

    /**
     * Gateway ID
     * @type {string}
     * @memberof LTEGatewaysApiLteNetworkIdGatewaysGatewayIdPut
     */
    readonly gatewayId: string

    /**
     * Full desired configuration of the gateway
     * @type {MutableLteGateway}
     * @memberof LTEGatewaysApiLteNetworkIdGatewaysGatewayIdPut
     */
    readonly gateway: MutableLteGateway
}

/**
 * Request parameters for lteNetworkIdGatewaysGatewayIdStatusGet operation in LTEGatewaysApi.
 * @export
 * @interface LTEGatewaysApiLteNetworkIdGatewaysGatewayIdStatusGetRequest
 */
export interface LTEGatewaysApiLteNetworkIdGatewaysGatewayIdStatusGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof LTEGatewaysApiLteNetworkIdGatewaysGatewayIdStatusGet
     */
    readonly networkId: string

    /**
     * Gateway ID
     * @type {string}
     * @memberof LTEGatewaysApiLteNetworkIdGatewaysGatewayIdStatusGet
     */
    readonly gatewayId: string
}

/**
 * Request parameters for lteNetworkIdGatewaysGatewayIdTierGet operation in LTEGatewaysApi.
 * @export
 * @interface LTEGatewaysApiLteNetworkIdGatewaysGatewayIdTierGetRequest
 */
export interface LTEGatewaysApiLteNetworkIdGatewaysGatewayIdTierGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof LTEGatewaysApiLteNetworkIdGatewaysGatewayIdTierGet
     */
    readonly networkId: string

    /**
     * Gateway ID
     * @type {string}
     * @memberof LTEGatewaysApiLteNetworkIdGatewaysGatewayIdTierGet
     */
    readonly gatewayId: string
}

/**
 * Request parameters for lteNetworkIdGatewaysGatewayIdTierPut operation in LTEGatewaysApi.
 * @export
 * @interface LTEGatewaysApiLteNetworkIdGatewaysGatewayIdTierPutRequest
 */
export interface LTEGatewaysApiLteNetworkIdGatewaysGatewayIdTierPutRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof LTEGatewaysApiLteNetworkIdGatewaysGatewayIdTierPut
     */
    readonly networkId: string

    /**
     * Gateway ID
     * @type {string}
     * @memberof LTEGatewaysApiLteNetworkIdGatewaysGatewayIdTierPut
     */
    readonly gatewayId: string

    /**
     * 
     * @type {string}
     * @memberof LTEGatewaysApiLteNetworkIdGatewaysGatewayIdTierPut
     */
    readonly tierId: string
}

/**
 * Request parameters for lteNetworkIdGatewaysGatewayIdVpnGet operation in LTEGatewaysApi.
 * @export
 * @interface LTEGatewaysApiLteNetworkIdGatewaysGatewayIdVpnGetRequest
 */
export interface LTEGatewaysApiLteNetworkIdGatewaysGatewayIdVpnGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof LTEGatewaysApiLteNetworkIdGatewaysGatewayIdVpnGet
     */
    readonly networkId: string

    /**
     * Gateway ID
     * @type {string}
     * @memberof LTEGatewaysApiLteNetworkIdGatewaysGatewayIdVpnGet
     */
    readonly gatewayId: string
}

/**
 * Request parameters for lteNetworkIdGatewaysGatewayIdVpnPut operation in LTEGatewaysApi.
 * @export
 * @interface LTEGatewaysApiLteNetworkIdGatewaysGatewayIdVpnPutRequest
 */
export interface LTEGatewaysApiLteNetworkIdGatewaysGatewayIdVpnPutRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof LTEGatewaysApiLteNetworkIdGatewaysGatewayIdVpnPut
     */
    readonly networkId: string

    /**
     * Gateway ID
     * @type {string}
     * @memberof LTEGatewaysApiLteNetworkIdGatewaysGatewayIdVpnPut
     */
    readonly gatewayId: string

    /**
     * New VPN configuration
     * @type {GatewayVpnConfigs}
     * @memberof LTEGatewaysApiLteNetworkIdGatewaysGatewayIdVpnPut
     */
    readonly config: GatewayVpnConfigs
}

/**
 * Request parameters for lteNetworkIdGatewaysGet operation in LTEGatewaysApi.
 * @export
 * @interface LTEGatewaysApiLteNetworkIdGatewaysGetRequest
 */
export interface LTEGatewaysApiLteNetworkIdGatewaysGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof LTEGatewaysApiLteNetworkIdGatewaysGet
     */
    readonly networkId: string
}

/**
 * Request parameters for lteNetworkIdGatewaysPost operation in LTEGatewaysApi.
 * @export
 * @interface LTEGatewaysApiLteNetworkIdGatewaysPostRequest
 */
export interface LTEGatewaysApiLteNetworkIdGatewaysPostRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof LTEGatewaysApiLteNetworkIdGatewaysPost
     */
    readonly networkId: string

    /**
     * Full desired configuration of the gateway
     * @type {MutableLteGateway}
     * @memberof LTEGatewaysApiLteNetworkIdGatewaysPost
     */
    readonly gateway: MutableLteGateway
}

/**
 * LTEGatewaysApi - object-oriented interface
 * @export
 * @class LTEGatewaysApi
 * @extends {BaseAPI}
 */
export class LTEGatewaysApi extends BaseAPI {
    /**
     * 
     * @summary Get DNS configuration of LTE gateway
     * @param {LTEGatewaysApiLteNetworkIdGatewaysGatewayIdCellularDnsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LTEGatewaysApi
     */
    public lteNetworkIdGatewaysGatewayIdCellularDnsGet(requestParameters: LTEGatewaysApiLteNetworkIdGatewaysGatewayIdCellularDnsGetRequest, options?: AxiosRequestConfig) {
        return LTEGatewaysApiFp(this.configuration).lteNetworkIdGatewaysGatewayIdCellularDnsGet(requestParameters.networkId, requestParameters.gatewayId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update DNS configuration of LTE gateway
     * @param {LTEGatewaysApiLteNetworkIdGatewaysGatewayIdCellularDnsPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LTEGatewaysApi
     */
    public lteNetworkIdGatewaysGatewayIdCellularDnsPut(requestParameters: LTEGatewaysApiLteNetworkIdGatewaysGatewayIdCellularDnsPutRequest, options?: AxiosRequestConfig) {
        return LTEGatewaysApiFp(this.configuration).lteNetworkIdGatewaysGatewayIdCellularDnsPut(requestParameters.networkId, requestParameters.gatewayId, requestParameters.config, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the DNS config records for LTE gateway
     * @param {LTEGatewaysApiLteNetworkIdGatewaysGatewayIdCellularDnsRecordsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LTEGatewaysApi
     */
    public lteNetworkIdGatewaysGatewayIdCellularDnsRecordsGet(requestParameters: LTEGatewaysApiLteNetworkIdGatewaysGatewayIdCellularDnsRecordsGetRequest, options?: AxiosRequestConfig) {
        return LTEGatewaysApiFp(this.configuration).lteNetworkIdGatewaysGatewayIdCellularDnsRecordsGet(requestParameters.networkId, requestParameters.gatewayId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Change all the DNS records for LTE gateway
     * @param {LTEGatewaysApiLteNetworkIdGatewaysGatewayIdCellularDnsRecordsPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LTEGatewaysApi
     */
    public lteNetworkIdGatewaysGatewayIdCellularDnsRecordsPut(requestParameters: LTEGatewaysApiLteNetworkIdGatewaysGatewayIdCellularDnsRecordsPutRequest, options?: AxiosRequestConfig) {
        return LTEGatewaysApiFp(this.configuration).lteNetworkIdGatewaysGatewayIdCellularDnsRecordsPut(requestParameters.networkId, requestParameters.gatewayId, requestParameters.records, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get gateway EPC configuration
     * @param {LTEGatewaysApiLteNetworkIdGatewaysGatewayIdCellularEpcGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LTEGatewaysApi
     */
    public lteNetworkIdGatewaysGatewayIdCellularEpcGet(requestParameters: LTEGatewaysApiLteNetworkIdGatewaysGatewayIdCellularEpcGetRequest, options?: AxiosRequestConfig) {
        return LTEGatewaysApiFp(this.configuration).lteNetworkIdGatewaysGatewayIdCellularEpcGet(requestParameters.networkId, requestParameters.gatewayId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update gateway EPC configuration
     * @param {LTEGatewaysApiLteNetworkIdGatewaysGatewayIdCellularEpcPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LTEGatewaysApi
     */
    public lteNetworkIdGatewaysGatewayIdCellularEpcPut(requestParameters: LTEGatewaysApiLteNetworkIdGatewaysGatewayIdCellularEpcPutRequest, options?: AxiosRequestConfig) {
        return LTEGatewaysApiFp(this.configuration).lteNetworkIdGatewaysGatewayIdCellularEpcPut(requestParameters.networkId, requestParameters.gatewayId, requestParameters.config, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get gateway cellular configuration
     * @param {LTEGatewaysApiLteNetworkIdGatewaysGatewayIdCellularGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LTEGatewaysApi
     */
    public lteNetworkIdGatewaysGatewayIdCellularGet(requestParameters: LTEGatewaysApiLteNetworkIdGatewaysGatewayIdCellularGetRequest, options?: AxiosRequestConfig) {
        return LTEGatewaysApiFp(this.configuration).lteNetworkIdGatewaysGatewayIdCellularGet(requestParameters.networkId, requestParameters.gatewayId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get gateway NGC configuration
     * @param {LTEGatewaysApiLteNetworkIdGatewaysGatewayIdCellularNgcGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LTEGatewaysApi
     */
    public lteNetworkIdGatewaysGatewayIdCellularNgcGet(requestParameters: LTEGatewaysApiLteNetworkIdGatewaysGatewayIdCellularNgcGetRequest, options?: AxiosRequestConfig) {
        return LTEGatewaysApiFp(this.configuration).lteNetworkIdGatewaysGatewayIdCellularNgcGet(requestParameters.networkId, requestParameters.gatewayId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update gateway NGC configuration
     * @param {LTEGatewaysApiLteNetworkIdGatewaysGatewayIdCellularNgcPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LTEGatewaysApi
     */
    public lteNetworkIdGatewaysGatewayIdCellularNgcPut(requestParameters: LTEGatewaysApiLteNetworkIdGatewaysGatewayIdCellularNgcPutRequest, options?: AxiosRequestConfig) {
        return LTEGatewaysApiFp(this.configuration).lteNetworkIdGatewaysGatewayIdCellularNgcPut(requestParameters.networkId, requestParameters.gatewayId, requestParameters.config, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get gateway Non-EPS configuration
     * @param {LTEGatewaysApiLteNetworkIdGatewaysGatewayIdCellularNonEpsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LTEGatewaysApi
     */
    public lteNetworkIdGatewaysGatewayIdCellularNonEpsGet(requestParameters: LTEGatewaysApiLteNetworkIdGatewaysGatewayIdCellularNonEpsGetRequest, options?: AxiosRequestConfig) {
        return LTEGatewaysApiFp(this.configuration).lteNetworkIdGatewaysGatewayIdCellularNonEpsGet(requestParameters.networkId, requestParameters.gatewayId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update gateway Non-EPS configuration
     * @param {LTEGatewaysApiLteNetworkIdGatewaysGatewayIdCellularNonEpsPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LTEGatewaysApi
     */
    public lteNetworkIdGatewaysGatewayIdCellularNonEpsPut(requestParameters: LTEGatewaysApiLteNetworkIdGatewaysGatewayIdCellularNonEpsPutRequest, options?: AxiosRequestConfig) {
        return LTEGatewaysApiFp(this.configuration).lteNetworkIdGatewaysGatewayIdCellularNonEpsPut(requestParameters.networkId, requestParameters.gatewayId, requestParameters.config, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the gateway pool records for LTE gateway
     * @param {LTEGatewaysApiLteNetworkIdGatewaysGatewayIdCellularPoolingGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LTEGatewaysApi
     */
    public lteNetworkIdGatewaysGatewayIdCellularPoolingGet(requestParameters: LTEGatewaysApiLteNetworkIdGatewaysGatewayIdCellularPoolingGetRequest, options?: AxiosRequestConfig) {
        return LTEGatewaysApiFp(this.configuration).lteNetworkIdGatewaysGatewayIdCellularPoolingGet(requestParameters.networkId, requestParameters.gatewayId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Change all the gateway pool records for LTE gateway
     * @param {LTEGatewaysApiLteNetworkIdGatewaysGatewayIdCellularPoolingPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LTEGatewaysApi
     */
    public lteNetworkIdGatewaysGatewayIdCellularPoolingPut(requestParameters: LTEGatewaysApiLteNetworkIdGatewaysGatewayIdCellularPoolingPutRequest, options?: AxiosRequestConfig) {
        return LTEGatewaysApiFp(this.configuration).lteNetworkIdGatewaysGatewayIdCellularPoolingPut(requestParameters.networkId, requestParameters.gatewayId, requestParameters.resource, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update gateway cellular configuration
     * @param {LTEGatewaysApiLteNetworkIdGatewaysGatewayIdCellularPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LTEGatewaysApi
     */
    public lteNetworkIdGatewaysGatewayIdCellularPut(requestParameters: LTEGatewaysApiLteNetworkIdGatewaysGatewayIdCellularPutRequest, options?: AxiosRequestConfig) {
        return LTEGatewaysApiFp(this.configuration).lteNetworkIdGatewaysGatewayIdCellularPut(requestParameters.networkId, requestParameters.gatewayId, requestParameters.config, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get gateway RAN configuration
     * @param {LTEGatewaysApiLteNetworkIdGatewaysGatewayIdCellularRanGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LTEGatewaysApi
     */
    public lteNetworkIdGatewaysGatewayIdCellularRanGet(requestParameters: LTEGatewaysApiLteNetworkIdGatewaysGatewayIdCellularRanGetRequest, options?: AxiosRequestConfig) {
        return LTEGatewaysApiFp(this.configuration).lteNetworkIdGatewaysGatewayIdCellularRanGet(requestParameters.networkId, requestParameters.gatewayId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update gateway RAN configuration
     * @param {LTEGatewaysApiLteNetworkIdGatewaysGatewayIdCellularRanPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LTEGatewaysApi
     */
    public lteNetworkIdGatewaysGatewayIdCellularRanPut(requestParameters: LTEGatewaysApiLteNetworkIdGatewaysGatewayIdCellularRanPutRequest, options?: AxiosRequestConfig) {
        return LTEGatewaysApiFp(this.configuration).lteNetworkIdGatewaysGatewayIdCellularRanPut(requestParameters.networkId, requestParameters.gatewayId, requestParameters.config, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove an enodeB from the connected devices list
     * @param {LTEGatewaysApiLteNetworkIdGatewaysGatewayIdConnectedEnodebSerialsDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LTEGatewaysApi
     */
    public lteNetworkIdGatewaysGatewayIdConnectedEnodebSerialsDelete(requestParameters: LTEGatewaysApiLteNetworkIdGatewaysGatewayIdConnectedEnodebSerialsDeleteRequest, options?: AxiosRequestConfig) {
        return LTEGatewaysApiFp(this.configuration).lteNetworkIdGatewaysGatewayIdConnectedEnodebSerialsDelete(requestParameters.networkId, requestParameters.gatewayId, requestParameters.serial, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the SNs of all enodeBs connected to a gateway
     * @param {LTEGatewaysApiLteNetworkIdGatewaysGatewayIdConnectedEnodebSerialsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LTEGatewaysApi
     */
    public lteNetworkIdGatewaysGatewayIdConnectedEnodebSerialsGet(requestParameters: LTEGatewaysApiLteNetworkIdGatewaysGatewayIdConnectedEnodebSerialsGetRequest, options?: AxiosRequestConfig) {
        return LTEGatewaysApiFp(this.configuration).lteNetworkIdGatewaysGatewayIdConnectedEnodebSerialsGet(requestParameters.networkId, requestParameters.gatewayId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add a new connected enodeB to a gateway
     * @param {LTEGatewaysApiLteNetworkIdGatewaysGatewayIdConnectedEnodebSerialsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LTEGatewaysApi
     */
    public lteNetworkIdGatewaysGatewayIdConnectedEnodebSerialsPost(requestParameters: LTEGatewaysApiLteNetworkIdGatewaysGatewayIdConnectedEnodebSerialsPostRequest, options?: AxiosRequestConfig) {
        return LTEGatewaysApiFp(this.configuration).lteNetworkIdGatewaysGatewayIdConnectedEnodebSerialsPost(requestParameters.networkId, requestParameters.gatewayId, requestParameters.serial, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the set of connected enodeBs
     * @param {LTEGatewaysApiLteNetworkIdGatewaysGatewayIdConnectedEnodebSerialsPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LTEGatewaysApi
     */
    public lteNetworkIdGatewaysGatewayIdConnectedEnodebSerialsPut(requestParameters: LTEGatewaysApiLteNetworkIdGatewaysGatewayIdConnectedEnodebSerialsPutRequest, options?: AxiosRequestConfig) {
        return LTEGatewaysApiFp(this.configuration).lteNetworkIdGatewaysGatewayIdConnectedEnodebSerialsPut(requestParameters.networkId, requestParameters.gatewayId, requestParameters.serials, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete an LTE gateway
     * @param {LTEGatewaysApiLteNetworkIdGatewaysGatewayIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LTEGatewaysApi
     */
    public lteNetworkIdGatewaysGatewayIdDelete(requestParameters: LTEGatewaysApiLteNetworkIdGatewaysGatewayIdDeleteRequest, options?: AxiosRequestConfig) {
        return LTEGatewaysApiFp(this.configuration).lteNetworkIdGatewaysGatewayIdDelete(requestParameters.networkId, requestParameters.gatewayId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the description of an LTE gateway
     * @param {LTEGatewaysApiLteNetworkIdGatewaysGatewayIdDescriptionGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LTEGatewaysApi
     */
    public lteNetworkIdGatewaysGatewayIdDescriptionGet(requestParameters: LTEGatewaysApiLteNetworkIdGatewaysGatewayIdDescriptionGetRequest, options?: AxiosRequestConfig) {
        return LTEGatewaysApiFp(this.configuration).lteNetworkIdGatewaysGatewayIdDescriptionGet(requestParameters.networkId, requestParameters.gatewayId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the description of an LTE gateway
     * @param {LTEGatewaysApiLteNetworkIdGatewaysGatewayIdDescriptionPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LTEGatewaysApi
     */
    public lteNetworkIdGatewaysGatewayIdDescriptionPut(requestParameters: LTEGatewaysApiLteNetworkIdGatewaysGatewayIdDescriptionPutRequest, options?: AxiosRequestConfig) {
        return LTEGatewaysApiFp(this.configuration).lteNetworkIdGatewaysGatewayIdDescriptionPut(requestParameters.networkId, requestParameters.gatewayId, requestParameters.description, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the physical device for an LTE gateway
     * @param {LTEGatewaysApiLteNetworkIdGatewaysGatewayIdDeviceGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LTEGatewaysApi
     */
    public lteNetworkIdGatewaysGatewayIdDeviceGet(requestParameters: LTEGatewaysApiLteNetworkIdGatewaysGatewayIdDeviceGetRequest, options?: AxiosRequestConfig) {
        return LTEGatewaysApiFp(this.configuration).lteNetworkIdGatewaysGatewayIdDeviceGet(requestParameters.networkId, requestParameters.gatewayId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the physical device for an LTE gateway
     * @param {LTEGatewaysApiLteNetworkIdGatewaysGatewayIdDevicePutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LTEGatewaysApi
     */
    public lteNetworkIdGatewaysGatewayIdDevicePut(requestParameters: LTEGatewaysApiLteNetworkIdGatewaysGatewayIdDevicePutRequest, options?: AxiosRequestConfig) {
        return LTEGatewaysApiFp(this.configuration).lteNetworkIdGatewaysGatewayIdDevicePut(requestParameters.networkId, requestParameters.gatewayId, requestParameters.device, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a specific LTE gateway
     * @param {LTEGatewaysApiLteNetworkIdGatewaysGatewayIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LTEGatewaysApi
     */
    public lteNetworkIdGatewaysGatewayIdGet(requestParameters: LTEGatewaysApiLteNetworkIdGatewaysGatewayIdGetRequest, options?: AxiosRequestConfig) {
        return LTEGatewaysApiFp(this.configuration).lteNetworkIdGatewaysGatewayIdGet(requestParameters.networkId, requestParameters.gatewayId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get magmad agent configuration
     * @param {LTEGatewaysApiLteNetworkIdGatewaysGatewayIdMagmadGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LTEGatewaysApi
     */
    public lteNetworkIdGatewaysGatewayIdMagmadGet(requestParameters: LTEGatewaysApiLteNetworkIdGatewaysGatewayIdMagmadGetRequest, options?: AxiosRequestConfig) {
        return LTEGatewaysApiFp(this.configuration).lteNetworkIdGatewaysGatewayIdMagmadGet(requestParameters.networkId, requestParameters.gatewayId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reconfigure magmad agent
     * @param {LTEGatewaysApiLteNetworkIdGatewaysGatewayIdMagmadPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LTEGatewaysApi
     */
    public lteNetworkIdGatewaysGatewayIdMagmadPut(requestParameters: LTEGatewaysApiLteNetworkIdGatewaysGatewayIdMagmadPutRequest, options?: AxiosRequestConfig) {
        return LTEGatewaysApiFp(this.configuration).lteNetworkIdGatewaysGatewayIdMagmadPut(requestParameters.networkId, requestParameters.gatewayId, requestParameters.magmad, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the name of an LTE gateway
     * @param {LTEGatewaysApiLteNetworkIdGatewaysGatewayIdNameGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LTEGatewaysApi
     */
    public lteNetworkIdGatewaysGatewayIdNameGet(requestParameters: LTEGatewaysApiLteNetworkIdGatewaysGatewayIdNameGetRequest, options?: AxiosRequestConfig) {
        return LTEGatewaysApiFp(this.configuration).lteNetworkIdGatewaysGatewayIdNameGet(requestParameters.networkId, requestParameters.gatewayId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the name of an LTE gateway
     * @param {LTEGatewaysApiLteNetworkIdGatewaysGatewayIdNamePutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LTEGatewaysApi
     */
    public lteNetworkIdGatewaysGatewayIdNamePut(requestParameters: LTEGatewaysApiLteNetworkIdGatewaysGatewayIdNamePutRequest, options?: AxiosRequestConfig) {
        return LTEGatewaysApiFp(this.configuration).lteNetworkIdGatewaysGatewayIdNamePut(requestParameters.networkId, requestParameters.gatewayId, requestParameters.name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an entire LTE gateway record
     * @param {LTEGatewaysApiLteNetworkIdGatewaysGatewayIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LTEGatewaysApi
     */
    public lteNetworkIdGatewaysGatewayIdPut(requestParameters: LTEGatewaysApiLteNetworkIdGatewaysGatewayIdPutRequest, options?: AxiosRequestConfig) {
        return LTEGatewaysApiFp(this.configuration).lteNetworkIdGatewaysGatewayIdPut(requestParameters.networkId, requestParameters.gatewayId, requestParameters.gateway, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the status of a gateway
     * @param {LTEGatewaysApiLteNetworkIdGatewaysGatewayIdStatusGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LTEGatewaysApi
     */
    public lteNetworkIdGatewaysGatewayIdStatusGet(requestParameters: LTEGatewaysApiLteNetworkIdGatewaysGatewayIdStatusGetRequest, options?: AxiosRequestConfig) {
        return LTEGatewaysApiFp(this.configuration).lteNetworkIdGatewaysGatewayIdStatusGet(requestParameters.networkId, requestParameters.gatewayId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the ID of the upgrade tier a gateway belongs to
     * @param {LTEGatewaysApiLteNetworkIdGatewaysGatewayIdTierGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LTEGatewaysApi
     */
    public lteNetworkIdGatewaysGatewayIdTierGet(requestParameters: LTEGatewaysApiLteNetworkIdGatewaysGatewayIdTierGetRequest, options?: AxiosRequestConfig) {
        return LTEGatewaysApiFp(this.configuration).lteNetworkIdGatewaysGatewayIdTierGet(requestParameters.networkId, requestParameters.gatewayId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the ID of the upgrade tier a gateway belongs to
     * @param {LTEGatewaysApiLteNetworkIdGatewaysGatewayIdTierPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LTEGatewaysApi
     */
    public lteNetworkIdGatewaysGatewayIdTierPut(requestParameters: LTEGatewaysApiLteNetworkIdGatewaysGatewayIdTierPutRequest, options?: AxiosRequestConfig) {
        return LTEGatewaysApiFp(this.configuration).lteNetworkIdGatewaysGatewayIdTierPut(requestParameters.networkId, requestParameters.gatewayId, requestParameters.tierId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the gateway VPN configuration
     * @param {LTEGatewaysApiLteNetworkIdGatewaysGatewayIdVpnGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LTEGatewaysApi
     */
    public lteNetworkIdGatewaysGatewayIdVpnGet(requestParameters: LTEGatewaysApiLteNetworkIdGatewaysGatewayIdVpnGetRequest, options?: AxiosRequestConfig) {
        return LTEGatewaysApiFp(this.configuration).lteNetworkIdGatewaysGatewayIdVpnGet(requestParameters.networkId, requestParameters.gatewayId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the gateway VPN configuration
     * @param {LTEGatewaysApiLteNetworkIdGatewaysGatewayIdVpnPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LTEGatewaysApi
     */
    public lteNetworkIdGatewaysGatewayIdVpnPut(requestParameters: LTEGatewaysApiLteNetworkIdGatewaysGatewayIdVpnPutRequest, options?: AxiosRequestConfig) {
        return LTEGatewaysApiFp(this.configuration).lteNetworkIdGatewaysGatewayIdVpnPut(requestParameters.networkId, requestParameters.gatewayId, requestParameters.config, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all gateways for an LTE network
     * @param {LTEGatewaysApiLteNetworkIdGatewaysGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LTEGatewaysApi
     */
    public lteNetworkIdGatewaysGet(requestParameters: LTEGatewaysApiLteNetworkIdGatewaysGetRequest, options?: AxiosRequestConfig) {
        return LTEGatewaysApiFp(this.configuration).lteNetworkIdGatewaysGet(requestParameters.networkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Register a new LTE gateway
     * @param {LTEGatewaysApiLteNetworkIdGatewaysPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LTEGatewaysApi
     */
    public lteNetworkIdGatewaysPost(requestParameters: LTEGatewaysApiLteNetworkIdGatewaysPostRequest, options?: AxiosRequestConfig) {
        return LTEGatewaysApiFp(this.configuration).lteNetworkIdGatewaysPost(requestParameters.networkId, requestParameters.gateway, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * LTENetworksApi - axios parameter creator
 * @export
 */
export const LTENetworksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List all LTE network IDs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/lte`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get EPC configuration of LTE network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdCellularEpcGet: async (networkId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdCellularEpcGet', 'networkId', networkId)
            const localVarPath = `/lte/{network_id}/cellular/epc`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update EPC configuration of LTE network
         * @param {string} networkId Network ID
         * @param {NetworkEpcConfigs} config New EPC configuration for the network
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdCellularEpcPut: async (networkId: string, config: NetworkEpcConfigs, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdCellularEpcPut', 'networkId', networkId)
            // verify required parameter 'config' is not null or undefined
            assertParamExists('lteNetworkIdCellularEpcPut', 'config', config)
            const localVarPath = `/lte/{network_id}/cellular/epc`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(config, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Federation Gateway network ID for the network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdCellularFegNetworkIdGet: async (networkId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdCellularFegNetworkIdGet', 'networkId', networkId)
            const localVarPath = `/lte/{network_id}/cellular/feg_network_id`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the Federation Gateway network ID
         * @param {string} networkId Network ID
         * @param {string} fegNetworkId Desired federation gateway network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdCellularFegNetworkIdPut: async (networkId: string, fegNetworkId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdCellularFegNetworkIdPut', 'networkId', networkId)
            // verify required parameter 'fegNetworkId' is not null or undefined
            assertParamExists('lteNetworkIdCellularFegNetworkIdPut', 'fegNetworkId', fegNetworkId)
            const localVarPath = `/lte/{network_id}/cellular/feg_network_id`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(fegNetworkId, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get cellular configuration of LTE network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdCellularGet: async (networkId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdCellularGet', 'networkId', networkId)
            const localVarPath = `/lte/{network_id}/cellular`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get NGC configuration of LTE Network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdCellularNgcGet: async (networkId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdCellularNgcGet', 'networkId', networkId)
            const localVarPath = `/lte/{network_id}/cellular/ngc`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update NGC configuration of LTE network
         * @param {string} networkId Network ID
         * @param {NetworkNgcConfigs} config New NGC configuration for the network
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdCellularNgcPut: async (networkId: string, config: NetworkNgcConfigs, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdCellularNgcPut', 'networkId', networkId)
            // verify required parameter 'config' is not null or undefined
            assertParamExists('lteNetworkIdCellularNgcPut', 'config', config)
            const localVarPath = `/lte/{network_id}/cellular/ngc`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(config, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update cellular configuration of LTE network
         * @param {string} networkId Network ID
         * @param {NetworkCellularConfigs} config New cellular configuration for the network
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdCellularPut: async (networkId: string, config: NetworkCellularConfigs, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdCellularPut', 'networkId', networkId)
            // verify required parameter 'config' is not null or undefined
            assertParamExists('lteNetworkIdCellularPut', 'config', config)
            const localVarPath = `/lte/{network_id}/cellular`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(config, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get RAN configuration of LTE network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdCellularRanGet: async (networkId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdCellularRanGet', 'networkId', networkId)
            const localVarPath = `/lte/{network_id}/cellular/ran`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update RAN configuration of LTE network
         * @param {string} networkId Network ID
         * @param {NetworkRanConfigs} config New RAN configuration for the network
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdCellularRanPut: async (networkId: string, config: NetworkRanConfigs, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdCellularRanPut', 'networkId', networkId)
            // verify required parameter 'config' is not null or undefined
            assertParamExists('lteNetworkIdCellularRanPut', 'config', config)
            const localVarPath = `/lte/{network_id}/cellular/ran`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(config, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete an LTE network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdDelete: async (networkId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdDelete', 'networkId', networkId)
            const localVarPath = `/lte/{network_id}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get description of an LTE network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdDescriptionGet: async (networkId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdDescriptionGet', 'networkId', networkId)
            const localVarPath = `/lte/{network_id}/description`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the description of an LTE network
         * @param {string} networkId Network ID
         * @param {string} description New name for the network
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdDescriptionPut: async (networkId: string, description: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdDescriptionPut', 'networkId', networkId)
            // verify required parameter 'description' is not null or undefined
            assertParamExists('lteNetworkIdDescriptionPut', 'description', description)
            const localVarPath = `/lte/{network_id}/description`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(description, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get DNS configuration of LTE network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdDnsGet: async (networkId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdDnsGet', 'networkId', networkId)
            const localVarPath = `/lte/{network_id}/dns`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update DNS configuration of LTE network
         * @param {string} networkId Network ID
         * @param {NetworkDnsConfig} config New DNS configuration for the network
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdDnsPut: async (networkId: string, config: NetworkDnsConfig, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdDnsPut', 'networkId', networkId)
            // verify required parameter 'config' is not null or undefined
            assertParamExists('lteNetworkIdDnsPut', 'config', config)
            const localVarPath = `/lte/{network_id}/dns`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(config, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete the DNS record for a specific domain
         * @param {string} networkId Network ID
         * @param {string} domain DNS record domain
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdDnsRecordsDomainDelete: async (networkId: string, domain: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdDnsRecordsDomainDelete', 'networkId', networkId)
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('lteNetworkIdDnsRecordsDomainDelete', 'domain', domain)
            const localVarPath = `/lte/{network_id}/dns/records/{domain}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the DNS config record for a specific domain
         * @param {string} networkId Network ID
         * @param {string} domain DNS record domain
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdDnsRecordsDomainGet: async (networkId: string, domain: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdDnsRecordsDomainGet', 'networkId', networkId)
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('lteNetworkIdDnsRecordsDomainGet', 'domain', domain)
            const localVarPath = `/lte/{network_id}/dns/records/{domain}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a DNS record for a specific domain
         * @param {string} networkId Network ID
         * @param {string} domain DNS record domain
         * @param {DnsConfigRecord} record Custom DNS record for the domain
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdDnsRecordsDomainPost: async (networkId: string, domain: string, record: DnsConfigRecord, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdDnsRecordsDomainPost', 'networkId', networkId)
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('lteNetworkIdDnsRecordsDomainPost', 'domain', domain)
            // verify required parameter 'record' is not null or undefined
            assertParamExists('lteNetworkIdDnsRecordsDomainPost', 'record', record)
            const localVarPath = `/lte/{network_id}/dns/records/{domain}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(record, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a DNS record for a specific domain
         * @param {string} networkId Network ID
         * @param {string} domain DNS record domain
         * @param {DnsConfigRecord} record Custom DNS record for the domain
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdDnsRecordsDomainPut: async (networkId: string, domain: string, record: DnsConfigRecord, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdDnsRecordsDomainPut', 'networkId', networkId)
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('lteNetworkIdDnsRecordsDomainPut', 'domain', domain)
            // verify required parameter 'record' is not null or undefined
            assertParamExists('lteNetworkIdDnsRecordsDomainPut', 'record', record)
            const localVarPath = `/lte/{network_id}/dns/records/{domain}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(record, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the DNS config records for the LTE network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdDnsRecordsGet: async (networkId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdDnsRecordsGet', 'networkId', networkId)
            const localVarPath = `/lte/{network_id}/dns/records`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Change all the DNS records for the LTE network
         * @param {string} networkId Network ID
         * @param {Array<DnsConfigRecord>} records Custom DNS records for the network
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdDnsRecordsPut: async (networkId: string, records: Array<DnsConfigRecord>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdDnsRecordsPut', 'networkId', networkId)
            // verify required parameter 'records' is not null or undefined
            assertParamExists('lteNetworkIdDnsRecordsPut', 'records', records)
            const localVarPath = `/lte/{network_id}/dns/records`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(records, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get feature flags for LTE network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdFeaturesGet: async (networkId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdFeaturesGet', 'networkId', networkId)
            const localVarPath = `/lte/{network_id}/features`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update feature flags for LTE network
         * @param {string} networkId Network ID
         * @param {NetworkFeatures} config New feature flags for the network
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdFeaturesPut: async (networkId: string, config: NetworkFeatures, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdFeaturesPut', 'networkId', networkId)
            // verify required parameter 'config' is not null or undefined
            assertParamExists('lteNetworkIdFeaturesPut', 'config', config)
            const localVarPath = `/lte/{network_id}/features`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(config, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete gateway pool from LTE network
         * @param {string} networkId Network ID
         * @param {string} gatewayPoolId Gateway Pool ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdGatewayPoolsGatewayPoolIdDelete: async (networkId: string, gatewayPoolId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdGatewayPoolsGatewayPoolIdDelete', 'networkId', networkId)
            // verify required parameter 'gatewayPoolId' is not null or undefined
            assertParamExists('lteNetworkIdGatewayPoolsGatewayPoolIdDelete', 'gatewayPoolId', gatewayPoolId)
            const localVarPath = `/lte/{network_id}/gateway_pools/{gateway_pool_id}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"gateway_pool_id"}}`, encodeURIComponent(String(gatewayPoolId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve gateway pool from LTE network
         * @param {string} networkId Network ID
         * @param {string} gatewayPoolId Gateway Pool ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdGatewayPoolsGatewayPoolIdGet: async (networkId: string, gatewayPoolId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdGatewayPoolsGatewayPoolIdGet', 'networkId', networkId)
            // verify required parameter 'gatewayPoolId' is not null or undefined
            assertParamExists('lteNetworkIdGatewayPoolsGatewayPoolIdGet', 'gatewayPoolId', gatewayPoolId)
            const localVarPath = `/lte/{network_id}/gateway_pools/{gateway_pool_id}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"gateway_pool_id"}}`, encodeURIComponent(String(gatewayPoolId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update gateway pool in LTE network
         * @param {string} networkId Network ID
         * @param {string} gatewayPoolId Gateway Pool ID
         * @param {MutableCellularGatewayPool} hAGatewayPool LTE HA gateway pool
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdGatewayPoolsGatewayPoolIdPut: async (networkId: string, gatewayPoolId: string, hAGatewayPool: MutableCellularGatewayPool, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdGatewayPoolsGatewayPoolIdPut', 'networkId', networkId)
            // verify required parameter 'gatewayPoolId' is not null or undefined
            assertParamExists('lteNetworkIdGatewayPoolsGatewayPoolIdPut', 'gatewayPoolId', gatewayPoolId)
            // verify required parameter 'hAGatewayPool' is not null or undefined
            assertParamExists('lteNetworkIdGatewayPoolsGatewayPoolIdPut', 'hAGatewayPool', hAGatewayPool)
            const localVarPath = `/lte/{network_id}/gateway_pools/{gateway_pool_id}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"gateway_pool_id"}}`, encodeURIComponent(String(gatewayPoolId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(hAGatewayPool, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all gateway pools in LTE network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdGatewayPoolsGet: async (networkId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdGatewayPoolsGet', 'networkId', networkId)
            const localVarPath = `/lte/{network_id}/gateway_pools`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create new gateway pool in LTE network
         * @param {string} networkId Network ID
         * @param {MutableCellularGatewayPool} hAGatewayPool LTE HA gateway pool
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdGatewayPoolsPost: async (networkId: string, hAGatewayPool: MutableCellularGatewayPool, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdGatewayPoolsPost', 'networkId', networkId)
            // verify required parameter 'hAGatewayPool' is not null or undefined
            assertParamExists('lteNetworkIdGatewayPoolsPost', 'hAGatewayPool', hAGatewayPool)
            const localVarPath = `/lte/{network_id}/gateway_pools`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(hAGatewayPool, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Describe an LTE network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdGet: async (networkId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdGet', 'networkId', networkId)
            const localVarPath = `/lte/{network_id}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get name of an LTE network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdNameGet: async (networkId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdNameGet', 'networkId', networkId)
            const localVarPath = `/lte/{network_id}/name`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the name of an LTE network
         * @param {string} networkId Network ID
         * @param {string} name New name for the network
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdNamePut: async (networkId: string, name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdNamePut', 'networkId', networkId)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('lteNetworkIdNamePut', 'name', name)
            const localVarPath = `/lte/{network_id}/name`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(name, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an entire LTE network
         * @param {string} networkId Network ID
         * @param {LteNetwork} lteNetwork Full desired configuration of the network
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdPut: async (networkId: string, lteNetwork: LteNetwork, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdPut', 'networkId', networkId)
            // verify required parameter 'lteNetwork' is not null or undefined
            assertParamExists('lteNetworkIdPut', 'lteNetwork', lteNetwork)
            const localVarPath = `/lte/{network_id}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(lteNetwork, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add a network-wide base name
         * @param {string} networkId Network ID
         * @param {string} baseName Charging Rule Base Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdSubscriberConfigBaseNamesBaseNameDelete: async (networkId: string, baseName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdSubscriberConfigBaseNamesBaseNameDelete', 'networkId', networkId)
            // verify required parameter 'baseName' is not null or undefined
            assertParamExists('lteNetworkIdSubscriberConfigBaseNamesBaseNameDelete', 'baseName', baseName)
            const localVarPath = `/lte/{network_id}/subscriber_config/base_names/{base_name}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"base_name"}}`, encodeURIComponent(String(baseName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add a network-wide base name
         * @param {string} networkId Network ID
         * @param {string} baseName Charging Rule Base Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdSubscriberConfigBaseNamesBaseNamePost: async (networkId: string, baseName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdSubscriberConfigBaseNamesBaseNamePost', 'networkId', networkId)
            // verify required parameter 'baseName' is not null or undefined
            assertParamExists('lteNetworkIdSubscriberConfigBaseNamesBaseNamePost', 'baseName', baseName)
            const localVarPath = `/lte/{network_id}/subscriber_config/base_names/{base_name}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"base_name"}}`, encodeURIComponent(String(baseName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get network-wide base names
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdSubscriberConfigBaseNamesGet: async (networkId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdSubscriberConfigBaseNamesGet', 'networkId', networkId)
            const localVarPath = `/lte/{network_id}/subscriber_config/base_names`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update network-wide base names
         * @param {string} networkId Network ID
         * @param {Array<string>} record Subscriber Config for the Network
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdSubscriberConfigBaseNamesPut: async (networkId: string, record: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdSubscriberConfigBaseNamesPut', 'networkId', networkId)
            // verify required parameter 'record' is not null or undefined
            assertParamExists('lteNetworkIdSubscriberConfigBaseNamesPut', 'record', record)
            const localVarPath = `/lte/{network_id}/subscriber_config/base_names`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(record, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a network-wide subscriber config
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdSubscriberConfigGet: async (networkId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdSubscriberConfigGet', 'networkId', networkId)
            const localVarPath = `/lte/{network_id}/subscriber_config`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a network-wide subscriber config
         * @param {string} networkId Network ID
         * @param {NetworkSubscriberConfig} record Subscriber Config for the Network
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdSubscriberConfigPut: async (networkId: string, record: NetworkSubscriberConfig, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdSubscriberConfigPut', 'networkId', networkId)
            // verify required parameter 'record' is not null or undefined
            assertParamExists('lteNetworkIdSubscriberConfigPut', 'record', record)
            const localVarPath = `/lte/{network_id}/subscriber_config`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(record, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get network-wide rule names
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdSubscriberConfigRuleNamesGet: async (networkId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdSubscriberConfigRuleNamesGet', 'networkId', networkId)
            const localVarPath = `/lte/{network_id}/subscriber_config/rule_names`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update network-wide rule names
         * @param {string} networkId Network ID
         * @param {Array<string>} record Subscriber Config for the Network
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdSubscriberConfigRuleNamesPut: async (networkId: string, record: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdSubscriberConfigRuleNamesPut', 'networkId', networkId)
            // verify required parameter 'record' is not null or undefined
            assertParamExists('lteNetworkIdSubscriberConfigRuleNamesPut', 'record', record)
            const localVarPath = `/lte/{network_id}/subscriber_config/rule_names`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(record, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add a network-wide rule name
         * @param {string} networkId Network ID
         * @param {string} ruleId Rule Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdSubscriberConfigRuleNamesRuleIdDelete: async (networkId: string, ruleId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdSubscriberConfigRuleNamesRuleIdDelete', 'networkId', networkId)
            // verify required parameter 'ruleId' is not null or undefined
            assertParamExists('lteNetworkIdSubscriberConfigRuleNamesRuleIdDelete', 'ruleId', ruleId)
            const localVarPath = `/lte/{network_id}/subscriber_config/rule_names/{rule_id}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"rule_id"}}`, encodeURIComponent(String(ruleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add a network-wide rule name
         * @param {string} networkId Network ID
         * @param {string} ruleId Rule Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdSubscriberConfigRuleNamesRuleIdPost: async (networkId: string, ruleId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdSubscriberConfigRuleNamesRuleIdPost', 'networkId', networkId)
            // verify required parameter 'ruleId' is not null or undefined
            assertParamExists('lteNetworkIdSubscriberConfigRuleNamesRuleIdPost', 'ruleId', ruleId)
            const localVarPath = `/lte/{network_id}/subscriber_config/rule_names/{rule_id}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"rule_id"}}`, encodeURIComponent(String(ruleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new LTE network
         * @param {LteNetwork} lteNetwork Configuration of the network to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ltePost: async (lteNetwork: LteNetwork, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'lteNetwork' is not null or undefined
            assertParamExists('ltePost', 'lteNetwork', lteNetwork)
            const localVarPath = `/lte`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(lteNetwork, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LTENetworksApi - functional programming interface
 * @export
 */
export const LTENetworksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LTENetworksApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List all LTE network IDs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get EPC configuration of LTE network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdCellularEpcGet(networkId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NetworkEpcConfigs>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdCellularEpcGet(networkId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update EPC configuration of LTE network
         * @param {string} networkId Network ID
         * @param {NetworkEpcConfigs} config New EPC configuration for the network
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdCellularEpcPut(networkId: string, config: NetworkEpcConfigs, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdCellularEpcPut(networkId, config, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Federation Gateway network ID for the network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdCellularFegNetworkIdGet(networkId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdCellularFegNetworkIdGet(networkId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update the Federation Gateway network ID
         * @param {string} networkId Network ID
         * @param {string} fegNetworkId Desired federation gateway network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdCellularFegNetworkIdPut(networkId: string, fegNetworkId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdCellularFegNetworkIdPut(networkId, fegNetworkId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get cellular configuration of LTE network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdCellularGet(networkId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NetworkCellularConfigs>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdCellularGet(networkId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get NGC configuration of LTE Network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdCellularNgcGet(networkId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NetworkNgcConfigs>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdCellularNgcGet(networkId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update NGC configuration of LTE network
         * @param {string} networkId Network ID
         * @param {NetworkNgcConfigs} config New NGC configuration for the network
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdCellularNgcPut(networkId: string, config: NetworkNgcConfigs, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdCellularNgcPut(networkId, config, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update cellular configuration of LTE network
         * @param {string} networkId Network ID
         * @param {NetworkCellularConfigs} config New cellular configuration for the network
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdCellularPut(networkId: string, config: NetworkCellularConfigs, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdCellularPut(networkId, config, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get RAN configuration of LTE network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdCellularRanGet(networkId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NetworkRanConfigs>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdCellularRanGet(networkId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update RAN configuration of LTE network
         * @param {string} networkId Network ID
         * @param {NetworkRanConfigs} config New RAN configuration for the network
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdCellularRanPut(networkId: string, config: NetworkRanConfigs, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdCellularRanPut(networkId, config, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete an LTE network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdDelete(networkId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdDelete(networkId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get description of an LTE network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdDescriptionGet(networkId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdDescriptionGet(networkId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update the description of an LTE network
         * @param {string} networkId Network ID
         * @param {string} description New name for the network
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdDescriptionPut(networkId: string, description: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdDescriptionPut(networkId, description, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get DNS configuration of LTE network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdDnsGet(networkId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NetworkDnsConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdDnsGet(networkId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update DNS configuration of LTE network
         * @param {string} networkId Network ID
         * @param {NetworkDnsConfig} config New DNS configuration for the network
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdDnsPut(networkId: string, config: NetworkDnsConfig, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdDnsPut(networkId, config, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete the DNS record for a specific domain
         * @param {string} networkId Network ID
         * @param {string} domain DNS record domain
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdDnsRecordsDomainDelete(networkId: string, domain: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdDnsRecordsDomainDelete(networkId, domain, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the DNS config record for a specific domain
         * @param {string} networkId Network ID
         * @param {string} domain DNS record domain
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdDnsRecordsDomainGet(networkId: string, domain: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DnsConfigRecord>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdDnsRecordsDomainGet(networkId, domain, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a DNS record for a specific domain
         * @param {string} networkId Network ID
         * @param {string} domain DNS record domain
         * @param {DnsConfigRecord} record Custom DNS record for the domain
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdDnsRecordsDomainPost(networkId: string, domain: string, record: DnsConfigRecord, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdDnsRecordsDomainPost(networkId, domain, record, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a DNS record for a specific domain
         * @param {string} networkId Network ID
         * @param {string} domain DNS record domain
         * @param {DnsConfigRecord} record Custom DNS record for the domain
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdDnsRecordsDomainPut(networkId: string, domain: string, record: DnsConfigRecord, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdDnsRecordsDomainPut(networkId, domain, record, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the DNS config records for the LTE network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdDnsRecordsGet(networkId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DnsConfigRecord>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdDnsRecordsGet(networkId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Change all the DNS records for the LTE network
         * @param {string} networkId Network ID
         * @param {Array<DnsConfigRecord>} records Custom DNS records for the network
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdDnsRecordsPut(networkId: string, records: Array<DnsConfigRecord>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdDnsRecordsPut(networkId, records, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get feature flags for LTE network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdFeaturesGet(networkId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NetworkFeatures>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdFeaturesGet(networkId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update feature flags for LTE network
         * @param {string} networkId Network ID
         * @param {NetworkFeatures} config New feature flags for the network
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdFeaturesPut(networkId: string, config: NetworkFeatures, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdFeaturesPut(networkId, config, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete gateway pool from LTE network
         * @param {string} networkId Network ID
         * @param {string} gatewayPoolId Gateway Pool ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdGatewayPoolsGatewayPoolIdDelete(networkId: string, gatewayPoolId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdGatewayPoolsGatewayPoolIdDelete(networkId, gatewayPoolId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve gateway pool from LTE network
         * @param {string} networkId Network ID
         * @param {string} gatewayPoolId Gateway Pool ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdGatewayPoolsGatewayPoolIdGet(networkId: string, gatewayPoolId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CellularGatewayPool>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdGatewayPoolsGatewayPoolIdGet(networkId, gatewayPoolId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update gateway pool in LTE network
         * @param {string} networkId Network ID
         * @param {string} gatewayPoolId Gateway Pool ID
         * @param {MutableCellularGatewayPool} hAGatewayPool LTE HA gateway pool
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdGatewayPoolsGatewayPoolIdPut(networkId: string, gatewayPoolId: string, hAGatewayPool: MutableCellularGatewayPool, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdGatewayPoolsGatewayPoolIdPut(networkId, gatewayPoolId, hAGatewayPool, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all gateway pools in LTE network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdGatewayPoolsGet(networkId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: CellularGatewayPool; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdGatewayPoolsGet(networkId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create new gateway pool in LTE network
         * @param {string} networkId Network ID
         * @param {MutableCellularGatewayPool} hAGatewayPool LTE HA gateway pool
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdGatewayPoolsPost(networkId: string, hAGatewayPool: MutableCellularGatewayPool, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdGatewayPoolsPost(networkId, hAGatewayPool, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Describe an LTE network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdGet(networkId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LteNetwork>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdGet(networkId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get name of an LTE network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdNameGet(networkId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdNameGet(networkId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update the name of an LTE network
         * @param {string} networkId Network ID
         * @param {string} name New name for the network
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdNamePut(networkId: string, name: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdNamePut(networkId, name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update an entire LTE network
         * @param {string} networkId Network ID
         * @param {LteNetwork} lteNetwork Full desired configuration of the network
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdPut(networkId: string, lteNetwork: LteNetwork, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdPut(networkId, lteNetwork, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add a network-wide base name
         * @param {string} networkId Network ID
         * @param {string} baseName Charging Rule Base Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdSubscriberConfigBaseNamesBaseNameDelete(networkId: string, baseName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdSubscriberConfigBaseNamesBaseNameDelete(networkId, baseName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add a network-wide base name
         * @param {string} networkId Network ID
         * @param {string} baseName Charging Rule Base Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdSubscriberConfigBaseNamesBaseNamePost(networkId: string, baseName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdSubscriberConfigBaseNamesBaseNamePost(networkId, baseName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get network-wide base names
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdSubscriberConfigBaseNamesGet(networkId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdSubscriberConfigBaseNamesGet(networkId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update network-wide base names
         * @param {string} networkId Network ID
         * @param {Array<string>} record Subscriber Config for the Network
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdSubscriberConfigBaseNamesPut(networkId: string, record: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdSubscriberConfigBaseNamesPut(networkId, record, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a network-wide subscriber config
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdSubscriberConfigGet(networkId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NetworkSubscriberConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdSubscriberConfigGet(networkId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a network-wide subscriber config
         * @param {string} networkId Network ID
         * @param {NetworkSubscriberConfig} record Subscriber Config for the Network
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdSubscriberConfigPut(networkId: string, record: NetworkSubscriberConfig, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdSubscriberConfigPut(networkId, record, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get network-wide rule names
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdSubscriberConfigRuleNamesGet(networkId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdSubscriberConfigRuleNamesGet(networkId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update network-wide rule names
         * @param {string} networkId Network ID
         * @param {Array<string>} record Subscriber Config for the Network
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdSubscriberConfigRuleNamesPut(networkId: string, record: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdSubscriberConfigRuleNamesPut(networkId, record, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add a network-wide rule name
         * @param {string} networkId Network ID
         * @param {string} ruleId Rule Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdSubscriberConfigRuleNamesRuleIdDelete(networkId: string, ruleId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdSubscriberConfigRuleNamesRuleIdDelete(networkId, ruleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add a network-wide rule name
         * @param {string} networkId Network ID
         * @param {string} ruleId Rule Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdSubscriberConfigRuleNamesRuleIdPost(networkId: string, ruleId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdSubscriberConfigRuleNamesRuleIdPost(networkId, ruleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a new LTE network
         * @param {LteNetwork} lteNetwork Configuration of the network to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ltePost(lteNetwork: LteNetwork, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ltePost(lteNetwork, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * LTENetworksApi - factory interface
 * @export
 */
export const LTENetworksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LTENetworksApiFp(configuration)
    return {
        /**
         * 
         * @summary List all LTE network IDs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteGet(options?: any): AxiosPromise<Array<string>> {
            return localVarFp.lteGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get EPC configuration of LTE network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdCellularEpcGet(networkId: string, options?: any): AxiosPromise<NetworkEpcConfigs> {
            return localVarFp.lteNetworkIdCellularEpcGet(networkId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update EPC configuration of LTE network
         * @param {string} networkId Network ID
         * @param {NetworkEpcConfigs} config New EPC configuration for the network
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdCellularEpcPut(networkId: string, config: NetworkEpcConfigs, options?: any): AxiosPromise<void> {
            return localVarFp.lteNetworkIdCellularEpcPut(networkId, config, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Federation Gateway network ID for the network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdCellularFegNetworkIdGet(networkId: string, options?: any): AxiosPromise<string> {
            return localVarFp.lteNetworkIdCellularFegNetworkIdGet(networkId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the Federation Gateway network ID
         * @param {string} networkId Network ID
         * @param {string} fegNetworkId Desired federation gateway network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdCellularFegNetworkIdPut(networkId: string, fegNetworkId: string, options?: any): AxiosPromise<void> {
            return localVarFp.lteNetworkIdCellularFegNetworkIdPut(networkId, fegNetworkId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get cellular configuration of LTE network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdCellularGet(networkId: string, options?: any): AxiosPromise<NetworkCellularConfigs> {
            return localVarFp.lteNetworkIdCellularGet(networkId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get NGC configuration of LTE Network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdCellularNgcGet(networkId: string, options?: any): AxiosPromise<NetworkNgcConfigs> {
            return localVarFp.lteNetworkIdCellularNgcGet(networkId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update NGC configuration of LTE network
         * @param {string} networkId Network ID
         * @param {NetworkNgcConfigs} config New NGC configuration for the network
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdCellularNgcPut(networkId: string, config: NetworkNgcConfigs, options?: any): AxiosPromise<void> {
            return localVarFp.lteNetworkIdCellularNgcPut(networkId, config, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update cellular configuration of LTE network
         * @param {string} networkId Network ID
         * @param {NetworkCellularConfigs} config New cellular configuration for the network
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdCellularPut(networkId: string, config: NetworkCellularConfigs, options?: any): AxiosPromise<void> {
            return localVarFp.lteNetworkIdCellularPut(networkId, config, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get RAN configuration of LTE network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdCellularRanGet(networkId: string, options?: any): AxiosPromise<NetworkRanConfigs> {
            return localVarFp.lteNetworkIdCellularRanGet(networkId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update RAN configuration of LTE network
         * @param {string} networkId Network ID
         * @param {NetworkRanConfigs} config New RAN configuration for the network
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdCellularRanPut(networkId: string, config: NetworkRanConfigs, options?: any): AxiosPromise<void> {
            return localVarFp.lteNetworkIdCellularRanPut(networkId, config, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete an LTE network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdDelete(networkId: string, options?: any): AxiosPromise<void> {
            return localVarFp.lteNetworkIdDelete(networkId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get description of an LTE network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdDescriptionGet(networkId: string, options?: any): AxiosPromise<string> {
            return localVarFp.lteNetworkIdDescriptionGet(networkId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the description of an LTE network
         * @param {string} networkId Network ID
         * @param {string} description New name for the network
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdDescriptionPut(networkId: string, description: string, options?: any): AxiosPromise<void> {
            return localVarFp.lteNetworkIdDescriptionPut(networkId, description, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get DNS configuration of LTE network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdDnsGet(networkId: string, options?: any): AxiosPromise<NetworkDnsConfig> {
            return localVarFp.lteNetworkIdDnsGet(networkId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update DNS configuration of LTE network
         * @param {string} networkId Network ID
         * @param {NetworkDnsConfig} config New DNS configuration for the network
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdDnsPut(networkId: string, config: NetworkDnsConfig, options?: any): AxiosPromise<void> {
            return localVarFp.lteNetworkIdDnsPut(networkId, config, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete the DNS record for a specific domain
         * @param {string} networkId Network ID
         * @param {string} domain DNS record domain
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdDnsRecordsDomainDelete(networkId: string, domain: string, options?: any): AxiosPromise<void> {
            return localVarFp.lteNetworkIdDnsRecordsDomainDelete(networkId, domain, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the DNS config record for a specific domain
         * @param {string} networkId Network ID
         * @param {string} domain DNS record domain
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdDnsRecordsDomainGet(networkId: string, domain: string, options?: any): AxiosPromise<DnsConfigRecord> {
            return localVarFp.lteNetworkIdDnsRecordsDomainGet(networkId, domain, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a DNS record for a specific domain
         * @param {string} networkId Network ID
         * @param {string} domain DNS record domain
         * @param {DnsConfigRecord} record Custom DNS record for the domain
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdDnsRecordsDomainPost(networkId: string, domain: string, record: DnsConfigRecord, options?: any): AxiosPromise<void> {
            return localVarFp.lteNetworkIdDnsRecordsDomainPost(networkId, domain, record, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a DNS record for a specific domain
         * @param {string} networkId Network ID
         * @param {string} domain DNS record domain
         * @param {DnsConfigRecord} record Custom DNS record for the domain
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdDnsRecordsDomainPut(networkId: string, domain: string, record: DnsConfigRecord, options?: any): AxiosPromise<void> {
            return localVarFp.lteNetworkIdDnsRecordsDomainPut(networkId, domain, record, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the DNS config records for the LTE network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdDnsRecordsGet(networkId: string, options?: any): AxiosPromise<Array<DnsConfigRecord>> {
            return localVarFp.lteNetworkIdDnsRecordsGet(networkId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Change all the DNS records for the LTE network
         * @param {string} networkId Network ID
         * @param {Array<DnsConfigRecord>} records Custom DNS records for the network
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdDnsRecordsPut(networkId: string, records: Array<DnsConfigRecord>, options?: any): AxiosPromise<void> {
            return localVarFp.lteNetworkIdDnsRecordsPut(networkId, records, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get feature flags for LTE network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdFeaturesGet(networkId: string, options?: any): AxiosPromise<NetworkFeatures> {
            return localVarFp.lteNetworkIdFeaturesGet(networkId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update feature flags for LTE network
         * @param {string} networkId Network ID
         * @param {NetworkFeatures} config New feature flags for the network
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdFeaturesPut(networkId: string, config: NetworkFeatures, options?: any): AxiosPromise<void> {
            return localVarFp.lteNetworkIdFeaturesPut(networkId, config, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete gateway pool from LTE network
         * @param {string} networkId Network ID
         * @param {string} gatewayPoolId Gateway Pool ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdGatewayPoolsGatewayPoolIdDelete(networkId: string, gatewayPoolId: string, options?: any): AxiosPromise<void> {
            return localVarFp.lteNetworkIdGatewayPoolsGatewayPoolIdDelete(networkId, gatewayPoolId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve gateway pool from LTE network
         * @param {string} networkId Network ID
         * @param {string} gatewayPoolId Gateway Pool ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdGatewayPoolsGatewayPoolIdGet(networkId: string, gatewayPoolId: string, options?: any): AxiosPromise<CellularGatewayPool> {
            return localVarFp.lteNetworkIdGatewayPoolsGatewayPoolIdGet(networkId, gatewayPoolId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update gateway pool in LTE network
         * @param {string} networkId Network ID
         * @param {string} gatewayPoolId Gateway Pool ID
         * @param {MutableCellularGatewayPool} hAGatewayPool LTE HA gateway pool
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdGatewayPoolsGatewayPoolIdPut(networkId: string, gatewayPoolId: string, hAGatewayPool: MutableCellularGatewayPool, options?: any): AxiosPromise<void> {
            return localVarFp.lteNetworkIdGatewayPoolsGatewayPoolIdPut(networkId, gatewayPoolId, hAGatewayPool, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all gateway pools in LTE network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdGatewayPoolsGet(networkId: string, options?: any): AxiosPromise<{ [key: string]: CellularGatewayPool; }> {
            return localVarFp.lteNetworkIdGatewayPoolsGet(networkId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create new gateway pool in LTE network
         * @param {string} networkId Network ID
         * @param {MutableCellularGatewayPool} hAGatewayPool LTE HA gateway pool
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdGatewayPoolsPost(networkId: string, hAGatewayPool: MutableCellularGatewayPool, options?: any): AxiosPromise<void> {
            return localVarFp.lteNetworkIdGatewayPoolsPost(networkId, hAGatewayPool, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Describe an LTE network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdGet(networkId: string, options?: any): AxiosPromise<LteNetwork> {
            return localVarFp.lteNetworkIdGet(networkId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get name of an LTE network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdNameGet(networkId: string, options?: any): AxiosPromise<string> {
            return localVarFp.lteNetworkIdNameGet(networkId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the name of an LTE network
         * @param {string} networkId Network ID
         * @param {string} name New name for the network
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdNamePut(networkId: string, name: string, options?: any): AxiosPromise<void> {
            return localVarFp.lteNetworkIdNamePut(networkId, name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an entire LTE network
         * @param {string} networkId Network ID
         * @param {LteNetwork} lteNetwork Full desired configuration of the network
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdPut(networkId: string, lteNetwork: LteNetwork, options?: any): AxiosPromise<void> {
            return localVarFp.lteNetworkIdPut(networkId, lteNetwork, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add a network-wide base name
         * @param {string} networkId Network ID
         * @param {string} baseName Charging Rule Base Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdSubscriberConfigBaseNamesBaseNameDelete(networkId: string, baseName: string, options?: any): AxiosPromise<void> {
            return localVarFp.lteNetworkIdSubscriberConfigBaseNamesBaseNameDelete(networkId, baseName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add a network-wide base name
         * @param {string} networkId Network ID
         * @param {string} baseName Charging Rule Base Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdSubscriberConfigBaseNamesBaseNamePost(networkId: string, baseName: string, options?: any): AxiosPromise<void> {
            return localVarFp.lteNetworkIdSubscriberConfigBaseNamesBaseNamePost(networkId, baseName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get network-wide base names
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdSubscriberConfigBaseNamesGet(networkId: string, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.lteNetworkIdSubscriberConfigBaseNamesGet(networkId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update network-wide base names
         * @param {string} networkId Network ID
         * @param {Array<string>} record Subscriber Config for the Network
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdSubscriberConfigBaseNamesPut(networkId: string, record: Array<string>, options?: any): AxiosPromise<void> {
            return localVarFp.lteNetworkIdSubscriberConfigBaseNamesPut(networkId, record, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a network-wide subscriber config
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdSubscriberConfigGet(networkId: string, options?: any): AxiosPromise<NetworkSubscriberConfig> {
            return localVarFp.lteNetworkIdSubscriberConfigGet(networkId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a network-wide subscriber config
         * @param {string} networkId Network ID
         * @param {NetworkSubscriberConfig} record Subscriber Config for the Network
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdSubscriberConfigPut(networkId: string, record: NetworkSubscriberConfig, options?: any): AxiosPromise<void> {
            return localVarFp.lteNetworkIdSubscriberConfigPut(networkId, record, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get network-wide rule names
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdSubscriberConfigRuleNamesGet(networkId: string, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.lteNetworkIdSubscriberConfigRuleNamesGet(networkId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update network-wide rule names
         * @param {string} networkId Network ID
         * @param {Array<string>} record Subscriber Config for the Network
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdSubscriberConfigRuleNamesPut(networkId: string, record: Array<string>, options?: any): AxiosPromise<void> {
            return localVarFp.lteNetworkIdSubscriberConfigRuleNamesPut(networkId, record, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add a network-wide rule name
         * @param {string} networkId Network ID
         * @param {string} ruleId Rule Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdSubscriberConfigRuleNamesRuleIdDelete(networkId: string, ruleId: string, options?: any): AxiosPromise<void> {
            return localVarFp.lteNetworkIdSubscriberConfigRuleNamesRuleIdDelete(networkId, ruleId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add a network-wide rule name
         * @param {string} networkId Network ID
         * @param {string} ruleId Rule Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdSubscriberConfigRuleNamesRuleIdPost(networkId: string, ruleId: string, options?: any): AxiosPromise<void> {
            return localVarFp.lteNetworkIdSubscriberConfigRuleNamesRuleIdPost(networkId, ruleId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new LTE network
         * @param {LteNetwork} lteNetwork Configuration of the network to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ltePost(lteNetwork: LteNetwork, options?: any): AxiosPromise<void> {
            return localVarFp.ltePost(lteNetwork, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for lteNetworkIdCellularEpcGet operation in LTENetworksApi.
 * @export
 * @interface LTENetworksApiLteNetworkIdCellularEpcGetRequest
 */
export interface LTENetworksApiLteNetworkIdCellularEpcGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof LTENetworksApiLteNetworkIdCellularEpcGet
     */
    readonly networkId: string
}

/**
 * Request parameters for lteNetworkIdCellularEpcPut operation in LTENetworksApi.
 * @export
 * @interface LTENetworksApiLteNetworkIdCellularEpcPutRequest
 */
export interface LTENetworksApiLteNetworkIdCellularEpcPutRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof LTENetworksApiLteNetworkIdCellularEpcPut
     */
    readonly networkId: string

    /**
     * New EPC configuration for the network
     * @type {NetworkEpcConfigs}
     * @memberof LTENetworksApiLteNetworkIdCellularEpcPut
     */
    readonly config: NetworkEpcConfigs
}

/**
 * Request parameters for lteNetworkIdCellularFegNetworkIdGet operation in LTENetworksApi.
 * @export
 * @interface LTENetworksApiLteNetworkIdCellularFegNetworkIdGetRequest
 */
export interface LTENetworksApiLteNetworkIdCellularFegNetworkIdGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof LTENetworksApiLteNetworkIdCellularFegNetworkIdGet
     */
    readonly networkId: string
}

/**
 * Request parameters for lteNetworkIdCellularFegNetworkIdPut operation in LTENetworksApi.
 * @export
 * @interface LTENetworksApiLteNetworkIdCellularFegNetworkIdPutRequest
 */
export interface LTENetworksApiLteNetworkIdCellularFegNetworkIdPutRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof LTENetworksApiLteNetworkIdCellularFegNetworkIdPut
     */
    readonly networkId: string

    /**
     * Desired federation gateway network ID
     * @type {string}
     * @memberof LTENetworksApiLteNetworkIdCellularFegNetworkIdPut
     */
    readonly fegNetworkId: string
}

/**
 * Request parameters for lteNetworkIdCellularGet operation in LTENetworksApi.
 * @export
 * @interface LTENetworksApiLteNetworkIdCellularGetRequest
 */
export interface LTENetworksApiLteNetworkIdCellularGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof LTENetworksApiLteNetworkIdCellularGet
     */
    readonly networkId: string
}

/**
 * Request parameters for lteNetworkIdCellularNgcGet operation in LTENetworksApi.
 * @export
 * @interface LTENetworksApiLteNetworkIdCellularNgcGetRequest
 */
export interface LTENetworksApiLteNetworkIdCellularNgcGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof LTENetworksApiLteNetworkIdCellularNgcGet
     */
    readonly networkId: string
}

/**
 * Request parameters for lteNetworkIdCellularNgcPut operation in LTENetworksApi.
 * @export
 * @interface LTENetworksApiLteNetworkIdCellularNgcPutRequest
 */
export interface LTENetworksApiLteNetworkIdCellularNgcPutRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof LTENetworksApiLteNetworkIdCellularNgcPut
     */
    readonly networkId: string

    /**
     * New NGC configuration for the network
     * @type {NetworkNgcConfigs}
     * @memberof LTENetworksApiLteNetworkIdCellularNgcPut
     */
    readonly config: NetworkNgcConfigs
}

/**
 * Request parameters for lteNetworkIdCellularPut operation in LTENetworksApi.
 * @export
 * @interface LTENetworksApiLteNetworkIdCellularPutRequest
 */
export interface LTENetworksApiLteNetworkIdCellularPutRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof LTENetworksApiLteNetworkIdCellularPut
     */
    readonly networkId: string

    /**
     * New cellular configuration for the network
     * @type {NetworkCellularConfigs}
     * @memberof LTENetworksApiLteNetworkIdCellularPut
     */
    readonly config: NetworkCellularConfigs
}

/**
 * Request parameters for lteNetworkIdCellularRanGet operation in LTENetworksApi.
 * @export
 * @interface LTENetworksApiLteNetworkIdCellularRanGetRequest
 */
export interface LTENetworksApiLteNetworkIdCellularRanGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof LTENetworksApiLteNetworkIdCellularRanGet
     */
    readonly networkId: string
}

/**
 * Request parameters for lteNetworkIdCellularRanPut operation in LTENetworksApi.
 * @export
 * @interface LTENetworksApiLteNetworkIdCellularRanPutRequest
 */
export interface LTENetworksApiLteNetworkIdCellularRanPutRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof LTENetworksApiLteNetworkIdCellularRanPut
     */
    readonly networkId: string

    /**
     * New RAN configuration for the network
     * @type {NetworkRanConfigs}
     * @memberof LTENetworksApiLteNetworkIdCellularRanPut
     */
    readonly config: NetworkRanConfigs
}

/**
 * Request parameters for lteNetworkIdDelete operation in LTENetworksApi.
 * @export
 * @interface LTENetworksApiLteNetworkIdDeleteRequest
 */
export interface LTENetworksApiLteNetworkIdDeleteRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof LTENetworksApiLteNetworkIdDelete
     */
    readonly networkId: string
}

/**
 * Request parameters for lteNetworkIdDescriptionGet operation in LTENetworksApi.
 * @export
 * @interface LTENetworksApiLteNetworkIdDescriptionGetRequest
 */
export interface LTENetworksApiLteNetworkIdDescriptionGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof LTENetworksApiLteNetworkIdDescriptionGet
     */
    readonly networkId: string
}

/**
 * Request parameters for lteNetworkIdDescriptionPut operation in LTENetworksApi.
 * @export
 * @interface LTENetworksApiLteNetworkIdDescriptionPutRequest
 */
export interface LTENetworksApiLteNetworkIdDescriptionPutRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof LTENetworksApiLteNetworkIdDescriptionPut
     */
    readonly networkId: string

    /**
     * New name for the network
     * @type {string}
     * @memberof LTENetworksApiLteNetworkIdDescriptionPut
     */
    readonly description: string
}

/**
 * Request parameters for lteNetworkIdDnsGet operation in LTENetworksApi.
 * @export
 * @interface LTENetworksApiLteNetworkIdDnsGetRequest
 */
export interface LTENetworksApiLteNetworkIdDnsGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof LTENetworksApiLteNetworkIdDnsGet
     */
    readonly networkId: string
}

/**
 * Request parameters for lteNetworkIdDnsPut operation in LTENetworksApi.
 * @export
 * @interface LTENetworksApiLteNetworkIdDnsPutRequest
 */
export interface LTENetworksApiLteNetworkIdDnsPutRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof LTENetworksApiLteNetworkIdDnsPut
     */
    readonly networkId: string

    /**
     * New DNS configuration for the network
     * @type {NetworkDnsConfig}
     * @memberof LTENetworksApiLteNetworkIdDnsPut
     */
    readonly config: NetworkDnsConfig
}

/**
 * Request parameters for lteNetworkIdDnsRecordsDomainDelete operation in LTENetworksApi.
 * @export
 * @interface LTENetworksApiLteNetworkIdDnsRecordsDomainDeleteRequest
 */
export interface LTENetworksApiLteNetworkIdDnsRecordsDomainDeleteRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof LTENetworksApiLteNetworkIdDnsRecordsDomainDelete
     */
    readonly networkId: string

    /**
     * DNS record domain
     * @type {string}
     * @memberof LTENetworksApiLteNetworkIdDnsRecordsDomainDelete
     */
    readonly domain: string
}

/**
 * Request parameters for lteNetworkIdDnsRecordsDomainGet operation in LTENetworksApi.
 * @export
 * @interface LTENetworksApiLteNetworkIdDnsRecordsDomainGetRequest
 */
export interface LTENetworksApiLteNetworkIdDnsRecordsDomainGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof LTENetworksApiLteNetworkIdDnsRecordsDomainGet
     */
    readonly networkId: string

    /**
     * DNS record domain
     * @type {string}
     * @memberof LTENetworksApiLteNetworkIdDnsRecordsDomainGet
     */
    readonly domain: string
}

/**
 * Request parameters for lteNetworkIdDnsRecordsDomainPost operation in LTENetworksApi.
 * @export
 * @interface LTENetworksApiLteNetworkIdDnsRecordsDomainPostRequest
 */
export interface LTENetworksApiLteNetworkIdDnsRecordsDomainPostRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof LTENetworksApiLteNetworkIdDnsRecordsDomainPost
     */
    readonly networkId: string

    /**
     * DNS record domain
     * @type {string}
     * @memberof LTENetworksApiLteNetworkIdDnsRecordsDomainPost
     */
    readonly domain: string

    /**
     * Custom DNS record for the domain
     * @type {DnsConfigRecord}
     * @memberof LTENetworksApiLteNetworkIdDnsRecordsDomainPost
     */
    readonly record: DnsConfigRecord
}

/**
 * Request parameters for lteNetworkIdDnsRecordsDomainPut operation in LTENetworksApi.
 * @export
 * @interface LTENetworksApiLteNetworkIdDnsRecordsDomainPutRequest
 */
export interface LTENetworksApiLteNetworkIdDnsRecordsDomainPutRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof LTENetworksApiLteNetworkIdDnsRecordsDomainPut
     */
    readonly networkId: string

    /**
     * DNS record domain
     * @type {string}
     * @memberof LTENetworksApiLteNetworkIdDnsRecordsDomainPut
     */
    readonly domain: string

    /**
     * Custom DNS record for the domain
     * @type {DnsConfigRecord}
     * @memberof LTENetworksApiLteNetworkIdDnsRecordsDomainPut
     */
    readonly record: DnsConfigRecord
}

/**
 * Request parameters for lteNetworkIdDnsRecordsGet operation in LTENetworksApi.
 * @export
 * @interface LTENetworksApiLteNetworkIdDnsRecordsGetRequest
 */
export interface LTENetworksApiLteNetworkIdDnsRecordsGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof LTENetworksApiLteNetworkIdDnsRecordsGet
     */
    readonly networkId: string
}

/**
 * Request parameters for lteNetworkIdDnsRecordsPut operation in LTENetworksApi.
 * @export
 * @interface LTENetworksApiLteNetworkIdDnsRecordsPutRequest
 */
export interface LTENetworksApiLteNetworkIdDnsRecordsPutRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof LTENetworksApiLteNetworkIdDnsRecordsPut
     */
    readonly networkId: string

    /**
     * Custom DNS records for the network
     * @type {Array<DnsConfigRecord>}
     * @memberof LTENetworksApiLteNetworkIdDnsRecordsPut
     */
    readonly records: Array<DnsConfigRecord>
}

/**
 * Request parameters for lteNetworkIdFeaturesGet operation in LTENetworksApi.
 * @export
 * @interface LTENetworksApiLteNetworkIdFeaturesGetRequest
 */
export interface LTENetworksApiLteNetworkIdFeaturesGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof LTENetworksApiLteNetworkIdFeaturesGet
     */
    readonly networkId: string
}

/**
 * Request parameters for lteNetworkIdFeaturesPut operation in LTENetworksApi.
 * @export
 * @interface LTENetworksApiLteNetworkIdFeaturesPutRequest
 */
export interface LTENetworksApiLteNetworkIdFeaturesPutRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof LTENetworksApiLteNetworkIdFeaturesPut
     */
    readonly networkId: string

    /**
     * New feature flags for the network
     * @type {NetworkFeatures}
     * @memberof LTENetworksApiLteNetworkIdFeaturesPut
     */
    readonly config: NetworkFeatures
}

/**
 * Request parameters for lteNetworkIdGatewayPoolsGatewayPoolIdDelete operation in LTENetworksApi.
 * @export
 * @interface LTENetworksApiLteNetworkIdGatewayPoolsGatewayPoolIdDeleteRequest
 */
export interface LTENetworksApiLteNetworkIdGatewayPoolsGatewayPoolIdDeleteRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof LTENetworksApiLteNetworkIdGatewayPoolsGatewayPoolIdDelete
     */
    readonly networkId: string

    /**
     * Gateway Pool ID
     * @type {string}
     * @memberof LTENetworksApiLteNetworkIdGatewayPoolsGatewayPoolIdDelete
     */
    readonly gatewayPoolId: string
}

/**
 * Request parameters for lteNetworkIdGatewayPoolsGatewayPoolIdGet operation in LTENetworksApi.
 * @export
 * @interface LTENetworksApiLteNetworkIdGatewayPoolsGatewayPoolIdGetRequest
 */
export interface LTENetworksApiLteNetworkIdGatewayPoolsGatewayPoolIdGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof LTENetworksApiLteNetworkIdGatewayPoolsGatewayPoolIdGet
     */
    readonly networkId: string

    /**
     * Gateway Pool ID
     * @type {string}
     * @memberof LTENetworksApiLteNetworkIdGatewayPoolsGatewayPoolIdGet
     */
    readonly gatewayPoolId: string
}

/**
 * Request parameters for lteNetworkIdGatewayPoolsGatewayPoolIdPut operation in LTENetworksApi.
 * @export
 * @interface LTENetworksApiLteNetworkIdGatewayPoolsGatewayPoolIdPutRequest
 */
export interface LTENetworksApiLteNetworkIdGatewayPoolsGatewayPoolIdPutRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof LTENetworksApiLteNetworkIdGatewayPoolsGatewayPoolIdPut
     */
    readonly networkId: string

    /**
     * Gateway Pool ID
     * @type {string}
     * @memberof LTENetworksApiLteNetworkIdGatewayPoolsGatewayPoolIdPut
     */
    readonly gatewayPoolId: string

    /**
     * LTE HA gateway pool
     * @type {MutableCellularGatewayPool}
     * @memberof LTENetworksApiLteNetworkIdGatewayPoolsGatewayPoolIdPut
     */
    readonly hAGatewayPool: MutableCellularGatewayPool
}

/**
 * Request parameters for lteNetworkIdGatewayPoolsGet operation in LTENetworksApi.
 * @export
 * @interface LTENetworksApiLteNetworkIdGatewayPoolsGetRequest
 */
export interface LTENetworksApiLteNetworkIdGatewayPoolsGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof LTENetworksApiLteNetworkIdGatewayPoolsGet
     */
    readonly networkId: string
}

/**
 * Request parameters for lteNetworkIdGatewayPoolsPost operation in LTENetworksApi.
 * @export
 * @interface LTENetworksApiLteNetworkIdGatewayPoolsPostRequest
 */
export interface LTENetworksApiLteNetworkIdGatewayPoolsPostRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof LTENetworksApiLteNetworkIdGatewayPoolsPost
     */
    readonly networkId: string

    /**
     * LTE HA gateway pool
     * @type {MutableCellularGatewayPool}
     * @memberof LTENetworksApiLteNetworkIdGatewayPoolsPost
     */
    readonly hAGatewayPool: MutableCellularGatewayPool
}

/**
 * Request parameters for lteNetworkIdGet operation in LTENetworksApi.
 * @export
 * @interface LTENetworksApiLteNetworkIdGetRequest
 */
export interface LTENetworksApiLteNetworkIdGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof LTENetworksApiLteNetworkIdGet
     */
    readonly networkId: string
}

/**
 * Request parameters for lteNetworkIdNameGet operation in LTENetworksApi.
 * @export
 * @interface LTENetworksApiLteNetworkIdNameGetRequest
 */
export interface LTENetworksApiLteNetworkIdNameGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof LTENetworksApiLteNetworkIdNameGet
     */
    readonly networkId: string
}

/**
 * Request parameters for lteNetworkIdNamePut operation in LTENetworksApi.
 * @export
 * @interface LTENetworksApiLteNetworkIdNamePutRequest
 */
export interface LTENetworksApiLteNetworkIdNamePutRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof LTENetworksApiLteNetworkIdNamePut
     */
    readonly networkId: string

    /**
     * New name for the network
     * @type {string}
     * @memberof LTENetworksApiLteNetworkIdNamePut
     */
    readonly name: string
}

/**
 * Request parameters for lteNetworkIdPut operation in LTENetworksApi.
 * @export
 * @interface LTENetworksApiLteNetworkIdPutRequest
 */
export interface LTENetworksApiLteNetworkIdPutRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof LTENetworksApiLteNetworkIdPut
     */
    readonly networkId: string

    /**
     * Full desired configuration of the network
     * @type {LteNetwork}
     * @memberof LTENetworksApiLteNetworkIdPut
     */
    readonly lteNetwork: LteNetwork
}

/**
 * Request parameters for lteNetworkIdSubscriberConfigBaseNamesBaseNameDelete operation in LTENetworksApi.
 * @export
 * @interface LTENetworksApiLteNetworkIdSubscriberConfigBaseNamesBaseNameDeleteRequest
 */
export interface LTENetworksApiLteNetworkIdSubscriberConfigBaseNamesBaseNameDeleteRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof LTENetworksApiLteNetworkIdSubscriberConfigBaseNamesBaseNameDelete
     */
    readonly networkId: string

    /**
     * Charging Rule Base Name
     * @type {string}
     * @memberof LTENetworksApiLteNetworkIdSubscriberConfigBaseNamesBaseNameDelete
     */
    readonly baseName: string
}

/**
 * Request parameters for lteNetworkIdSubscriberConfigBaseNamesBaseNamePost operation in LTENetworksApi.
 * @export
 * @interface LTENetworksApiLteNetworkIdSubscriberConfigBaseNamesBaseNamePostRequest
 */
export interface LTENetworksApiLteNetworkIdSubscriberConfigBaseNamesBaseNamePostRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof LTENetworksApiLteNetworkIdSubscriberConfigBaseNamesBaseNamePost
     */
    readonly networkId: string

    /**
     * Charging Rule Base Name
     * @type {string}
     * @memberof LTENetworksApiLteNetworkIdSubscriberConfigBaseNamesBaseNamePost
     */
    readonly baseName: string
}

/**
 * Request parameters for lteNetworkIdSubscriberConfigBaseNamesGet operation in LTENetworksApi.
 * @export
 * @interface LTENetworksApiLteNetworkIdSubscriberConfigBaseNamesGetRequest
 */
export interface LTENetworksApiLteNetworkIdSubscriberConfigBaseNamesGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof LTENetworksApiLteNetworkIdSubscriberConfigBaseNamesGet
     */
    readonly networkId: string
}

/**
 * Request parameters for lteNetworkIdSubscriberConfigBaseNamesPut operation in LTENetworksApi.
 * @export
 * @interface LTENetworksApiLteNetworkIdSubscriberConfigBaseNamesPutRequest
 */
export interface LTENetworksApiLteNetworkIdSubscriberConfigBaseNamesPutRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof LTENetworksApiLteNetworkIdSubscriberConfigBaseNamesPut
     */
    readonly networkId: string

    /**
     * Subscriber Config for the Network
     * @type {Array<string>}
     * @memberof LTENetworksApiLteNetworkIdSubscriberConfigBaseNamesPut
     */
    readonly record: Array<string>
}

/**
 * Request parameters for lteNetworkIdSubscriberConfigGet operation in LTENetworksApi.
 * @export
 * @interface LTENetworksApiLteNetworkIdSubscriberConfigGetRequest
 */
export interface LTENetworksApiLteNetworkIdSubscriberConfigGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof LTENetworksApiLteNetworkIdSubscriberConfigGet
     */
    readonly networkId: string
}

/**
 * Request parameters for lteNetworkIdSubscriberConfigPut operation in LTENetworksApi.
 * @export
 * @interface LTENetworksApiLteNetworkIdSubscriberConfigPutRequest
 */
export interface LTENetworksApiLteNetworkIdSubscriberConfigPutRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof LTENetworksApiLteNetworkIdSubscriberConfigPut
     */
    readonly networkId: string

    /**
     * Subscriber Config for the Network
     * @type {NetworkSubscriberConfig}
     * @memberof LTENetworksApiLteNetworkIdSubscriberConfigPut
     */
    readonly record: NetworkSubscriberConfig
}

/**
 * Request parameters for lteNetworkIdSubscriberConfigRuleNamesGet operation in LTENetworksApi.
 * @export
 * @interface LTENetworksApiLteNetworkIdSubscriberConfigRuleNamesGetRequest
 */
export interface LTENetworksApiLteNetworkIdSubscriberConfigRuleNamesGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof LTENetworksApiLteNetworkIdSubscriberConfigRuleNamesGet
     */
    readonly networkId: string
}

/**
 * Request parameters for lteNetworkIdSubscriberConfigRuleNamesPut operation in LTENetworksApi.
 * @export
 * @interface LTENetworksApiLteNetworkIdSubscriberConfigRuleNamesPutRequest
 */
export interface LTENetworksApiLteNetworkIdSubscriberConfigRuleNamesPutRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof LTENetworksApiLteNetworkIdSubscriberConfigRuleNamesPut
     */
    readonly networkId: string

    /**
     * Subscriber Config for the Network
     * @type {Array<string>}
     * @memberof LTENetworksApiLteNetworkIdSubscriberConfigRuleNamesPut
     */
    readonly record: Array<string>
}

/**
 * Request parameters for lteNetworkIdSubscriberConfigRuleNamesRuleIdDelete operation in LTENetworksApi.
 * @export
 * @interface LTENetworksApiLteNetworkIdSubscriberConfigRuleNamesRuleIdDeleteRequest
 */
export interface LTENetworksApiLteNetworkIdSubscriberConfigRuleNamesRuleIdDeleteRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof LTENetworksApiLteNetworkIdSubscriberConfigRuleNamesRuleIdDelete
     */
    readonly networkId: string

    /**
     * Rule Id
     * @type {string}
     * @memberof LTENetworksApiLteNetworkIdSubscriberConfigRuleNamesRuleIdDelete
     */
    readonly ruleId: string
}

/**
 * Request parameters for lteNetworkIdSubscriberConfigRuleNamesRuleIdPost operation in LTENetworksApi.
 * @export
 * @interface LTENetworksApiLteNetworkIdSubscriberConfigRuleNamesRuleIdPostRequest
 */
export interface LTENetworksApiLteNetworkIdSubscriberConfigRuleNamesRuleIdPostRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof LTENetworksApiLteNetworkIdSubscriberConfigRuleNamesRuleIdPost
     */
    readonly networkId: string

    /**
     * Rule Id
     * @type {string}
     * @memberof LTENetworksApiLteNetworkIdSubscriberConfigRuleNamesRuleIdPost
     */
    readonly ruleId: string
}

/**
 * Request parameters for ltePost operation in LTENetworksApi.
 * @export
 * @interface LTENetworksApiLtePostRequest
 */
export interface LTENetworksApiLtePostRequest {
    /**
     * Configuration of the network to create
     * @type {LteNetwork}
     * @memberof LTENetworksApiLtePost
     */
    readonly lteNetwork: LteNetwork
}

/**
 * LTENetworksApi - object-oriented interface
 * @export
 * @class LTENetworksApi
 * @extends {BaseAPI}
 */
export class LTENetworksApi extends BaseAPI {
    /**
     * 
     * @summary List all LTE network IDs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LTENetworksApi
     */
    public lteGet(options?: AxiosRequestConfig) {
        return LTENetworksApiFp(this.configuration).lteGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get EPC configuration of LTE network
     * @param {LTENetworksApiLteNetworkIdCellularEpcGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LTENetworksApi
     */
    public lteNetworkIdCellularEpcGet(requestParameters: LTENetworksApiLteNetworkIdCellularEpcGetRequest, options?: AxiosRequestConfig) {
        return LTENetworksApiFp(this.configuration).lteNetworkIdCellularEpcGet(requestParameters.networkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update EPC configuration of LTE network
     * @param {LTENetworksApiLteNetworkIdCellularEpcPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LTENetworksApi
     */
    public lteNetworkIdCellularEpcPut(requestParameters: LTENetworksApiLteNetworkIdCellularEpcPutRequest, options?: AxiosRequestConfig) {
        return LTENetworksApiFp(this.configuration).lteNetworkIdCellularEpcPut(requestParameters.networkId, requestParameters.config, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Federation Gateway network ID for the network
     * @param {LTENetworksApiLteNetworkIdCellularFegNetworkIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LTENetworksApi
     */
    public lteNetworkIdCellularFegNetworkIdGet(requestParameters: LTENetworksApiLteNetworkIdCellularFegNetworkIdGetRequest, options?: AxiosRequestConfig) {
        return LTENetworksApiFp(this.configuration).lteNetworkIdCellularFegNetworkIdGet(requestParameters.networkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the Federation Gateway network ID
     * @param {LTENetworksApiLteNetworkIdCellularFegNetworkIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LTENetworksApi
     */
    public lteNetworkIdCellularFegNetworkIdPut(requestParameters: LTENetworksApiLteNetworkIdCellularFegNetworkIdPutRequest, options?: AxiosRequestConfig) {
        return LTENetworksApiFp(this.configuration).lteNetworkIdCellularFegNetworkIdPut(requestParameters.networkId, requestParameters.fegNetworkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get cellular configuration of LTE network
     * @param {LTENetworksApiLteNetworkIdCellularGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LTENetworksApi
     */
    public lteNetworkIdCellularGet(requestParameters: LTENetworksApiLteNetworkIdCellularGetRequest, options?: AxiosRequestConfig) {
        return LTENetworksApiFp(this.configuration).lteNetworkIdCellularGet(requestParameters.networkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get NGC configuration of LTE Network
     * @param {LTENetworksApiLteNetworkIdCellularNgcGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LTENetworksApi
     */
    public lteNetworkIdCellularNgcGet(requestParameters: LTENetworksApiLteNetworkIdCellularNgcGetRequest, options?: AxiosRequestConfig) {
        return LTENetworksApiFp(this.configuration).lteNetworkIdCellularNgcGet(requestParameters.networkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update NGC configuration of LTE network
     * @param {LTENetworksApiLteNetworkIdCellularNgcPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LTENetworksApi
     */
    public lteNetworkIdCellularNgcPut(requestParameters: LTENetworksApiLteNetworkIdCellularNgcPutRequest, options?: AxiosRequestConfig) {
        return LTENetworksApiFp(this.configuration).lteNetworkIdCellularNgcPut(requestParameters.networkId, requestParameters.config, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update cellular configuration of LTE network
     * @param {LTENetworksApiLteNetworkIdCellularPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LTENetworksApi
     */
    public lteNetworkIdCellularPut(requestParameters: LTENetworksApiLteNetworkIdCellularPutRequest, options?: AxiosRequestConfig) {
        return LTENetworksApiFp(this.configuration).lteNetworkIdCellularPut(requestParameters.networkId, requestParameters.config, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get RAN configuration of LTE network
     * @param {LTENetworksApiLteNetworkIdCellularRanGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LTENetworksApi
     */
    public lteNetworkIdCellularRanGet(requestParameters: LTENetworksApiLteNetworkIdCellularRanGetRequest, options?: AxiosRequestConfig) {
        return LTENetworksApiFp(this.configuration).lteNetworkIdCellularRanGet(requestParameters.networkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update RAN configuration of LTE network
     * @param {LTENetworksApiLteNetworkIdCellularRanPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LTENetworksApi
     */
    public lteNetworkIdCellularRanPut(requestParameters: LTENetworksApiLteNetworkIdCellularRanPutRequest, options?: AxiosRequestConfig) {
        return LTENetworksApiFp(this.configuration).lteNetworkIdCellularRanPut(requestParameters.networkId, requestParameters.config, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete an LTE network
     * @param {LTENetworksApiLteNetworkIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LTENetworksApi
     */
    public lteNetworkIdDelete(requestParameters: LTENetworksApiLteNetworkIdDeleteRequest, options?: AxiosRequestConfig) {
        return LTENetworksApiFp(this.configuration).lteNetworkIdDelete(requestParameters.networkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get description of an LTE network
     * @param {LTENetworksApiLteNetworkIdDescriptionGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LTENetworksApi
     */
    public lteNetworkIdDescriptionGet(requestParameters: LTENetworksApiLteNetworkIdDescriptionGetRequest, options?: AxiosRequestConfig) {
        return LTENetworksApiFp(this.configuration).lteNetworkIdDescriptionGet(requestParameters.networkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the description of an LTE network
     * @param {LTENetworksApiLteNetworkIdDescriptionPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LTENetworksApi
     */
    public lteNetworkIdDescriptionPut(requestParameters: LTENetworksApiLteNetworkIdDescriptionPutRequest, options?: AxiosRequestConfig) {
        return LTENetworksApiFp(this.configuration).lteNetworkIdDescriptionPut(requestParameters.networkId, requestParameters.description, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get DNS configuration of LTE network
     * @param {LTENetworksApiLteNetworkIdDnsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LTENetworksApi
     */
    public lteNetworkIdDnsGet(requestParameters: LTENetworksApiLteNetworkIdDnsGetRequest, options?: AxiosRequestConfig) {
        return LTENetworksApiFp(this.configuration).lteNetworkIdDnsGet(requestParameters.networkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update DNS configuration of LTE network
     * @param {LTENetworksApiLteNetworkIdDnsPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LTENetworksApi
     */
    public lteNetworkIdDnsPut(requestParameters: LTENetworksApiLteNetworkIdDnsPutRequest, options?: AxiosRequestConfig) {
        return LTENetworksApiFp(this.configuration).lteNetworkIdDnsPut(requestParameters.networkId, requestParameters.config, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete the DNS record for a specific domain
     * @param {LTENetworksApiLteNetworkIdDnsRecordsDomainDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LTENetworksApi
     */
    public lteNetworkIdDnsRecordsDomainDelete(requestParameters: LTENetworksApiLteNetworkIdDnsRecordsDomainDeleteRequest, options?: AxiosRequestConfig) {
        return LTENetworksApiFp(this.configuration).lteNetworkIdDnsRecordsDomainDelete(requestParameters.networkId, requestParameters.domain, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the DNS config record for a specific domain
     * @param {LTENetworksApiLteNetworkIdDnsRecordsDomainGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LTENetworksApi
     */
    public lteNetworkIdDnsRecordsDomainGet(requestParameters: LTENetworksApiLteNetworkIdDnsRecordsDomainGetRequest, options?: AxiosRequestConfig) {
        return LTENetworksApiFp(this.configuration).lteNetworkIdDnsRecordsDomainGet(requestParameters.networkId, requestParameters.domain, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a DNS record for a specific domain
     * @param {LTENetworksApiLteNetworkIdDnsRecordsDomainPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LTENetworksApi
     */
    public lteNetworkIdDnsRecordsDomainPost(requestParameters: LTENetworksApiLteNetworkIdDnsRecordsDomainPostRequest, options?: AxiosRequestConfig) {
        return LTENetworksApiFp(this.configuration).lteNetworkIdDnsRecordsDomainPost(requestParameters.networkId, requestParameters.domain, requestParameters.record, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a DNS record for a specific domain
     * @param {LTENetworksApiLteNetworkIdDnsRecordsDomainPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LTENetworksApi
     */
    public lteNetworkIdDnsRecordsDomainPut(requestParameters: LTENetworksApiLteNetworkIdDnsRecordsDomainPutRequest, options?: AxiosRequestConfig) {
        return LTENetworksApiFp(this.configuration).lteNetworkIdDnsRecordsDomainPut(requestParameters.networkId, requestParameters.domain, requestParameters.record, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the DNS config records for the LTE network
     * @param {LTENetworksApiLteNetworkIdDnsRecordsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LTENetworksApi
     */
    public lteNetworkIdDnsRecordsGet(requestParameters: LTENetworksApiLteNetworkIdDnsRecordsGetRequest, options?: AxiosRequestConfig) {
        return LTENetworksApiFp(this.configuration).lteNetworkIdDnsRecordsGet(requestParameters.networkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Change all the DNS records for the LTE network
     * @param {LTENetworksApiLteNetworkIdDnsRecordsPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LTENetworksApi
     */
    public lteNetworkIdDnsRecordsPut(requestParameters: LTENetworksApiLteNetworkIdDnsRecordsPutRequest, options?: AxiosRequestConfig) {
        return LTENetworksApiFp(this.configuration).lteNetworkIdDnsRecordsPut(requestParameters.networkId, requestParameters.records, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get feature flags for LTE network
     * @param {LTENetworksApiLteNetworkIdFeaturesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LTENetworksApi
     */
    public lteNetworkIdFeaturesGet(requestParameters: LTENetworksApiLteNetworkIdFeaturesGetRequest, options?: AxiosRequestConfig) {
        return LTENetworksApiFp(this.configuration).lteNetworkIdFeaturesGet(requestParameters.networkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update feature flags for LTE network
     * @param {LTENetworksApiLteNetworkIdFeaturesPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LTENetworksApi
     */
    public lteNetworkIdFeaturesPut(requestParameters: LTENetworksApiLteNetworkIdFeaturesPutRequest, options?: AxiosRequestConfig) {
        return LTENetworksApiFp(this.configuration).lteNetworkIdFeaturesPut(requestParameters.networkId, requestParameters.config, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete gateway pool from LTE network
     * @param {LTENetworksApiLteNetworkIdGatewayPoolsGatewayPoolIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LTENetworksApi
     */
    public lteNetworkIdGatewayPoolsGatewayPoolIdDelete(requestParameters: LTENetworksApiLteNetworkIdGatewayPoolsGatewayPoolIdDeleteRequest, options?: AxiosRequestConfig) {
        return LTENetworksApiFp(this.configuration).lteNetworkIdGatewayPoolsGatewayPoolIdDelete(requestParameters.networkId, requestParameters.gatewayPoolId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve gateway pool from LTE network
     * @param {LTENetworksApiLteNetworkIdGatewayPoolsGatewayPoolIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LTENetworksApi
     */
    public lteNetworkIdGatewayPoolsGatewayPoolIdGet(requestParameters: LTENetworksApiLteNetworkIdGatewayPoolsGatewayPoolIdGetRequest, options?: AxiosRequestConfig) {
        return LTENetworksApiFp(this.configuration).lteNetworkIdGatewayPoolsGatewayPoolIdGet(requestParameters.networkId, requestParameters.gatewayPoolId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update gateway pool in LTE network
     * @param {LTENetworksApiLteNetworkIdGatewayPoolsGatewayPoolIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LTENetworksApi
     */
    public lteNetworkIdGatewayPoolsGatewayPoolIdPut(requestParameters: LTENetworksApiLteNetworkIdGatewayPoolsGatewayPoolIdPutRequest, options?: AxiosRequestConfig) {
        return LTENetworksApiFp(this.configuration).lteNetworkIdGatewayPoolsGatewayPoolIdPut(requestParameters.networkId, requestParameters.gatewayPoolId, requestParameters.hAGatewayPool, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all gateway pools in LTE network
     * @param {LTENetworksApiLteNetworkIdGatewayPoolsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LTENetworksApi
     */
    public lteNetworkIdGatewayPoolsGet(requestParameters: LTENetworksApiLteNetworkIdGatewayPoolsGetRequest, options?: AxiosRequestConfig) {
        return LTENetworksApiFp(this.configuration).lteNetworkIdGatewayPoolsGet(requestParameters.networkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create new gateway pool in LTE network
     * @param {LTENetworksApiLteNetworkIdGatewayPoolsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LTENetworksApi
     */
    public lteNetworkIdGatewayPoolsPost(requestParameters: LTENetworksApiLteNetworkIdGatewayPoolsPostRequest, options?: AxiosRequestConfig) {
        return LTENetworksApiFp(this.configuration).lteNetworkIdGatewayPoolsPost(requestParameters.networkId, requestParameters.hAGatewayPool, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Describe an LTE network
     * @param {LTENetworksApiLteNetworkIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LTENetworksApi
     */
    public lteNetworkIdGet(requestParameters: LTENetworksApiLteNetworkIdGetRequest, options?: AxiosRequestConfig) {
        return LTENetworksApiFp(this.configuration).lteNetworkIdGet(requestParameters.networkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get name of an LTE network
     * @param {LTENetworksApiLteNetworkIdNameGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LTENetworksApi
     */
    public lteNetworkIdNameGet(requestParameters: LTENetworksApiLteNetworkIdNameGetRequest, options?: AxiosRequestConfig) {
        return LTENetworksApiFp(this.configuration).lteNetworkIdNameGet(requestParameters.networkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the name of an LTE network
     * @param {LTENetworksApiLteNetworkIdNamePutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LTENetworksApi
     */
    public lteNetworkIdNamePut(requestParameters: LTENetworksApiLteNetworkIdNamePutRequest, options?: AxiosRequestConfig) {
        return LTENetworksApiFp(this.configuration).lteNetworkIdNamePut(requestParameters.networkId, requestParameters.name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an entire LTE network
     * @param {LTENetworksApiLteNetworkIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LTENetworksApi
     */
    public lteNetworkIdPut(requestParameters: LTENetworksApiLteNetworkIdPutRequest, options?: AxiosRequestConfig) {
        return LTENetworksApiFp(this.configuration).lteNetworkIdPut(requestParameters.networkId, requestParameters.lteNetwork, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add a network-wide base name
     * @param {LTENetworksApiLteNetworkIdSubscriberConfigBaseNamesBaseNameDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LTENetworksApi
     */
    public lteNetworkIdSubscriberConfigBaseNamesBaseNameDelete(requestParameters: LTENetworksApiLteNetworkIdSubscriberConfigBaseNamesBaseNameDeleteRequest, options?: AxiosRequestConfig) {
        return LTENetworksApiFp(this.configuration).lteNetworkIdSubscriberConfigBaseNamesBaseNameDelete(requestParameters.networkId, requestParameters.baseName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add a network-wide base name
     * @param {LTENetworksApiLteNetworkIdSubscriberConfigBaseNamesBaseNamePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LTENetworksApi
     */
    public lteNetworkIdSubscriberConfigBaseNamesBaseNamePost(requestParameters: LTENetworksApiLteNetworkIdSubscriberConfigBaseNamesBaseNamePostRequest, options?: AxiosRequestConfig) {
        return LTENetworksApiFp(this.configuration).lteNetworkIdSubscriberConfigBaseNamesBaseNamePost(requestParameters.networkId, requestParameters.baseName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get network-wide base names
     * @param {LTENetworksApiLteNetworkIdSubscriberConfigBaseNamesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LTENetworksApi
     */
    public lteNetworkIdSubscriberConfigBaseNamesGet(requestParameters: LTENetworksApiLteNetworkIdSubscriberConfigBaseNamesGetRequest, options?: AxiosRequestConfig) {
        return LTENetworksApiFp(this.configuration).lteNetworkIdSubscriberConfigBaseNamesGet(requestParameters.networkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update network-wide base names
     * @param {LTENetworksApiLteNetworkIdSubscriberConfigBaseNamesPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LTENetworksApi
     */
    public lteNetworkIdSubscriberConfigBaseNamesPut(requestParameters: LTENetworksApiLteNetworkIdSubscriberConfigBaseNamesPutRequest, options?: AxiosRequestConfig) {
        return LTENetworksApiFp(this.configuration).lteNetworkIdSubscriberConfigBaseNamesPut(requestParameters.networkId, requestParameters.record, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a network-wide subscriber config
     * @param {LTENetworksApiLteNetworkIdSubscriberConfigGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LTENetworksApi
     */
    public lteNetworkIdSubscriberConfigGet(requestParameters: LTENetworksApiLteNetworkIdSubscriberConfigGetRequest, options?: AxiosRequestConfig) {
        return LTENetworksApiFp(this.configuration).lteNetworkIdSubscriberConfigGet(requestParameters.networkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a network-wide subscriber config
     * @param {LTENetworksApiLteNetworkIdSubscriberConfigPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LTENetworksApi
     */
    public lteNetworkIdSubscriberConfigPut(requestParameters: LTENetworksApiLteNetworkIdSubscriberConfigPutRequest, options?: AxiosRequestConfig) {
        return LTENetworksApiFp(this.configuration).lteNetworkIdSubscriberConfigPut(requestParameters.networkId, requestParameters.record, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get network-wide rule names
     * @param {LTENetworksApiLteNetworkIdSubscriberConfigRuleNamesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LTENetworksApi
     */
    public lteNetworkIdSubscriberConfigRuleNamesGet(requestParameters: LTENetworksApiLteNetworkIdSubscriberConfigRuleNamesGetRequest, options?: AxiosRequestConfig) {
        return LTENetworksApiFp(this.configuration).lteNetworkIdSubscriberConfigRuleNamesGet(requestParameters.networkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update network-wide rule names
     * @param {LTENetworksApiLteNetworkIdSubscriberConfigRuleNamesPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LTENetworksApi
     */
    public lteNetworkIdSubscriberConfigRuleNamesPut(requestParameters: LTENetworksApiLteNetworkIdSubscriberConfigRuleNamesPutRequest, options?: AxiosRequestConfig) {
        return LTENetworksApiFp(this.configuration).lteNetworkIdSubscriberConfigRuleNamesPut(requestParameters.networkId, requestParameters.record, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add a network-wide rule name
     * @param {LTENetworksApiLteNetworkIdSubscriberConfigRuleNamesRuleIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LTENetworksApi
     */
    public lteNetworkIdSubscriberConfigRuleNamesRuleIdDelete(requestParameters: LTENetworksApiLteNetworkIdSubscriberConfigRuleNamesRuleIdDeleteRequest, options?: AxiosRequestConfig) {
        return LTENetworksApiFp(this.configuration).lteNetworkIdSubscriberConfigRuleNamesRuleIdDelete(requestParameters.networkId, requestParameters.ruleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add a network-wide rule name
     * @param {LTENetworksApiLteNetworkIdSubscriberConfigRuleNamesRuleIdPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LTENetworksApi
     */
    public lteNetworkIdSubscriberConfigRuleNamesRuleIdPost(requestParameters: LTENetworksApiLteNetworkIdSubscriberConfigRuleNamesRuleIdPostRequest, options?: AxiosRequestConfig) {
        return LTENetworksApiFp(this.configuration).lteNetworkIdSubscriberConfigRuleNamesRuleIdPost(requestParameters.networkId, requestParameters.ruleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new LTE network
     * @param {LTENetworksApiLtePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LTENetworksApi
     */
    public ltePost(requestParameters: LTENetworksApiLtePostRequest, options?: AxiosRequestConfig) {
        return LTENetworksApiFp(this.configuration).ltePost(requestParameters.lteNetwork, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * LogsApi - axios parameter creator
 * @export
 */
export const LogsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List messages between ENODEBD and DP and between DP and SAS ordered by time
         * @param {string} networkId Network ID
         * @param {number} [offset] Start index for pagination
         * @param {number} [limit] Number of record to return
         * @param {string} [begin] start datetime of log
         * @param {string} [end] end datatime of log
         * @param {string} [serialNumber] serial number of cbsd
         * @param {string} [fccId] fcc id of cbsd
         * @param {string} [type] log type
         * @param {number} [responseCode] response code (only applicable for SAS responses)
         * @param {'SAS' | 'DP' | 'CBSD'} [from] log origin
         * @param {'SAS' | 'DP' | 'CBSD'} [to] log destination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dpNetworkIdLogsGet: async (networkId: string, offset?: number, limit?: number, begin?: string, end?: string, serialNumber?: string, fccId?: string, type?: string, responseCode?: number, from?: 'SAS' | 'DP' | 'CBSD', to?: 'SAS' | 'DP' | 'CBSD', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('dpNetworkIdLogsGet', 'networkId', networkId)
            const localVarPath = `/dp/{network_id}/logs`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (begin !== undefined) {
                localVarQueryParameter['begin'] = (begin as any instanceof Date) ?
                    (begin as any).toISOString() :
                    begin;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = (end as any instanceof Date) ?
                    (end as any).toISOString() :
                    end;
            }

            if (serialNumber !== undefined) {
                localVarQueryParameter['serial_number'] = serialNumber;
            }

            if (fccId !== undefined) {
                localVarQueryParameter['fcc_id'] = fccId;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (responseCode !== undefined) {
                localVarQueryParameter['response_code'] = responseCode;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Count logs
         * @param {string} networkId Network ID
         * @param {string} [simpleQuery] Simple Query String to execute
         * @param {string} [fields] Comma-separated list of fields to search with the simple query. Defaults to the log field.
         * @param {string} [filters] Comma-separated list of key:value pairs to filter the query with.
         * @param {string} [start] Time to start searching
         * @param {string} [end] Time to end searching
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdLogsCountGet: async (networkId: string, simpleQuery?: string, fields?: string, filters?: string, start?: string, end?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networksNetworkIdLogsCountGet', 'networkId', networkId)
            const localVarPath = `/networks/{network_id}/logs/count`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (simpleQuery !== undefined) {
                localVarQueryParameter['simple_query'] = simpleQuery;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = end;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search logs
         * @param {string} networkId Network ID
         * @param {string} [simpleQuery] Simple Query String to execute
         * @param {string} [fields] Comma-separated list of fields to search with the simple query. Defaults to the log field.
         * @param {string} [filters] Comma-separated list of key:value pairs to filter the query with.
         * @param {string} [size] Maximum number of hits returned. Defaults to 10.
         * @param {string} [from] The starting offset to fetch from the search hits. This param along with size can be used for pagination.
         * @param {string} [start] Time to start searching
         * @param {string} [end] Time to end searching
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdLogsSearchGet: async (networkId: string, simpleQuery?: string, fields?: string, filters?: string, size?: string, from?: string, start?: string, end?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networksNetworkIdLogsSearchGet', 'networkId', networkId)
            const localVarPath = `/networks/{network_id}/logs/search`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (simpleQuery !== undefined) {
                localVarQueryParameter['simple_query'] = simpleQuery;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = end;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LogsApi - functional programming interface
 * @export
 */
export const LogsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LogsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List messages between ENODEBD and DP and between DP and SAS ordered by time
         * @param {string} networkId Network ID
         * @param {number} [offset] Start index for pagination
         * @param {number} [limit] Number of record to return
         * @param {string} [begin] start datetime of log
         * @param {string} [end] end datatime of log
         * @param {string} [serialNumber] serial number of cbsd
         * @param {string} [fccId] fcc id of cbsd
         * @param {string} [type] log type
         * @param {number} [responseCode] response code (only applicable for SAS responses)
         * @param {'SAS' | 'DP' | 'CBSD'} [from] log origin
         * @param {'SAS' | 'DP' | 'CBSD'} [to] log destination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dpNetworkIdLogsGet(networkId: string, offset?: number, limit?: number, begin?: string, end?: string, serialNumber?: string, fccId?: string, type?: string, responseCode?: number, from?: 'SAS' | 'DP' | 'CBSD', to?: 'SAS' | 'DP' | 'CBSD', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedLogs>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dpNetworkIdLogsGet(networkId, offset, limit, begin, end, serialNumber, fccId, type, responseCode, from, to, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Count logs
         * @param {string} networkId Network ID
         * @param {string} [simpleQuery] Simple Query String to execute
         * @param {string} [fields] Comma-separated list of fields to search with the simple query. Defaults to the log field.
         * @param {string} [filters] Comma-separated list of key:value pairs to filter the query with.
         * @param {string} [start] Time to start searching
         * @param {string} [end] Time to end searching
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksNetworkIdLogsCountGet(networkId: string, simpleQuery?: string, fields?: string, filters?: string, start?: string, end?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksNetworkIdLogsCountGet(networkId, simpleQuery, fields, filters, start, end, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Search logs
         * @param {string} networkId Network ID
         * @param {string} [simpleQuery] Simple Query String to execute
         * @param {string} [fields] Comma-separated list of fields to search with the simple query. Defaults to the log field.
         * @param {string} [filters] Comma-separated list of key:value pairs to filter the query with.
         * @param {string} [size] Maximum number of hits returned. Defaults to 10.
         * @param {string} [from] The starting offset to fetch from the search hits. This param along with size can be used for pagination.
         * @param {string} [start] Time to start searching
         * @param {string} [end] Time to end searching
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksNetworkIdLogsSearchGet(networkId: string, simpleQuery?: string, fields?: string, filters?: string, size?: string, from?: string, start?: string, end?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ElasticHit>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksNetworkIdLogsSearchGet(networkId, simpleQuery, fields, filters, size, from, start, end, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * LogsApi - factory interface
 * @export
 */
export const LogsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LogsApiFp(configuration)
    return {
        /**
         * 
         * @summary List messages between ENODEBD and DP and between DP and SAS ordered by time
         * @param {string} networkId Network ID
         * @param {number} [offset] Start index for pagination
         * @param {number} [limit] Number of record to return
         * @param {string} [begin] start datetime of log
         * @param {string} [end] end datatime of log
         * @param {string} [serialNumber] serial number of cbsd
         * @param {string} [fccId] fcc id of cbsd
         * @param {string} [type] log type
         * @param {number} [responseCode] response code (only applicable for SAS responses)
         * @param {'SAS' | 'DP' | 'CBSD'} [from] log origin
         * @param {'SAS' | 'DP' | 'CBSD'} [to] log destination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dpNetworkIdLogsGet(networkId: string, offset?: number, limit?: number, begin?: string, end?: string, serialNumber?: string, fccId?: string, type?: string, responseCode?: number, from?: 'SAS' | 'DP' | 'CBSD', to?: 'SAS' | 'DP' | 'CBSD', options?: any): AxiosPromise<PaginatedLogs> {
            return localVarFp.dpNetworkIdLogsGet(networkId, offset, limit, begin, end, serialNumber, fccId, type, responseCode, from, to, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Count logs
         * @param {string} networkId Network ID
         * @param {string} [simpleQuery] Simple Query String to execute
         * @param {string} [fields] Comma-separated list of fields to search with the simple query. Defaults to the log field.
         * @param {string} [filters] Comma-separated list of key:value pairs to filter the query with.
         * @param {string} [start] Time to start searching
         * @param {string} [end] Time to end searching
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdLogsCountGet(networkId: string, simpleQuery?: string, fields?: string, filters?: string, start?: string, end?: string, options?: any): AxiosPromise<number> {
            return localVarFp.networksNetworkIdLogsCountGet(networkId, simpleQuery, fields, filters, start, end, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search logs
         * @param {string} networkId Network ID
         * @param {string} [simpleQuery] Simple Query String to execute
         * @param {string} [fields] Comma-separated list of fields to search with the simple query. Defaults to the log field.
         * @param {string} [filters] Comma-separated list of key:value pairs to filter the query with.
         * @param {string} [size] Maximum number of hits returned. Defaults to 10.
         * @param {string} [from] The starting offset to fetch from the search hits. This param along with size can be used for pagination.
         * @param {string} [start] Time to start searching
         * @param {string} [end] Time to end searching
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdLogsSearchGet(networkId: string, simpleQuery?: string, fields?: string, filters?: string, size?: string, from?: string, start?: string, end?: string, options?: any): AxiosPromise<Array<ElasticHit>> {
            return localVarFp.networksNetworkIdLogsSearchGet(networkId, simpleQuery, fields, filters, size, from, start, end, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for dpNetworkIdLogsGet operation in LogsApi.
 * @export
 * @interface LogsApiDpNetworkIdLogsGetRequest
 */
export interface LogsApiDpNetworkIdLogsGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof LogsApiDpNetworkIdLogsGet
     */
    readonly networkId: string

    /**
     * Start index for pagination
     * @type {number}
     * @memberof LogsApiDpNetworkIdLogsGet
     */
    readonly offset?: number

    /**
     * Number of record to return
     * @type {number}
     * @memberof LogsApiDpNetworkIdLogsGet
     */
    readonly limit?: number

    /**
     * start datetime of log
     * @type {string}
     * @memberof LogsApiDpNetworkIdLogsGet
     */
    readonly begin?: string

    /**
     * end datatime of log
     * @type {string}
     * @memberof LogsApiDpNetworkIdLogsGet
     */
    readonly end?: string

    /**
     * serial number of cbsd
     * @type {string}
     * @memberof LogsApiDpNetworkIdLogsGet
     */
    readonly serialNumber?: string

    /**
     * fcc id of cbsd
     * @type {string}
     * @memberof LogsApiDpNetworkIdLogsGet
     */
    readonly fccId?: string

    /**
     * log type
     * @type {string}
     * @memberof LogsApiDpNetworkIdLogsGet
     */
    readonly type?: string

    /**
     * response code (only applicable for SAS responses)
     * @type {number}
     * @memberof LogsApiDpNetworkIdLogsGet
     */
    readonly responseCode?: number

    /**
     * log origin
     * @type {'SAS' | 'DP' | 'CBSD'}
     * @memberof LogsApiDpNetworkIdLogsGet
     */
    readonly from?: 'SAS' | 'DP' | 'CBSD'

    /**
     * log destination
     * @type {'SAS' | 'DP' | 'CBSD'}
     * @memberof LogsApiDpNetworkIdLogsGet
     */
    readonly to?: 'SAS' | 'DP' | 'CBSD'
}

/**
 * Request parameters for networksNetworkIdLogsCountGet operation in LogsApi.
 * @export
 * @interface LogsApiNetworksNetworkIdLogsCountGetRequest
 */
export interface LogsApiNetworksNetworkIdLogsCountGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof LogsApiNetworksNetworkIdLogsCountGet
     */
    readonly networkId: string

    /**
     * Simple Query String to execute
     * @type {string}
     * @memberof LogsApiNetworksNetworkIdLogsCountGet
     */
    readonly simpleQuery?: string

    /**
     * Comma-separated list of fields to search with the simple query. Defaults to the log field.
     * @type {string}
     * @memberof LogsApiNetworksNetworkIdLogsCountGet
     */
    readonly fields?: string

    /**
     * Comma-separated list of key:value pairs to filter the query with.
     * @type {string}
     * @memberof LogsApiNetworksNetworkIdLogsCountGet
     */
    readonly filters?: string

    /**
     * Time to start searching
     * @type {string}
     * @memberof LogsApiNetworksNetworkIdLogsCountGet
     */
    readonly start?: string

    /**
     * Time to end searching
     * @type {string}
     * @memberof LogsApiNetworksNetworkIdLogsCountGet
     */
    readonly end?: string
}

/**
 * Request parameters for networksNetworkIdLogsSearchGet operation in LogsApi.
 * @export
 * @interface LogsApiNetworksNetworkIdLogsSearchGetRequest
 */
export interface LogsApiNetworksNetworkIdLogsSearchGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof LogsApiNetworksNetworkIdLogsSearchGet
     */
    readonly networkId: string

    /**
     * Simple Query String to execute
     * @type {string}
     * @memberof LogsApiNetworksNetworkIdLogsSearchGet
     */
    readonly simpleQuery?: string

    /**
     * Comma-separated list of fields to search with the simple query. Defaults to the log field.
     * @type {string}
     * @memberof LogsApiNetworksNetworkIdLogsSearchGet
     */
    readonly fields?: string

    /**
     * Comma-separated list of key:value pairs to filter the query with.
     * @type {string}
     * @memberof LogsApiNetworksNetworkIdLogsSearchGet
     */
    readonly filters?: string

    /**
     * Maximum number of hits returned. Defaults to 10.
     * @type {string}
     * @memberof LogsApiNetworksNetworkIdLogsSearchGet
     */
    readonly size?: string

    /**
     * The starting offset to fetch from the search hits. This param along with size can be used for pagination.
     * @type {string}
     * @memberof LogsApiNetworksNetworkIdLogsSearchGet
     */
    readonly from?: string

    /**
     * Time to start searching
     * @type {string}
     * @memberof LogsApiNetworksNetworkIdLogsSearchGet
     */
    readonly start?: string

    /**
     * Time to end searching
     * @type {string}
     * @memberof LogsApiNetworksNetworkIdLogsSearchGet
     */
    readonly end?: string
}

/**
 * LogsApi - object-oriented interface
 * @export
 * @class LogsApi
 * @extends {BaseAPI}
 */
export class LogsApi extends BaseAPI {
    /**
     * 
     * @summary List messages between ENODEBD and DP and between DP and SAS ordered by time
     * @param {LogsApiDpNetworkIdLogsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogsApi
     */
    public dpNetworkIdLogsGet(requestParameters: LogsApiDpNetworkIdLogsGetRequest, options?: AxiosRequestConfig) {
        return LogsApiFp(this.configuration).dpNetworkIdLogsGet(requestParameters.networkId, requestParameters.offset, requestParameters.limit, requestParameters.begin, requestParameters.end, requestParameters.serialNumber, requestParameters.fccId, requestParameters.type, requestParameters.responseCode, requestParameters.from, requestParameters.to, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Count logs
     * @param {LogsApiNetworksNetworkIdLogsCountGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogsApi
     */
    public networksNetworkIdLogsCountGet(requestParameters: LogsApiNetworksNetworkIdLogsCountGetRequest, options?: AxiosRequestConfig) {
        return LogsApiFp(this.configuration).networksNetworkIdLogsCountGet(requestParameters.networkId, requestParameters.simpleQuery, requestParameters.fields, requestParameters.filters, requestParameters.start, requestParameters.end, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search logs
     * @param {LogsApiNetworksNetworkIdLogsSearchGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogsApi
     */
    public networksNetworkIdLogsSearchGet(requestParameters: LogsApiNetworksNetworkIdLogsSearchGetRequest, options?: AxiosRequestConfig) {
        return LogsApiFp(this.configuration).networksNetworkIdLogsSearchGet(requestParameters.networkId, requestParameters.simpleQuery, requestParameters.fields, requestParameters.filters, requestParameters.size, requestParameters.from, requestParameters.start, requestParameters.end, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MetricsApi - axios parameter creator
 * @export
 */
export const MetricsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Submit metrics to orchestrator databases
         * @param {string} networkId Network ID
         * @param {Array<PushedMetric>} metrics Metrics to be submitted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdMetricsPushPost: async (networkId: string, metrics: Array<PushedMetric>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networksNetworkIdMetricsPushPost', 'networkId', networkId)
            // verify required parameter 'metrics' is not null or undefined
            assertParamExists('networksNetworkIdMetricsPushPost', 'metrics', metrics)
            const localVarPath = `/networks/{network_id}/metrics/push`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(metrics, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve the datapoints from a Prometheus Query
         * @param {string} networkId Network ID
         * @param {string} query PromQL query to proxy to prometheus
         * @param {string} [time] time for query (UnixTime or RFC3339)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdPrometheusQueryGet: async (networkId: string, query: string, time?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networksNetworkIdPrometheusQueryGet', 'networkId', networkId)
            // verify required parameter 'query' is not null or undefined
            assertParamExists('networksNetworkIdPrometheusQueryGet', 'query', query)
            const localVarPath = `/networks/{network_id}/prometheus/query`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (time !== undefined) {
                localVarQueryParameter['time'] = time;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve the datapoints from a Prometheus Query over a specified time range
         * @param {string} networkId Network ID
         * @param {string} query PromQL query to proxy to prometheus
         * @param {string} start start time of the requested range (UnixTime or RFC3339)
         * @param {string} [end] end time of the requested range (UnixTime or RFC3339)
         * @param {string} [step] query range resolution step width
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdPrometheusQueryRangeGet: async (networkId: string, query: string, start: string, end?: string, step?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networksNetworkIdPrometheusQueryRangeGet', 'networkId', networkId)
            // verify required parameter 'query' is not null or undefined
            assertParamExists('networksNetworkIdPrometheusQueryRangeGet', 'query', query)
            // verify required parameter 'start' is not null or undefined
            assertParamExists('networksNetworkIdPrometheusQueryRangeGet', 'start', start)
            const localVarPath = `/networks/{network_id}/prometheus/query_range`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = end;
            }

            if (step !== undefined) {
                localVarQueryParameter['step'] = step;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of metric series in prometheus database
         * @param {string} networkId Network ID
         * @param {Array<string>} [match] Matcher for metric series query
         * @param {string} [start] start time of the requested range (UnixTime or RFC3339)
         * @param {string} [end] end time of the requested range (UnixTime or RFC3339)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdPrometheusSeriesGet: async (networkId: string, match?: Array<string>, start?: string, end?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networksNetworkIdPrometheusSeriesGet', 'networkId', networkId)
            const localVarPath = `/networks/{network_id}/prometheus/series`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (match) {
                localVarQueryParameter['match'] = match.join(COLLECTION_FORMATS.ssv);
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = end;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve description of all metrics
         * @param {string} [matchTarget] Label selectors like {job &#x3D; \&quot;magma_pushgateway\&quot;} . All targets are selected if left empty
         * @param {string} [metric] A metric name to retrieve metadata for. All metric metadata is retrieved if left empty
         * @param {string} [limit] Maximum number of targets to match
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tenantsTargetsMetadataGet: async (matchTarget?: string, metric?: string, limit?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tenants/targets_metadata`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (matchTarget !== undefined) {
                localVarQueryParameter['match_target'] = matchTarget;
            }

            if (metric !== undefined) {
                localVarQueryParameter['metric'] = metric;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve list of label values for the given label name
         * @param {number} tenantId Tenant ID
         * @param {string} labelName Label name to get values of
         * @param {string} [start] start time of the requested range (UnixTime or RFC3339)
         * @param {string} [end] end time of the requested range (UnixTime or RFC3339)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tenantsTenantIdMetricsApiV1LabelLabelNameValuesGet: async (tenantId: number, labelName: string, start?: string, end?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantId' is not null or undefined
            assertParamExists('tenantsTenantIdMetricsApiV1LabelLabelNameValuesGet', 'tenantId', tenantId)
            // verify required parameter 'labelName' is not null or undefined
            assertParamExists('tenantsTenantIdMetricsApiV1LabelLabelNameValuesGet', 'labelName', labelName)
            const localVarPath = `/tenants/{tenant_id}/metrics/api/v1/label/{label_name}/values`
                .replace(`{${"tenant_id"}}`, encodeURIComponent(String(tenantId)))
                .replace(`{${"label_name"}}`, encodeURIComponent(String(labelName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = end;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve the datapoints from a Prometheus Query
         * @param {number} tenantId Tenant ID
         * @param {string} query PromQL query to proxy to prometheus
         * @param {string} [time] time for query (UnixTime or RFC3339)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tenantsTenantIdMetricsApiV1QueryGet: async (tenantId: number, query: string, time?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantId' is not null or undefined
            assertParamExists('tenantsTenantIdMetricsApiV1QueryGet', 'tenantId', tenantId)
            // verify required parameter 'query' is not null or undefined
            assertParamExists('tenantsTenantIdMetricsApiV1QueryGet', 'query', query)
            const localVarPath = `/tenants/{tenant_id}/metrics/api/v1/query`
                .replace(`{${"tenant_id"}}`, encodeURIComponent(String(tenantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (time !== undefined) {
                localVarQueryParameter['time'] = time;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve the datapoints from a Prometheus Query over a specified time range
         * @param {number} tenantId Tenant ID
         * @param {string} query PromQL query to proxy to prometheus
         * @param {string} start start time of the requested range (UnixTime or RFC3339)
         * @param {string} [end] end time of the requested range (UnixTime or RFC3339)
         * @param {string} [step] query range resolution step width
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tenantsTenantIdMetricsApiV1QueryRangeGet: async (tenantId: number, query: string, start: string, end?: string, step?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantId' is not null or undefined
            assertParamExists('tenantsTenantIdMetricsApiV1QueryRangeGet', 'tenantId', tenantId)
            // verify required parameter 'query' is not null or undefined
            assertParamExists('tenantsTenantIdMetricsApiV1QueryRangeGet', 'query', query)
            // verify required parameter 'start' is not null or undefined
            assertParamExists('tenantsTenantIdMetricsApiV1QueryRangeGet', 'start', start)
            const localVarPath = `/tenants/{tenant_id}/metrics/api/v1/query_range`
                .replace(`{${"tenant_id"}}`, encodeURIComponent(String(tenantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = end;
            }

            if (step !== undefined) {
                localVarQueryParameter['step'] = step;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of metric series in prometheus database
         * @param {number} tenantId Tenant ID
         * @param {Array<string>} [match] Matcher for metric series query
         * @param {string} [start] start time of the requested range (UnixTime or RFC3339)
         * @param {string} [end] end time of the requested range (UnixTime or RFC3339)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tenantsTenantIdMetricsApiV1SeriesGet: async (tenantId: number, match?: Array<string>, start?: string, end?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantId' is not null or undefined
            assertParamExists('tenantsTenantIdMetricsApiV1SeriesGet', 'tenantId', tenantId)
            const localVarPath = `/tenants/{tenant_id}/metrics/api/v1/series`
                .replace(`{${"tenant_id"}}`, encodeURIComponent(String(tenantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (match) {
                localVarQueryParameter['match[]'] = match.join(COLLECTION_FORMATS.ssv);
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = end;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve the datapoints from a Prometheus Query
         * @param {number} tenantId Tenant ID
         * @param {string} query PromQL query to proxy to prometheus
         * @param {string} [time] time for query (UnixTime or RFC3339)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tenantsTenantIdMetricsQueryGet: async (tenantId: number, query: string, time?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantId' is not null or undefined
            assertParamExists('tenantsTenantIdMetricsQueryGet', 'tenantId', tenantId)
            // verify required parameter 'query' is not null or undefined
            assertParamExists('tenantsTenantIdMetricsQueryGet', 'query', query)
            const localVarPath = `/tenants/{tenant_id}/metrics/query`
                .replace(`{${"tenant_id"}}`, encodeURIComponent(String(tenantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (time !== undefined) {
                localVarQueryParameter['time'] = time;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve the datapoints from a Prometheus Query over a specified time range
         * @param {number} tenantId Tenant ID
         * @param {string} query PromQL query to proxy to prometheus
         * @param {string} start start time of the requested range (UnixTime or RFC3339)
         * @param {string} [end] end time of the requested range (UnixTime or RFC3339)
         * @param {string} [step] query range resolution step width
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tenantsTenantIdMetricsQueryRangeGet: async (tenantId: number, query: string, start: string, end?: string, step?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantId' is not null or undefined
            assertParamExists('tenantsTenantIdMetricsQueryRangeGet', 'tenantId', tenantId)
            // verify required parameter 'query' is not null or undefined
            assertParamExists('tenantsTenantIdMetricsQueryRangeGet', 'query', query)
            // verify required parameter 'start' is not null or undefined
            assertParamExists('tenantsTenantIdMetricsQueryRangeGet', 'start', start)
            const localVarPath = `/tenants/{tenant_id}/metrics/query_range`
                .replace(`{${"tenant_id"}}`, encodeURIComponent(String(tenantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = end;
            }

            if (step !== undefined) {
                localVarQueryParameter['step'] = step;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of metric series in prometheus database
         * @param {number} tenantId Tenant ID
         * @param {Array<string>} [match] Matcher for metric series query
         * @param {string} [start] start time of the requested range (UnixTime or RFC3339)
         * @param {string} [end] end time of the requested range (UnixTime or RFC3339)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tenantsTenantIdMetricsSeriesGet: async (tenantId: number, match?: Array<string>, start?: string, end?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantId' is not null or undefined
            assertParamExists('tenantsTenantIdMetricsSeriesGet', 'tenantId', tenantId)
            const localVarPath = `/tenants/{tenant_id}/metrics/series`
                .replace(`{${"tenant_id"}}`, encodeURIComponent(String(tenantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (match) {
                localVarQueryParameter['match'] = match.join(COLLECTION_FORMATS.ssv);
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = end;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MetricsApi - functional programming interface
 * @export
 */
export const MetricsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MetricsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Submit metrics to orchestrator databases
         * @param {string} networkId Network ID
         * @param {Array<PushedMetric>} metrics Metrics to be submitted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksNetworkIdMetricsPushPost(networkId: string, metrics: Array<PushedMetric>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksNetworkIdMetricsPushPost(networkId, metrics, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve the datapoints from a Prometheus Query
         * @param {string} networkId Network ID
         * @param {string} query PromQL query to proxy to prometheus
         * @param {string} [time] time for query (UnixTime or RFC3339)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksNetworkIdPrometheusQueryGet(networkId: string, query: string, time?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PromqlReturnObject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksNetworkIdPrometheusQueryGet(networkId, query, time, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve the datapoints from a Prometheus Query over a specified time range
         * @param {string} networkId Network ID
         * @param {string} query PromQL query to proxy to prometheus
         * @param {string} start start time of the requested range (UnixTime or RFC3339)
         * @param {string} [end] end time of the requested range (UnixTime or RFC3339)
         * @param {string} [step] query range resolution step width
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksNetworkIdPrometheusQueryRangeGet(networkId: string, query: string, start: string, end?: string, step?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PromqlReturnObject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksNetworkIdPrometheusQueryRangeGet(networkId, query, start, end, step, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a list of metric series in prometheus database
         * @param {string} networkId Network ID
         * @param {Array<string>} [match] Matcher for metric series query
         * @param {string} [start] start time of the requested range (UnixTime or RFC3339)
         * @param {string} [end] end time of the requested range (UnixTime or RFC3339)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksNetworkIdPrometheusSeriesGet(networkId: string, match?: Array<string>, start?: string, end?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<{ [key: string]: string; }>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksNetworkIdPrometheusSeriesGet(networkId, match, start, end, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve description of all metrics
         * @param {string} [matchTarget] Label selectors like {job &#x3D; \&quot;magma_pushgateway\&quot;} . All targets are selected if left empty
         * @param {string} [metric] A metric name to retrieve metadata for. All metric metadata is retrieved if left empty
         * @param {string} [limit] Maximum number of targets to match
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tenantsTargetsMetadataGet(matchTarget?: string, metric?: string, limit?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PrometheusTargetsMetadata>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tenantsTargetsMetadataGet(matchTarget, metric, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve list of label values for the given label name
         * @param {number} tenantId Tenant ID
         * @param {string} labelName Label name to get values of
         * @param {string} [start] start time of the requested range (UnixTime or RFC3339)
         * @param {string} [end] end time of the requested range (UnixTime or RFC3339)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tenantsTenantIdMetricsApiV1LabelLabelNameValuesGet(tenantId: number, labelName: string, start?: string, end?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TenantsTenantIdMetricsApiV1LabelLabelNameValuesGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tenantsTenantIdMetricsApiV1LabelLabelNameValuesGet(tenantId, labelName, start, end, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve the datapoints from a Prometheus Query
         * @param {number} tenantId Tenant ID
         * @param {string} query PromQL query to proxy to prometheus
         * @param {string} [time] time for query (UnixTime or RFC3339)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tenantsTenantIdMetricsApiV1QueryGet(tenantId: number, query: string, time?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PromqlReturnObject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tenantsTenantIdMetricsApiV1QueryGet(tenantId, query, time, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve the datapoints from a Prometheus Query over a specified time range
         * @param {number} tenantId Tenant ID
         * @param {string} query PromQL query to proxy to prometheus
         * @param {string} start start time of the requested range (UnixTime or RFC3339)
         * @param {string} [end] end time of the requested range (UnixTime or RFC3339)
         * @param {string} [step] query range resolution step width
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tenantsTenantIdMetricsApiV1QueryRangeGet(tenantId: number, query: string, start: string, end?: string, step?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PromqlReturnObject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tenantsTenantIdMetricsApiV1QueryRangeGet(tenantId, query, start, end, step, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a list of metric series in prometheus database
         * @param {number} tenantId Tenant ID
         * @param {Array<string>} [match] Matcher for metric series query
         * @param {string} [start] start time of the requested range (UnixTime or RFC3339)
         * @param {string} [end] end time of the requested range (UnixTime or RFC3339)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tenantsTenantIdMetricsApiV1SeriesGet(tenantId: number, match?: Array<string>, start?: string, end?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<{ [key: string]: string; }>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tenantsTenantIdMetricsApiV1SeriesGet(tenantId, match, start, end, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve the datapoints from a Prometheus Query
         * @param {number} tenantId Tenant ID
         * @param {string} query PromQL query to proxy to prometheus
         * @param {string} [time] time for query (UnixTime or RFC3339)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tenantsTenantIdMetricsQueryGet(tenantId: number, query: string, time?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PromqlReturnObject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tenantsTenantIdMetricsQueryGet(tenantId, query, time, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve the datapoints from a Prometheus Query over a specified time range
         * @param {number} tenantId Tenant ID
         * @param {string} query PromQL query to proxy to prometheus
         * @param {string} start start time of the requested range (UnixTime or RFC3339)
         * @param {string} [end] end time of the requested range (UnixTime or RFC3339)
         * @param {string} [step] query range resolution step width
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tenantsTenantIdMetricsQueryRangeGet(tenantId: number, query: string, start: string, end?: string, step?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PromqlReturnObject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tenantsTenantIdMetricsQueryRangeGet(tenantId, query, start, end, step, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a list of metric series in prometheus database
         * @param {number} tenantId Tenant ID
         * @param {Array<string>} [match] Matcher for metric series query
         * @param {string} [start] start time of the requested range (UnixTime or RFC3339)
         * @param {string} [end] end time of the requested range (UnixTime or RFC3339)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tenantsTenantIdMetricsSeriesGet(tenantId: number, match?: Array<string>, start?: string, end?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<{ [key: string]: string; }>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tenantsTenantIdMetricsSeriesGet(tenantId, match, start, end, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MetricsApi - factory interface
 * @export
 */
export const MetricsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MetricsApiFp(configuration)
    return {
        /**
         * 
         * @summary Submit metrics to orchestrator databases
         * @param {string} networkId Network ID
         * @param {Array<PushedMetric>} metrics Metrics to be submitted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdMetricsPushPost(networkId: string, metrics: Array<PushedMetric>, options?: any): AxiosPromise<void> {
            return localVarFp.networksNetworkIdMetricsPushPost(networkId, metrics, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve the datapoints from a Prometheus Query
         * @param {string} networkId Network ID
         * @param {string} query PromQL query to proxy to prometheus
         * @param {string} [time] time for query (UnixTime or RFC3339)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdPrometheusQueryGet(networkId: string, query: string, time?: string, options?: any): AxiosPromise<PromqlReturnObject> {
            return localVarFp.networksNetworkIdPrometheusQueryGet(networkId, query, time, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve the datapoints from a Prometheus Query over a specified time range
         * @param {string} networkId Network ID
         * @param {string} query PromQL query to proxy to prometheus
         * @param {string} start start time of the requested range (UnixTime or RFC3339)
         * @param {string} [end] end time of the requested range (UnixTime or RFC3339)
         * @param {string} [step] query range resolution step width
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdPrometheusQueryRangeGet(networkId: string, query: string, start: string, end?: string, step?: string, options?: any): AxiosPromise<PromqlReturnObject> {
            return localVarFp.networksNetworkIdPrometheusQueryRangeGet(networkId, query, start, end, step, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a list of metric series in prometheus database
         * @param {string} networkId Network ID
         * @param {Array<string>} [match] Matcher for metric series query
         * @param {string} [start] start time of the requested range (UnixTime or RFC3339)
         * @param {string} [end] end time of the requested range (UnixTime or RFC3339)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdPrometheusSeriesGet(networkId: string, match?: Array<string>, start?: string, end?: string, options?: any): AxiosPromise<Array<{ [key: string]: string; }>> {
            return localVarFp.networksNetworkIdPrometheusSeriesGet(networkId, match, start, end, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve description of all metrics
         * @param {string} [matchTarget] Label selectors like {job &#x3D; \&quot;magma_pushgateway\&quot;} . All targets are selected if left empty
         * @param {string} [metric] A metric name to retrieve metadata for. All metric metadata is retrieved if left empty
         * @param {string} [limit] Maximum number of targets to match
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tenantsTargetsMetadataGet(matchTarget?: string, metric?: string, limit?: string, options?: any): AxiosPromise<Array<PrometheusTargetsMetadata>> {
            return localVarFp.tenantsTargetsMetadataGet(matchTarget, metric, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve list of label values for the given label name
         * @param {number} tenantId Tenant ID
         * @param {string} labelName Label name to get values of
         * @param {string} [start] start time of the requested range (UnixTime or RFC3339)
         * @param {string} [end] end time of the requested range (UnixTime or RFC3339)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tenantsTenantIdMetricsApiV1LabelLabelNameValuesGet(tenantId: number, labelName: string, start?: string, end?: string, options?: any): AxiosPromise<TenantsTenantIdMetricsApiV1LabelLabelNameValuesGet200Response> {
            return localVarFp.tenantsTenantIdMetricsApiV1LabelLabelNameValuesGet(tenantId, labelName, start, end, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve the datapoints from a Prometheus Query
         * @param {number} tenantId Tenant ID
         * @param {string} query PromQL query to proxy to prometheus
         * @param {string} [time] time for query (UnixTime or RFC3339)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tenantsTenantIdMetricsApiV1QueryGet(tenantId: number, query: string, time?: string, options?: any): AxiosPromise<PromqlReturnObject> {
            return localVarFp.tenantsTenantIdMetricsApiV1QueryGet(tenantId, query, time, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve the datapoints from a Prometheus Query over a specified time range
         * @param {number} tenantId Tenant ID
         * @param {string} query PromQL query to proxy to prometheus
         * @param {string} start start time of the requested range (UnixTime or RFC3339)
         * @param {string} [end] end time of the requested range (UnixTime or RFC3339)
         * @param {string} [step] query range resolution step width
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tenantsTenantIdMetricsApiV1QueryRangeGet(tenantId: number, query: string, start: string, end?: string, step?: string, options?: any): AxiosPromise<PromqlReturnObject> {
            return localVarFp.tenantsTenantIdMetricsApiV1QueryRangeGet(tenantId, query, start, end, step, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a list of metric series in prometheus database
         * @param {number} tenantId Tenant ID
         * @param {Array<string>} [match] Matcher for metric series query
         * @param {string} [start] start time of the requested range (UnixTime or RFC3339)
         * @param {string} [end] end time of the requested range (UnixTime or RFC3339)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tenantsTenantIdMetricsApiV1SeriesGet(tenantId: number, match?: Array<string>, start?: string, end?: string, options?: any): AxiosPromise<Array<{ [key: string]: string; }>> {
            return localVarFp.tenantsTenantIdMetricsApiV1SeriesGet(tenantId, match, start, end, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve the datapoints from a Prometheus Query
         * @param {number} tenantId Tenant ID
         * @param {string} query PromQL query to proxy to prometheus
         * @param {string} [time] time for query (UnixTime or RFC3339)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tenantsTenantIdMetricsQueryGet(tenantId: number, query: string, time?: string, options?: any): AxiosPromise<PromqlReturnObject> {
            return localVarFp.tenantsTenantIdMetricsQueryGet(tenantId, query, time, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve the datapoints from a Prometheus Query over a specified time range
         * @param {number} tenantId Tenant ID
         * @param {string} query PromQL query to proxy to prometheus
         * @param {string} start start time of the requested range (UnixTime or RFC3339)
         * @param {string} [end] end time of the requested range (UnixTime or RFC3339)
         * @param {string} [step] query range resolution step width
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tenantsTenantIdMetricsQueryRangeGet(tenantId: number, query: string, start: string, end?: string, step?: string, options?: any): AxiosPromise<PromqlReturnObject> {
            return localVarFp.tenantsTenantIdMetricsQueryRangeGet(tenantId, query, start, end, step, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a list of metric series in prometheus database
         * @param {number} tenantId Tenant ID
         * @param {Array<string>} [match] Matcher for metric series query
         * @param {string} [start] start time of the requested range (UnixTime or RFC3339)
         * @param {string} [end] end time of the requested range (UnixTime or RFC3339)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tenantsTenantIdMetricsSeriesGet(tenantId: number, match?: Array<string>, start?: string, end?: string, options?: any): AxiosPromise<Array<{ [key: string]: string; }>> {
            return localVarFp.tenantsTenantIdMetricsSeriesGet(tenantId, match, start, end, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for networksNetworkIdMetricsPushPost operation in MetricsApi.
 * @export
 * @interface MetricsApiNetworksNetworkIdMetricsPushPostRequest
 */
export interface MetricsApiNetworksNetworkIdMetricsPushPostRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof MetricsApiNetworksNetworkIdMetricsPushPost
     */
    readonly networkId: string

    /**
     * Metrics to be submitted
     * @type {Array<PushedMetric>}
     * @memberof MetricsApiNetworksNetworkIdMetricsPushPost
     */
    readonly metrics: Array<PushedMetric>
}

/**
 * Request parameters for networksNetworkIdPrometheusQueryGet operation in MetricsApi.
 * @export
 * @interface MetricsApiNetworksNetworkIdPrometheusQueryGetRequest
 */
export interface MetricsApiNetworksNetworkIdPrometheusQueryGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof MetricsApiNetworksNetworkIdPrometheusQueryGet
     */
    readonly networkId: string

    /**
     * PromQL query to proxy to prometheus
     * @type {string}
     * @memberof MetricsApiNetworksNetworkIdPrometheusQueryGet
     */
    readonly query: string

    /**
     * time for query (UnixTime or RFC3339)
     * @type {string}
     * @memberof MetricsApiNetworksNetworkIdPrometheusQueryGet
     */
    readonly time?: string
}

/**
 * Request parameters for networksNetworkIdPrometheusQueryRangeGet operation in MetricsApi.
 * @export
 * @interface MetricsApiNetworksNetworkIdPrometheusQueryRangeGetRequest
 */
export interface MetricsApiNetworksNetworkIdPrometheusQueryRangeGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof MetricsApiNetworksNetworkIdPrometheusQueryRangeGet
     */
    readonly networkId: string

    /**
     * PromQL query to proxy to prometheus
     * @type {string}
     * @memberof MetricsApiNetworksNetworkIdPrometheusQueryRangeGet
     */
    readonly query: string

    /**
     * start time of the requested range (UnixTime or RFC3339)
     * @type {string}
     * @memberof MetricsApiNetworksNetworkIdPrometheusQueryRangeGet
     */
    readonly start: string

    /**
     * end time of the requested range (UnixTime or RFC3339)
     * @type {string}
     * @memberof MetricsApiNetworksNetworkIdPrometheusQueryRangeGet
     */
    readonly end?: string

    /**
     * query range resolution step width
     * @type {string}
     * @memberof MetricsApiNetworksNetworkIdPrometheusQueryRangeGet
     */
    readonly step?: string
}

/**
 * Request parameters for networksNetworkIdPrometheusSeriesGet operation in MetricsApi.
 * @export
 * @interface MetricsApiNetworksNetworkIdPrometheusSeriesGetRequest
 */
export interface MetricsApiNetworksNetworkIdPrometheusSeriesGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof MetricsApiNetworksNetworkIdPrometheusSeriesGet
     */
    readonly networkId: string

    /**
     * Matcher for metric series query
     * @type {Array<string>}
     * @memberof MetricsApiNetworksNetworkIdPrometheusSeriesGet
     */
    readonly match?: Array<string>

    /**
     * start time of the requested range (UnixTime or RFC3339)
     * @type {string}
     * @memberof MetricsApiNetworksNetworkIdPrometheusSeriesGet
     */
    readonly start?: string

    /**
     * end time of the requested range (UnixTime or RFC3339)
     * @type {string}
     * @memberof MetricsApiNetworksNetworkIdPrometheusSeriesGet
     */
    readonly end?: string
}

/**
 * Request parameters for tenantsTargetsMetadataGet operation in MetricsApi.
 * @export
 * @interface MetricsApiTenantsTargetsMetadataGetRequest
 */
export interface MetricsApiTenantsTargetsMetadataGetRequest {
    /**
     * Label selectors like {job &#x3D; \&quot;magma_pushgateway\&quot;} . All targets are selected if left empty
     * @type {string}
     * @memberof MetricsApiTenantsTargetsMetadataGet
     */
    readonly matchTarget?: string

    /**
     * A metric name to retrieve metadata for. All metric metadata is retrieved if left empty
     * @type {string}
     * @memberof MetricsApiTenantsTargetsMetadataGet
     */
    readonly metric?: string

    /**
     * Maximum number of targets to match
     * @type {string}
     * @memberof MetricsApiTenantsTargetsMetadataGet
     */
    readonly limit?: string
}

/**
 * Request parameters for tenantsTenantIdMetricsApiV1LabelLabelNameValuesGet operation in MetricsApi.
 * @export
 * @interface MetricsApiTenantsTenantIdMetricsApiV1LabelLabelNameValuesGetRequest
 */
export interface MetricsApiTenantsTenantIdMetricsApiV1LabelLabelNameValuesGetRequest {
    /**
     * Tenant ID
     * @type {number}
     * @memberof MetricsApiTenantsTenantIdMetricsApiV1LabelLabelNameValuesGet
     */
    readonly tenantId: number

    /**
     * Label name to get values of
     * @type {string}
     * @memberof MetricsApiTenantsTenantIdMetricsApiV1LabelLabelNameValuesGet
     */
    readonly labelName: string

    /**
     * start time of the requested range (UnixTime or RFC3339)
     * @type {string}
     * @memberof MetricsApiTenantsTenantIdMetricsApiV1LabelLabelNameValuesGet
     */
    readonly start?: string

    /**
     * end time of the requested range (UnixTime or RFC3339)
     * @type {string}
     * @memberof MetricsApiTenantsTenantIdMetricsApiV1LabelLabelNameValuesGet
     */
    readonly end?: string
}

/**
 * Request parameters for tenantsTenantIdMetricsApiV1QueryGet operation in MetricsApi.
 * @export
 * @interface MetricsApiTenantsTenantIdMetricsApiV1QueryGetRequest
 */
export interface MetricsApiTenantsTenantIdMetricsApiV1QueryGetRequest {
    /**
     * Tenant ID
     * @type {number}
     * @memberof MetricsApiTenantsTenantIdMetricsApiV1QueryGet
     */
    readonly tenantId: number

    /**
     * PromQL query to proxy to prometheus
     * @type {string}
     * @memberof MetricsApiTenantsTenantIdMetricsApiV1QueryGet
     */
    readonly query: string

    /**
     * time for query (UnixTime or RFC3339)
     * @type {string}
     * @memberof MetricsApiTenantsTenantIdMetricsApiV1QueryGet
     */
    readonly time?: string
}

/**
 * Request parameters for tenantsTenantIdMetricsApiV1QueryRangeGet operation in MetricsApi.
 * @export
 * @interface MetricsApiTenantsTenantIdMetricsApiV1QueryRangeGetRequest
 */
export interface MetricsApiTenantsTenantIdMetricsApiV1QueryRangeGetRequest {
    /**
     * Tenant ID
     * @type {number}
     * @memberof MetricsApiTenantsTenantIdMetricsApiV1QueryRangeGet
     */
    readonly tenantId: number

    /**
     * PromQL query to proxy to prometheus
     * @type {string}
     * @memberof MetricsApiTenantsTenantIdMetricsApiV1QueryRangeGet
     */
    readonly query: string

    /**
     * start time of the requested range (UnixTime or RFC3339)
     * @type {string}
     * @memberof MetricsApiTenantsTenantIdMetricsApiV1QueryRangeGet
     */
    readonly start: string

    /**
     * end time of the requested range (UnixTime or RFC3339)
     * @type {string}
     * @memberof MetricsApiTenantsTenantIdMetricsApiV1QueryRangeGet
     */
    readonly end?: string

    /**
     * query range resolution step width
     * @type {string}
     * @memberof MetricsApiTenantsTenantIdMetricsApiV1QueryRangeGet
     */
    readonly step?: string
}

/**
 * Request parameters for tenantsTenantIdMetricsApiV1SeriesGet operation in MetricsApi.
 * @export
 * @interface MetricsApiTenantsTenantIdMetricsApiV1SeriesGetRequest
 */
export interface MetricsApiTenantsTenantIdMetricsApiV1SeriesGetRequest {
    /**
     * Tenant ID
     * @type {number}
     * @memberof MetricsApiTenantsTenantIdMetricsApiV1SeriesGet
     */
    readonly tenantId: number

    /**
     * Matcher for metric series query
     * @type {Array<string>}
     * @memberof MetricsApiTenantsTenantIdMetricsApiV1SeriesGet
     */
    readonly match?: Array<string>

    /**
     * start time of the requested range (UnixTime or RFC3339)
     * @type {string}
     * @memberof MetricsApiTenantsTenantIdMetricsApiV1SeriesGet
     */
    readonly start?: string

    /**
     * end time of the requested range (UnixTime or RFC3339)
     * @type {string}
     * @memberof MetricsApiTenantsTenantIdMetricsApiV1SeriesGet
     */
    readonly end?: string
}

/**
 * Request parameters for tenantsTenantIdMetricsQueryGet operation in MetricsApi.
 * @export
 * @interface MetricsApiTenantsTenantIdMetricsQueryGetRequest
 */
export interface MetricsApiTenantsTenantIdMetricsQueryGetRequest {
    /**
     * Tenant ID
     * @type {number}
     * @memberof MetricsApiTenantsTenantIdMetricsQueryGet
     */
    readonly tenantId: number

    /**
     * PromQL query to proxy to prometheus
     * @type {string}
     * @memberof MetricsApiTenantsTenantIdMetricsQueryGet
     */
    readonly query: string

    /**
     * time for query (UnixTime or RFC3339)
     * @type {string}
     * @memberof MetricsApiTenantsTenantIdMetricsQueryGet
     */
    readonly time?: string
}

/**
 * Request parameters for tenantsTenantIdMetricsQueryRangeGet operation in MetricsApi.
 * @export
 * @interface MetricsApiTenantsTenantIdMetricsQueryRangeGetRequest
 */
export interface MetricsApiTenantsTenantIdMetricsQueryRangeGetRequest {
    /**
     * Tenant ID
     * @type {number}
     * @memberof MetricsApiTenantsTenantIdMetricsQueryRangeGet
     */
    readonly tenantId: number

    /**
     * PromQL query to proxy to prometheus
     * @type {string}
     * @memberof MetricsApiTenantsTenantIdMetricsQueryRangeGet
     */
    readonly query: string

    /**
     * start time of the requested range (UnixTime or RFC3339)
     * @type {string}
     * @memberof MetricsApiTenantsTenantIdMetricsQueryRangeGet
     */
    readonly start: string

    /**
     * end time of the requested range (UnixTime or RFC3339)
     * @type {string}
     * @memberof MetricsApiTenantsTenantIdMetricsQueryRangeGet
     */
    readonly end?: string

    /**
     * query range resolution step width
     * @type {string}
     * @memberof MetricsApiTenantsTenantIdMetricsQueryRangeGet
     */
    readonly step?: string
}

/**
 * Request parameters for tenantsTenantIdMetricsSeriesGet operation in MetricsApi.
 * @export
 * @interface MetricsApiTenantsTenantIdMetricsSeriesGetRequest
 */
export interface MetricsApiTenantsTenantIdMetricsSeriesGetRequest {
    /**
     * Tenant ID
     * @type {number}
     * @memberof MetricsApiTenantsTenantIdMetricsSeriesGet
     */
    readonly tenantId: number

    /**
     * Matcher for metric series query
     * @type {Array<string>}
     * @memberof MetricsApiTenantsTenantIdMetricsSeriesGet
     */
    readonly match?: Array<string>

    /**
     * start time of the requested range (UnixTime or RFC3339)
     * @type {string}
     * @memberof MetricsApiTenantsTenantIdMetricsSeriesGet
     */
    readonly start?: string

    /**
     * end time of the requested range (UnixTime or RFC3339)
     * @type {string}
     * @memberof MetricsApiTenantsTenantIdMetricsSeriesGet
     */
    readonly end?: string
}

/**
 * MetricsApi - object-oriented interface
 * @export
 * @class MetricsApi
 * @extends {BaseAPI}
 */
export class MetricsApi extends BaseAPI {
    /**
     * 
     * @summary Submit metrics to orchestrator databases
     * @param {MetricsApiNetworksNetworkIdMetricsPushPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public networksNetworkIdMetricsPushPost(requestParameters: MetricsApiNetworksNetworkIdMetricsPushPostRequest, options?: AxiosRequestConfig) {
        return MetricsApiFp(this.configuration).networksNetworkIdMetricsPushPost(requestParameters.networkId, requestParameters.metrics, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve the datapoints from a Prometheus Query
     * @param {MetricsApiNetworksNetworkIdPrometheusQueryGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public networksNetworkIdPrometheusQueryGet(requestParameters: MetricsApiNetworksNetworkIdPrometheusQueryGetRequest, options?: AxiosRequestConfig) {
        return MetricsApiFp(this.configuration).networksNetworkIdPrometheusQueryGet(requestParameters.networkId, requestParameters.query, requestParameters.time, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve the datapoints from a Prometheus Query over a specified time range
     * @param {MetricsApiNetworksNetworkIdPrometheusQueryRangeGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public networksNetworkIdPrometheusQueryRangeGet(requestParameters: MetricsApiNetworksNetworkIdPrometheusQueryRangeGetRequest, options?: AxiosRequestConfig) {
        return MetricsApiFp(this.configuration).networksNetworkIdPrometheusQueryRangeGet(requestParameters.networkId, requestParameters.query, requestParameters.start, requestParameters.end, requestParameters.step, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a list of metric series in prometheus database
     * @param {MetricsApiNetworksNetworkIdPrometheusSeriesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public networksNetworkIdPrometheusSeriesGet(requestParameters: MetricsApiNetworksNetworkIdPrometheusSeriesGetRequest, options?: AxiosRequestConfig) {
        return MetricsApiFp(this.configuration).networksNetworkIdPrometheusSeriesGet(requestParameters.networkId, requestParameters.match, requestParameters.start, requestParameters.end, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve description of all metrics
     * @param {MetricsApiTenantsTargetsMetadataGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public tenantsTargetsMetadataGet(requestParameters: MetricsApiTenantsTargetsMetadataGetRequest = {}, options?: AxiosRequestConfig) {
        return MetricsApiFp(this.configuration).tenantsTargetsMetadataGet(requestParameters.matchTarget, requestParameters.metric, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve list of label values for the given label name
     * @param {MetricsApiTenantsTenantIdMetricsApiV1LabelLabelNameValuesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public tenantsTenantIdMetricsApiV1LabelLabelNameValuesGet(requestParameters: MetricsApiTenantsTenantIdMetricsApiV1LabelLabelNameValuesGetRequest, options?: AxiosRequestConfig) {
        return MetricsApiFp(this.configuration).tenantsTenantIdMetricsApiV1LabelLabelNameValuesGet(requestParameters.tenantId, requestParameters.labelName, requestParameters.start, requestParameters.end, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve the datapoints from a Prometheus Query
     * @param {MetricsApiTenantsTenantIdMetricsApiV1QueryGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public tenantsTenantIdMetricsApiV1QueryGet(requestParameters: MetricsApiTenantsTenantIdMetricsApiV1QueryGetRequest, options?: AxiosRequestConfig) {
        return MetricsApiFp(this.configuration).tenantsTenantIdMetricsApiV1QueryGet(requestParameters.tenantId, requestParameters.query, requestParameters.time, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve the datapoints from a Prometheus Query over a specified time range
     * @param {MetricsApiTenantsTenantIdMetricsApiV1QueryRangeGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public tenantsTenantIdMetricsApiV1QueryRangeGet(requestParameters: MetricsApiTenantsTenantIdMetricsApiV1QueryRangeGetRequest, options?: AxiosRequestConfig) {
        return MetricsApiFp(this.configuration).tenantsTenantIdMetricsApiV1QueryRangeGet(requestParameters.tenantId, requestParameters.query, requestParameters.start, requestParameters.end, requestParameters.step, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a list of metric series in prometheus database
     * @param {MetricsApiTenantsTenantIdMetricsApiV1SeriesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public tenantsTenantIdMetricsApiV1SeriesGet(requestParameters: MetricsApiTenantsTenantIdMetricsApiV1SeriesGetRequest, options?: AxiosRequestConfig) {
        return MetricsApiFp(this.configuration).tenantsTenantIdMetricsApiV1SeriesGet(requestParameters.tenantId, requestParameters.match, requestParameters.start, requestParameters.end, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve the datapoints from a Prometheus Query
     * @param {MetricsApiTenantsTenantIdMetricsQueryGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public tenantsTenantIdMetricsQueryGet(requestParameters: MetricsApiTenantsTenantIdMetricsQueryGetRequest, options?: AxiosRequestConfig) {
        return MetricsApiFp(this.configuration).tenantsTenantIdMetricsQueryGet(requestParameters.tenantId, requestParameters.query, requestParameters.time, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve the datapoints from a Prometheus Query over a specified time range
     * @param {MetricsApiTenantsTenantIdMetricsQueryRangeGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public tenantsTenantIdMetricsQueryRangeGet(requestParameters: MetricsApiTenantsTenantIdMetricsQueryRangeGetRequest, options?: AxiosRequestConfig) {
        return MetricsApiFp(this.configuration).tenantsTenantIdMetricsQueryRangeGet(requestParameters.tenantId, requestParameters.query, requestParameters.start, requestParameters.end, requestParameters.step, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a list of metric series in prometheus database
     * @param {MetricsApiTenantsTenantIdMetricsSeriesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public tenantsTenantIdMetricsSeriesGet(requestParameters: MetricsApiTenantsTenantIdMetricsSeriesGetRequest, options?: AxiosRequestConfig) {
        return MetricsApiFp(this.configuration).tenantsTenantIdMetricsSeriesGet(requestParameters.tenantId, requestParameters.match, requestParameters.start, requestParameters.end, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * NetworkProbesApi - axios parameter creator
 * @export
 */
export const NetworkProbesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove a NetworkProbe Destination from the network
         * @param {string} networkId Network ID
         * @param {string} destinationId Network Probe Destination ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdNetworkProbeDestinationsDestinationIdDelete: async (networkId: string, destinationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdNetworkProbeDestinationsDestinationIdDelete', 'networkId', networkId)
            // verify required parameter 'destinationId' is not null or undefined
            assertParamExists('lteNetworkIdNetworkProbeDestinationsDestinationIdDelete', 'destinationId', destinationId)
            const localVarPath = `/lte/{network_id}/network_probe/destinations/{destination_id}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"destination_id"}}`, encodeURIComponent(String(destinationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a NetworkProbe Destination
         * @param {string} networkId Network ID
         * @param {string} destinationId Network Probe Destination ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdNetworkProbeDestinationsDestinationIdGet: async (networkId: string, destinationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdNetworkProbeDestinationsDestinationIdGet', 'networkId', networkId)
            // verify required parameter 'destinationId' is not null or undefined
            assertParamExists('lteNetworkIdNetworkProbeDestinationsDestinationIdGet', 'destinationId', destinationId)
            const localVarPath = `/lte/{network_id}/network_probe/destinations/{destination_id}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"destination_id"}}`, encodeURIComponent(String(destinationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an existing NetworkProbe Destination in the network
         * @param {string} networkId Network ID
         * @param {string} destinationId Network Probe Destination ID
         * @param {NetworkProbeDestination} networkProbeDestination New NetworkProbeDestination configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdNetworkProbeDestinationsDestinationIdPut: async (networkId: string, destinationId: string, networkProbeDestination: NetworkProbeDestination, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdNetworkProbeDestinationsDestinationIdPut', 'networkId', networkId)
            // verify required parameter 'destinationId' is not null or undefined
            assertParamExists('lteNetworkIdNetworkProbeDestinationsDestinationIdPut', 'destinationId', destinationId)
            // verify required parameter 'networkProbeDestination' is not null or undefined
            assertParamExists('lteNetworkIdNetworkProbeDestinationsDestinationIdPut', 'networkProbeDestination', networkProbeDestination)
            const localVarPath = `/lte/{network_id}/network_probe/destinations/{destination_id}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"destination_id"}}`, encodeURIComponent(String(destinationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(networkProbeDestination, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List NetworkProbe Destinations in the network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdNetworkProbeDestinationsGet: async (networkId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdNetworkProbeDestinationsGet', 'networkId', networkId)
            const localVarPath = `/lte/{network_id}/network_probe/destinations`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add a new NetworkProbeDestination to the network
         * @param {string} networkId Network ID
         * @param {NetworkProbeDestination} networkProbeDestination 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdNetworkProbeDestinationsPost: async (networkId: string, networkProbeDestination: NetworkProbeDestination, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdNetworkProbeDestinationsPost', 'networkId', networkId)
            // verify required parameter 'networkProbeDestination' is not null or undefined
            assertParamExists('lteNetworkIdNetworkProbeDestinationsPost', 'networkProbeDestination', networkProbeDestination)
            const localVarPath = `/lte/{network_id}/network_probe/destinations`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(networkProbeDestination, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List NetworkProbeTask in the network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdNetworkProbeTasksGet: async (networkId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdNetworkProbeTasksGet', 'networkId', networkId)
            const localVarPath = `/lte/{network_id}/network_probe/tasks`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add a new NetworkProbeTask to the network
         * @param {string} networkId Network ID
         * @param {NetworkProbeTask} networkProbeTask 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdNetworkProbeTasksPost: async (networkId: string, networkProbeTask: NetworkProbeTask, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdNetworkProbeTasksPost', 'networkId', networkId)
            // verify required parameter 'networkProbeTask' is not null or undefined
            assertParamExists('lteNetworkIdNetworkProbeTasksPost', 'networkProbeTask', networkProbeTask)
            const localVarPath = `/lte/{network_id}/network_probe/tasks`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(networkProbeTask, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove an NetworkProbeTask from the network
         * @param {string} networkId Network ID
         * @param {string} taskId Network Probe Task ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdNetworkProbeTasksTaskIdDelete: async (networkId: string, taskId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdNetworkProbeTasksTaskIdDelete', 'networkId', networkId)
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('lteNetworkIdNetworkProbeTasksTaskIdDelete', 'taskId', taskId)
            const localVarPath = `/lte/{network_id}/network_probe/tasks/{task_id}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"task_id"}}`, encodeURIComponent(String(taskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve the NetworkProbeTask info
         * @param {string} networkId Network ID
         * @param {string} taskId Network Probe Task ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdNetworkProbeTasksTaskIdGet: async (networkId: string, taskId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdNetworkProbeTasksTaskIdGet', 'networkId', networkId)
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('lteNetworkIdNetworkProbeTasksTaskIdGet', 'taskId', taskId)
            const localVarPath = `/lte/{network_id}/network_probe/tasks/{task_id}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"task_id"}}`, encodeURIComponent(String(taskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an existing NetworkProbeTask in the network
         * @param {string} networkId Network ID
         * @param {string} taskId Network Probe Task ID
         * @param {NetworkProbeTask} networkProbeTask New NetworkProbeTask configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdNetworkProbeTasksTaskIdPut: async (networkId: string, taskId: string, networkProbeTask: NetworkProbeTask, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdNetworkProbeTasksTaskIdPut', 'networkId', networkId)
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('lteNetworkIdNetworkProbeTasksTaskIdPut', 'taskId', taskId)
            // verify required parameter 'networkProbeTask' is not null or undefined
            assertParamExists('lteNetworkIdNetworkProbeTasksTaskIdPut', 'networkProbeTask', networkProbeTask)
            const localVarPath = `/lte/{network_id}/network_probe/tasks/{task_id}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"task_id"}}`, encodeURIComponent(String(taskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(networkProbeTask, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NetworkProbesApi - functional programming interface
 * @export
 */
export const NetworkProbesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NetworkProbesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove a NetworkProbe Destination from the network
         * @param {string} networkId Network ID
         * @param {string} destinationId Network Probe Destination ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdNetworkProbeDestinationsDestinationIdDelete(networkId: string, destinationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdNetworkProbeDestinationsDestinationIdDelete(networkId, destinationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve a NetworkProbe Destination
         * @param {string} networkId Network ID
         * @param {string} destinationId Network Probe Destination ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdNetworkProbeDestinationsDestinationIdGet(networkId: string, destinationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NetworkProbeDestination>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdNetworkProbeDestinationsDestinationIdGet(networkId, destinationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update an existing NetworkProbe Destination in the network
         * @param {string} networkId Network ID
         * @param {string} destinationId Network Probe Destination ID
         * @param {NetworkProbeDestination} networkProbeDestination New NetworkProbeDestination configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdNetworkProbeDestinationsDestinationIdPut(networkId: string, destinationId: string, networkProbeDestination: NetworkProbeDestination, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdNetworkProbeDestinationsDestinationIdPut(networkId, destinationId, networkProbeDestination, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List NetworkProbe Destinations in the network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdNetworkProbeDestinationsGet(networkId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NetworkProbeDestination>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdNetworkProbeDestinationsGet(networkId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add a new NetworkProbeDestination to the network
         * @param {string} networkId Network ID
         * @param {NetworkProbeDestination} networkProbeDestination 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdNetworkProbeDestinationsPost(networkId: string, networkProbeDestination: NetworkProbeDestination, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdNetworkProbeDestinationsPost(networkId, networkProbeDestination, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List NetworkProbeTask in the network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdNetworkProbeTasksGet(networkId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NetworkProbeTask>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdNetworkProbeTasksGet(networkId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add a new NetworkProbeTask to the network
         * @param {string} networkId Network ID
         * @param {NetworkProbeTask} networkProbeTask 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdNetworkProbeTasksPost(networkId: string, networkProbeTask: NetworkProbeTask, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdNetworkProbeTasksPost(networkId, networkProbeTask, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove an NetworkProbeTask from the network
         * @param {string} networkId Network ID
         * @param {string} taskId Network Probe Task ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdNetworkProbeTasksTaskIdDelete(networkId: string, taskId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdNetworkProbeTasksTaskIdDelete(networkId, taskId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve the NetworkProbeTask info
         * @param {string} networkId Network ID
         * @param {string} taskId Network Probe Task ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdNetworkProbeTasksTaskIdGet(networkId: string, taskId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NetworkProbeTask>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdNetworkProbeTasksTaskIdGet(networkId, taskId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update an existing NetworkProbeTask in the network
         * @param {string} networkId Network ID
         * @param {string} taskId Network Probe Task ID
         * @param {NetworkProbeTask} networkProbeTask New NetworkProbeTask configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdNetworkProbeTasksTaskIdPut(networkId: string, taskId: string, networkProbeTask: NetworkProbeTask, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdNetworkProbeTasksTaskIdPut(networkId, taskId, networkProbeTask, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * NetworkProbesApi - factory interface
 * @export
 */
export const NetworkProbesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NetworkProbesApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove a NetworkProbe Destination from the network
         * @param {string} networkId Network ID
         * @param {string} destinationId Network Probe Destination ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdNetworkProbeDestinationsDestinationIdDelete(networkId: string, destinationId: string, options?: any): AxiosPromise<void> {
            return localVarFp.lteNetworkIdNetworkProbeDestinationsDestinationIdDelete(networkId, destinationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a NetworkProbe Destination
         * @param {string} networkId Network ID
         * @param {string} destinationId Network Probe Destination ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdNetworkProbeDestinationsDestinationIdGet(networkId: string, destinationId: string, options?: any): AxiosPromise<NetworkProbeDestination> {
            return localVarFp.lteNetworkIdNetworkProbeDestinationsDestinationIdGet(networkId, destinationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an existing NetworkProbe Destination in the network
         * @param {string} networkId Network ID
         * @param {string} destinationId Network Probe Destination ID
         * @param {NetworkProbeDestination} networkProbeDestination New NetworkProbeDestination configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdNetworkProbeDestinationsDestinationIdPut(networkId: string, destinationId: string, networkProbeDestination: NetworkProbeDestination, options?: any): AxiosPromise<void> {
            return localVarFp.lteNetworkIdNetworkProbeDestinationsDestinationIdPut(networkId, destinationId, networkProbeDestination, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List NetworkProbe Destinations in the network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdNetworkProbeDestinationsGet(networkId: string, options?: any): AxiosPromise<NetworkProbeDestination> {
            return localVarFp.lteNetworkIdNetworkProbeDestinationsGet(networkId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add a new NetworkProbeDestination to the network
         * @param {string} networkId Network ID
         * @param {NetworkProbeDestination} networkProbeDestination 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdNetworkProbeDestinationsPost(networkId: string, networkProbeDestination: NetworkProbeDestination, options?: any): AxiosPromise<void> {
            return localVarFp.lteNetworkIdNetworkProbeDestinationsPost(networkId, networkProbeDestination, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List NetworkProbeTask in the network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdNetworkProbeTasksGet(networkId: string, options?: any): AxiosPromise<NetworkProbeTask> {
            return localVarFp.lteNetworkIdNetworkProbeTasksGet(networkId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add a new NetworkProbeTask to the network
         * @param {string} networkId Network ID
         * @param {NetworkProbeTask} networkProbeTask 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdNetworkProbeTasksPost(networkId: string, networkProbeTask: NetworkProbeTask, options?: any): AxiosPromise<void> {
            return localVarFp.lteNetworkIdNetworkProbeTasksPost(networkId, networkProbeTask, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove an NetworkProbeTask from the network
         * @param {string} networkId Network ID
         * @param {string} taskId Network Probe Task ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdNetworkProbeTasksTaskIdDelete(networkId: string, taskId: string, options?: any): AxiosPromise<void> {
            return localVarFp.lteNetworkIdNetworkProbeTasksTaskIdDelete(networkId, taskId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve the NetworkProbeTask info
         * @param {string} networkId Network ID
         * @param {string} taskId Network Probe Task ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdNetworkProbeTasksTaskIdGet(networkId: string, taskId: string, options?: any): AxiosPromise<NetworkProbeTask> {
            return localVarFp.lteNetworkIdNetworkProbeTasksTaskIdGet(networkId, taskId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an existing NetworkProbeTask in the network
         * @param {string} networkId Network ID
         * @param {string} taskId Network Probe Task ID
         * @param {NetworkProbeTask} networkProbeTask New NetworkProbeTask configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdNetworkProbeTasksTaskIdPut(networkId: string, taskId: string, networkProbeTask: NetworkProbeTask, options?: any): AxiosPromise<void> {
            return localVarFp.lteNetworkIdNetworkProbeTasksTaskIdPut(networkId, taskId, networkProbeTask, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for lteNetworkIdNetworkProbeDestinationsDestinationIdDelete operation in NetworkProbesApi.
 * @export
 * @interface NetworkProbesApiLteNetworkIdNetworkProbeDestinationsDestinationIdDeleteRequest
 */
export interface NetworkProbesApiLteNetworkIdNetworkProbeDestinationsDestinationIdDeleteRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof NetworkProbesApiLteNetworkIdNetworkProbeDestinationsDestinationIdDelete
     */
    readonly networkId: string

    /**
     * Network Probe Destination ID
     * @type {string}
     * @memberof NetworkProbesApiLteNetworkIdNetworkProbeDestinationsDestinationIdDelete
     */
    readonly destinationId: string
}

/**
 * Request parameters for lteNetworkIdNetworkProbeDestinationsDestinationIdGet operation in NetworkProbesApi.
 * @export
 * @interface NetworkProbesApiLteNetworkIdNetworkProbeDestinationsDestinationIdGetRequest
 */
export interface NetworkProbesApiLteNetworkIdNetworkProbeDestinationsDestinationIdGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof NetworkProbesApiLteNetworkIdNetworkProbeDestinationsDestinationIdGet
     */
    readonly networkId: string

    /**
     * Network Probe Destination ID
     * @type {string}
     * @memberof NetworkProbesApiLteNetworkIdNetworkProbeDestinationsDestinationIdGet
     */
    readonly destinationId: string
}

/**
 * Request parameters for lteNetworkIdNetworkProbeDestinationsDestinationIdPut operation in NetworkProbesApi.
 * @export
 * @interface NetworkProbesApiLteNetworkIdNetworkProbeDestinationsDestinationIdPutRequest
 */
export interface NetworkProbesApiLteNetworkIdNetworkProbeDestinationsDestinationIdPutRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof NetworkProbesApiLteNetworkIdNetworkProbeDestinationsDestinationIdPut
     */
    readonly networkId: string

    /**
     * Network Probe Destination ID
     * @type {string}
     * @memberof NetworkProbesApiLteNetworkIdNetworkProbeDestinationsDestinationIdPut
     */
    readonly destinationId: string

    /**
     * New NetworkProbeDestination configuration
     * @type {NetworkProbeDestination}
     * @memberof NetworkProbesApiLteNetworkIdNetworkProbeDestinationsDestinationIdPut
     */
    readonly networkProbeDestination: NetworkProbeDestination
}

/**
 * Request parameters for lteNetworkIdNetworkProbeDestinationsGet operation in NetworkProbesApi.
 * @export
 * @interface NetworkProbesApiLteNetworkIdNetworkProbeDestinationsGetRequest
 */
export interface NetworkProbesApiLteNetworkIdNetworkProbeDestinationsGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof NetworkProbesApiLteNetworkIdNetworkProbeDestinationsGet
     */
    readonly networkId: string
}

/**
 * Request parameters for lteNetworkIdNetworkProbeDestinationsPost operation in NetworkProbesApi.
 * @export
 * @interface NetworkProbesApiLteNetworkIdNetworkProbeDestinationsPostRequest
 */
export interface NetworkProbesApiLteNetworkIdNetworkProbeDestinationsPostRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof NetworkProbesApiLteNetworkIdNetworkProbeDestinationsPost
     */
    readonly networkId: string

    /**
     * 
     * @type {NetworkProbeDestination}
     * @memberof NetworkProbesApiLteNetworkIdNetworkProbeDestinationsPost
     */
    readonly networkProbeDestination: NetworkProbeDestination
}

/**
 * Request parameters for lteNetworkIdNetworkProbeTasksGet operation in NetworkProbesApi.
 * @export
 * @interface NetworkProbesApiLteNetworkIdNetworkProbeTasksGetRequest
 */
export interface NetworkProbesApiLteNetworkIdNetworkProbeTasksGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof NetworkProbesApiLteNetworkIdNetworkProbeTasksGet
     */
    readonly networkId: string
}

/**
 * Request parameters for lteNetworkIdNetworkProbeTasksPost operation in NetworkProbesApi.
 * @export
 * @interface NetworkProbesApiLteNetworkIdNetworkProbeTasksPostRequest
 */
export interface NetworkProbesApiLteNetworkIdNetworkProbeTasksPostRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof NetworkProbesApiLteNetworkIdNetworkProbeTasksPost
     */
    readonly networkId: string

    /**
     * 
     * @type {NetworkProbeTask}
     * @memberof NetworkProbesApiLteNetworkIdNetworkProbeTasksPost
     */
    readonly networkProbeTask: NetworkProbeTask
}

/**
 * Request parameters for lteNetworkIdNetworkProbeTasksTaskIdDelete operation in NetworkProbesApi.
 * @export
 * @interface NetworkProbesApiLteNetworkIdNetworkProbeTasksTaskIdDeleteRequest
 */
export interface NetworkProbesApiLteNetworkIdNetworkProbeTasksTaskIdDeleteRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof NetworkProbesApiLteNetworkIdNetworkProbeTasksTaskIdDelete
     */
    readonly networkId: string

    /**
     * Network Probe Task ID
     * @type {string}
     * @memberof NetworkProbesApiLteNetworkIdNetworkProbeTasksTaskIdDelete
     */
    readonly taskId: string
}

/**
 * Request parameters for lteNetworkIdNetworkProbeTasksTaskIdGet operation in NetworkProbesApi.
 * @export
 * @interface NetworkProbesApiLteNetworkIdNetworkProbeTasksTaskIdGetRequest
 */
export interface NetworkProbesApiLteNetworkIdNetworkProbeTasksTaskIdGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof NetworkProbesApiLteNetworkIdNetworkProbeTasksTaskIdGet
     */
    readonly networkId: string

    /**
     * Network Probe Task ID
     * @type {string}
     * @memberof NetworkProbesApiLteNetworkIdNetworkProbeTasksTaskIdGet
     */
    readonly taskId: string
}

/**
 * Request parameters for lteNetworkIdNetworkProbeTasksTaskIdPut operation in NetworkProbesApi.
 * @export
 * @interface NetworkProbesApiLteNetworkIdNetworkProbeTasksTaskIdPutRequest
 */
export interface NetworkProbesApiLteNetworkIdNetworkProbeTasksTaskIdPutRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof NetworkProbesApiLteNetworkIdNetworkProbeTasksTaskIdPut
     */
    readonly networkId: string

    /**
     * Network Probe Task ID
     * @type {string}
     * @memberof NetworkProbesApiLteNetworkIdNetworkProbeTasksTaskIdPut
     */
    readonly taskId: string

    /**
     * New NetworkProbeTask configuration
     * @type {NetworkProbeTask}
     * @memberof NetworkProbesApiLteNetworkIdNetworkProbeTasksTaskIdPut
     */
    readonly networkProbeTask: NetworkProbeTask
}

/**
 * NetworkProbesApi - object-oriented interface
 * @export
 * @class NetworkProbesApi
 * @extends {BaseAPI}
 */
export class NetworkProbesApi extends BaseAPI {
    /**
     * 
     * @summary Remove a NetworkProbe Destination from the network
     * @param {NetworkProbesApiLteNetworkIdNetworkProbeDestinationsDestinationIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkProbesApi
     */
    public lteNetworkIdNetworkProbeDestinationsDestinationIdDelete(requestParameters: NetworkProbesApiLteNetworkIdNetworkProbeDestinationsDestinationIdDeleteRequest, options?: AxiosRequestConfig) {
        return NetworkProbesApiFp(this.configuration).lteNetworkIdNetworkProbeDestinationsDestinationIdDelete(requestParameters.networkId, requestParameters.destinationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a NetworkProbe Destination
     * @param {NetworkProbesApiLteNetworkIdNetworkProbeDestinationsDestinationIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkProbesApi
     */
    public lteNetworkIdNetworkProbeDestinationsDestinationIdGet(requestParameters: NetworkProbesApiLteNetworkIdNetworkProbeDestinationsDestinationIdGetRequest, options?: AxiosRequestConfig) {
        return NetworkProbesApiFp(this.configuration).lteNetworkIdNetworkProbeDestinationsDestinationIdGet(requestParameters.networkId, requestParameters.destinationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an existing NetworkProbe Destination in the network
     * @param {NetworkProbesApiLteNetworkIdNetworkProbeDestinationsDestinationIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkProbesApi
     */
    public lteNetworkIdNetworkProbeDestinationsDestinationIdPut(requestParameters: NetworkProbesApiLteNetworkIdNetworkProbeDestinationsDestinationIdPutRequest, options?: AxiosRequestConfig) {
        return NetworkProbesApiFp(this.configuration).lteNetworkIdNetworkProbeDestinationsDestinationIdPut(requestParameters.networkId, requestParameters.destinationId, requestParameters.networkProbeDestination, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List NetworkProbe Destinations in the network
     * @param {NetworkProbesApiLteNetworkIdNetworkProbeDestinationsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkProbesApi
     */
    public lteNetworkIdNetworkProbeDestinationsGet(requestParameters: NetworkProbesApiLteNetworkIdNetworkProbeDestinationsGetRequest, options?: AxiosRequestConfig) {
        return NetworkProbesApiFp(this.configuration).lteNetworkIdNetworkProbeDestinationsGet(requestParameters.networkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add a new NetworkProbeDestination to the network
     * @param {NetworkProbesApiLteNetworkIdNetworkProbeDestinationsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkProbesApi
     */
    public lteNetworkIdNetworkProbeDestinationsPost(requestParameters: NetworkProbesApiLteNetworkIdNetworkProbeDestinationsPostRequest, options?: AxiosRequestConfig) {
        return NetworkProbesApiFp(this.configuration).lteNetworkIdNetworkProbeDestinationsPost(requestParameters.networkId, requestParameters.networkProbeDestination, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List NetworkProbeTask in the network
     * @param {NetworkProbesApiLteNetworkIdNetworkProbeTasksGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkProbesApi
     */
    public lteNetworkIdNetworkProbeTasksGet(requestParameters: NetworkProbesApiLteNetworkIdNetworkProbeTasksGetRequest, options?: AxiosRequestConfig) {
        return NetworkProbesApiFp(this.configuration).lteNetworkIdNetworkProbeTasksGet(requestParameters.networkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add a new NetworkProbeTask to the network
     * @param {NetworkProbesApiLteNetworkIdNetworkProbeTasksPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkProbesApi
     */
    public lteNetworkIdNetworkProbeTasksPost(requestParameters: NetworkProbesApiLteNetworkIdNetworkProbeTasksPostRequest, options?: AxiosRequestConfig) {
        return NetworkProbesApiFp(this.configuration).lteNetworkIdNetworkProbeTasksPost(requestParameters.networkId, requestParameters.networkProbeTask, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove an NetworkProbeTask from the network
     * @param {NetworkProbesApiLteNetworkIdNetworkProbeTasksTaskIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkProbesApi
     */
    public lteNetworkIdNetworkProbeTasksTaskIdDelete(requestParameters: NetworkProbesApiLteNetworkIdNetworkProbeTasksTaskIdDeleteRequest, options?: AxiosRequestConfig) {
        return NetworkProbesApiFp(this.configuration).lteNetworkIdNetworkProbeTasksTaskIdDelete(requestParameters.networkId, requestParameters.taskId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve the NetworkProbeTask info
     * @param {NetworkProbesApiLteNetworkIdNetworkProbeTasksTaskIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkProbesApi
     */
    public lteNetworkIdNetworkProbeTasksTaskIdGet(requestParameters: NetworkProbesApiLteNetworkIdNetworkProbeTasksTaskIdGetRequest, options?: AxiosRequestConfig) {
        return NetworkProbesApiFp(this.configuration).lteNetworkIdNetworkProbeTasksTaskIdGet(requestParameters.networkId, requestParameters.taskId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an existing NetworkProbeTask in the network
     * @param {NetworkProbesApiLteNetworkIdNetworkProbeTasksTaskIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkProbesApi
     */
    public lteNetworkIdNetworkProbeTasksTaskIdPut(requestParameters: NetworkProbesApiLteNetworkIdNetworkProbeTasksTaskIdPutRequest, options?: AxiosRequestConfig) {
        return NetworkProbesApiFp(this.configuration).lteNetworkIdNetworkProbeTasksTaskIdPut(requestParameters.networkId, requestParameters.taskId, requestParameters.networkProbeTask, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * NetworksApi - axios parameter creator
 * @export
 */
export const NetworksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List all network IDs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/networks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdDelete: async (networkId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networksNetworkIdDelete', 'networkId', networkId)
            const localVarPath = `/networks/{network_id}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the description of a network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdDescriptionGet: async (networkId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networksNetworkIdDescriptionGet', 'networkId', networkId)
            const localVarPath = `/networks/{network_id}/description`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the description of a network
         * @param {string} networkId Network ID
         * @param {string} description New name for the network
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdDescriptionPut: async (networkId: string, description: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networksNetworkIdDescriptionPut', 'networkId', networkId)
            // verify required parameter 'description' is not null or undefined
            assertParamExists('networksNetworkIdDescriptionPut', 'description', description)
            const localVarPath = `/networks/{network_id}/description`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(description, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get DNS of network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdDnsGet: async (networkId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networksNetworkIdDnsGet', 'networkId', networkId)
            const localVarPath = `/networks/{network_id}/dns`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update DNS of network
         * @param {string} networkId Network ID
         * @param {NetworkDnsConfig} networkDNS New DNS configuration for the network
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdDnsPut: async (networkId: string, networkDNS: NetworkDnsConfig, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networksNetworkIdDnsPut', 'networkId', networkId)
            // verify required parameter 'networkDNS' is not null or undefined
            assertParamExists('networksNetworkIdDnsPut', 'networkDNS', networkDNS)
            const localVarPath = `/networks/{network_id}/dns`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(networkDNS, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete the DNS record for a specific domain
         * @param {string} networkId Network ID
         * @param {string} domain DNS record domain
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdDnsRecordsDomainDelete: async (networkId: string, domain: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networksNetworkIdDnsRecordsDomainDelete', 'networkId', networkId)
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('networksNetworkIdDnsRecordsDomainDelete', 'domain', domain)
            const localVarPath = `/networks/{network_id}/dns/records/{domain}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the DNS config record for a specific domain
         * @param {string} networkId Network ID
         * @param {string} domain DNS record domain
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdDnsRecordsDomainGet: async (networkId: string, domain: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networksNetworkIdDnsRecordsDomainGet', 'networkId', networkId)
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('networksNetworkIdDnsRecordsDomainGet', 'domain', domain)
            const localVarPath = `/networks/{network_id}/dns/records/{domain}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a DNS record for a specific domain
         * @param {string} networkId Network ID
         * @param {string} domain DNS record domain
         * @param {DnsConfigRecord} record Custom DNS record for the domain
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdDnsRecordsDomainPost: async (networkId: string, domain: string, record: DnsConfigRecord, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networksNetworkIdDnsRecordsDomainPost', 'networkId', networkId)
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('networksNetworkIdDnsRecordsDomainPost', 'domain', domain)
            // verify required parameter 'record' is not null or undefined
            assertParamExists('networksNetworkIdDnsRecordsDomainPost', 'record', record)
            const localVarPath = `/networks/{network_id}/dns/records/{domain}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(record, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a DNS record for a specific domain
         * @param {string} networkId Network ID
         * @param {string} domain DNS record domain
         * @param {DnsConfigRecord} record Custom DNS record for the domain
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdDnsRecordsDomainPut: async (networkId: string, domain: string, record: DnsConfigRecord, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networksNetworkIdDnsRecordsDomainPut', 'networkId', networkId)
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('networksNetworkIdDnsRecordsDomainPut', 'domain', domain)
            // verify required parameter 'record' is not null or undefined
            assertParamExists('networksNetworkIdDnsRecordsDomainPut', 'record', record)
            const localVarPath = `/networks/{network_id}/dns/records/{domain}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(record, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the DNS config records for the network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdDnsRecordsGet: async (networkId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networksNetworkIdDnsRecordsGet', 'networkId', networkId)
            const localVarPath = `/networks/{network_id}/dns/records`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Change all the DNS records for the network
         * @param {string} networkId Network ID
         * @param {Array<DnsConfigRecord>} records Custom DNS records for the network
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdDnsRecordsPut: async (networkId: string, records: Array<DnsConfigRecord>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networksNetworkIdDnsRecordsPut', 'networkId', networkId)
            // verify required parameter 'records' is not null or undefined
            assertParamExists('networksNetworkIdDnsRecordsPut', 'records', records)
            const localVarPath = `/networks/{network_id}/dns/records`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(records, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get feature flags for network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdFeaturesGet: async (networkId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networksNetworkIdFeaturesGet', 'networkId', networkId)
            const localVarPath = `/networks/{network_id}/features`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update feature flags for network
         * @param {string} networkId Network ID
         * @param {NetworkFeatures} networkFeatures New network features for the network
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdFeaturesPut: async (networkId: string, networkFeatures: NetworkFeatures, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networksNetworkIdFeaturesPut', 'networkId', networkId)
            // verify required parameter 'networkFeatures' is not null or undefined
            assertParamExists('networksNetworkIdFeaturesPut', 'networkFeatures', networkFeatures)
            const localVarPath = `/networks/{network_id}/features`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(networkFeatures, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a generic network description
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdGet: async (networkId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networksNetworkIdGet', 'networkId', networkId)
            const localVarPath = `/networks/{network_id}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the name of a network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdNameGet: async (networkId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networksNetworkIdNameGet', 'networkId', networkId)
            const localVarPath = `/networks/{network_id}/name`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the name of a network
         * @param {string} networkId Network ID
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdNamePut: async (networkId: string, name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networksNetworkIdNamePut', 'networkId', networkId)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('networksNetworkIdNamePut', 'name', name)
            const localVarPath = `/networks/{network_id}/name`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(name, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an entire network
         * @param {string} networkId Network ID
         * @param {Network} network Full desired configuration of the network
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdPut: async (networkId: string, network: Network, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networksNetworkIdPut', 'networkId', networkId)
            // verify required parameter 'network' is not null or undefined
            assertParamExists('networksNetworkIdPut', 'network', network)
            const localVarPath = `/networks/{network_id}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(network, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the Sentry.io configuration for network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdSentryGet: async (networkId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networksNetworkIdSentryGet', 'networkId', networkId)
            const localVarPath = `/networks/{network_id}/sentry`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the Sentry.io configuration for network
         * @param {string} networkId Network ID
         * @param {NetworkSentryConfig} networkSentryConfig 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdSentryPut: async (networkId: string, networkSentryConfig: NetworkSentryConfig, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networksNetworkIdSentryPut', 'networkId', networkId)
            // verify required parameter 'networkSentryConfig' is not null or undefined
            assertParamExists('networksNetworkIdSentryPut', 'networkSentryConfig', networkSentryConfig)
            const localVarPath = `/networks/{network_id}/sentry`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(networkSentryConfig, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the state configuration for network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdStateGet: async (networkId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networksNetworkIdStateGet', 'networkId', networkId)
            const localVarPath = `/networks/{network_id}/state`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the state configuration for network
         * @param {string} networkId Network ID
         * @param {StateConfig} stateConfig 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdStatePut: async (networkId: string, stateConfig: StateConfig, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networksNetworkIdStatePut', 'networkId', networkId)
            // verify required parameter 'stateConfig' is not null or undefined
            assertParamExists('networksNetworkIdStatePut', 'stateConfig', stateConfig)
            const localVarPath = `/networks/{network_id}/state`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(stateConfig, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the type of a network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdTypeGet: async (networkId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networksNetworkIdTypeGet', 'networkId', networkId)
            const localVarPath = `/networks/{network_id}/type`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the type of a network
         * @param {string} networkId Network ID
         * @param {string} type 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdTypePut: async (networkId: string, type: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networksNetworkIdTypePut', 'networkId', networkId)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('networksNetworkIdTypePut', 'type', type)
            const localVarPath = `/networks/{network_id}/type`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(type, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Register a network
         * @param {Network} network Configuration of the network to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksPost: async (network: Network, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'network' is not null or undefined
            assertParamExists('networksPost', 'network', network)
            const localVarPath = `/networks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(network, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NetworksApi - functional programming interface
 * @export
 */
export const NetworksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NetworksApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List all network IDs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksNetworkIdDelete(networkId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksNetworkIdDelete(networkId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the description of a network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksNetworkIdDescriptionGet(networkId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksNetworkIdDescriptionGet(networkId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update the description of a network
         * @param {string} networkId Network ID
         * @param {string} description New name for the network
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksNetworkIdDescriptionPut(networkId: string, description: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksNetworkIdDescriptionPut(networkId, description, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get DNS of network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksNetworkIdDnsGet(networkId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NetworkDnsConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksNetworkIdDnsGet(networkId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update DNS of network
         * @param {string} networkId Network ID
         * @param {NetworkDnsConfig} networkDNS New DNS configuration for the network
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksNetworkIdDnsPut(networkId: string, networkDNS: NetworkDnsConfig, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksNetworkIdDnsPut(networkId, networkDNS, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete the DNS record for a specific domain
         * @param {string} networkId Network ID
         * @param {string} domain DNS record domain
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksNetworkIdDnsRecordsDomainDelete(networkId: string, domain: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksNetworkIdDnsRecordsDomainDelete(networkId, domain, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the DNS config record for a specific domain
         * @param {string} networkId Network ID
         * @param {string} domain DNS record domain
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksNetworkIdDnsRecordsDomainGet(networkId: string, domain: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DnsConfigRecord>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksNetworkIdDnsRecordsDomainGet(networkId, domain, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a DNS record for a specific domain
         * @param {string} networkId Network ID
         * @param {string} domain DNS record domain
         * @param {DnsConfigRecord} record Custom DNS record for the domain
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksNetworkIdDnsRecordsDomainPost(networkId: string, domain: string, record: DnsConfigRecord, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksNetworkIdDnsRecordsDomainPost(networkId, domain, record, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a DNS record for a specific domain
         * @param {string} networkId Network ID
         * @param {string} domain DNS record domain
         * @param {DnsConfigRecord} record Custom DNS record for the domain
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksNetworkIdDnsRecordsDomainPut(networkId: string, domain: string, record: DnsConfigRecord, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksNetworkIdDnsRecordsDomainPut(networkId, domain, record, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the DNS config records for the network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksNetworkIdDnsRecordsGet(networkId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DnsConfigRecord>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksNetworkIdDnsRecordsGet(networkId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Change all the DNS records for the network
         * @param {string} networkId Network ID
         * @param {Array<DnsConfigRecord>} records Custom DNS records for the network
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksNetworkIdDnsRecordsPut(networkId: string, records: Array<DnsConfigRecord>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksNetworkIdDnsRecordsPut(networkId, records, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get feature flags for network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksNetworkIdFeaturesGet(networkId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NetworkFeatures>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksNetworkIdFeaturesGet(networkId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update feature flags for network
         * @param {string} networkId Network ID
         * @param {NetworkFeatures} networkFeatures New network features for the network
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksNetworkIdFeaturesPut(networkId: string, networkFeatures: NetworkFeatures, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksNetworkIdFeaturesPut(networkId, networkFeatures, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a generic network description
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksNetworkIdGet(networkId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Network>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksNetworkIdGet(networkId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the name of a network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksNetworkIdNameGet(networkId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksNetworkIdNameGet(networkId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update the name of a network
         * @param {string} networkId Network ID
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksNetworkIdNamePut(networkId: string, name: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksNetworkIdNamePut(networkId, name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update an entire network
         * @param {string} networkId Network ID
         * @param {Network} network Full desired configuration of the network
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksNetworkIdPut(networkId: string, network: Network, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksNetworkIdPut(networkId, network, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the Sentry.io configuration for network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksNetworkIdSentryGet(networkId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NetworkSentryConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksNetworkIdSentryGet(networkId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update the Sentry.io configuration for network
         * @param {string} networkId Network ID
         * @param {NetworkSentryConfig} networkSentryConfig 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksNetworkIdSentryPut(networkId: string, networkSentryConfig: NetworkSentryConfig, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksNetworkIdSentryPut(networkId, networkSentryConfig, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the state configuration for network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksNetworkIdStateGet(networkId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StateConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksNetworkIdStateGet(networkId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update the state configuration for network
         * @param {string} networkId Network ID
         * @param {StateConfig} stateConfig 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksNetworkIdStatePut(networkId: string, stateConfig: StateConfig, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksNetworkIdStatePut(networkId, stateConfig, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the type of a network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksNetworkIdTypeGet(networkId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksNetworkIdTypeGet(networkId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update the type of a network
         * @param {string} networkId Network ID
         * @param {string} type 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksNetworkIdTypePut(networkId: string, type: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksNetworkIdTypePut(networkId, type, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Register a network
         * @param {Network} network Configuration of the network to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksPost(network: Network, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksPost(network, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * NetworksApi - factory interface
 * @export
 */
export const NetworksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NetworksApiFp(configuration)
    return {
        /**
         * 
         * @summary List all network IDs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksGet(options?: any): AxiosPromise<Array<string>> {
            return localVarFp.networksGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdDelete(networkId: string, options?: any): AxiosPromise<void> {
            return localVarFp.networksNetworkIdDelete(networkId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the description of a network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdDescriptionGet(networkId: string, options?: any): AxiosPromise<string> {
            return localVarFp.networksNetworkIdDescriptionGet(networkId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the description of a network
         * @param {string} networkId Network ID
         * @param {string} description New name for the network
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdDescriptionPut(networkId: string, description: string, options?: any): AxiosPromise<void> {
            return localVarFp.networksNetworkIdDescriptionPut(networkId, description, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get DNS of network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdDnsGet(networkId: string, options?: any): AxiosPromise<NetworkDnsConfig> {
            return localVarFp.networksNetworkIdDnsGet(networkId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update DNS of network
         * @param {string} networkId Network ID
         * @param {NetworkDnsConfig} networkDNS New DNS configuration for the network
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdDnsPut(networkId: string, networkDNS: NetworkDnsConfig, options?: any): AxiosPromise<void> {
            return localVarFp.networksNetworkIdDnsPut(networkId, networkDNS, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete the DNS record for a specific domain
         * @param {string} networkId Network ID
         * @param {string} domain DNS record domain
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdDnsRecordsDomainDelete(networkId: string, domain: string, options?: any): AxiosPromise<void> {
            return localVarFp.networksNetworkIdDnsRecordsDomainDelete(networkId, domain, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the DNS config record for a specific domain
         * @param {string} networkId Network ID
         * @param {string} domain DNS record domain
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdDnsRecordsDomainGet(networkId: string, domain: string, options?: any): AxiosPromise<DnsConfigRecord> {
            return localVarFp.networksNetworkIdDnsRecordsDomainGet(networkId, domain, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a DNS record for a specific domain
         * @param {string} networkId Network ID
         * @param {string} domain DNS record domain
         * @param {DnsConfigRecord} record Custom DNS record for the domain
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdDnsRecordsDomainPost(networkId: string, domain: string, record: DnsConfigRecord, options?: any): AxiosPromise<void> {
            return localVarFp.networksNetworkIdDnsRecordsDomainPost(networkId, domain, record, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a DNS record for a specific domain
         * @param {string} networkId Network ID
         * @param {string} domain DNS record domain
         * @param {DnsConfigRecord} record Custom DNS record for the domain
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdDnsRecordsDomainPut(networkId: string, domain: string, record: DnsConfigRecord, options?: any): AxiosPromise<void> {
            return localVarFp.networksNetworkIdDnsRecordsDomainPut(networkId, domain, record, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the DNS config records for the network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdDnsRecordsGet(networkId: string, options?: any): AxiosPromise<Array<DnsConfigRecord>> {
            return localVarFp.networksNetworkIdDnsRecordsGet(networkId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Change all the DNS records for the network
         * @param {string} networkId Network ID
         * @param {Array<DnsConfigRecord>} records Custom DNS records for the network
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdDnsRecordsPut(networkId: string, records: Array<DnsConfigRecord>, options?: any): AxiosPromise<void> {
            return localVarFp.networksNetworkIdDnsRecordsPut(networkId, records, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get feature flags for network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdFeaturesGet(networkId: string, options?: any): AxiosPromise<NetworkFeatures> {
            return localVarFp.networksNetworkIdFeaturesGet(networkId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update feature flags for network
         * @param {string} networkId Network ID
         * @param {NetworkFeatures} networkFeatures New network features for the network
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdFeaturesPut(networkId: string, networkFeatures: NetworkFeatures, options?: any): AxiosPromise<void> {
            return localVarFp.networksNetworkIdFeaturesPut(networkId, networkFeatures, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a generic network description
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdGet(networkId: string, options?: any): AxiosPromise<Network> {
            return localVarFp.networksNetworkIdGet(networkId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the name of a network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdNameGet(networkId: string, options?: any): AxiosPromise<string> {
            return localVarFp.networksNetworkIdNameGet(networkId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the name of a network
         * @param {string} networkId Network ID
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdNamePut(networkId: string, name: string, options?: any): AxiosPromise<void> {
            return localVarFp.networksNetworkIdNamePut(networkId, name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an entire network
         * @param {string} networkId Network ID
         * @param {Network} network Full desired configuration of the network
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdPut(networkId: string, network: Network, options?: any): AxiosPromise<void> {
            return localVarFp.networksNetworkIdPut(networkId, network, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the Sentry.io configuration for network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdSentryGet(networkId: string, options?: any): AxiosPromise<NetworkSentryConfig> {
            return localVarFp.networksNetworkIdSentryGet(networkId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the Sentry.io configuration for network
         * @param {string} networkId Network ID
         * @param {NetworkSentryConfig} networkSentryConfig 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdSentryPut(networkId: string, networkSentryConfig: NetworkSentryConfig, options?: any): AxiosPromise<void> {
            return localVarFp.networksNetworkIdSentryPut(networkId, networkSentryConfig, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the state configuration for network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdStateGet(networkId: string, options?: any): AxiosPromise<StateConfig> {
            return localVarFp.networksNetworkIdStateGet(networkId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the state configuration for network
         * @param {string} networkId Network ID
         * @param {StateConfig} stateConfig 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdStatePut(networkId: string, stateConfig: StateConfig, options?: any): AxiosPromise<void> {
            return localVarFp.networksNetworkIdStatePut(networkId, stateConfig, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the type of a network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdTypeGet(networkId: string, options?: any): AxiosPromise<string> {
            return localVarFp.networksNetworkIdTypeGet(networkId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the type of a network
         * @param {string} networkId Network ID
         * @param {string} type 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdTypePut(networkId: string, type: string, options?: any): AxiosPromise<void> {
            return localVarFp.networksNetworkIdTypePut(networkId, type, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Register a network
         * @param {Network} network Configuration of the network to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksPost(network: Network, options?: any): AxiosPromise<void> {
            return localVarFp.networksPost(network, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for networksNetworkIdDelete operation in NetworksApi.
 * @export
 * @interface NetworksApiNetworksNetworkIdDeleteRequest
 */
export interface NetworksApiNetworksNetworkIdDeleteRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof NetworksApiNetworksNetworkIdDelete
     */
    readonly networkId: string
}

/**
 * Request parameters for networksNetworkIdDescriptionGet operation in NetworksApi.
 * @export
 * @interface NetworksApiNetworksNetworkIdDescriptionGetRequest
 */
export interface NetworksApiNetworksNetworkIdDescriptionGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof NetworksApiNetworksNetworkIdDescriptionGet
     */
    readonly networkId: string
}

/**
 * Request parameters for networksNetworkIdDescriptionPut operation in NetworksApi.
 * @export
 * @interface NetworksApiNetworksNetworkIdDescriptionPutRequest
 */
export interface NetworksApiNetworksNetworkIdDescriptionPutRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof NetworksApiNetworksNetworkIdDescriptionPut
     */
    readonly networkId: string

    /**
     * New name for the network
     * @type {string}
     * @memberof NetworksApiNetworksNetworkIdDescriptionPut
     */
    readonly description: string
}

/**
 * Request parameters for networksNetworkIdDnsGet operation in NetworksApi.
 * @export
 * @interface NetworksApiNetworksNetworkIdDnsGetRequest
 */
export interface NetworksApiNetworksNetworkIdDnsGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof NetworksApiNetworksNetworkIdDnsGet
     */
    readonly networkId: string
}

/**
 * Request parameters for networksNetworkIdDnsPut operation in NetworksApi.
 * @export
 * @interface NetworksApiNetworksNetworkIdDnsPutRequest
 */
export interface NetworksApiNetworksNetworkIdDnsPutRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof NetworksApiNetworksNetworkIdDnsPut
     */
    readonly networkId: string

    /**
     * New DNS configuration for the network
     * @type {NetworkDnsConfig}
     * @memberof NetworksApiNetworksNetworkIdDnsPut
     */
    readonly networkDNS: NetworkDnsConfig
}

/**
 * Request parameters for networksNetworkIdDnsRecordsDomainDelete operation in NetworksApi.
 * @export
 * @interface NetworksApiNetworksNetworkIdDnsRecordsDomainDeleteRequest
 */
export interface NetworksApiNetworksNetworkIdDnsRecordsDomainDeleteRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof NetworksApiNetworksNetworkIdDnsRecordsDomainDelete
     */
    readonly networkId: string

    /**
     * DNS record domain
     * @type {string}
     * @memberof NetworksApiNetworksNetworkIdDnsRecordsDomainDelete
     */
    readonly domain: string
}

/**
 * Request parameters for networksNetworkIdDnsRecordsDomainGet operation in NetworksApi.
 * @export
 * @interface NetworksApiNetworksNetworkIdDnsRecordsDomainGetRequest
 */
export interface NetworksApiNetworksNetworkIdDnsRecordsDomainGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof NetworksApiNetworksNetworkIdDnsRecordsDomainGet
     */
    readonly networkId: string

    /**
     * DNS record domain
     * @type {string}
     * @memberof NetworksApiNetworksNetworkIdDnsRecordsDomainGet
     */
    readonly domain: string
}

/**
 * Request parameters for networksNetworkIdDnsRecordsDomainPost operation in NetworksApi.
 * @export
 * @interface NetworksApiNetworksNetworkIdDnsRecordsDomainPostRequest
 */
export interface NetworksApiNetworksNetworkIdDnsRecordsDomainPostRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof NetworksApiNetworksNetworkIdDnsRecordsDomainPost
     */
    readonly networkId: string

    /**
     * DNS record domain
     * @type {string}
     * @memberof NetworksApiNetworksNetworkIdDnsRecordsDomainPost
     */
    readonly domain: string

    /**
     * Custom DNS record for the domain
     * @type {DnsConfigRecord}
     * @memberof NetworksApiNetworksNetworkIdDnsRecordsDomainPost
     */
    readonly record: DnsConfigRecord
}

/**
 * Request parameters for networksNetworkIdDnsRecordsDomainPut operation in NetworksApi.
 * @export
 * @interface NetworksApiNetworksNetworkIdDnsRecordsDomainPutRequest
 */
export interface NetworksApiNetworksNetworkIdDnsRecordsDomainPutRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof NetworksApiNetworksNetworkIdDnsRecordsDomainPut
     */
    readonly networkId: string

    /**
     * DNS record domain
     * @type {string}
     * @memberof NetworksApiNetworksNetworkIdDnsRecordsDomainPut
     */
    readonly domain: string

    /**
     * Custom DNS record for the domain
     * @type {DnsConfigRecord}
     * @memberof NetworksApiNetworksNetworkIdDnsRecordsDomainPut
     */
    readonly record: DnsConfigRecord
}

/**
 * Request parameters for networksNetworkIdDnsRecordsGet operation in NetworksApi.
 * @export
 * @interface NetworksApiNetworksNetworkIdDnsRecordsGetRequest
 */
export interface NetworksApiNetworksNetworkIdDnsRecordsGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof NetworksApiNetworksNetworkIdDnsRecordsGet
     */
    readonly networkId: string
}

/**
 * Request parameters for networksNetworkIdDnsRecordsPut operation in NetworksApi.
 * @export
 * @interface NetworksApiNetworksNetworkIdDnsRecordsPutRequest
 */
export interface NetworksApiNetworksNetworkIdDnsRecordsPutRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof NetworksApiNetworksNetworkIdDnsRecordsPut
     */
    readonly networkId: string

    /**
     * Custom DNS records for the network
     * @type {Array<DnsConfigRecord>}
     * @memberof NetworksApiNetworksNetworkIdDnsRecordsPut
     */
    readonly records: Array<DnsConfigRecord>
}

/**
 * Request parameters for networksNetworkIdFeaturesGet operation in NetworksApi.
 * @export
 * @interface NetworksApiNetworksNetworkIdFeaturesGetRequest
 */
export interface NetworksApiNetworksNetworkIdFeaturesGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof NetworksApiNetworksNetworkIdFeaturesGet
     */
    readonly networkId: string
}

/**
 * Request parameters for networksNetworkIdFeaturesPut operation in NetworksApi.
 * @export
 * @interface NetworksApiNetworksNetworkIdFeaturesPutRequest
 */
export interface NetworksApiNetworksNetworkIdFeaturesPutRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof NetworksApiNetworksNetworkIdFeaturesPut
     */
    readonly networkId: string

    /**
     * New network features for the network
     * @type {NetworkFeatures}
     * @memberof NetworksApiNetworksNetworkIdFeaturesPut
     */
    readonly networkFeatures: NetworkFeatures
}

/**
 * Request parameters for networksNetworkIdGet operation in NetworksApi.
 * @export
 * @interface NetworksApiNetworksNetworkIdGetRequest
 */
export interface NetworksApiNetworksNetworkIdGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof NetworksApiNetworksNetworkIdGet
     */
    readonly networkId: string
}

/**
 * Request parameters for networksNetworkIdNameGet operation in NetworksApi.
 * @export
 * @interface NetworksApiNetworksNetworkIdNameGetRequest
 */
export interface NetworksApiNetworksNetworkIdNameGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof NetworksApiNetworksNetworkIdNameGet
     */
    readonly networkId: string
}

/**
 * Request parameters for networksNetworkIdNamePut operation in NetworksApi.
 * @export
 * @interface NetworksApiNetworksNetworkIdNamePutRequest
 */
export interface NetworksApiNetworksNetworkIdNamePutRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof NetworksApiNetworksNetworkIdNamePut
     */
    readonly networkId: string

    /**
     * 
     * @type {string}
     * @memberof NetworksApiNetworksNetworkIdNamePut
     */
    readonly name: string
}

/**
 * Request parameters for networksNetworkIdPut operation in NetworksApi.
 * @export
 * @interface NetworksApiNetworksNetworkIdPutRequest
 */
export interface NetworksApiNetworksNetworkIdPutRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof NetworksApiNetworksNetworkIdPut
     */
    readonly networkId: string

    /**
     * Full desired configuration of the network
     * @type {Network}
     * @memberof NetworksApiNetworksNetworkIdPut
     */
    readonly network: Network
}

/**
 * Request parameters for networksNetworkIdSentryGet operation in NetworksApi.
 * @export
 * @interface NetworksApiNetworksNetworkIdSentryGetRequest
 */
export interface NetworksApiNetworksNetworkIdSentryGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof NetworksApiNetworksNetworkIdSentryGet
     */
    readonly networkId: string
}

/**
 * Request parameters for networksNetworkIdSentryPut operation in NetworksApi.
 * @export
 * @interface NetworksApiNetworksNetworkIdSentryPutRequest
 */
export interface NetworksApiNetworksNetworkIdSentryPutRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof NetworksApiNetworksNetworkIdSentryPut
     */
    readonly networkId: string

    /**
     * 
     * @type {NetworkSentryConfig}
     * @memberof NetworksApiNetworksNetworkIdSentryPut
     */
    readonly networkSentryConfig: NetworkSentryConfig
}

/**
 * Request parameters for networksNetworkIdStateGet operation in NetworksApi.
 * @export
 * @interface NetworksApiNetworksNetworkIdStateGetRequest
 */
export interface NetworksApiNetworksNetworkIdStateGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof NetworksApiNetworksNetworkIdStateGet
     */
    readonly networkId: string
}

/**
 * Request parameters for networksNetworkIdStatePut operation in NetworksApi.
 * @export
 * @interface NetworksApiNetworksNetworkIdStatePutRequest
 */
export interface NetworksApiNetworksNetworkIdStatePutRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof NetworksApiNetworksNetworkIdStatePut
     */
    readonly networkId: string

    /**
     * 
     * @type {StateConfig}
     * @memberof NetworksApiNetworksNetworkIdStatePut
     */
    readonly stateConfig: StateConfig
}

/**
 * Request parameters for networksNetworkIdTypeGet operation in NetworksApi.
 * @export
 * @interface NetworksApiNetworksNetworkIdTypeGetRequest
 */
export interface NetworksApiNetworksNetworkIdTypeGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof NetworksApiNetworksNetworkIdTypeGet
     */
    readonly networkId: string
}

/**
 * Request parameters for networksNetworkIdTypePut operation in NetworksApi.
 * @export
 * @interface NetworksApiNetworksNetworkIdTypePutRequest
 */
export interface NetworksApiNetworksNetworkIdTypePutRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof NetworksApiNetworksNetworkIdTypePut
     */
    readonly networkId: string

    /**
     * 
     * @type {string}
     * @memberof NetworksApiNetworksNetworkIdTypePut
     */
    readonly type: string
}

/**
 * Request parameters for networksPost operation in NetworksApi.
 * @export
 * @interface NetworksApiNetworksPostRequest
 */
export interface NetworksApiNetworksPostRequest {
    /**
     * Configuration of the network to create
     * @type {Network}
     * @memberof NetworksApiNetworksPost
     */
    readonly network: Network
}

/**
 * NetworksApi - object-oriented interface
 * @export
 * @class NetworksApi
 * @extends {BaseAPI}
 */
export class NetworksApi extends BaseAPI {
    /**
     * 
     * @summary List all network IDs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworksApi
     */
    public networksGet(options?: AxiosRequestConfig) {
        return NetworksApiFp(this.configuration).networksGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a network
     * @param {NetworksApiNetworksNetworkIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworksApi
     */
    public networksNetworkIdDelete(requestParameters: NetworksApiNetworksNetworkIdDeleteRequest, options?: AxiosRequestConfig) {
        return NetworksApiFp(this.configuration).networksNetworkIdDelete(requestParameters.networkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the description of a network
     * @param {NetworksApiNetworksNetworkIdDescriptionGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworksApi
     */
    public networksNetworkIdDescriptionGet(requestParameters: NetworksApiNetworksNetworkIdDescriptionGetRequest, options?: AxiosRequestConfig) {
        return NetworksApiFp(this.configuration).networksNetworkIdDescriptionGet(requestParameters.networkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the description of a network
     * @param {NetworksApiNetworksNetworkIdDescriptionPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworksApi
     */
    public networksNetworkIdDescriptionPut(requestParameters: NetworksApiNetworksNetworkIdDescriptionPutRequest, options?: AxiosRequestConfig) {
        return NetworksApiFp(this.configuration).networksNetworkIdDescriptionPut(requestParameters.networkId, requestParameters.description, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get DNS of network
     * @param {NetworksApiNetworksNetworkIdDnsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworksApi
     */
    public networksNetworkIdDnsGet(requestParameters: NetworksApiNetworksNetworkIdDnsGetRequest, options?: AxiosRequestConfig) {
        return NetworksApiFp(this.configuration).networksNetworkIdDnsGet(requestParameters.networkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update DNS of network
     * @param {NetworksApiNetworksNetworkIdDnsPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworksApi
     */
    public networksNetworkIdDnsPut(requestParameters: NetworksApiNetworksNetworkIdDnsPutRequest, options?: AxiosRequestConfig) {
        return NetworksApiFp(this.configuration).networksNetworkIdDnsPut(requestParameters.networkId, requestParameters.networkDNS, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete the DNS record for a specific domain
     * @param {NetworksApiNetworksNetworkIdDnsRecordsDomainDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworksApi
     */
    public networksNetworkIdDnsRecordsDomainDelete(requestParameters: NetworksApiNetworksNetworkIdDnsRecordsDomainDeleteRequest, options?: AxiosRequestConfig) {
        return NetworksApiFp(this.configuration).networksNetworkIdDnsRecordsDomainDelete(requestParameters.networkId, requestParameters.domain, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the DNS config record for a specific domain
     * @param {NetworksApiNetworksNetworkIdDnsRecordsDomainGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworksApi
     */
    public networksNetworkIdDnsRecordsDomainGet(requestParameters: NetworksApiNetworksNetworkIdDnsRecordsDomainGetRequest, options?: AxiosRequestConfig) {
        return NetworksApiFp(this.configuration).networksNetworkIdDnsRecordsDomainGet(requestParameters.networkId, requestParameters.domain, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a DNS record for a specific domain
     * @param {NetworksApiNetworksNetworkIdDnsRecordsDomainPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworksApi
     */
    public networksNetworkIdDnsRecordsDomainPost(requestParameters: NetworksApiNetworksNetworkIdDnsRecordsDomainPostRequest, options?: AxiosRequestConfig) {
        return NetworksApiFp(this.configuration).networksNetworkIdDnsRecordsDomainPost(requestParameters.networkId, requestParameters.domain, requestParameters.record, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a DNS record for a specific domain
     * @param {NetworksApiNetworksNetworkIdDnsRecordsDomainPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworksApi
     */
    public networksNetworkIdDnsRecordsDomainPut(requestParameters: NetworksApiNetworksNetworkIdDnsRecordsDomainPutRequest, options?: AxiosRequestConfig) {
        return NetworksApiFp(this.configuration).networksNetworkIdDnsRecordsDomainPut(requestParameters.networkId, requestParameters.domain, requestParameters.record, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the DNS config records for the network
     * @param {NetworksApiNetworksNetworkIdDnsRecordsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworksApi
     */
    public networksNetworkIdDnsRecordsGet(requestParameters: NetworksApiNetworksNetworkIdDnsRecordsGetRequest, options?: AxiosRequestConfig) {
        return NetworksApiFp(this.configuration).networksNetworkIdDnsRecordsGet(requestParameters.networkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Change all the DNS records for the network
     * @param {NetworksApiNetworksNetworkIdDnsRecordsPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworksApi
     */
    public networksNetworkIdDnsRecordsPut(requestParameters: NetworksApiNetworksNetworkIdDnsRecordsPutRequest, options?: AxiosRequestConfig) {
        return NetworksApiFp(this.configuration).networksNetworkIdDnsRecordsPut(requestParameters.networkId, requestParameters.records, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get feature flags for network
     * @param {NetworksApiNetworksNetworkIdFeaturesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworksApi
     */
    public networksNetworkIdFeaturesGet(requestParameters: NetworksApiNetworksNetworkIdFeaturesGetRequest, options?: AxiosRequestConfig) {
        return NetworksApiFp(this.configuration).networksNetworkIdFeaturesGet(requestParameters.networkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update feature flags for network
     * @param {NetworksApiNetworksNetworkIdFeaturesPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworksApi
     */
    public networksNetworkIdFeaturesPut(requestParameters: NetworksApiNetworksNetworkIdFeaturesPutRequest, options?: AxiosRequestConfig) {
        return NetworksApiFp(this.configuration).networksNetworkIdFeaturesPut(requestParameters.networkId, requestParameters.networkFeatures, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a generic network description
     * @param {NetworksApiNetworksNetworkIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworksApi
     */
    public networksNetworkIdGet(requestParameters: NetworksApiNetworksNetworkIdGetRequest, options?: AxiosRequestConfig) {
        return NetworksApiFp(this.configuration).networksNetworkIdGet(requestParameters.networkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the name of a network
     * @param {NetworksApiNetworksNetworkIdNameGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworksApi
     */
    public networksNetworkIdNameGet(requestParameters: NetworksApiNetworksNetworkIdNameGetRequest, options?: AxiosRequestConfig) {
        return NetworksApiFp(this.configuration).networksNetworkIdNameGet(requestParameters.networkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the name of a network
     * @param {NetworksApiNetworksNetworkIdNamePutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworksApi
     */
    public networksNetworkIdNamePut(requestParameters: NetworksApiNetworksNetworkIdNamePutRequest, options?: AxiosRequestConfig) {
        return NetworksApiFp(this.configuration).networksNetworkIdNamePut(requestParameters.networkId, requestParameters.name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an entire network
     * @param {NetworksApiNetworksNetworkIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworksApi
     */
    public networksNetworkIdPut(requestParameters: NetworksApiNetworksNetworkIdPutRequest, options?: AxiosRequestConfig) {
        return NetworksApiFp(this.configuration).networksNetworkIdPut(requestParameters.networkId, requestParameters.network, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the Sentry.io configuration for network
     * @param {NetworksApiNetworksNetworkIdSentryGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworksApi
     */
    public networksNetworkIdSentryGet(requestParameters: NetworksApiNetworksNetworkIdSentryGetRequest, options?: AxiosRequestConfig) {
        return NetworksApiFp(this.configuration).networksNetworkIdSentryGet(requestParameters.networkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the Sentry.io configuration for network
     * @param {NetworksApiNetworksNetworkIdSentryPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworksApi
     */
    public networksNetworkIdSentryPut(requestParameters: NetworksApiNetworksNetworkIdSentryPutRequest, options?: AxiosRequestConfig) {
        return NetworksApiFp(this.configuration).networksNetworkIdSentryPut(requestParameters.networkId, requestParameters.networkSentryConfig, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the state configuration for network
     * @param {NetworksApiNetworksNetworkIdStateGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworksApi
     */
    public networksNetworkIdStateGet(requestParameters: NetworksApiNetworksNetworkIdStateGetRequest, options?: AxiosRequestConfig) {
        return NetworksApiFp(this.configuration).networksNetworkIdStateGet(requestParameters.networkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the state configuration for network
     * @param {NetworksApiNetworksNetworkIdStatePutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworksApi
     */
    public networksNetworkIdStatePut(requestParameters: NetworksApiNetworksNetworkIdStatePutRequest, options?: AxiosRequestConfig) {
        return NetworksApiFp(this.configuration).networksNetworkIdStatePut(requestParameters.networkId, requestParameters.stateConfig, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the type of a network
     * @param {NetworksApiNetworksNetworkIdTypeGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworksApi
     */
    public networksNetworkIdTypeGet(requestParameters: NetworksApiNetworksNetworkIdTypeGetRequest, options?: AxiosRequestConfig) {
        return NetworksApiFp(this.configuration).networksNetworkIdTypeGet(requestParameters.networkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the type of a network
     * @param {NetworksApiNetworksNetworkIdTypePutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworksApi
     */
    public networksNetworkIdTypePut(requestParameters: NetworksApiNetworksNetworkIdTypePutRequest, options?: AxiosRequestConfig) {
        return NetworksApiFp(this.configuration).networksNetworkIdTypePut(requestParameters.networkId, requestParameters.type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Register a network
     * @param {NetworksApiNetworksPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworksApi
     */
    public networksPost(requestParameters: NetworksApiNetworksPostRequest, options?: AxiosRequestConfig) {
        return NetworksApiFp(this.configuration).networksPost(requestParameters.network, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PoliciesApi - axios parameter creator
 * @export
 */
export const PoliciesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get policy QoS profiles in LTE network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdPolicyQosProfilesGet: async (networkId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdPolicyQosProfilesGet', 'networkId', networkId)
            const localVarPath = `/lte/{network_id}/policy_qos_profiles`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create policy QoS profile in LTE network
         * @param {string} networkId Network ID
         * @param {PolicyQosProfile} policy Policy QoS profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdPolicyQosProfilesPost: async (networkId: string, policy: PolicyQosProfile, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdPolicyQosProfilesPost', 'networkId', networkId)
            // verify required parameter 'policy' is not null or undefined
            assertParamExists('lteNetworkIdPolicyQosProfilesPost', 'policy', policy)
            const localVarPath = `/lte/{network_id}/policy_qos_profiles`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(policy, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete policy QoS profile in LTE network
         * @param {string} networkId Network ID
         * @param {string} profileId Policy QoS profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdPolicyQosProfilesProfileIdDelete: async (networkId: string, profileId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdPolicyQosProfilesProfileIdDelete', 'networkId', networkId)
            // verify required parameter 'profileId' is not null or undefined
            assertParamExists('lteNetworkIdPolicyQosProfilesProfileIdDelete', 'profileId', profileId)
            const localVarPath = `/lte/{network_id}/policy_qos_profiles/{profile_id}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"profile_id"}}`, encodeURIComponent(String(profileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get policy QoS profile in LTE network
         * @param {string} networkId Network ID
         * @param {string} profileId Policy QoS profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdPolicyQosProfilesProfileIdGet: async (networkId: string, profileId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdPolicyQosProfilesProfileIdGet', 'networkId', networkId)
            // verify required parameter 'profileId' is not null or undefined
            assertParamExists('lteNetworkIdPolicyQosProfilesProfileIdGet', 'profileId', profileId)
            const localVarPath = `/lte/{network_id}/policy_qos_profiles/{profile_id}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"profile_id"}}`, encodeURIComponent(String(profileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update policy QoS profile in LTE network
         * @param {string} networkId Network ID
         * @param {string} profileId Policy QoS profile
         * @param {PolicyQosProfile} profile Policy QoS profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdPolicyQosProfilesProfileIdPut: async (networkId: string, profileId: string, profile: PolicyQosProfile, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdPolicyQosProfilesProfileIdPut', 'networkId', networkId)
            // verify required parameter 'profileId' is not null or undefined
            assertParamExists('lteNetworkIdPolicyQosProfilesProfileIdPut', 'profileId', profileId)
            // verify required parameter 'profile' is not null or undefined
            assertParamExists('lteNetworkIdPolicyQosProfilesProfileIdPut', 'profile', profile)
            const localVarPath = `/lte/{network_id}/policy_qos_profiles/{profile_id}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"profile_id"}}`, encodeURIComponent(String(profileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(profile, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a Charging Rule Base Name
         * @param {string} networkId Network ID
         * @param {string} baseName Charging Rule Base Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdPoliciesBaseNamesBaseNameDelete: async (networkId: string, baseName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networksNetworkIdPoliciesBaseNamesBaseNameDelete', 'networkId', networkId)
            // verify required parameter 'baseName' is not null or undefined
            assertParamExists('networksNetworkIdPoliciesBaseNamesBaseNameDelete', 'baseName', baseName)
            const localVarPath = `/networks/{network_id}/policies/base_names/{base_name}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"base_name"}}`, encodeURIComponent(String(baseName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Charging Rule Base Name
         * @param {string} networkId Network ID
         * @param {string} baseName Charging Rule Base Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdPoliciesBaseNamesBaseNameGet: async (networkId: string, baseName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networksNetworkIdPoliciesBaseNamesBaseNameGet', 'networkId', networkId)
            // verify required parameter 'baseName' is not null or undefined
            assertParamExists('networksNetworkIdPoliciesBaseNamesBaseNameGet', 'baseName', baseName)
            const localVarPath = `/networks/{network_id}/policies/base_names/{base_name}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"base_name"}}`, encodeURIComponent(String(baseName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Modify a Charging Rule Base Name
         * @param {string} networkId Network ID
         * @param {string} baseName Charging Rule Base Name
         * @param {BaseNameRecord} baseNameRecord Charging Rule Base Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdPoliciesBaseNamesBaseNamePut: async (networkId: string, baseName: string, baseNameRecord: BaseNameRecord, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networksNetworkIdPoliciesBaseNamesBaseNamePut', 'networkId', networkId)
            // verify required parameter 'baseName' is not null or undefined
            assertParamExists('networksNetworkIdPoliciesBaseNamesBaseNamePut', 'baseName', baseName)
            // verify required parameter 'baseNameRecord' is not null or undefined
            assertParamExists('networksNetworkIdPoliciesBaseNamesBaseNamePut', 'baseNameRecord', baseNameRecord)
            const localVarPath = `/networks/{network_id}/policies/base_names/{base_name}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"base_name"}}`, encodeURIComponent(String(baseName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(baseNameRecord, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Charging Rule Base Names
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdPoliciesBaseNamesGet: async (networkId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networksNetworkIdPoliciesBaseNamesGet', 'networkId', networkId)
            const localVarPath = `/networks/{network_id}/policies/base_names`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Charging Rule Base Name
         * @param {string} networkId Network ID
         * @param {BaseNameRecord} baseNameRecord Charging Rule Base Name to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdPoliciesBaseNamesPost: async (networkId: string, baseNameRecord: BaseNameRecord, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networksNetworkIdPoliciesBaseNamesPost', 'networkId', networkId)
            // verify required parameter 'baseNameRecord' is not null or undefined
            assertParamExists('networksNetworkIdPoliciesBaseNamesPost', 'baseNameRecord', baseNameRecord)
            const localVarPath = `/networks/{network_id}/policies/base_names`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(baseNameRecord, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all base names
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdPoliciesBaseNamesviewfullGet: async (networkId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networksNetworkIdPoliciesBaseNamesviewfullGet', 'networkId', networkId)
            const localVarPath = `/networks/{network_id}/policies/base_names?view=full`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List policy rules
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdPoliciesRulesGet: async (networkId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networksNetworkIdPoliciesRulesGet', 'networkId', networkId)
            const localVarPath = `/networks/{network_id}/policies/rules`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add a new policy rule
         * @param {string} networkId Network ID
         * @param {PolicyRule} policyRule Policy rule to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdPoliciesRulesPost: async (networkId: string, policyRule: PolicyRule, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networksNetworkIdPoliciesRulesPost', 'networkId', networkId)
            // verify required parameter 'policyRule' is not null or undefined
            assertParamExists('networksNetworkIdPoliciesRulesPost', 'policyRule', policyRule)
            const localVarPath = `/networks/{network_id}/policies/rules`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(policyRule, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a policy rule
         * @param {string} networkId Network ID
         * @param {string} ruleId Rule Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdPoliciesRulesRuleIdDelete: async (networkId: string, ruleId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networksNetworkIdPoliciesRulesRuleIdDelete', 'networkId', networkId)
            // verify required parameter 'ruleId' is not null or undefined
            assertParamExists('networksNetworkIdPoliciesRulesRuleIdDelete', 'ruleId', ruleId)
            const localVarPath = `/networks/{network_id}/policies/rules/{rule_id}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"rule_id"}}`, encodeURIComponent(String(ruleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get policy rule
         * @param {string} networkId Network ID
         * @param {string} ruleId Rule Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdPoliciesRulesRuleIdGet: async (networkId: string, ruleId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networksNetworkIdPoliciesRulesRuleIdGet', 'networkId', networkId)
            // verify required parameter 'ruleId' is not null or undefined
            assertParamExists('networksNetworkIdPoliciesRulesRuleIdGet', 'ruleId', ruleId)
            const localVarPath = `/networks/{network_id}/policies/rules/{rule_id}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"rule_id"}}`, encodeURIComponent(String(ruleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Modify a policy rule
         * @param {string} networkId Network ID
         * @param {string} ruleId Rule Id
         * @param {PolicyRule} policyRule Policy rule
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdPoliciesRulesRuleIdPut: async (networkId: string, ruleId: string, policyRule: PolicyRule, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networksNetworkIdPoliciesRulesRuleIdPut', 'networkId', networkId)
            // verify required parameter 'ruleId' is not null or undefined
            assertParamExists('networksNetworkIdPoliciesRulesRuleIdPut', 'ruleId', ruleId)
            // verify required parameter 'policyRule' is not null or undefined
            assertParamExists('networksNetworkIdPoliciesRulesRuleIdPut', 'policyRule', policyRule)
            const localVarPath = `/networks/{network_id}/policies/rules/{rule_id}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"rule_id"}}`, encodeURIComponent(String(ruleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(policyRule, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all policy rules
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdPoliciesRulesviewfullGet: async (networkId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networksNetworkIdPoliciesRulesviewfullGet', 'networkId', networkId)
            const localVarPath = `/networks/{network_id}/policies/rules?view=full`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PoliciesApi - functional programming interface
 * @export
 */
export const PoliciesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PoliciesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get policy QoS profiles in LTE network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdPolicyQosProfilesGet(networkId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: PolicyQosProfile; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdPolicyQosProfilesGet(networkId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create policy QoS profile in LTE network
         * @param {string} networkId Network ID
         * @param {PolicyQosProfile} policy Policy QoS profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdPolicyQosProfilesPost(networkId: string, policy: PolicyQosProfile, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdPolicyQosProfilesPost(networkId, policy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete policy QoS profile in LTE network
         * @param {string} networkId Network ID
         * @param {string} profileId Policy QoS profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdPolicyQosProfilesProfileIdDelete(networkId: string, profileId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdPolicyQosProfilesProfileIdDelete(networkId, profileId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get policy QoS profile in LTE network
         * @param {string} networkId Network ID
         * @param {string} profileId Policy QoS profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdPolicyQosProfilesProfileIdGet(networkId: string, profileId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PolicyQosProfile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdPolicyQosProfilesProfileIdGet(networkId, profileId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update policy QoS profile in LTE network
         * @param {string} networkId Network ID
         * @param {string} profileId Policy QoS profile
         * @param {PolicyQosProfile} profile Policy QoS profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdPolicyQosProfilesProfileIdPut(networkId: string, profileId: string, profile: PolicyQosProfile, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdPolicyQosProfilesProfileIdPut(networkId, profileId, profile, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a Charging Rule Base Name
         * @param {string} networkId Network ID
         * @param {string} baseName Charging Rule Base Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksNetworkIdPoliciesBaseNamesBaseNameDelete(networkId: string, baseName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksNetworkIdPoliciesBaseNamesBaseNameDelete(networkId, baseName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Charging Rule Base Name
         * @param {string} networkId Network ID
         * @param {string} baseName Charging Rule Base Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksNetworkIdPoliciesBaseNamesBaseNameGet(networkId: string, baseName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseNameRecord>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksNetworkIdPoliciesBaseNamesBaseNameGet(networkId, baseName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Modify a Charging Rule Base Name
         * @param {string} networkId Network ID
         * @param {string} baseName Charging Rule Base Name
         * @param {BaseNameRecord} baseNameRecord Charging Rule Base Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksNetworkIdPoliciesBaseNamesBaseNamePut(networkId: string, baseName: string, baseNameRecord: BaseNameRecord, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksNetworkIdPoliciesBaseNamesBaseNamePut(networkId, baseName, baseNameRecord, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Charging Rule Base Names
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksNetworkIdPoliciesBaseNamesGet(networkId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksNetworkIdPoliciesBaseNamesGet(networkId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create Charging Rule Base Name
         * @param {string} networkId Network ID
         * @param {BaseNameRecord} baseNameRecord Charging Rule Base Name to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksNetworkIdPoliciesBaseNamesPost(networkId: string, baseNameRecord: BaseNameRecord, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksNetworkIdPoliciesBaseNamesPost(networkId, baseNameRecord, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all base names
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksNetworkIdPoliciesBaseNamesviewfullGet(networkId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: BaseNameRecord; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksNetworkIdPoliciesBaseNamesviewfullGet(networkId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List policy rules
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksNetworkIdPoliciesRulesGet(networkId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksNetworkIdPoliciesRulesGet(networkId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add a new policy rule
         * @param {string} networkId Network ID
         * @param {PolicyRule} policyRule Policy rule to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksNetworkIdPoliciesRulesPost(networkId: string, policyRule: PolicyRule, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksNetworkIdPoliciesRulesPost(networkId, policyRule, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a policy rule
         * @param {string} networkId Network ID
         * @param {string} ruleId Rule Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksNetworkIdPoliciesRulesRuleIdDelete(networkId: string, ruleId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksNetworkIdPoliciesRulesRuleIdDelete(networkId, ruleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get policy rule
         * @param {string} networkId Network ID
         * @param {string} ruleId Rule Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksNetworkIdPoliciesRulesRuleIdGet(networkId: string, ruleId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PolicyRule>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksNetworkIdPoliciesRulesRuleIdGet(networkId, ruleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Modify a policy rule
         * @param {string} networkId Network ID
         * @param {string} ruleId Rule Id
         * @param {PolicyRule} policyRule Policy rule
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksNetworkIdPoliciesRulesRuleIdPut(networkId: string, ruleId: string, policyRule: PolicyRule, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksNetworkIdPoliciesRulesRuleIdPut(networkId, ruleId, policyRule, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all policy rules
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksNetworkIdPoliciesRulesviewfullGet(networkId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: PolicyRule; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksNetworkIdPoliciesRulesviewfullGet(networkId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PoliciesApi - factory interface
 * @export
 */
export const PoliciesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PoliciesApiFp(configuration)
    return {
        /**
         * 
         * @summary Get policy QoS profiles in LTE network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdPolicyQosProfilesGet(networkId: string, options?: any): AxiosPromise<{ [key: string]: PolicyQosProfile; }> {
            return localVarFp.lteNetworkIdPolicyQosProfilesGet(networkId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create policy QoS profile in LTE network
         * @param {string} networkId Network ID
         * @param {PolicyQosProfile} policy Policy QoS profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdPolicyQosProfilesPost(networkId: string, policy: PolicyQosProfile, options?: any): AxiosPromise<void> {
            return localVarFp.lteNetworkIdPolicyQosProfilesPost(networkId, policy, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete policy QoS profile in LTE network
         * @param {string} networkId Network ID
         * @param {string} profileId Policy QoS profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdPolicyQosProfilesProfileIdDelete(networkId: string, profileId: string, options?: any): AxiosPromise<void> {
            return localVarFp.lteNetworkIdPolicyQosProfilesProfileIdDelete(networkId, profileId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get policy QoS profile in LTE network
         * @param {string} networkId Network ID
         * @param {string} profileId Policy QoS profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdPolicyQosProfilesProfileIdGet(networkId: string, profileId: string, options?: any): AxiosPromise<PolicyQosProfile> {
            return localVarFp.lteNetworkIdPolicyQosProfilesProfileIdGet(networkId, profileId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update policy QoS profile in LTE network
         * @param {string} networkId Network ID
         * @param {string} profileId Policy QoS profile
         * @param {PolicyQosProfile} profile Policy QoS profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdPolicyQosProfilesProfileIdPut(networkId: string, profileId: string, profile: PolicyQosProfile, options?: any): AxiosPromise<void> {
            return localVarFp.lteNetworkIdPolicyQosProfilesProfileIdPut(networkId, profileId, profile, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a Charging Rule Base Name
         * @param {string} networkId Network ID
         * @param {string} baseName Charging Rule Base Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdPoliciesBaseNamesBaseNameDelete(networkId: string, baseName: string, options?: any): AxiosPromise<void> {
            return localVarFp.networksNetworkIdPoliciesBaseNamesBaseNameDelete(networkId, baseName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Charging Rule Base Name
         * @param {string} networkId Network ID
         * @param {string} baseName Charging Rule Base Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdPoliciesBaseNamesBaseNameGet(networkId: string, baseName: string, options?: any): AxiosPromise<BaseNameRecord> {
            return localVarFp.networksNetworkIdPoliciesBaseNamesBaseNameGet(networkId, baseName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Modify a Charging Rule Base Name
         * @param {string} networkId Network ID
         * @param {string} baseName Charging Rule Base Name
         * @param {BaseNameRecord} baseNameRecord Charging Rule Base Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdPoliciesBaseNamesBaseNamePut(networkId: string, baseName: string, baseNameRecord: BaseNameRecord, options?: any): AxiosPromise<void> {
            return localVarFp.networksNetworkIdPoliciesBaseNamesBaseNamePut(networkId, baseName, baseNameRecord, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Charging Rule Base Names
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdPoliciesBaseNamesGet(networkId: string, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.networksNetworkIdPoliciesBaseNamesGet(networkId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create Charging Rule Base Name
         * @param {string} networkId Network ID
         * @param {BaseNameRecord} baseNameRecord Charging Rule Base Name to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdPoliciesBaseNamesPost(networkId: string, baseNameRecord: BaseNameRecord, options?: any): AxiosPromise<string> {
            return localVarFp.networksNetworkIdPoliciesBaseNamesPost(networkId, baseNameRecord, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all base names
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdPoliciesBaseNamesviewfullGet(networkId: string, options?: any): AxiosPromise<{ [key: string]: BaseNameRecord; }> {
            return localVarFp.networksNetworkIdPoliciesBaseNamesviewfullGet(networkId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List policy rules
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdPoliciesRulesGet(networkId: string, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.networksNetworkIdPoliciesRulesGet(networkId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add a new policy rule
         * @param {string} networkId Network ID
         * @param {PolicyRule} policyRule Policy rule to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdPoliciesRulesPost(networkId: string, policyRule: PolicyRule, options?: any): AxiosPromise<string> {
            return localVarFp.networksNetworkIdPoliciesRulesPost(networkId, policyRule, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a policy rule
         * @param {string} networkId Network ID
         * @param {string} ruleId Rule Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdPoliciesRulesRuleIdDelete(networkId: string, ruleId: string, options?: any): AxiosPromise<void> {
            return localVarFp.networksNetworkIdPoliciesRulesRuleIdDelete(networkId, ruleId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get policy rule
         * @param {string} networkId Network ID
         * @param {string} ruleId Rule Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdPoliciesRulesRuleIdGet(networkId: string, ruleId: string, options?: any): AxiosPromise<PolicyRule> {
            return localVarFp.networksNetworkIdPoliciesRulesRuleIdGet(networkId, ruleId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Modify a policy rule
         * @param {string} networkId Network ID
         * @param {string} ruleId Rule Id
         * @param {PolicyRule} policyRule Policy rule
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdPoliciesRulesRuleIdPut(networkId: string, ruleId: string, policyRule: PolicyRule, options?: any): AxiosPromise<void> {
            return localVarFp.networksNetworkIdPoliciesRulesRuleIdPut(networkId, ruleId, policyRule, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all policy rules
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdPoliciesRulesviewfullGet(networkId: string, options?: any): AxiosPromise<{ [key: string]: PolicyRule; }> {
            return localVarFp.networksNetworkIdPoliciesRulesviewfullGet(networkId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for lteNetworkIdPolicyQosProfilesGet operation in PoliciesApi.
 * @export
 * @interface PoliciesApiLteNetworkIdPolicyQosProfilesGetRequest
 */
export interface PoliciesApiLteNetworkIdPolicyQosProfilesGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof PoliciesApiLteNetworkIdPolicyQosProfilesGet
     */
    readonly networkId: string
}

/**
 * Request parameters for lteNetworkIdPolicyQosProfilesPost operation in PoliciesApi.
 * @export
 * @interface PoliciesApiLteNetworkIdPolicyQosProfilesPostRequest
 */
export interface PoliciesApiLteNetworkIdPolicyQosProfilesPostRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof PoliciesApiLteNetworkIdPolicyQosProfilesPost
     */
    readonly networkId: string

    /**
     * Policy QoS profile
     * @type {PolicyQosProfile}
     * @memberof PoliciesApiLteNetworkIdPolicyQosProfilesPost
     */
    readonly policy: PolicyQosProfile
}

/**
 * Request parameters for lteNetworkIdPolicyQosProfilesProfileIdDelete operation in PoliciesApi.
 * @export
 * @interface PoliciesApiLteNetworkIdPolicyQosProfilesProfileIdDeleteRequest
 */
export interface PoliciesApiLteNetworkIdPolicyQosProfilesProfileIdDeleteRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof PoliciesApiLteNetworkIdPolicyQosProfilesProfileIdDelete
     */
    readonly networkId: string

    /**
     * Policy QoS profile
     * @type {string}
     * @memberof PoliciesApiLteNetworkIdPolicyQosProfilesProfileIdDelete
     */
    readonly profileId: string
}

/**
 * Request parameters for lteNetworkIdPolicyQosProfilesProfileIdGet operation in PoliciesApi.
 * @export
 * @interface PoliciesApiLteNetworkIdPolicyQosProfilesProfileIdGetRequest
 */
export interface PoliciesApiLteNetworkIdPolicyQosProfilesProfileIdGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof PoliciesApiLteNetworkIdPolicyQosProfilesProfileIdGet
     */
    readonly networkId: string

    /**
     * Policy QoS profile
     * @type {string}
     * @memberof PoliciesApiLteNetworkIdPolicyQosProfilesProfileIdGet
     */
    readonly profileId: string
}

/**
 * Request parameters for lteNetworkIdPolicyQosProfilesProfileIdPut operation in PoliciesApi.
 * @export
 * @interface PoliciesApiLteNetworkIdPolicyQosProfilesProfileIdPutRequest
 */
export interface PoliciesApiLteNetworkIdPolicyQosProfilesProfileIdPutRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof PoliciesApiLteNetworkIdPolicyQosProfilesProfileIdPut
     */
    readonly networkId: string

    /**
     * Policy QoS profile
     * @type {string}
     * @memberof PoliciesApiLteNetworkIdPolicyQosProfilesProfileIdPut
     */
    readonly profileId: string

    /**
     * Policy QoS profile
     * @type {PolicyQosProfile}
     * @memberof PoliciesApiLteNetworkIdPolicyQosProfilesProfileIdPut
     */
    readonly profile: PolicyQosProfile
}

/**
 * Request parameters for networksNetworkIdPoliciesBaseNamesBaseNameDelete operation in PoliciesApi.
 * @export
 * @interface PoliciesApiNetworksNetworkIdPoliciesBaseNamesBaseNameDeleteRequest
 */
export interface PoliciesApiNetworksNetworkIdPoliciesBaseNamesBaseNameDeleteRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof PoliciesApiNetworksNetworkIdPoliciesBaseNamesBaseNameDelete
     */
    readonly networkId: string

    /**
     * Charging Rule Base Name
     * @type {string}
     * @memberof PoliciesApiNetworksNetworkIdPoliciesBaseNamesBaseNameDelete
     */
    readonly baseName: string
}

/**
 * Request parameters for networksNetworkIdPoliciesBaseNamesBaseNameGet operation in PoliciesApi.
 * @export
 * @interface PoliciesApiNetworksNetworkIdPoliciesBaseNamesBaseNameGetRequest
 */
export interface PoliciesApiNetworksNetworkIdPoliciesBaseNamesBaseNameGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof PoliciesApiNetworksNetworkIdPoliciesBaseNamesBaseNameGet
     */
    readonly networkId: string

    /**
     * Charging Rule Base Name
     * @type {string}
     * @memberof PoliciesApiNetworksNetworkIdPoliciesBaseNamesBaseNameGet
     */
    readonly baseName: string
}

/**
 * Request parameters for networksNetworkIdPoliciesBaseNamesBaseNamePut operation in PoliciesApi.
 * @export
 * @interface PoliciesApiNetworksNetworkIdPoliciesBaseNamesBaseNamePutRequest
 */
export interface PoliciesApiNetworksNetworkIdPoliciesBaseNamesBaseNamePutRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof PoliciesApiNetworksNetworkIdPoliciesBaseNamesBaseNamePut
     */
    readonly networkId: string

    /**
     * Charging Rule Base Name
     * @type {string}
     * @memberof PoliciesApiNetworksNetworkIdPoliciesBaseNamesBaseNamePut
     */
    readonly baseName: string

    /**
     * Charging Rule Base Name
     * @type {BaseNameRecord}
     * @memberof PoliciesApiNetworksNetworkIdPoliciesBaseNamesBaseNamePut
     */
    readonly baseNameRecord: BaseNameRecord
}

/**
 * Request parameters for networksNetworkIdPoliciesBaseNamesGet operation in PoliciesApi.
 * @export
 * @interface PoliciesApiNetworksNetworkIdPoliciesBaseNamesGetRequest
 */
export interface PoliciesApiNetworksNetworkIdPoliciesBaseNamesGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof PoliciesApiNetworksNetworkIdPoliciesBaseNamesGet
     */
    readonly networkId: string
}

/**
 * Request parameters for networksNetworkIdPoliciesBaseNamesPost operation in PoliciesApi.
 * @export
 * @interface PoliciesApiNetworksNetworkIdPoliciesBaseNamesPostRequest
 */
export interface PoliciesApiNetworksNetworkIdPoliciesBaseNamesPostRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof PoliciesApiNetworksNetworkIdPoliciesBaseNamesPost
     */
    readonly networkId: string

    /**
     * Charging Rule Base Name to add
     * @type {BaseNameRecord}
     * @memberof PoliciesApiNetworksNetworkIdPoliciesBaseNamesPost
     */
    readonly baseNameRecord: BaseNameRecord
}

/**
 * Request parameters for networksNetworkIdPoliciesBaseNamesviewfullGet operation in PoliciesApi.
 * @export
 * @interface PoliciesApiNetworksNetworkIdPoliciesBaseNamesviewfullGetRequest
 */
export interface PoliciesApiNetworksNetworkIdPoliciesBaseNamesviewfullGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof PoliciesApiNetworksNetworkIdPoliciesBaseNamesviewfullGet
     */
    readonly networkId: string
}

/**
 * Request parameters for networksNetworkIdPoliciesRulesGet operation in PoliciesApi.
 * @export
 * @interface PoliciesApiNetworksNetworkIdPoliciesRulesGetRequest
 */
export interface PoliciesApiNetworksNetworkIdPoliciesRulesGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof PoliciesApiNetworksNetworkIdPoliciesRulesGet
     */
    readonly networkId: string
}

/**
 * Request parameters for networksNetworkIdPoliciesRulesPost operation in PoliciesApi.
 * @export
 * @interface PoliciesApiNetworksNetworkIdPoliciesRulesPostRequest
 */
export interface PoliciesApiNetworksNetworkIdPoliciesRulesPostRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof PoliciesApiNetworksNetworkIdPoliciesRulesPost
     */
    readonly networkId: string

    /**
     * Policy rule to add
     * @type {PolicyRule}
     * @memberof PoliciesApiNetworksNetworkIdPoliciesRulesPost
     */
    readonly policyRule: PolicyRule
}

/**
 * Request parameters for networksNetworkIdPoliciesRulesRuleIdDelete operation in PoliciesApi.
 * @export
 * @interface PoliciesApiNetworksNetworkIdPoliciesRulesRuleIdDeleteRequest
 */
export interface PoliciesApiNetworksNetworkIdPoliciesRulesRuleIdDeleteRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof PoliciesApiNetworksNetworkIdPoliciesRulesRuleIdDelete
     */
    readonly networkId: string

    /**
     * Rule Id
     * @type {string}
     * @memberof PoliciesApiNetworksNetworkIdPoliciesRulesRuleIdDelete
     */
    readonly ruleId: string
}

/**
 * Request parameters for networksNetworkIdPoliciesRulesRuleIdGet operation in PoliciesApi.
 * @export
 * @interface PoliciesApiNetworksNetworkIdPoliciesRulesRuleIdGetRequest
 */
export interface PoliciesApiNetworksNetworkIdPoliciesRulesRuleIdGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof PoliciesApiNetworksNetworkIdPoliciesRulesRuleIdGet
     */
    readonly networkId: string

    /**
     * Rule Id
     * @type {string}
     * @memberof PoliciesApiNetworksNetworkIdPoliciesRulesRuleIdGet
     */
    readonly ruleId: string
}

/**
 * Request parameters for networksNetworkIdPoliciesRulesRuleIdPut operation in PoliciesApi.
 * @export
 * @interface PoliciesApiNetworksNetworkIdPoliciesRulesRuleIdPutRequest
 */
export interface PoliciesApiNetworksNetworkIdPoliciesRulesRuleIdPutRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof PoliciesApiNetworksNetworkIdPoliciesRulesRuleIdPut
     */
    readonly networkId: string

    /**
     * Rule Id
     * @type {string}
     * @memberof PoliciesApiNetworksNetworkIdPoliciesRulesRuleIdPut
     */
    readonly ruleId: string

    /**
     * Policy rule
     * @type {PolicyRule}
     * @memberof PoliciesApiNetworksNetworkIdPoliciesRulesRuleIdPut
     */
    readonly policyRule: PolicyRule
}

/**
 * Request parameters for networksNetworkIdPoliciesRulesviewfullGet operation in PoliciesApi.
 * @export
 * @interface PoliciesApiNetworksNetworkIdPoliciesRulesviewfullGetRequest
 */
export interface PoliciesApiNetworksNetworkIdPoliciesRulesviewfullGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof PoliciesApiNetworksNetworkIdPoliciesRulesviewfullGet
     */
    readonly networkId: string
}

/**
 * PoliciesApi - object-oriented interface
 * @export
 * @class PoliciesApi
 * @extends {BaseAPI}
 */
export class PoliciesApi extends BaseAPI {
    /**
     * 
     * @summary Get policy QoS profiles in LTE network
     * @param {PoliciesApiLteNetworkIdPolicyQosProfilesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public lteNetworkIdPolicyQosProfilesGet(requestParameters: PoliciesApiLteNetworkIdPolicyQosProfilesGetRequest, options?: AxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).lteNetworkIdPolicyQosProfilesGet(requestParameters.networkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create policy QoS profile in LTE network
     * @param {PoliciesApiLteNetworkIdPolicyQosProfilesPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public lteNetworkIdPolicyQosProfilesPost(requestParameters: PoliciesApiLteNetworkIdPolicyQosProfilesPostRequest, options?: AxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).lteNetworkIdPolicyQosProfilesPost(requestParameters.networkId, requestParameters.policy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete policy QoS profile in LTE network
     * @param {PoliciesApiLteNetworkIdPolicyQosProfilesProfileIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public lteNetworkIdPolicyQosProfilesProfileIdDelete(requestParameters: PoliciesApiLteNetworkIdPolicyQosProfilesProfileIdDeleteRequest, options?: AxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).lteNetworkIdPolicyQosProfilesProfileIdDelete(requestParameters.networkId, requestParameters.profileId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get policy QoS profile in LTE network
     * @param {PoliciesApiLteNetworkIdPolicyQosProfilesProfileIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public lteNetworkIdPolicyQosProfilesProfileIdGet(requestParameters: PoliciesApiLteNetworkIdPolicyQosProfilesProfileIdGetRequest, options?: AxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).lteNetworkIdPolicyQosProfilesProfileIdGet(requestParameters.networkId, requestParameters.profileId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update policy QoS profile in LTE network
     * @param {PoliciesApiLteNetworkIdPolicyQosProfilesProfileIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public lteNetworkIdPolicyQosProfilesProfileIdPut(requestParameters: PoliciesApiLteNetworkIdPolicyQosProfilesProfileIdPutRequest, options?: AxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).lteNetworkIdPolicyQosProfilesProfileIdPut(requestParameters.networkId, requestParameters.profileId, requestParameters.profile, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a Charging Rule Base Name
     * @param {PoliciesApiNetworksNetworkIdPoliciesBaseNamesBaseNameDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public networksNetworkIdPoliciesBaseNamesBaseNameDelete(requestParameters: PoliciesApiNetworksNetworkIdPoliciesBaseNamesBaseNameDeleteRequest, options?: AxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).networksNetworkIdPoliciesBaseNamesBaseNameDelete(requestParameters.networkId, requestParameters.baseName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Charging Rule Base Name
     * @param {PoliciesApiNetworksNetworkIdPoliciesBaseNamesBaseNameGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public networksNetworkIdPoliciesBaseNamesBaseNameGet(requestParameters: PoliciesApiNetworksNetworkIdPoliciesBaseNamesBaseNameGetRequest, options?: AxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).networksNetworkIdPoliciesBaseNamesBaseNameGet(requestParameters.networkId, requestParameters.baseName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Modify a Charging Rule Base Name
     * @param {PoliciesApiNetworksNetworkIdPoliciesBaseNamesBaseNamePutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public networksNetworkIdPoliciesBaseNamesBaseNamePut(requestParameters: PoliciesApiNetworksNetworkIdPoliciesBaseNamesBaseNamePutRequest, options?: AxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).networksNetworkIdPoliciesBaseNamesBaseNamePut(requestParameters.networkId, requestParameters.baseName, requestParameters.baseNameRecord, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Charging Rule Base Names
     * @param {PoliciesApiNetworksNetworkIdPoliciesBaseNamesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public networksNetworkIdPoliciesBaseNamesGet(requestParameters: PoliciesApiNetworksNetworkIdPoliciesBaseNamesGetRequest, options?: AxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).networksNetworkIdPoliciesBaseNamesGet(requestParameters.networkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create Charging Rule Base Name
     * @param {PoliciesApiNetworksNetworkIdPoliciesBaseNamesPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public networksNetworkIdPoliciesBaseNamesPost(requestParameters: PoliciesApiNetworksNetworkIdPoliciesBaseNamesPostRequest, options?: AxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).networksNetworkIdPoliciesBaseNamesPost(requestParameters.networkId, requestParameters.baseNameRecord, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all base names
     * @param {PoliciesApiNetworksNetworkIdPoliciesBaseNamesviewfullGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public networksNetworkIdPoliciesBaseNamesviewfullGet(requestParameters: PoliciesApiNetworksNetworkIdPoliciesBaseNamesviewfullGetRequest, options?: AxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).networksNetworkIdPoliciesBaseNamesviewfullGet(requestParameters.networkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List policy rules
     * @param {PoliciesApiNetworksNetworkIdPoliciesRulesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public networksNetworkIdPoliciesRulesGet(requestParameters: PoliciesApiNetworksNetworkIdPoliciesRulesGetRequest, options?: AxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).networksNetworkIdPoliciesRulesGet(requestParameters.networkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add a new policy rule
     * @param {PoliciesApiNetworksNetworkIdPoliciesRulesPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public networksNetworkIdPoliciesRulesPost(requestParameters: PoliciesApiNetworksNetworkIdPoliciesRulesPostRequest, options?: AxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).networksNetworkIdPoliciesRulesPost(requestParameters.networkId, requestParameters.policyRule, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a policy rule
     * @param {PoliciesApiNetworksNetworkIdPoliciesRulesRuleIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public networksNetworkIdPoliciesRulesRuleIdDelete(requestParameters: PoliciesApiNetworksNetworkIdPoliciesRulesRuleIdDeleteRequest, options?: AxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).networksNetworkIdPoliciesRulesRuleIdDelete(requestParameters.networkId, requestParameters.ruleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get policy rule
     * @param {PoliciesApiNetworksNetworkIdPoliciesRulesRuleIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public networksNetworkIdPoliciesRulesRuleIdGet(requestParameters: PoliciesApiNetworksNetworkIdPoliciesRulesRuleIdGetRequest, options?: AxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).networksNetworkIdPoliciesRulesRuleIdGet(requestParameters.networkId, requestParameters.ruleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Modify a policy rule
     * @param {PoliciesApiNetworksNetworkIdPoliciesRulesRuleIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public networksNetworkIdPoliciesRulesRuleIdPut(requestParameters: PoliciesApiNetworksNetworkIdPoliciesRulesRuleIdPutRequest, options?: AxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).networksNetworkIdPoliciesRulesRuleIdPut(requestParameters.networkId, requestParameters.ruleId, requestParameters.policyRule, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all policy rules
     * @param {PoliciesApiNetworksNetworkIdPoliciesRulesviewfullGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public networksNetworkIdPoliciesRulesviewfullGet(requestParameters: PoliciesApiNetworksNetworkIdPoliciesRulesviewfullGetRequest, options?: AxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).networksNetworkIdPoliciesRulesviewfullGet(requestParameters.networkId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RatingGroupsApi - axios parameter creator
 * @export
 */
export const RatingGroupsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List rating groups
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdRatingGroupsGet: async (networkId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networksNetworkIdRatingGroupsGet', 'networkId', networkId)
            const localVarPath = `/networks/{network_id}/rating_groups`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add a new rating group
         * @param {string} networkId Network ID
         * @param {RatingGroup} ratingGroup Rating group to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdRatingGroupsPost: async (networkId: string, ratingGroup: RatingGroup, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networksNetworkIdRatingGroupsPost', 'networkId', networkId)
            // verify required parameter 'ratingGroup' is not null or undefined
            assertParamExists('networksNetworkIdRatingGroupsPost', 'ratingGroup', ratingGroup)
            const localVarPath = `/networks/{network_id}/rating_groups`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ratingGroup, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a rating group
         * @param {string} networkId Network ID
         * @param {number} ratingGroupId Rating Group Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdRatingGroupsRatingGroupIdDelete: async (networkId: string, ratingGroupId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networksNetworkIdRatingGroupsRatingGroupIdDelete', 'networkId', networkId)
            // verify required parameter 'ratingGroupId' is not null or undefined
            assertParamExists('networksNetworkIdRatingGroupsRatingGroupIdDelete', 'ratingGroupId', ratingGroupId)
            const localVarPath = `/networks/{network_id}/rating_groups/{rating_group_id}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"rating_group_id"}}`, encodeURIComponent(String(ratingGroupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get rating group
         * @param {string} networkId Network ID
         * @param {number} ratingGroupId Rating Group Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdRatingGroupsRatingGroupIdGet: async (networkId: string, ratingGroupId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networksNetworkIdRatingGroupsRatingGroupIdGet', 'networkId', networkId)
            // verify required parameter 'ratingGroupId' is not null or undefined
            assertParamExists('networksNetworkIdRatingGroupsRatingGroupIdGet', 'ratingGroupId', ratingGroupId)
            const localVarPath = `/networks/{network_id}/rating_groups/{rating_group_id}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"rating_group_id"}}`, encodeURIComponent(String(ratingGroupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Modify a rating group
         * @param {string} networkId Network ID
         * @param {number} ratingGroupId Rating Group Id
         * @param {MutableRatingGroup} ratingGroup Rating group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdRatingGroupsRatingGroupIdPut: async (networkId: string, ratingGroupId: number, ratingGroup: MutableRatingGroup, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networksNetworkIdRatingGroupsRatingGroupIdPut', 'networkId', networkId)
            // verify required parameter 'ratingGroupId' is not null or undefined
            assertParamExists('networksNetworkIdRatingGroupsRatingGroupIdPut', 'ratingGroupId', ratingGroupId)
            // verify required parameter 'ratingGroup' is not null or undefined
            assertParamExists('networksNetworkIdRatingGroupsRatingGroupIdPut', 'ratingGroup', ratingGroup)
            const localVarPath = `/networks/{network_id}/rating_groups/{rating_group_id}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"rating_group_id"}}`, encodeURIComponent(String(ratingGroupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ratingGroup, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RatingGroupsApi - functional programming interface
 * @export
 */
export const RatingGroupsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RatingGroupsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List rating groups
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksNetworkIdRatingGroupsGet(networkId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: RatingGroup; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksNetworkIdRatingGroupsGet(networkId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add a new rating group
         * @param {string} networkId Network ID
         * @param {RatingGroup} ratingGroup Rating group to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksNetworkIdRatingGroupsPost(networkId: string, ratingGroup: RatingGroup, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksNetworkIdRatingGroupsPost(networkId, ratingGroup, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a rating group
         * @param {string} networkId Network ID
         * @param {number} ratingGroupId Rating Group Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksNetworkIdRatingGroupsRatingGroupIdDelete(networkId: string, ratingGroupId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksNetworkIdRatingGroupsRatingGroupIdDelete(networkId, ratingGroupId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get rating group
         * @param {string} networkId Network ID
         * @param {number} ratingGroupId Rating Group Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksNetworkIdRatingGroupsRatingGroupIdGet(networkId: string, ratingGroupId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RatingGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksNetworkIdRatingGroupsRatingGroupIdGet(networkId, ratingGroupId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Modify a rating group
         * @param {string} networkId Network ID
         * @param {number} ratingGroupId Rating Group Id
         * @param {MutableRatingGroup} ratingGroup Rating group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksNetworkIdRatingGroupsRatingGroupIdPut(networkId: string, ratingGroupId: number, ratingGroup: MutableRatingGroup, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksNetworkIdRatingGroupsRatingGroupIdPut(networkId, ratingGroupId, ratingGroup, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RatingGroupsApi - factory interface
 * @export
 */
export const RatingGroupsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RatingGroupsApiFp(configuration)
    return {
        /**
         * 
         * @summary List rating groups
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdRatingGroupsGet(networkId: string, options?: any): AxiosPromise<{ [key: string]: RatingGroup; }> {
            return localVarFp.networksNetworkIdRatingGroupsGet(networkId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add a new rating group
         * @param {string} networkId Network ID
         * @param {RatingGroup} ratingGroup Rating group to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdRatingGroupsPost(networkId: string, ratingGroup: RatingGroup, options?: any): AxiosPromise<number> {
            return localVarFp.networksNetworkIdRatingGroupsPost(networkId, ratingGroup, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a rating group
         * @param {string} networkId Network ID
         * @param {number} ratingGroupId Rating Group Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdRatingGroupsRatingGroupIdDelete(networkId: string, ratingGroupId: number, options?: any): AxiosPromise<void> {
            return localVarFp.networksNetworkIdRatingGroupsRatingGroupIdDelete(networkId, ratingGroupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get rating group
         * @param {string} networkId Network ID
         * @param {number} ratingGroupId Rating Group Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdRatingGroupsRatingGroupIdGet(networkId: string, ratingGroupId: number, options?: any): AxiosPromise<RatingGroup> {
            return localVarFp.networksNetworkIdRatingGroupsRatingGroupIdGet(networkId, ratingGroupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Modify a rating group
         * @param {string} networkId Network ID
         * @param {number} ratingGroupId Rating Group Id
         * @param {MutableRatingGroup} ratingGroup Rating group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdRatingGroupsRatingGroupIdPut(networkId: string, ratingGroupId: number, ratingGroup: MutableRatingGroup, options?: any): AxiosPromise<void> {
            return localVarFp.networksNetworkIdRatingGroupsRatingGroupIdPut(networkId, ratingGroupId, ratingGroup, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for networksNetworkIdRatingGroupsGet operation in RatingGroupsApi.
 * @export
 * @interface RatingGroupsApiNetworksNetworkIdRatingGroupsGetRequest
 */
export interface RatingGroupsApiNetworksNetworkIdRatingGroupsGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof RatingGroupsApiNetworksNetworkIdRatingGroupsGet
     */
    readonly networkId: string
}

/**
 * Request parameters for networksNetworkIdRatingGroupsPost operation in RatingGroupsApi.
 * @export
 * @interface RatingGroupsApiNetworksNetworkIdRatingGroupsPostRequest
 */
export interface RatingGroupsApiNetworksNetworkIdRatingGroupsPostRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof RatingGroupsApiNetworksNetworkIdRatingGroupsPost
     */
    readonly networkId: string

    /**
     * Rating group to add
     * @type {RatingGroup}
     * @memberof RatingGroupsApiNetworksNetworkIdRatingGroupsPost
     */
    readonly ratingGroup: RatingGroup
}

/**
 * Request parameters for networksNetworkIdRatingGroupsRatingGroupIdDelete operation in RatingGroupsApi.
 * @export
 * @interface RatingGroupsApiNetworksNetworkIdRatingGroupsRatingGroupIdDeleteRequest
 */
export interface RatingGroupsApiNetworksNetworkIdRatingGroupsRatingGroupIdDeleteRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof RatingGroupsApiNetworksNetworkIdRatingGroupsRatingGroupIdDelete
     */
    readonly networkId: string

    /**
     * Rating Group Id
     * @type {number}
     * @memberof RatingGroupsApiNetworksNetworkIdRatingGroupsRatingGroupIdDelete
     */
    readonly ratingGroupId: number
}

/**
 * Request parameters for networksNetworkIdRatingGroupsRatingGroupIdGet operation in RatingGroupsApi.
 * @export
 * @interface RatingGroupsApiNetworksNetworkIdRatingGroupsRatingGroupIdGetRequest
 */
export interface RatingGroupsApiNetworksNetworkIdRatingGroupsRatingGroupIdGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof RatingGroupsApiNetworksNetworkIdRatingGroupsRatingGroupIdGet
     */
    readonly networkId: string

    /**
     * Rating Group Id
     * @type {number}
     * @memberof RatingGroupsApiNetworksNetworkIdRatingGroupsRatingGroupIdGet
     */
    readonly ratingGroupId: number
}

/**
 * Request parameters for networksNetworkIdRatingGroupsRatingGroupIdPut operation in RatingGroupsApi.
 * @export
 * @interface RatingGroupsApiNetworksNetworkIdRatingGroupsRatingGroupIdPutRequest
 */
export interface RatingGroupsApiNetworksNetworkIdRatingGroupsRatingGroupIdPutRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof RatingGroupsApiNetworksNetworkIdRatingGroupsRatingGroupIdPut
     */
    readonly networkId: string

    /**
     * Rating Group Id
     * @type {number}
     * @memberof RatingGroupsApiNetworksNetworkIdRatingGroupsRatingGroupIdPut
     */
    readonly ratingGroupId: number

    /**
     * Rating group
     * @type {MutableRatingGroup}
     * @memberof RatingGroupsApiNetworksNetworkIdRatingGroupsRatingGroupIdPut
     */
    readonly ratingGroup: MutableRatingGroup
}

/**
 * RatingGroupsApi - object-oriented interface
 * @export
 * @class RatingGroupsApi
 * @extends {BaseAPI}
 */
export class RatingGroupsApi extends BaseAPI {
    /**
     * 
     * @summary List rating groups
     * @param {RatingGroupsApiNetworksNetworkIdRatingGroupsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RatingGroupsApi
     */
    public networksNetworkIdRatingGroupsGet(requestParameters: RatingGroupsApiNetworksNetworkIdRatingGroupsGetRequest, options?: AxiosRequestConfig) {
        return RatingGroupsApiFp(this.configuration).networksNetworkIdRatingGroupsGet(requestParameters.networkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add a new rating group
     * @param {RatingGroupsApiNetworksNetworkIdRatingGroupsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RatingGroupsApi
     */
    public networksNetworkIdRatingGroupsPost(requestParameters: RatingGroupsApiNetworksNetworkIdRatingGroupsPostRequest, options?: AxiosRequestConfig) {
        return RatingGroupsApiFp(this.configuration).networksNetworkIdRatingGroupsPost(requestParameters.networkId, requestParameters.ratingGroup, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a rating group
     * @param {RatingGroupsApiNetworksNetworkIdRatingGroupsRatingGroupIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RatingGroupsApi
     */
    public networksNetworkIdRatingGroupsRatingGroupIdDelete(requestParameters: RatingGroupsApiNetworksNetworkIdRatingGroupsRatingGroupIdDeleteRequest, options?: AxiosRequestConfig) {
        return RatingGroupsApiFp(this.configuration).networksNetworkIdRatingGroupsRatingGroupIdDelete(requestParameters.networkId, requestParameters.ratingGroupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get rating group
     * @param {RatingGroupsApiNetworksNetworkIdRatingGroupsRatingGroupIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RatingGroupsApi
     */
    public networksNetworkIdRatingGroupsRatingGroupIdGet(requestParameters: RatingGroupsApiNetworksNetworkIdRatingGroupsRatingGroupIdGetRequest, options?: AxiosRequestConfig) {
        return RatingGroupsApiFp(this.configuration).networksNetworkIdRatingGroupsRatingGroupIdGet(requestParameters.networkId, requestParameters.ratingGroupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Modify a rating group
     * @param {RatingGroupsApiNetworksNetworkIdRatingGroupsRatingGroupIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RatingGroupsApi
     */
    public networksNetworkIdRatingGroupsRatingGroupIdPut(requestParameters: RatingGroupsApiNetworksNetworkIdRatingGroupsRatingGroupIdPutRequest, options?: AxiosRequestConfig) {
        return RatingGroupsApiFp(this.configuration).networksNetworkIdRatingGroupsRatingGroupIdPut(requestParameters.networkId, requestParameters.ratingGroupId, requestParameters.ratingGroup, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SMSApi - axios parameter creator
 * @export
 */
export const SMSApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List SMS messages
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdSmsGet: async (networkId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdSmsGet', 'networkId', networkId)
            const localVarPath = `/lte/{network_id}/sms`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create new SMS message
         * @param {string} networkId Network ID
         * @param {MutableSmsMessage} sms Message to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdSmsPost: async (networkId: string, sms: MutableSmsMessage, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdSmsPost', 'networkId', networkId)
            // verify required parameter 'sms' is not null or undefined
            assertParamExists('lteNetworkIdSmsPost', 'sms', sms)
            const localVarPath = `/lte/{network_id}/sms`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sms, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete SMS message
         * @param {string} networkId Network ID
         * @param {string} smsPk PK of the SMS message
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdSmsSmsPkDelete: async (networkId: string, smsPk: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdSmsSmsPkDelete', 'networkId', networkId)
            // verify required parameter 'smsPk' is not null or undefined
            assertParamExists('lteNetworkIdSmsSmsPkDelete', 'smsPk', smsPk)
            const localVarPath = `/lte/{network_id}/sms/{sms_pk}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"sms_pk"}}`, encodeURIComponent(String(smsPk)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get SMS message
         * @param {string} networkId Network ID
         * @param {string} smsPk PK of the SMS message
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdSmsSmsPkGet: async (networkId: string, smsPk: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdSmsSmsPkGet', 'networkId', networkId)
            // verify required parameter 'smsPk' is not null or undefined
            assertParamExists('lteNetworkIdSmsSmsPkGet', 'smsPk', smsPk)
            const localVarPath = `/lte/{network_id}/sms/{sms_pk}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"sms_pk"}}`, encodeURIComponent(String(smsPk)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SMSApi - functional programming interface
 * @export
 */
export const SMSApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SMSApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List SMS messages
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdSmsGet(networkId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SmsMessage>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdSmsGet(networkId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create new SMS message
         * @param {string} networkId Network ID
         * @param {MutableSmsMessage} sms Message to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdSmsPost(networkId: string, sms: MutableSmsMessage, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdSmsPost(networkId, sms, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete SMS message
         * @param {string} networkId Network ID
         * @param {string} smsPk PK of the SMS message
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdSmsSmsPkDelete(networkId: string, smsPk: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdSmsSmsPkDelete(networkId, smsPk, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get SMS message
         * @param {string} networkId Network ID
         * @param {string} smsPk PK of the SMS message
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdSmsSmsPkGet(networkId: string, smsPk: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SmsMessage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdSmsSmsPkGet(networkId, smsPk, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SMSApi - factory interface
 * @export
 */
export const SMSApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SMSApiFp(configuration)
    return {
        /**
         * 
         * @summary List SMS messages
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdSmsGet(networkId: string, options?: any): AxiosPromise<Array<SmsMessage>> {
            return localVarFp.lteNetworkIdSmsGet(networkId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create new SMS message
         * @param {string} networkId Network ID
         * @param {MutableSmsMessage} sms Message to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdSmsPost(networkId: string, sms: MutableSmsMessage, options?: any): AxiosPromise<string> {
            return localVarFp.lteNetworkIdSmsPost(networkId, sms, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete SMS message
         * @param {string} networkId Network ID
         * @param {string} smsPk PK of the SMS message
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdSmsSmsPkDelete(networkId: string, smsPk: string, options?: any): AxiosPromise<void> {
            return localVarFp.lteNetworkIdSmsSmsPkDelete(networkId, smsPk, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get SMS message
         * @param {string} networkId Network ID
         * @param {string} smsPk PK of the SMS message
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdSmsSmsPkGet(networkId: string, smsPk: string, options?: any): AxiosPromise<SmsMessage> {
            return localVarFp.lteNetworkIdSmsSmsPkGet(networkId, smsPk, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for lteNetworkIdSmsGet operation in SMSApi.
 * @export
 * @interface SMSApiLteNetworkIdSmsGetRequest
 */
export interface SMSApiLteNetworkIdSmsGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof SMSApiLteNetworkIdSmsGet
     */
    readonly networkId: string
}

/**
 * Request parameters for lteNetworkIdSmsPost operation in SMSApi.
 * @export
 * @interface SMSApiLteNetworkIdSmsPostRequest
 */
export interface SMSApiLteNetworkIdSmsPostRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof SMSApiLteNetworkIdSmsPost
     */
    readonly networkId: string

    /**
     * Message to create
     * @type {MutableSmsMessage}
     * @memberof SMSApiLteNetworkIdSmsPost
     */
    readonly sms: MutableSmsMessage
}

/**
 * Request parameters for lteNetworkIdSmsSmsPkDelete operation in SMSApi.
 * @export
 * @interface SMSApiLteNetworkIdSmsSmsPkDeleteRequest
 */
export interface SMSApiLteNetworkIdSmsSmsPkDeleteRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof SMSApiLteNetworkIdSmsSmsPkDelete
     */
    readonly networkId: string

    /**
     * PK of the SMS message
     * @type {string}
     * @memberof SMSApiLteNetworkIdSmsSmsPkDelete
     */
    readonly smsPk: string
}

/**
 * Request parameters for lteNetworkIdSmsSmsPkGet operation in SMSApi.
 * @export
 * @interface SMSApiLteNetworkIdSmsSmsPkGetRequest
 */
export interface SMSApiLteNetworkIdSmsSmsPkGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof SMSApiLteNetworkIdSmsSmsPkGet
     */
    readonly networkId: string

    /**
     * PK of the SMS message
     * @type {string}
     * @memberof SMSApiLteNetworkIdSmsSmsPkGet
     */
    readonly smsPk: string
}

/**
 * SMSApi - object-oriented interface
 * @export
 * @class SMSApi
 * @extends {BaseAPI}
 */
export class SMSApi extends BaseAPI {
    /**
     * 
     * @summary List SMS messages
     * @param {SMSApiLteNetworkIdSmsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SMSApi
     */
    public lteNetworkIdSmsGet(requestParameters: SMSApiLteNetworkIdSmsGetRequest, options?: AxiosRequestConfig) {
        return SMSApiFp(this.configuration).lteNetworkIdSmsGet(requestParameters.networkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create new SMS message
     * @param {SMSApiLteNetworkIdSmsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SMSApi
     */
    public lteNetworkIdSmsPost(requestParameters: SMSApiLteNetworkIdSmsPostRequest, options?: AxiosRequestConfig) {
        return SMSApiFp(this.configuration).lteNetworkIdSmsPost(requestParameters.networkId, requestParameters.sms, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete SMS message
     * @param {SMSApiLteNetworkIdSmsSmsPkDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SMSApi
     */
    public lteNetworkIdSmsSmsPkDelete(requestParameters: SMSApiLteNetworkIdSmsSmsPkDeleteRequest, options?: AxiosRequestConfig) {
        return SMSApiFp(this.configuration).lteNetworkIdSmsSmsPkDelete(requestParameters.networkId, requestParameters.smsPk, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get SMS message
     * @param {SMSApiLteNetworkIdSmsSmsPkGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SMSApi
     */
    public lteNetworkIdSmsSmsPkGet(requestParameters: SMSApiLteNetworkIdSmsSmsPkGetRequest, options?: AxiosRequestConfig) {
        return SMSApiFp(this.configuration).lteNetworkIdSmsSmsPkGet(requestParameters.networkId, requestParameters.smsPk, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SubscribersApi - axios parameter creator
 * @export
 */
export const SubscribersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List MSISDNS in the network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdMsisdnsGet: async (networkId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdMsisdnsGet', 'networkId', networkId)
            const localVarPath = `/lte/{network_id}/msisdns`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove MSISDN association
         * @param {string} networkId Network ID
         * @param {string} msisdn Mobile station international subscriber directory number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdMsisdnsMsisdnDelete: async (networkId: string, msisdn: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdMsisdnsMsisdnDelete', 'networkId', networkId)
            // verify required parameter 'msisdn' is not null or undefined
            assertParamExists('lteNetworkIdMsisdnsMsisdnDelete', 'msisdn', msisdn)
            const localVarPath = `/lte/{network_id}/msisdns/{msisdn}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"msisdn"}}`, encodeURIComponent(String(msisdn)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve subscriber ID for the MSISDN
         * @param {string} networkId Network ID
         * @param {string} msisdn Mobile station international subscriber directory number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdMsisdnsMsisdnGet: async (networkId: string, msisdn: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdMsisdnsMsisdnGet', 'networkId', networkId)
            // verify required parameter 'msisdn' is not null or undefined
            assertParamExists('lteNetworkIdMsisdnsMsisdnGet', 'msisdn', msisdn)
            const localVarPath = `/lte/{network_id}/msisdns/{msisdn}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"msisdn"}}`, encodeURIComponent(String(msisdn)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add a new MSISDN to the network
         * @param {string} networkId Network ID
         * @param {MsisdnAssignment} msisdnAssignment MSISDN to associate with an existing subscriber ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdMsisdnsPost: async (networkId: string, msisdnAssignment: MsisdnAssignment, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdMsisdnsPost', 'networkId', networkId)
            // verify required parameter 'msisdnAssignment' is not null or undefined
            assertParamExists('lteNetworkIdMsisdnsPost', 'msisdnAssignment', msisdnAssignment)
            const localVarPath = `/lte/{network_id}/msisdns`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(msisdnAssignment, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List subscriber state in the network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdSubscriberStateGet: async (networkId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdSubscriberStateGet', 'networkId', networkId)
            const localVarPath = `/lte/{network_id}/subscriber_state`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List a subscriber\'s state
         * @param {string} networkId Network ID
         * @param {string} subscriberId Subscriber ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdSubscriberStateSubscriberIdGet: async (networkId: string, subscriberId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdSubscriberStateSubscriberIdGet', 'networkId', networkId)
            // verify required parameter 'subscriberId' is not null or undefined
            assertParamExists('lteNetworkIdSubscriberStateSubscriberIdGet', 'subscriberId', subscriberId)
            const localVarPath = `/lte/{network_id}/subscriber_state/{subscriber_id}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"subscriber_id"}}`, encodeURIComponent(String(subscriberId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List subscribers in the network with pagination support
         * @param {string} networkId Network ID
         * @param {string} [msisdn] Filter to subscribers with the passed MSISDN
         * @param {string} [ip] Filter to subscribers assigned the passed IP address
         * @param {number} [pageSize] Maximum number of entities to return
         * @param {string} [pageToken] Opaque page token for paginated requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdSubscribersGet: async (networkId: string, msisdn?: string, ip?: string, pageSize?: number, pageToken?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdSubscribersGet', 'networkId', networkId)
            const localVarPath = `/lte/{network_id}/subscribers`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (msisdn !== undefined) {
                localVarQueryParameter['msisdn'] = msisdn;
            }

            if (ip !== undefined) {
                localVarQueryParameter['ip'] = ip;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = pageToken;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add new subscribers to the network
         * @param {string} networkId Network ID
         * @param {Array<MutableSubscriber>} subscribers Subscribers to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdSubscribersPost: async (networkId: string, subscribers: Array<MutableSubscriber>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdSubscribersPost', 'networkId', networkId)
            // verify required parameter 'subscribers' is not null or undefined
            assertParamExists('lteNetworkIdSubscribersPost', 'subscribers', subscribers)
            const localVarPath = `/lte/{network_id}/subscribers`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(subscribers, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Activate a subscriber
         * @param {string} networkId Network ID
         * @param {string} subscriberId Subscriber ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdSubscribersSubscriberIdActivatePost: async (networkId: string, subscriberId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdSubscribersSubscriberIdActivatePost', 'networkId', networkId)
            // verify required parameter 'subscriberId' is not null or undefined
            assertParamExists('lteNetworkIdSubscribersSubscriberIdActivatePost', 'subscriberId', subscriberId)
            const localVarPath = `/lte/{network_id}/subscribers/{subscriber_id}/activate`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"subscriber_id"}}`, encodeURIComponent(String(subscriberId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deactivate a subscriber
         * @param {string} networkId Network ID
         * @param {string} subscriberId Subscriber ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdSubscribersSubscriberIdDeactivatePost: async (networkId: string, subscriberId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdSubscribersSubscriberIdDeactivatePost', 'networkId', networkId)
            // verify required parameter 'subscriberId' is not null or undefined
            assertParamExists('lteNetworkIdSubscribersSubscriberIdDeactivatePost', 'subscriberId', subscriberId)
            const localVarPath = `/lte/{network_id}/subscribers/{subscriber_id}/deactivate`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"subscriber_id"}}`, encodeURIComponent(String(subscriberId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove a subscriber from the network
         * @param {string} networkId Network ID
         * @param {string} subscriberId Subscriber ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdSubscribersSubscriberIdDelete: async (networkId: string, subscriberId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdSubscribersSubscriberIdDelete', 'networkId', networkId)
            // verify required parameter 'subscriberId' is not null or undefined
            assertParamExists('lteNetworkIdSubscribersSubscriberIdDelete', 'subscriberId', subscriberId)
            const localVarPath = `/lte/{network_id}/subscribers/{subscriber_id}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"subscriber_id"}}`, encodeURIComponent(String(subscriberId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve the subscriber info
         * @param {string} networkId Network ID
         * @param {string} subscriberId Subscriber ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdSubscribersSubscriberIdGet: async (networkId: string, subscriberId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdSubscribersSubscriberIdGet', 'networkId', networkId)
            // verify required parameter 'subscriberId' is not null or undefined
            assertParamExists('lteNetworkIdSubscribersSubscriberIdGet', 'subscriberId', subscriberId)
            const localVarPath = `/lte/{network_id}/subscribers/{subscriber_id}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"subscriber_id"}}`, encodeURIComponent(String(subscriberId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Change a subscriber\'s data profile
         * @param {string} networkId Network ID
         * @param {string} subscriberId Subscriber ID
         * @param {string} profileName New profile name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdSubscribersSubscriberIdLteSubProfilePut: async (networkId: string, subscriberId: string, profileName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdSubscribersSubscriberIdLteSubProfilePut', 'networkId', networkId)
            // verify required parameter 'subscriberId' is not null or undefined
            assertParamExists('lteNetworkIdSubscribersSubscriberIdLteSubProfilePut', 'subscriberId', subscriberId)
            // verify required parameter 'profileName' is not null or undefined
            assertParamExists('lteNetworkIdSubscribersSubscriberIdLteSubProfilePut', 'profileName', profileName)
            const localVarPath = `/lte/{network_id}/subscribers/{subscriber_id}/lte/sub_profile`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"subscriber_id"}}`, encodeURIComponent(String(subscriberId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(profileName, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Modify subscriber info
         * @param {string} networkId Network ID
         * @param {string} subscriberId Subscriber ID
         * @param {MutableSubscriber} subscriber Subscriber Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdSubscribersSubscriberIdPut: async (networkId: string, subscriberId: string, subscriber: MutableSubscriber, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdSubscribersSubscriberIdPut', 'networkId', networkId)
            // verify required parameter 'subscriberId' is not null or undefined
            assertParamExists('lteNetworkIdSubscribersSubscriberIdPut', 'subscriberId', subscriberId)
            // verify required parameter 'subscriber' is not null or undefined
            assertParamExists('lteNetworkIdSubscribersSubscriberIdPut', 'subscriber', subscriber)
            const localVarPath = `/lte/{network_id}/subscribers/{subscriber_id}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"subscriber_id"}}`, encodeURIComponent(String(subscriberId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(subscriber, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List subscribers in the network with pagination support
         * @param {string} networkId Network ID
         * @param {string} [msisdn] Filter to subscribers with the passed MSISDN
         * @param {string} [ip] Filter to subscribers assigned the passed IP address
         * @param {number} [pageSize] Maximum number of entities to return
         * @param {string} [pageToken] Opaque page token for paginated requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdSubscribersverbosefalseGet: async (networkId: string, msisdn?: string, ip?: string, pageSize?: number, pageToken?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('lteNetworkIdSubscribersverbosefalseGet', 'networkId', networkId)
            const localVarPath = `/lte/{network_id}/subscribers?verbose=false`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (msisdn !== undefined) {
                localVarQueryParameter['msisdn'] = msisdn;
            }

            if (ip !== undefined) {
                localVarQueryParameter['ip'] = ip;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = pageToken;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SubscribersApi - functional programming interface
 * @export
 */
export const SubscribersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SubscribersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List MSISDNS in the network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdMsisdnsGet(networkId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: string; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdMsisdnsGet(networkId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove MSISDN association
         * @param {string} networkId Network ID
         * @param {string} msisdn Mobile station international subscriber directory number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdMsisdnsMsisdnDelete(networkId: string, msisdn: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdMsisdnsMsisdnDelete(networkId, msisdn, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve subscriber ID for the MSISDN
         * @param {string} networkId Network ID
         * @param {string} msisdn Mobile station international subscriber directory number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdMsisdnsMsisdnGet(networkId: string, msisdn: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdMsisdnsMsisdnGet(networkId, msisdn, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add a new MSISDN to the network
         * @param {string} networkId Network ID
         * @param {MsisdnAssignment} msisdnAssignment MSISDN to associate with an existing subscriber ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdMsisdnsPost(networkId: string, msisdnAssignment: MsisdnAssignment, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdMsisdnsPost(networkId, msisdnAssignment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List subscriber state in the network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdSubscriberStateGet(networkId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: SubscriberState; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdSubscriberStateGet(networkId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List a subscriber\'s state
         * @param {string} networkId Network ID
         * @param {string} subscriberId Subscriber ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdSubscriberStateSubscriberIdGet(networkId: string, subscriberId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubscriberState>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdSubscriberStateSubscriberIdGet(networkId, subscriberId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List subscribers in the network with pagination support
         * @param {string} networkId Network ID
         * @param {string} [msisdn] Filter to subscribers with the passed MSISDN
         * @param {string} [ip] Filter to subscribers assigned the passed IP address
         * @param {number} [pageSize] Maximum number of entities to return
         * @param {string} [pageToken] Opaque page token for paginated requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdSubscribersGet(networkId: string, msisdn?: string, ip?: string, pageSize?: number, pageToken?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedSubscribers>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdSubscribersGet(networkId, msisdn, ip, pageSize, pageToken, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add new subscribers to the network
         * @param {string} networkId Network ID
         * @param {Array<MutableSubscriber>} subscribers Subscribers to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdSubscribersPost(networkId: string, subscribers: Array<MutableSubscriber>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdSubscribersPost(networkId, subscribers, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Activate a subscriber
         * @param {string} networkId Network ID
         * @param {string} subscriberId Subscriber ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdSubscribersSubscriberIdActivatePost(networkId: string, subscriberId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdSubscribersSubscriberIdActivatePost(networkId, subscriberId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Deactivate a subscriber
         * @param {string} networkId Network ID
         * @param {string} subscriberId Subscriber ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdSubscribersSubscriberIdDeactivatePost(networkId: string, subscriberId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdSubscribersSubscriberIdDeactivatePost(networkId, subscriberId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove a subscriber from the network
         * @param {string} networkId Network ID
         * @param {string} subscriberId Subscriber ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdSubscribersSubscriberIdDelete(networkId: string, subscriberId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdSubscribersSubscriberIdDelete(networkId, subscriberId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve the subscriber info
         * @param {string} networkId Network ID
         * @param {string} subscriberId Subscriber ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdSubscribersSubscriberIdGet(networkId: string, subscriberId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Subscriber>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdSubscribersSubscriberIdGet(networkId, subscriberId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Change a subscriber\'s data profile
         * @param {string} networkId Network ID
         * @param {string} subscriberId Subscriber ID
         * @param {string} profileName New profile name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdSubscribersSubscriberIdLteSubProfilePut(networkId: string, subscriberId: string, profileName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdSubscribersSubscriberIdLteSubProfilePut(networkId, subscriberId, profileName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Modify subscriber info
         * @param {string} networkId Network ID
         * @param {string} subscriberId Subscriber ID
         * @param {MutableSubscriber} subscriber Subscriber Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdSubscribersSubscriberIdPut(networkId: string, subscriberId: string, subscriber: MutableSubscriber, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdSubscribersSubscriberIdPut(networkId, subscriberId, subscriber, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List subscribers in the network with pagination support
         * @param {string} networkId Network ID
         * @param {string} [msisdn] Filter to subscribers with the passed MSISDN
         * @param {string} [ip] Filter to subscribers assigned the passed IP address
         * @param {number} [pageSize] Maximum number of entities to return
         * @param {string} [pageToken] Opaque page token for paginated requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lteNetworkIdSubscribersverbosefalseGet(networkId: string, msisdn?: string, ip?: string, pageSize?: number, pageToken?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedSubscriberIds>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lteNetworkIdSubscribersverbosefalseGet(networkId, msisdn, ip, pageSize, pageToken, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SubscribersApi - factory interface
 * @export
 */
export const SubscribersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SubscribersApiFp(configuration)
    return {
        /**
         * 
         * @summary List MSISDNS in the network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdMsisdnsGet(networkId: string, options?: any): AxiosPromise<{ [key: string]: string; }> {
            return localVarFp.lteNetworkIdMsisdnsGet(networkId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove MSISDN association
         * @param {string} networkId Network ID
         * @param {string} msisdn Mobile station international subscriber directory number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdMsisdnsMsisdnDelete(networkId: string, msisdn: string, options?: any): AxiosPromise<void> {
            return localVarFp.lteNetworkIdMsisdnsMsisdnDelete(networkId, msisdn, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve subscriber ID for the MSISDN
         * @param {string} networkId Network ID
         * @param {string} msisdn Mobile station international subscriber directory number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdMsisdnsMsisdnGet(networkId: string, msisdn: string, options?: any): AxiosPromise<string> {
            return localVarFp.lteNetworkIdMsisdnsMsisdnGet(networkId, msisdn, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add a new MSISDN to the network
         * @param {string} networkId Network ID
         * @param {MsisdnAssignment} msisdnAssignment MSISDN to associate with an existing subscriber ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdMsisdnsPost(networkId: string, msisdnAssignment: MsisdnAssignment, options?: any): AxiosPromise<void> {
            return localVarFp.lteNetworkIdMsisdnsPost(networkId, msisdnAssignment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List subscriber state in the network
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdSubscriberStateGet(networkId: string, options?: any): AxiosPromise<{ [key: string]: SubscriberState; }> {
            return localVarFp.lteNetworkIdSubscriberStateGet(networkId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List a subscriber\'s state
         * @param {string} networkId Network ID
         * @param {string} subscriberId Subscriber ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdSubscriberStateSubscriberIdGet(networkId: string, subscriberId: string, options?: any): AxiosPromise<SubscriberState> {
            return localVarFp.lteNetworkIdSubscriberStateSubscriberIdGet(networkId, subscriberId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List subscribers in the network with pagination support
         * @param {string} networkId Network ID
         * @param {string} [msisdn] Filter to subscribers with the passed MSISDN
         * @param {string} [ip] Filter to subscribers assigned the passed IP address
         * @param {number} [pageSize] Maximum number of entities to return
         * @param {string} [pageToken] Opaque page token for paginated requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdSubscribersGet(networkId: string, msisdn?: string, ip?: string, pageSize?: number, pageToken?: string, options?: any): AxiosPromise<PaginatedSubscribers> {
            return localVarFp.lteNetworkIdSubscribersGet(networkId, msisdn, ip, pageSize, pageToken, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add new subscribers to the network
         * @param {string} networkId Network ID
         * @param {Array<MutableSubscriber>} subscribers Subscribers to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdSubscribersPost(networkId: string, subscribers: Array<MutableSubscriber>, options?: any): AxiosPromise<void> {
            return localVarFp.lteNetworkIdSubscribersPost(networkId, subscribers, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Activate a subscriber
         * @param {string} networkId Network ID
         * @param {string} subscriberId Subscriber ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdSubscribersSubscriberIdActivatePost(networkId: string, subscriberId: string, options?: any): AxiosPromise<void> {
            return localVarFp.lteNetworkIdSubscribersSubscriberIdActivatePost(networkId, subscriberId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deactivate a subscriber
         * @param {string} networkId Network ID
         * @param {string} subscriberId Subscriber ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdSubscribersSubscriberIdDeactivatePost(networkId: string, subscriberId: string, options?: any): AxiosPromise<void> {
            return localVarFp.lteNetworkIdSubscribersSubscriberIdDeactivatePost(networkId, subscriberId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove a subscriber from the network
         * @param {string} networkId Network ID
         * @param {string} subscriberId Subscriber ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdSubscribersSubscriberIdDelete(networkId: string, subscriberId: string, options?: any): AxiosPromise<void> {
            return localVarFp.lteNetworkIdSubscribersSubscriberIdDelete(networkId, subscriberId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve the subscriber info
         * @param {string} networkId Network ID
         * @param {string} subscriberId Subscriber ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdSubscribersSubscriberIdGet(networkId: string, subscriberId: string, options?: any): AxiosPromise<Subscriber> {
            return localVarFp.lteNetworkIdSubscribersSubscriberIdGet(networkId, subscriberId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Change a subscriber\'s data profile
         * @param {string} networkId Network ID
         * @param {string} subscriberId Subscriber ID
         * @param {string} profileName New profile name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdSubscribersSubscriberIdLteSubProfilePut(networkId: string, subscriberId: string, profileName: string, options?: any): AxiosPromise<void> {
            return localVarFp.lteNetworkIdSubscribersSubscriberIdLteSubProfilePut(networkId, subscriberId, profileName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Modify subscriber info
         * @param {string} networkId Network ID
         * @param {string} subscriberId Subscriber ID
         * @param {MutableSubscriber} subscriber Subscriber Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdSubscribersSubscriberIdPut(networkId: string, subscriberId: string, subscriber: MutableSubscriber, options?: any): AxiosPromise<void> {
            return localVarFp.lteNetworkIdSubscribersSubscriberIdPut(networkId, subscriberId, subscriber, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List subscribers in the network with pagination support
         * @param {string} networkId Network ID
         * @param {string} [msisdn] Filter to subscribers with the passed MSISDN
         * @param {string} [ip] Filter to subscribers assigned the passed IP address
         * @param {number} [pageSize] Maximum number of entities to return
         * @param {string} [pageToken] Opaque page token for paginated requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lteNetworkIdSubscribersverbosefalseGet(networkId: string, msisdn?: string, ip?: string, pageSize?: number, pageToken?: string, options?: any): AxiosPromise<PaginatedSubscriberIds> {
            return localVarFp.lteNetworkIdSubscribersverbosefalseGet(networkId, msisdn, ip, pageSize, pageToken, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for lteNetworkIdMsisdnsGet operation in SubscribersApi.
 * @export
 * @interface SubscribersApiLteNetworkIdMsisdnsGetRequest
 */
export interface SubscribersApiLteNetworkIdMsisdnsGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof SubscribersApiLteNetworkIdMsisdnsGet
     */
    readonly networkId: string
}

/**
 * Request parameters for lteNetworkIdMsisdnsMsisdnDelete operation in SubscribersApi.
 * @export
 * @interface SubscribersApiLteNetworkIdMsisdnsMsisdnDeleteRequest
 */
export interface SubscribersApiLteNetworkIdMsisdnsMsisdnDeleteRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof SubscribersApiLteNetworkIdMsisdnsMsisdnDelete
     */
    readonly networkId: string

    /**
     * Mobile station international subscriber directory number
     * @type {string}
     * @memberof SubscribersApiLteNetworkIdMsisdnsMsisdnDelete
     */
    readonly msisdn: string
}

/**
 * Request parameters for lteNetworkIdMsisdnsMsisdnGet operation in SubscribersApi.
 * @export
 * @interface SubscribersApiLteNetworkIdMsisdnsMsisdnGetRequest
 */
export interface SubscribersApiLteNetworkIdMsisdnsMsisdnGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof SubscribersApiLteNetworkIdMsisdnsMsisdnGet
     */
    readonly networkId: string

    /**
     * Mobile station international subscriber directory number
     * @type {string}
     * @memberof SubscribersApiLteNetworkIdMsisdnsMsisdnGet
     */
    readonly msisdn: string
}

/**
 * Request parameters for lteNetworkIdMsisdnsPost operation in SubscribersApi.
 * @export
 * @interface SubscribersApiLteNetworkIdMsisdnsPostRequest
 */
export interface SubscribersApiLteNetworkIdMsisdnsPostRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof SubscribersApiLteNetworkIdMsisdnsPost
     */
    readonly networkId: string

    /**
     * MSISDN to associate with an existing subscriber ID
     * @type {MsisdnAssignment}
     * @memberof SubscribersApiLteNetworkIdMsisdnsPost
     */
    readonly msisdnAssignment: MsisdnAssignment
}

/**
 * Request parameters for lteNetworkIdSubscriberStateGet operation in SubscribersApi.
 * @export
 * @interface SubscribersApiLteNetworkIdSubscriberStateGetRequest
 */
export interface SubscribersApiLteNetworkIdSubscriberStateGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof SubscribersApiLteNetworkIdSubscriberStateGet
     */
    readonly networkId: string
}

/**
 * Request parameters for lteNetworkIdSubscriberStateSubscriberIdGet operation in SubscribersApi.
 * @export
 * @interface SubscribersApiLteNetworkIdSubscriberStateSubscriberIdGetRequest
 */
export interface SubscribersApiLteNetworkIdSubscriberStateSubscriberIdGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof SubscribersApiLteNetworkIdSubscriberStateSubscriberIdGet
     */
    readonly networkId: string

    /**
     * Subscriber ID
     * @type {string}
     * @memberof SubscribersApiLteNetworkIdSubscriberStateSubscriberIdGet
     */
    readonly subscriberId: string
}

/**
 * Request parameters for lteNetworkIdSubscribersGet operation in SubscribersApi.
 * @export
 * @interface SubscribersApiLteNetworkIdSubscribersGetRequest
 */
export interface SubscribersApiLteNetworkIdSubscribersGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof SubscribersApiLteNetworkIdSubscribersGet
     */
    readonly networkId: string

    /**
     * Filter to subscribers with the passed MSISDN
     * @type {string}
     * @memberof SubscribersApiLteNetworkIdSubscribersGet
     */
    readonly msisdn?: string

    /**
     * Filter to subscribers assigned the passed IP address
     * @type {string}
     * @memberof SubscribersApiLteNetworkIdSubscribersGet
     */
    readonly ip?: string

    /**
     * Maximum number of entities to return
     * @type {number}
     * @memberof SubscribersApiLteNetworkIdSubscribersGet
     */
    readonly pageSize?: number

    /**
     * Opaque page token for paginated requests
     * @type {string}
     * @memberof SubscribersApiLteNetworkIdSubscribersGet
     */
    readonly pageToken?: string
}

/**
 * Request parameters for lteNetworkIdSubscribersPost operation in SubscribersApi.
 * @export
 * @interface SubscribersApiLteNetworkIdSubscribersPostRequest
 */
export interface SubscribersApiLteNetworkIdSubscribersPostRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof SubscribersApiLteNetworkIdSubscribersPost
     */
    readonly networkId: string

    /**
     * Subscribers to add
     * @type {Array<MutableSubscriber>}
     * @memberof SubscribersApiLteNetworkIdSubscribersPost
     */
    readonly subscribers: Array<MutableSubscriber>
}

/**
 * Request parameters for lteNetworkIdSubscribersSubscriberIdActivatePost operation in SubscribersApi.
 * @export
 * @interface SubscribersApiLteNetworkIdSubscribersSubscriberIdActivatePostRequest
 */
export interface SubscribersApiLteNetworkIdSubscribersSubscriberIdActivatePostRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof SubscribersApiLteNetworkIdSubscribersSubscriberIdActivatePost
     */
    readonly networkId: string

    /**
     * Subscriber ID
     * @type {string}
     * @memberof SubscribersApiLteNetworkIdSubscribersSubscriberIdActivatePost
     */
    readonly subscriberId: string
}

/**
 * Request parameters for lteNetworkIdSubscribersSubscriberIdDeactivatePost operation in SubscribersApi.
 * @export
 * @interface SubscribersApiLteNetworkIdSubscribersSubscriberIdDeactivatePostRequest
 */
export interface SubscribersApiLteNetworkIdSubscribersSubscriberIdDeactivatePostRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof SubscribersApiLteNetworkIdSubscribersSubscriberIdDeactivatePost
     */
    readonly networkId: string

    /**
     * Subscriber ID
     * @type {string}
     * @memberof SubscribersApiLteNetworkIdSubscribersSubscriberIdDeactivatePost
     */
    readonly subscriberId: string
}

/**
 * Request parameters for lteNetworkIdSubscribersSubscriberIdDelete operation in SubscribersApi.
 * @export
 * @interface SubscribersApiLteNetworkIdSubscribersSubscriberIdDeleteRequest
 */
export interface SubscribersApiLteNetworkIdSubscribersSubscriberIdDeleteRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof SubscribersApiLteNetworkIdSubscribersSubscriberIdDelete
     */
    readonly networkId: string

    /**
     * Subscriber ID
     * @type {string}
     * @memberof SubscribersApiLteNetworkIdSubscribersSubscriberIdDelete
     */
    readonly subscriberId: string
}

/**
 * Request parameters for lteNetworkIdSubscribersSubscriberIdGet operation in SubscribersApi.
 * @export
 * @interface SubscribersApiLteNetworkIdSubscribersSubscriberIdGetRequest
 */
export interface SubscribersApiLteNetworkIdSubscribersSubscriberIdGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof SubscribersApiLteNetworkIdSubscribersSubscriberIdGet
     */
    readonly networkId: string

    /**
     * Subscriber ID
     * @type {string}
     * @memberof SubscribersApiLteNetworkIdSubscribersSubscriberIdGet
     */
    readonly subscriberId: string
}

/**
 * Request parameters for lteNetworkIdSubscribersSubscriberIdLteSubProfilePut operation in SubscribersApi.
 * @export
 * @interface SubscribersApiLteNetworkIdSubscribersSubscriberIdLteSubProfilePutRequest
 */
export interface SubscribersApiLteNetworkIdSubscribersSubscriberIdLteSubProfilePutRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof SubscribersApiLteNetworkIdSubscribersSubscriberIdLteSubProfilePut
     */
    readonly networkId: string

    /**
     * Subscriber ID
     * @type {string}
     * @memberof SubscribersApiLteNetworkIdSubscribersSubscriberIdLteSubProfilePut
     */
    readonly subscriberId: string

    /**
     * New profile name
     * @type {string}
     * @memberof SubscribersApiLteNetworkIdSubscribersSubscriberIdLteSubProfilePut
     */
    readonly profileName: string
}

/**
 * Request parameters for lteNetworkIdSubscribersSubscriberIdPut operation in SubscribersApi.
 * @export
 * @interface SubscribersApiLteNetworkIdSubscribersSubscriberIdPutRequest
 */
export interface SubscribersApiLteNetworkIdSubscribersSubscriberIdPutRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof SubscribersApiLteNetworkIdSubscribersSubscriberIdPut
     */
    readonly networkId: string

    /**
     * Subscriber ID
     * @type {string}
     * @memberof SubscribersApiLteNetworkIdSubscribersSubscriberIdPut
     */
    readonly subscriberId: string

    /**
     * Subscriber Info
     * @type {MutableSubscriber}
     * @memberof SubscribersApiLteNetworkIdSubscribersSubscriberIdPut
     */
    readonly subscriber: MutableSubscriber
}

/**
 * Request parameters for lteNetworkIdSubscribersverbosefalseGet operation in SubscribersApi.
 * @export
 * @interface SubscribersApiLteNetworkIdSubscribersverbosefalseGetRequest
 */
export interface SubscribersApiLteNetworkIdSubscribersverbosefalseGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof SubscribersApiLteNetworkIdSubscribersverbosefalseGet
     */
    readonly networkId: string

    /**
     * Filter to subscribers with the passed MSISDN
     * @type {string}
     * @memberof SubscribersApiLteNetworkIdSubscribersverbosefalseGet
     */
    readonly msisdn?: string

    /**
     * Filter to subscribers assigned the passed IP address
     * @type {string}
     * @memberof SubscribersApiLteNetworkIdSubscribersverbosefalseGet
     */
    readonly ip?: string

    /**
     * Maximum number of entities to return
     * @type {number}
     * @memberof SubscribersApiLteNetworkIdSubscribersverbosefalseGet
     */
    readonly pageSize?: number

    /**
     * Opaque page token for paginated requests
     * @type {string}
     * @memberof SubscribersApiLteNetworkIdSubscribersverbosefalseGet
     */
    readonly pageToken?: string
}

/**
 * SubscribersApi - object-oriented interface
 * @export
 * @class SubscribersApi
 * @extends {BaseAPI}
 */
export class SubscribersApi extends BaseAPI {
    /**
     * 
     * @summary List MSISDNS in the network
     * @param {SubscribersApiLteNetworkIdMsisdnsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscribersApi
     */
    public lteNetworkIdMsisdnsGet(requestParameters: SubscribersApiLteNetworkIdMsisdnsGetRequest, options?: AxiosRequestConfig) {
        return SubscribersApiFp(this.configuration).lteNetworkIdMsisdnsGet(requestParameters.networkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove MSISDN association
     * @param {SubscribersApiLteNetworkIdMsisdnsMsisdnDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscribersApi
     */
    public lteNetworkIdMsisdnsMsisdnDelete(requestParameters: SubscribersApiLteNetworkIdMsisdnsMsisdnDeleteRequest, options?: AxiosRequestConfig) {
        return SubscribersApiFp(this.configuration).lteNetworkIdMsisdnsMsisdnDelete(requestParameters.networkId, requestParameters.msisdn, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve subscriber ID for the MSISDN
     * @param {SubscribersApiLteNetworkIdMsisdnsMsisdnGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscribersApi
     */
    public lteNetworkIdMsisdnsMsisdnGet(requestParameters: SubscribersApiLteNetworkIdMsisdnsMsisdnGetRequest, options?: AxiosRequestConfig) {
        return SubscribersApiFp(this.configuration).lteNetworkIdMsisdnsMsisdnGet(requestParameters.networkId, requestParameters.msisdn, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add a new MSISDN to the network
     * @param {SubscribersApiLteNetworkIdMsisdnsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscribersApi
     */
    public lteNetworkIdMsisdnsPost(requestParameters: SubscribersApiLteNetworkIdMsisdnsPostRequest, options?: AxiosRequestConfig) {
        return SubscribersApiFp(this.configuration).lteNetworkIdMsisdnsPost(requestParameters.networkId, requestParameters.msisdnAssignment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List subscriber state in the network
     * @param {SubscribersApiLteNetworkIdSubscriberStateGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscribersApi
     */
    public lteNetworkIdSubscriberStateGet(requestParameters: SubscribersApiLteNetworkIdSubscriberStateGetRequest, options?: AxiosRequestConfig) {
        return SubscribersApiFp(this.configuration).lteNetworkIdSubscriberStateGet(requestParameters.networkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List a subscriber\'s state
     * @param {SubscribersApiLteNetworkIdSubscriberStateSubscriberIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscribersApi
     */
    public lteNetworkIdSubscriberStateSubscriberIdGet(requestParameters: SubscribersApiLteNetworkIdSubscriberStateSubscriberIdGetRequest, options?: AxiosRequestConfig) {
        return SubscribersApiFp(this.configuration).lteNetworkIdSubscriberStateSubscriberIdGet(requestParameters.networkId, requestParameters.subscriberId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List subscribers in the network with pagination support
     * @param {SubscribersApiLteNetworkIdSubscribersGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscribersApi
     */
    public lteNetworkIdSubscribersGet(requestParameters: SubscribersApiLteNetworkIdSubscribersGetRequest, options?: AxiosRequestConfig) {
        return SubscribersApiFp(this.configuration).lteNetworkIdSubscribersGet(requestParameters.networkId, requestParameters.msisdn, requestParameters.ip, requestParameters.pageSize, requestParameters.pageToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add new subscribers to the network
     * @param {SubscribersApiLteNetworkIdSubscribersPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscribersApi
     */
    public lteNetworkIdSubscribersPost(requestParameters: SubscribersApiLteNetworkIdSubscribersPostRequest, options?: AxiosRequestConfig) {
        return SubscribersApiFp(this.configuration).lteNetworkIdSubscribersPost(requestParameters.networkId, requestParameters.subscribers, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Activate a subscriber
     * @param {SubscribersApiLteNetworkIdSubscribersSubscriberIdActivatePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscribersApi
     */
    public lteNetworkIdSubscribersSubscriberIdActivatePost(requestParameters: SubscribersApiLteNetworkIdSubscribersSubscriberIdActivatePostRequest, options?: AxiosRequestConfig) {
        return SubscribersApiFp(this.configuration).lteNetworkIdSubscribersSubscriberIdActivatePost(requestParameters.networkId, requestParameters.subscriberId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deactivate a subscriber
     * @param {SubscribersApiLteNetworkIdSubscribersSubscriberIdDeactivatePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscribersApi
     */
    public lteNetworkIdSubscribersSubscriberIdDeactivatePost(requestParameters: SubscribersApiLteNetworkIdSubscribersSubscriberIdDeactivatePostRequest, options?: AxiosRequestConfig) {
        return SubscribersApiFp(this.configuration).lteNetworkIdSubscribersSubscriberIdDeactivatePost(requestParameters.networkId, requestParameters.subscriberId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove a subscriber from the network
     * @param {SubscribersApiLteNetworkIdSubscribersSubscriberIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscribersApi
     */
    public lteNetworkIdSubscribersSubscriberIdDelete(requestParameters: SubscribersApiLteNetworkIdSubscribersSubscriberIdDeleteRequest, options?: AxiosRequestConfig) {
        return SubscribersApiFp(this.configuration).lteNetworkIdSubscribersSubscriberIdDelete(requestParameters.networkId, requestParameters.subscriberId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve the subscriber info
     * @param {SubscribersApiLteNetworkIdSubscribersSubscriberIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscribersApi
     */
    public lteNetworkIdSubscribersSubscriberIdGet(requestParameters: SubscribersApiLteNetworkIdSubscribersSubscriberIdGetRequest, options?: AxiosRequestConfig) {
        return SubscribersApiFp(this.configuration).lteNetworkIdSubscribersSubscriberIdGet(requestParameters.networkId, requestParameters.subscriberId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Change a subscriber\'s data profile
     * @param {SubscribersApiLteNetworkIdSubscribersSubscriberIdLteSubProfilePutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscribersApi
     */
    public lteNetworkIdSubscribersSubscriberIdLteSubProfilePut(requestParameters: SubscribersApiLteNetworkIdSubscribersSubscriberIdLteSubProfilePutRequest, options?: AxiosRequestConfig) {
        return SubscribersApiFp(this.configuration).lteNetworkIdSubscribersSubscriberIdLteSubProfilePut(requestParameters.networkId, requestParameters.subscriberId, requestParameters.profileName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Modify subscriber info
     * @param {SubscribersApiLteNetworkIdSubscribersSubscriberIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscribersApi
     */
    public lteNetworkIdSubscribersSubscriberIdPut(requestParameters: SubscribersApiLteNetworkIdSubscribersSubscriberIdPutRequest, options?: AxiosRequestConfig) {
        return SubscribersApiFp(this.configuration).lteNetworkIdSubscribersSubscriberIdPut(requestParameters.networkId, requestParameters.subscriberId, requestParameters.subscriber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List subscribers in the network with pagination support
     * @param {SubscribersApiLteNetworkIdSubscribersverbosefalseGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscribersApi
     */
    public lteNetworkIdSubscribersverbosefalseGet(requestParameters: SubscribersApiLteNetworkIdSubscribersverbosefalseGetRequest, options?: AxiosRequestConfig) {
        return SubscribersApiFp(this.configuration).lteNetworkIdSubscribersverbosefalseGet(requestParameters.networkId, requestParameters.msisdn, requestParameters.ip, requestParameters.pageSize, requestParameters.pageToken, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TenantsApi - axios parameter creator
 * @export
 */
export const TenantsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Retrieve all tenants
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tenantsGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tenants`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a tenant. This should not be called manually, tenants and organizations are updated in NMS and synced to orc8r.
         * @param {Tenant} tenant Tenant to be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tenantsPost: async (tenant: Tenant, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('tenantsPost', 'tenant', tenant)
            const localVarPath = `/tenants`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tenant, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve control proxy content by tenant ID
         * @param {number} tenantId Tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tenantsTenantIdControlProxyGet: async (tenantId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantId' is not null or undefined
            assertParamExists('tenantsTenantIdControlProxyGet', 'tenantId', tenantId)
            const localVarPath = `/tenants/{tenant_id}/control_proxy`
                .replace(`{${"tenant_id"}}`, encodeURIComponent(String(tenantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create or update control proxy content
         * @param {number} tenantId Tenant ID
         * @param {ControlProxy} controlProxy Control proxy content to be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tenantsTenantIdControlProxyPut: async (tenantId: number, controlProxy: ControlProxy, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantId' is not null or undefined
            assertParamExists('tenantsTenantIdControlProxyPut', 'tenantId', tenantId)
            // verify required parameter 'controlProxy' is not null or undefined
            assertParamExists('tenantsTenantIdControlProxyPut', 'controlProxy', controlProxy)
            const localVarPath = `/tenants/{tenant_id}/control_proxy`
                .replace(`{${"tenant_id"}}`, encodeURIComponent(String(tenantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(controlProxy, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a tenant. This should not be called manually, tenants and organizations are updated in NMS and synced to orc8r.
         * @param {number} tenantId Tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tenantsTenantIdDelete: async (tenantId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantId' is not null or undefined
            assertParamExists('tenantsTenantIdDelete', 'tenantId', tenantId)
            const localVarPath = `/tenants/{tenant_id}`
                .replace(`{${"tenant_id"}}`, encodeURIComponent(String(tenantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve tenant info by tenant ID
         * @param {number} tenantId Tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tenantsTenantIdGet: async (tenantId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantId' is not null or undefined
            assertParamExists('tenantsTenantIdGet', 'tenantId', tenantId)
            const localVarPath = `/tenants/{tenant_id}`
                .replace(`{${"tenant_id"}}`, encodeURIComponent(String(tenantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set tenant info. This should not be called manually, tenants and organizations are updated in NMS and synced to orc8r.
         * @param {number} tenantId Tenant ID
         * @param {Tenant} tenant Tenant to be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tenantsTenantIdPut: async (tenantId: number, tenant: Tenant, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantId' is not null or undefined
            assertParamExists('tenantsTenantIdPut', 'tenantId', tenantId)
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('tenantsTenantIdPut', 'tenant', tenant)
            const localVarPath = `/tenants/{tenant_id}`
                .replace(`{${"tenant_id"}}`, encodeURIComponent(String(tenantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tenant, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TenantsApi - functional programming interface
 * @export
 */
export const TenantsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TenantsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Retrieve all tenants
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tenantsGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tenant>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tenantsGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a tenant. This should not be called manually, tenants and organizations are updated in NMS and synced to orc8r.
         * @param {Tenant} tenant Tenant to be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tenantsPost(tenant: Tenant, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tenantsPost(tenant, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve control proxy content by tenant ID
         * @param {number} tenantId Tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tenantsTenantIdControlProxyGet(tenantId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ControlProxy>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tenantsTenantIdControlProxyGet(tenantId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create or update control proxy content
         * @param {number} tenantId Tenant ID
         * @param {ControlProxy} controlProxy Control proxy content to be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tenantsTenantIdControlProxyPut(tenantId: number, controlProxy: ControlProxy, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tenantsTenantIdControlProxyPut(tenantId, controlProxy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a tenant. This should not be called manually, tenants and organizations are updated in NMS and synced to orc8r.
         * @param {number} tenantId Tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tenantsTenantIdDelete(tenantId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tenantsTenantIdDelete(tenantId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve tenant info by tenant ID
         * @param {number} tenantId Tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tenantsTenantIdGet(tenantId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tenant>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tenantsTenantIdGet(tenantId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Set tenant info. This should not be called manually, tenants and organizations are updated in NMS and synced to orc8r.
         * @param {number} tenantId Tenant ID
         * @param {Tenant} tenant Tenant to be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tenantsTenantIdPut(tenantId: number, tenant: Tenant, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tenantsTenantIdPut(tenantId, tenant, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TenantsApi - factory interface
 * @export
 */
export const TenantsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TenantsApiFp(configuration)
    return {
        /**
         * 
         * @summary Retrieve all tenants
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tenantsGet(options?: any): AxiosPromise<Array<Tenant>> {
            return localVarFp.tenantsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a tenant. This should not be called manually, tenants and organizations are updated in NMS and synced to orc8r.
         * @param {Tenant} tenant Tenant to be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tenantsPost(tenant: Tenant, options?: any): AxiosPromise<void> {
            return localVarFp.tenantsPost(tenant, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve control proxy content by tenant ID
         * @param {number} tenantId Tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tenantsTenantIdControlProxyGet(tenantId: number, options?: any): AxiosPromise<ControlProxy> {
            return localVarFp.tenantsTenantIdControlProxyGet(tenantId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create or update control proxy content
         * @param {number} tenantId Tenant ID
         * @param {ControlProxy} controlProxy Control proxy content to be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tenantsTenantIdControlProxyPut(tenantId: number, controlProxy: ControlProxy, options?: any): AxiosPromise<void> {
            return localVarFp.tenantsTenantIdControlProxyPut(tenantId, controlProxy, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a tenant. This should not be called manually, tenants and organizations are updated in NMS and synced to orc8r.
         * @param {number} tenantId Tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tenantsTenantIdDelete(tenantId: number, options?: any): AxiosPromise<void> {
            return localVarFp.tenantsTenantIdDelete(tenantId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve tenant info by tenant ID
         * @param {number} tenantId Tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tenantsTenantIdGet(tenantId: number, options?: any): AxiosPromise<Tenant> {
            return localVarFp.tenantsTenantIdGet(tenantId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set tenant info. This should not be called manually, tenants and organizations are updated in NMS and synced to orc8r.
         * @param {number} tenantId Tenant ID
         * @param {Tenant} tenant Tenant to be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tenantsTenantIdPut(tenantId: number, tenant: Tenant, options?: any): AxiosPromise<void> {
            return localVarFp.tenantsTenantIdPut(tenantId, tenant, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for tenantsPost operation in TenantsApi.
 * @export
 * @interface TenantsApiTenantsPostRequest
 */
export interface TenantsApiTenantsPostRequest {
    /**
     * Tenant to be created
     * @type {Tenant}
     * @memberof TenantsApiTenantsPost
     */
    readonly tenant: Tenant
}

/**
 * Request parameters for tenantsTenantIdControlProxyGet operation in TenantsApi.
 * @export
 * @interface TenantsApiTenantsTenantIdControlProxyGetRequest
 */
export interface TenantsApiTenantsTenantIdControlProxyGetRequest {
    /**
     * Tenant ID
     * @type {number}
     * @memberof TenantsApiTenantsTenantIdControlProxyGet
     */
    readonly tenantId: number
}

/**
 * Request parameters for tenantsTenantIdControlProxyPut operation in TenantsApi.
 * @export
 * @interface TenantsApiTenantsTenantIdControlProxyPutRequest
 */
export interface TenantsApiTenantsTenantIdControlProxyPutRequest {
    /**
     * Tenant ID
     * @type {number}
     * @memberof TenantsApiTenantsTenantIdControlProxyPut
     */
    readonly tenantId: number

    /**
     * Control proxy content to be updated
     * @type {ControlProxy}
     * @memberof TenantsApiTenantsTenantIdControlProxyPut
     */
    readonly controlProxy: ControlProxy
}

/**
 * Request parameters for tenantsTenantIdDelete operation in TenantsApi.
 * @export
 * @interface TenantsApiTenantsTenantIdDeleteRequest
 */
export interface TenantsApiTenantsTenantIdDeleteRequest {
    /**
     * Tenant ID
     * @type {number}
     * @memberof TenantsApiTenantsTenantIdDelete
     */
    readonly tenantId: number
}

/**
 * Request parameters for tenantsTenantIdGet operation in TenantsApi.
 * @export
 * @interface TenantsApiTenantsTenantIdGetRequest
 */
export interface TenantsApiTenantsTenantIdGetRequest {
    /**
     * Tenant ID
     * @type {number}
     * @memberof TenantsApiTenantsTenantIdGet
     */
    readonly tenantId: number
}

/**
 * Request parameters for tenantsTenantIdPut operation in TenantsApi.
 * @export
 * @interface TenantsApiTenantsTenantIdPutRequest
 */
export interface TenantsApiTenantsTenantIdPutRequest {
    /**
     * Tenant ID
     * @type {number}
     * @memberof TenantsApiTenantsTenantIdPut
     */
    readonly tenantId: number

    /**
     * Tenant to be updated
     * @type {Tenant}
     * @memberof TenantsApiTenantsTenantIdPut
     */
    readonly tenant: Tenant
}

/**
 * TenantsApi - object-oriented interface
 * @export
 * @class TenantsApi
 * @extends {BaseAPI}
 */
export class TenantsApi extends BaseAPI {
    /**
     * 
     * @summary Retrieve all tenants
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantsApi
     */
    public tenantsGet(options?: AxiosRequestConfig) {
        return TenantsApiFp(this.configuration).tenantsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a tenant. This should not be called manually, tenants and organizations are updated in NMS and synced to orc8r.
     * @param {TenantsApiTenantsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantsApi
     */
    public tenantsPost(requestParameters: TenantsApiTenantsPostRequest, options?: AxiosRequestConfig) {
        return TenantsApiFp(this.configuration).tenantsPost(requestParameters.tenant, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve control proxy content by tenant ID
     * @param {TenantsApiTenantsTenantIdControlProxyGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantsApi
     */
    public tenantsTenantIdControlProxyGet(requestParameters: TenantsApiTenantsTenantIdControlProxyGetRequest, options?: AxiosRequestConfig) {
        return TenantsApiFp(this.configuration).tenantsTenantIdControlProxyGet(requestParameters.tenantId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create or update control proxy content
     * @param {TenantsApiTenantsTenantIdControlProxyPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantsApi
     */
    public tenantsTenantIdControlProxyPut(requestParameters: TenantsApiTenantsTenantIdControlProxyPutRequest, options?: AxiosRequestConfig) {
        return TenantsApiFp(this.configuration).tenantsTenantIdControlProxyPut(requestParameters.tenantId, requestParameters.controlProxy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a tenant. This should not be called manually, tenants and organizations are updated in NMS and synced to orc8r.
     * @param {TenantsApiTenantsTenantIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantsApi
     */
    public tenantsTenantIdDelete(requestParameters: TenantsApiTenantsTenantIdDeleteRequest, options?: AxiosRequestConfig) {
        return TenantsApiFp(this.configuration).tenantsTenantIdDelete(requestParameters.tenantId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve tenant info by tenant ID
     * @param {TenantsApiTenantsTenantIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantsApi
     */
    public tenantsTenantIdGet(requestParameters: TenantsApiTenantsTenantIdGetRequest, options?: AxiosRequestConfig) {
        return TenantsApiFp(this.configuration).tenantsTenantIdGet(requestParameters.tenantId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set tenant info. This should not be called manually, tenants and organizations are updated in NMS and synced to orc8r.
     * @param {TenantsApiTenantsTenantIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantsApi
     */
    public tenantsTenantIdPut(requestParameters: TenantsApiTenantsTenantIdPutRequest, options?: AxiosRequestConfig) {
        return TenantsApiFp(this.configuration).tenantsTenantIdPut(requestParameters.tenantId, requestParameters.tenant, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UpgradesApi - axios parameter creator
 * @export
 */
export const UpgradesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete a release channel
         * @param {string} channelId Release Channel ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelsChannelIdDelete: async (channelId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('channelsChannelIdDelete', 'channelId', channelId)
            const localVarPath = `/channels/{channel_id}`
                .replace(`{${"channel_id"}}`, encodeURIComponent(String(channelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get release channel by id
         * @param {string} channelId Release Channel ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelsChannelIdGet: async (channelId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('channelsChannelIdGet', 'channelId', channelId)
            const localVarPath = `/channels/{channel_id}`
                .replace(`{${"channel_id"}}`, encodeURIComponent(String(channelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a release channel
         * @param {string} channelId Release Channel ID
         * @param {ReleaseChannel} releaseChannel New channel configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelsChannelIdPut: async (channelId: string, releaseChannel: ReleaseChannel, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('channelsChannelIdPut', 'channelId', channelId)
            // verify required parameter 'releaseChannel' is not null or undefined
            assertParamExists('channelsChannelIdPut', 'releaseChannel', releaseChannel)
            const localVarPath = `/channels/{channel_id}`
                .replace(`{${"channel_id"}}`, encodeURIComponent(String(channelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(releaseChannel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all release channels
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelsGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/channels`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new release channel
         * @param {ReleaseChannel} channel The release channel to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelsPost: async (channel: ReleaseChannel, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            assertParamExists('channelsPost', 'channel', channel)
            const localVarPath = `/channels`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(channel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of upgrade tiers
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdTiersGet: async (networkId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networksNetworkIdTiersGet', 'networkId', networkId)
            const localVarPath = `/networks/{network_id}/tiers`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Register a tier
         * @param {string} networkId Network ID
         * @param {Tier} tier Configuration of the tier to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdTiersPost: async (networkId: string, tier: Tier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networksNetworkIdTiersPost', 'networkId', networkId)
            // verify required parameter 'tier' is not null or undefined
            assertParamExists('networksNetworkIdTiersPost', 'tier', tier)
            const localVarPath = `/networks/{network_id}/tiers`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tier, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete upgrade tier
         * @param {string} networkId Network ID
         * @param {string} tierId Tier ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdTiersTierIdDelete: async (networkId: string, tierId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networksNetworkIdTiersTierIdDelete', 'networkId', networkId)
            // verify required parameter 'tierId' is not null or undefined
            assertParamExists('networksNetworkIdTiersTierIdDelete', 'tierId', tierId)
            const localVarPath = `/networks/{network_id}/tiers/{tier_id}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"tier_id"}}`, encodeURIComponent(String(tierId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove a gateway from tier
         * @param {string} networkId Network ID
         * @param {string} tierId Tier ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdTiersTierIdGatewaysGatewayIdDelete: async (networkId: string, tierId: string, gatewayId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networksNetworkIdTiersTierIdGatewaysGatewayIdDelete', 'networkId', networkId)
            // verify required parameter 'tierId' is not null or undefined
            assertParamExists('networksNetworkIdTiersTierIdGatewaysGatewayIdDelete', 'tierId', tierId)
            // verify required parameter 'gatewayId' is not null or undefined
            assertParamExists('networksNetworkIdTiersTierIdGatewaysGatewayIdDelete', 'gatewayId', gatewayId)
            const localVarPath = `/networks/{network_id}/tiers/{tier_id}/gateways/{gateway_id}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"tier_id"}}`, encodeURIComponent(String(tierId)))
                .replace(`{${"gateway_id"}}`, encodeURIComponent(String(gatewayId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get gateways of upgrade tier
         * @param {string} networkId Network ID
         * @param {string} tierId Tier ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdTiersTierIdGatewaysGet: async (networkId: string, tierId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networksNetworkIdTiersTierIdGatewaysGet', 'networkId', networkId)
            // verify required parameter 'tierId' is not null or undefined
            assertParamExists('networksNetworkIdTiersTierIdGatewaysGet', 'tierId', tierId)
            const localVarPath = `/networks/{network_id}/tiers/{tier_id}/gateways`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"tier_id"}}`, encodeURIComponent(String(tierId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add a gateway to upgrade tier
         * @param {string} networkId Network ID
         * @param {string} tierId Tier ID
         * @param {string} gateway New gateway for the tier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdTiersTierIdGatewaysPost: async (networkId: string, tierId: string, gateway: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networksNetworkIdTiersTierIdGatewaysPost', 'networkId', networkId)
            // verify required parameter 'tierId' is not null or undefined
            assertParamExists('networksNetworkIdTiersTierIdGatewaysPost', 'tierId', tierId)
            // verify required parameter 'gateway' is not null or undefined
            assertParamExists('networksNetworkIdTiersTierIdGatewaysPost', 'gateway', gateway)
            const localVarPath = `/networks/{network_id}/tiers/{tier_id}/gateways`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"tier_id"}}`, encodeURIComponent(String(tierId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(gateway, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update upgrade tier gateways
         * @param {string} networkId Network ID
         * @param {string} tierId Tier ID
         * @param {Array<string>} tier New images for the tier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdTiersTierIdGatewaysPut: async (networkId: string, tierId: string, tier: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networksNetworkIdTiersTierIdGatewaysPut', 'networkId', networkId)
            // verify required parameter 'tierId' is not null or undefined
            assertParamExists('networksNetworkIdTiersTierIdGatewaysPut', 'tierId', tierId)
            // verify required parameter 'tier' is not null or undefined
            assertParamExists('networksNetworkIdTiersTierIdGatewaysPut', 'tier', tier)
            const localVarPath = `/networks/{network_id}/tiers/{tier_id}/gateways`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"tier_id"}}`, encodeURIComponent(String(tierId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tier, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get upgrade tier
         * @param {string} networkId Network ID
         * @param {string} tierId Tier ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdTiersTierIdGet: async (networkId: string, tierId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networksNetworkIdTiersTierIdGet', 'networkId', networkId)
            // verify required parameter 'tierId' is not null or undefined
            assertParamExists('networksNetworkIdTiersTierIdGet', 'tierId', tierId)
            const localVarPath = `/networks/{network_id}/tiers/{tier_id}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"tier_id"}}`, encodeURIComponent(String(tierId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get images of upgrade tier
         * @param {string} networkId Network ID
         * @param {string} tierId Tier ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdTiersTierIdImagesGet: async (networkId: string, tierId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networksNetworkIdTiersTierIdImagesGet', 'networkId', networkId)
            // verify required parameter 'tierId' is not null or undefined
            assertParamExists('networksNetworkIdTiersTierIdImagesGet', 'tierId', tierId)
            const localVarPath = `/networks/{network_id}/tiers/{tier_id}/images`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"tier_id"}}`, encodeURIComponent(String(tierId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove an image from tier
         * @param {string} networkId Network ID
         * @param {string} tierId Tier ID
         * @param {string} imageName Name of an image
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdTiersTierIdImagesImageNameDelete: async (networkId: string, tierId: string, imageName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networksNetworkIdTiersTierIdImagesImageNameDelete', 'networkId', networkId)
            // verify required parameter 'tierId' is not null or undefined
            assertParamExists('networksNetworkIdTiersTierIdImagesImageNameDelete', 'tierId', tierId)
            // verify required parameter 'imageName' is not null or undefined
            assertParamExists('networksNetworkIdTiersTierIdImagesImageNameDelete', 'imageName', imageName)
            const localVarPath = `/networks/{network_id}/tiers/{tier_id}/images/{image_name}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"tier_id"}}`, encodeURIComponent(String(tierId)))
                .replace(`{${"image_name"}}`, encodeURIComponent(String(imageName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add an image to upgrade tier
         * @param {string} networkId Network ID
         * @param {string} tierId Tier ID
         * @param {TierImage} image New image for the tier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdTiersTierIdImagesPost: async (networkId: string, tierId: string, image: TierImage, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networksNetworkIdTiersTierIdImagesPost', 'networkId', networkId)
            // verify required parameter 'tierId' is not null or undefined
            assertParamExists('networksNetworkIdTiersTierIdImagesPost', 'tierId', tierId)
            // verify required parameter 'image' is not null or undefined
            assertParamExists('networksNetworkIdTiersTierIdImagesPost', 'image', image)
            const localVarPath = `/networks/{network_id}/tiers/{tier_id}/images`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"tier_id"}}`, encodeURIComponent(String(tierId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(image, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update upgrade tier images
         * @param {string} networkId Network ID
         * @param {string} tierId Tier ID
         * @param {Array<TierImage>} tier New images for the tier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdTiersTierIdImagesPut: async (networkId: string, tierId: string, tier: Array<TierImage>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networksNetworkIdTiersTierIdImagesPut', 'networkId', networkId)
            // verify required parameter 'tierId' is not null or undefined
            assertParamExists('networksNetworkIdTiersTierIdImagesPut', 'tierId', tierId)
            // verify required parameter 'tier' is not null or undefined
            assertParamExists('networksNetworkIdTiersTierIdImagesPut', 'tier', tier)
            const localVarPath = `/networks/{network_id}/tiers/{tier_id}/images`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"tier_id"}}`, encodeURIComponent(String(tierId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tier, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get name of upgrade tier
         * @param {string} networkId Network ID
         * @param {string} tierId Tier ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdTiersTierIdNameGet: async (networkId: string, tierId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networksNetworkIdTiersTierIdNameGet', 'networkId', networkId)
            // verify required parameter 'tierId' is not null or undefined
            assertParamExists('networksNetworkIdTiersTierIdNameGet', 'tierId', tierId)
            const localVarPath = `/networks/{network_id}/tiers/{tier_id}/name`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"tier_id"}}`, encodeURIComponent(String(tierId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update upgrade tier name
         * @param {string} networkId Network ID
         * @param {string} tierId Tier ID
         * @param {string} name New name for the tier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdTiersTierIdNamePut: async (networkId: string, tierId: string, name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networksNetworkIdTiersTierIdNamePut', 'networkId', networkId)
            // verify required parameter 'tierId' is not null or undefined
            assertParamExists('networksNetworkIdTiersTierIdNamePut', 'tierId', tierId)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('networksNetworkIdTiersTierIdNamePut', 'name', name)
            const localVarPath = `/networks/{network_id}/tiers/{tier_id}/name`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"tier_id"}}`, encodeURIComponent(String(tierId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(name, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update upgrade tier
         * @param {string} networkId Network ID
         * @param {string} tierId Tier ID
         * @param {Tier} tier Configuration of the tier to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdTiersTierIdPut: async (networkId: string, tierId: string, tier: Tier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networksNetworkIdTiersTierIdPut', 'networkId', networkId)
            // verify required parameter 'tierId' is not null or undefined
            assertParamExists('networksNetworkIdTiersTierIdPut', 'tierId', tierId)
            // verify required parameter 'tier' is not null or undefined
            assertParamExists('networksNetworkIdTiersTierIdPut', 'tier', tier)
            const localVarPath = `/networks/{network_id}/tiers/{tier_id}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"tier_id"}}`, encodeURIComponent(String(tierId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tier, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get version of upgrade tier
         * @param {string} networkId Network ID
         * @param {string} tierId Tier ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdTiersTierIdVersionGet: async (networkId: string, tierId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networksNetworkIdTiersTierIdVersionGet', 'networkId', networkId)
            // verify required parameter 'tierId' is not null or undefined
            assertParamExists('networksNetworkIdTiersTierIdVersionGet', 'tierId', tierId)
            const localVarPath = `/networks/{network_id}/tiers/{tier_id}/version`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"tier_id"}}`, encodeURIComponent(String(tierId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update upgrade tier version
         * @param {string} networkId Network ID
         * @param {string} tierId Tier ID
         * @param {string} version New version for the tier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdTiersTierIdVersionPut: async (networkId: string, tierId: string, version: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networksNetworkIdTiersTierIdVersionPut', 'networkId', networkId)
            // verify required parameter 'tierId' is not null or undefined
            assertParamExists('networksNetworkIdTiersTierIdVersionPut', 'tierId', tierId)
            // verify required parameter 'version' is not null or undefined
            assertParamExists('networksNetworkIdTiersTierIdVersionPut', 'version', version)
            const localVarPath = `/networks/{network_id}/tiers/{tier_id}/version`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"tier_id"}}`, encodeURIComponent(String(tierId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(version, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UpgradesApi - functional programming interface
 * @export
 */
export const UpgradesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UpgradesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete a release channel
         * @param {string} channelId Release Channel ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelsChannelIdDelete(channelId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.channelsChannelIdDelete(channelId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get release channel by id
         * @param {string} channelId Release Channel ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelsChannelIdGet(channelId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReleaseChannel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.channelsChannelIdGet(channelId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a release channel
         * @param {string} channelId Release Channel ID
         * @param {ReleaseChannel} releaseChannel New channel configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelsChannelIdPut(channelId: string, releaseChannel: ReleaseChannel, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.channelsChannelIdPut(channelId, releaseChannel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all release channels
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelsGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.channelsGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a new release channel
         * @param {ReleaseChannel} channel The release channel to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelsPost(channel: ReleaseChannel, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.channelsPost(channel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a list of upgrade tiers
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksNetworkIdTiersGet(networkId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksNetworkIdTiersGet(networkId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Register a tier
         * @param {string} networkId Network ID
         * @param {Tier} tier Configuration of the tier to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksNetworkIdTiersPost(networkId: string, tier: Tier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksNetworkIdTiersPost(networkId, tier, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete upgrade tier
         * @param {string} networkId Network ID
         * @param {string} tierId Tier ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksNetworkIdTiersTierIdDelete(networkId: string, tierId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksNetworkIdTiersTierIdDelete(networkId, tierId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove a gateway from tier
         * @param {string} networkId Network ID
         * @param {string} tierId Tier ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksNetworkIdTiersTierIdGatewaysGatewayIdDelete(networkId: string, tierId: string, gatewayId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksNetworkIdTiersTierIdGatewaysGatewayIdDelete(networkId, tierId, gatewayId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get gateways of upgrade tier
         * @param {string} networkId Network ID
         * @param {string} tierId Tier ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksNetworkIdTiersTierIdGatewaysGet(networkId: string, tierId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksNetworkIdTiersTierIdGatewaysGet(networkId, tierId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add a gateway to upgrade tier
         * @param {string} networkId Network ID
         * @param {string} tierId Tier ID
         * @param {string} gateway New gateway for the tier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksNetworkIdTiersTierIdGatewaysPost(networkId: string, tierId: string, gateway: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksNetworkIdTiersTierIdGatewaysPost(networkId, tierId, gateway, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update upgrade tier gateways
         * @param {string} networkId Network ID
         * @param {string} tierId Tier ID
         * @param {Array<string>} tier New images for the tier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksNetworkIdTiersTierIdGatewaysPut(networkId: string, tierId: string, tier: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksNetworkIdTiersTierIdGatewaysPut(networkId, tierId, tier, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get upgrade tier
         * @param {string} networkId Network ID
         * @param {string} tierId Tier ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksNetworkIdTiersTierIdGet(networkId: string, tierId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tier>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksNetworkIdTiersTierIdGet(networkId, tierId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get images of upgrade tier
         * @param {string} networkId Network ID
         * @param {string} tierId Tier ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksNetworkIdTiersTierIdImagesGet(networkId: string, tierId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TierImage>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksNetworkIdTiersTierIdImagesGet(networkId, tierId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove an image from tier
         * @param {string} networkId Network ID
         * @param {string} tierId Tier ID
         * @param {string} imageName Name of an image
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksNetworkIdTiersTierIdImagesImageNameDelete(networkId: string, tierId: string, imageName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksNetworkIdTiersTierIdImagesImageNameDelete(networkId, tierId, imageName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add an image to upgrade tier
         * @param {string} networkId Network ID
         * @param {string} tierId Tier ID
         * @param {TierImage} image New image for the tier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksNetworkIdTiersTierIdImagesPost(networkId: string, tierId: string, image: TierImage, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksNetworkIdTiersTierIdImagesPost(networkId, tierId, image, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update upgrade tier images
         * @param {string} networkId Network ID
         * @param {string} tierId Tier ID
         * @param {Array<TierImage>} tier New images for the tier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksNetworkIdTiersTierIdImagesPut(networkId: string, tierId: string, tier: Array<TierImage>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksNetworkIdTiersTierIdImagesPut(networkId, tierId, tier, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get name of upgrade tier
         * @param {string} networkId Network ID
         * @param {string} tierId Tier ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksNetworkIdTiersTierIdNameGet(networkId: string, tierId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksNetworkIdTiersTierIdNameGet(networkId, tierId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update upgrade tier name
         * @param {string} networkId Network ID
         * @param {string} tierId Tier ID
         * @param {string} name New name for the tier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksNetworkIdTiersTierIdNamePut(networkId: string, tierId: string, name: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksNetworkIdTiersTierIdNamePut(networkId, tierId, name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update upgrade tier
         * @param {string} networkId Network ID
         * @param {string} tierId Tier ID
         * @param {Tier} tier Configuration of the tier to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksNetworkIdTiersTierIdPut(networkId: string, tierId: string, tier: Tier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksNetworkIdTiersTierIdPut(networkId, tierId, tier, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get version of upgrade tier
         * @param {string} networkId Network ID
         * @param {string} tierId Tier ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksNetworkIdTiersTierIdVersionGet(networkId: string, tierId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksNetworkIdTiersTierIdVersionGet(networkId, tierId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update upgrade tier version
         * @param {string} networkId Network ID
         * @param {string} tierId Tier ID
         * @param {string} version New version for the tier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksNetworkIdTiersTierIdVersionPut(networkId: string, tierId: string, version: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksNetworkIdTiersTierIdVersionPut(networkId, tierId, version, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UpgradesApi - factory interface
 * @export
 */
export const UpgradesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UpgradesApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete a release channel
         * @param {string} channelId Release Channel ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelsChannelIdDelete(channelId: string, options?: any): AxiosPromise<void> {
            return localVarFp.channelsChannelIdDelete(channelId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get release channel by id
         * @param {string} channelId Release Channel ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelsChannelIdGet(channelId: string, options?: any): AxiosPromise<ReleaseChannel> {
            return localVarFp.channelsChannelIdGet(channelId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a release channel
         * @param {string} channelId Release Channel ID
         * @param {ReleaseChannel} releaseChannel New channel configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelsChannelIdPut(channelId: string, releaseChannel: ReleaseChannel, options?: any): AxiosPromise<void> {
            return localVarFp.channelsChannelIdPut(channelId, releaseChannel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all release channels
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelsGet(options?: any): AxiosPromise<Array<string>> {
            return localVarFp.channelsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new release channel
         * @param {ReleaseChannel} channel The release channel to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelsPost(channel: ReleaseChannel, options?: any): AxiosPromise<void> {
            return localVarFp.channelsPost(channel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a list of upgrade tiers
         * @param {string} networkId Network ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdTiersGet(networkId: string, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.networksNetworkIdTiersGet(networkId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Register a tier
         * @param {string} networkId Network ID
         * @param {Tier} tier Configuration of the tier to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdTiersPost(networkId: string, tier: Tier, options?: any): AxiosPromise<void> {
            return localVarFp.networksNetworkIdTiersPost(networkId, tier, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete upgrade tier
         * @param {string} networkId Network ID
         * @param {string} tierId Tier ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdTiersTierIdDelete(networkId: string, tierId: string, options?: any): AxiosPromise<void> {
            return localVarFp.networksNetworkIdTiersTierIdDelete(networkId, tierId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove a gateway from tier
         * @param {string} networkId Network ID
         * @param {string} tierId Tier ID
         * @param {string} gatewayId Gateway ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdTiersTierIdGatewaysGatewayIdDelete(networkId: string, tierId: string, gatewayId: string, options?: any): AxiosPromise<void> {
            return localVarFp.networksNetworkIdTiersTierIdGatewaysGatewayIdDelete(networkId, tierId, gatewayId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get gateways of upgrade tier
         * @param {string} networkId Network ID
         * @param {string} tierId Tier ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdTiersTierIdGatewaysGet(networkId: string, tierId: string, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.networksNetworkIdTiersTierIdGatewaysGet(networkId, tierId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add a gateway to upgrade tier
         * @param {string} networkId Network ID
         * @param {string} tierId Tier ID
         * @param {string} gateway New gateway for the tier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdTiersTierIdGatewaysPost(networkId: string, tierId: string, gateway: string, options?: any): AxiosPromise<void> {
            return localVarFp.networksNetworkIdTiersTierIdGatewaysPost(networkId, tierId, gateway, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update upgrade tier gateways
         * @param {string} networkId Network ID
         * @param {string} tierId Tier ID
         * @param {Array<string>} tier New images for the tier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdTiersTierIdGatewaysPut(networkId: string, tierId: string, tier: Array<string>, options?: any): AxiosPromise<void> {
            return localVarFp.networksNetworkIdTiersTierIdGatewaysPut(networkId, tierId, tier, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get upgrade tier
         * @param {string} networkId Network ID
         * @param {string} tierId Tier ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdTiersTierIdGet(networkId: string, tierId: string, options?: any): AxiosPromise<Tier> {
            return localVarFp.networksNetworkIdTiersTierIdGet(networkId, tierId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get images of upgrade tier
         * @param {string} networkId Network ID
         * @param {string} tierId Tier ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdTiersTierIdImagesGet(networkId: string, tierId: string, options?: any): AxiosPromise<Array<TierImage>> {
            return localVarFp.networksNetworkIdTiersTierIdImagesGet(networkId, tierId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove an image from tier
         * @param {string} networkId Network ID
         * @param {string} tierId Tier ID
         * @param {string} imageName Name of an image
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdTiersTierIdImagesImageNameDelete(networkId: string, tierId: string, imageName: string, options?: any): AxiosPromise<void> {
            return localVarFp.networksNetworkIdTiersTierIdImagesImageNameDelete(networkId, tierId, imageName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add an image to upgrade tier
         * @param {string} networkId Network ID
         * @param {string} tierId Tier ID
         * @param {TierImage} image New image for the tier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdTiersTierIdImagesPost(networkId: string, tierId: string, image: TierImage, options?: any): AxiosPromise<void> {
            return localVarFp.networksNetworkIdTiersTierIdImagesPost(networkId, tierId, image, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update upgrade tier images
         * @param {string} networkId Network ID
         * @param {string} tierId Tier ID
         * @param {Array<TierImage>} tier New images for the tier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdTiersTierIdImagesPut(networkId: string, tierId: string, tier: Array<TierImage>, options?: any): AxiosPromise<void> {
            return localVarFp.networksNetworkIdTiersTierIdImagesPut(networkId, tierId, tier, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get name of upgrade tier
         * @param {string} networkId Network ID
         * @param {string} tierId Tier ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdTiersTierIdNameGet(networkId: string, tierId: string, options?: any): AxiosPromise<string> {
            return localVarFp.networksNetworkIdTiersTierIdNameGet(networkId, tierId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update upgrade tier name
         * @param {string} networkId Network ID
         * @param {string} tierId Tier ID
         * @param {string} name New name for the tier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdTiersTierIdNamePut(networkId: string, tierId: string, name: string, options?: any): AxiosPromise<void> {
            return localVarFp.networksNetworkIdTiersTierIdNamePut(networkId, tierId, name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update upgrade tier
         * @param {string} networkId Network ID
         * @param {string} tierId Tier ID
         * @param {Tier} tier Configuration of the tier to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdTiersTierIdPut(networkId: string, tierId: string, tier: Tier, options?: any): AxiosPromise<void> {
            return localVarFp.networksNetworkIdTiersTierIdPut(networkId, tierId, tier, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get version of upgrade tier
         * @param {string} networkId Network ID
         * @param {string} tierId Tier ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdTiersTierIdVersionGet(networkId: string, tierId: string, options?: any): AxiosPromise<string> {
            return localVarFp.networksNetworkIdTiersTierIdVersionGet(networkId, tierId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update upgrade tier version
         * @param {string} networkId Network ID
         * @param {string} tierId Tier ID
         * @param {string} version New version for the tier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdTiersTierIdVersionPut(networkId: string, tierId: string, version: string, options?: any): AxiosPromise<void> {
            return localVarFp.networksNetworkIdTiersTierIdVersionPut(networkId, tierId, version, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for channelsChannelIdDelete operation in UpgradesApi.
 * @export
 * @interface UpgradesApiChannelsChannelIdDeleteRequest
 */
export interface UpgradesApiChannelsChannelIdDeleteRequest {
    /**
     * Release Channel ID
     * @type {string}
     * @memberof UpgradesApiChannelsChannelIdDelete
     */
    readonly channelId: string
}

/**
 * Request parameters for channelsChannelIdGet operation in UpgradesApi.
 * @export
 * @interface UpgradesApiChannelsChannelIdGetRequest
 */
export interface UpgradesApiChannelsChannelIdGetRequest {
    /**
     * Release Channel ID
     * @type {string}
     * @memberof UpgradesApiChannelsChannelIdGet
     */
    readonly channelId: string
}

/**
 * Request parameters for channelsChannelIdPut operation in UpgradesApi.
 * @export
 * @interface UpgradesApiChannelsChannelIdPutRequest
 */
export interface UpgradesApiChannelsChannelIdPutRequest {
    /**
     * Release Channel ID
     * @type {string}
     * @memberof UpgradesApiChannelsChannelIdPut
     */
    readonly channelId: string

    /**
     * New channel configuration
     * @type {ReleaseChannel}
     * @memberof UpgradesApiChannelsChannelIdPut
     */
    readonly releaseChannel: ReleaseChannel
}

/**
 * Request parameters for channelsPost operation in UpgradesApi.
 * @export
 * @interface UpgradesApiChannelsPostRequest
 */
export interface UpgradesApiChannelsPostRequest {
    /**
     * The release channel to create
     * @type {ReleaseChannel}
     * @memberof UpgradesApiChannelsPost
     */
    readonly channel: ReleaseChannel
}

/**
 * Request parameters for networksNetworkIdTiersGet operation in UpgradesApi.
 * @export
 * @interface UpgradesApiNetworksNetworkIdTiersGetRequest
 */
export interface UpgradesApiNetworksNetworkIdTiersGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof UpgradesApiNetworksNetworkIdTiersGet
     */
    readonly networkId: string
}

/**
 * Request parameters for networksNetworkIdTiersPost operation in UpgradesApi.
 * @export
 * @interface UpgradesApiNetworksNetworkIdTiersPostRequest
 */
export interface UpgradesApiNetworksNetworkIdTiersPostRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof UpgradesApiNetworksNetworkIdTiersPost
     */
    readonly networkId: string

    /**
     * Configuration of the tier to create
     * @type {Tier}
     * @memberof UpgradesApiNetworksNetworkIdTiersPost
     */
    readonly tier: Tier
}

/**
 * Request parameters for networksNetworkIdTiersTierIdDelete operation in UpgradesApi.
 * @export
 * @interface UpgradesApiNetworksNetworkIdTiersTierIdDeleteRequest
 */
export interface UpgradesApiNetworksNetworkIdTiersTierIdDeleteRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof UpgradesApiNetworksNetworkIdTiersTierIdDelete
     */
    readonly networkId: string

    /**
     * Tier ID
     * @type {string}
     * @memberof UpgradesApiNetworksNetworkIdTiersTierIdDelete
     */
    readonly tierId: string
}

/**
 * Request parameters for networksNetworkIdTiersTierIdGatewaysGatewayIdDelete operation in UpgradesApi.
 * @export
 * @interface UpgradesApiNetworksNetworkIdTiersTierIdGatewaysGatewayIdDeleteRequest
 */
export interface UpgradesApiNetworksNetworkIdTiersTierIdGatewaysGatewayIdDeleteRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof UpgradesApiNetworksNetworkIdTiersTierIdGatewaysGatewayIdDelete
     */
    readonly networkId: string

    /**
     * Tier ID
     * @type {string}
     * @memberof UpgradesApiNetworksNetworkIdTiersTierIdGatewaysGatewayIdDelete
     */
    readonly tierId: string

    /**
     * Gateway ID
     * @type {string}
     * @memberof UpgradesApiNetworksNetworkIdTiersTierIdGatewaysGatewayIdDelete
     */
    readonly gatewayId: string
}

/**
 * Request parameters for networksNetworkIdTiersTierIdGatewaysGet operation in UpgradesApi.
 * @export
 * @interface UpgradesApiNetworksNetworkIdTiersTierIdGatewaysGetRequest
 */
export interface UpgradesApiNetworksNetworkIdTiersTierIdGatewaysGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof UpgradesApiNetworksNetworkIdTiersTierIdGatewaysGet
     */
    readonly networkId: string

    /**
     * Tier ID
     * @type {string}
     * @memberof UpgradesApiNetworksNetworkIdTiersTierIdGatewaysGet
     */
    readonly tierId: string
}

/**
 * Request parameters for networksNetworkIdTiersTierIdGatewaysPost operation in UpgradesApi.
 * @export
 * @interface UpgradesApiNetworksNetworkIdTiersTierIdGatewaysPostRequest
 */
export interface UpgradesApiNetworksNetworkIdTiersTierIdGatewaysPostRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof UpgradesApiNetworksNetworkIdTiersTierIdGatewaysPost
     */
    readonly networkId: string

    /**
     * Tier ID
     * @type {string}
     * @memberof UpgradesApiNetworksNetworkIdTiersTierIdGatewaysPost
     */
    readonly tierId: string

    /**
     * New gateway for the tier
     * @type {string}
     * @memberof UpgradesApiNetworksNetworkIdTiersTierIdGatewaysPost
     */
    readonly gateway: string
}

/**
 * Request parameters for networksNetworkIdTiersTierIdGatewaysPut operation in UpgradesApi.
 * @export
 * @interface UpgradesApiNetworksNetworkIdTiersTierIdGatewaysPutRequest
 */
export interface UpgradesApiNetworksNetworkIdTiersTierIdGatewaysPutRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof UpgradesApiNetworksNetworkIdTiersTierIdGatewaysPut
     */
    readonly networkId: string

    /**
     * Tier ID
     * @type {string}
     * @memberof UpgradesApiNetworksNetworkIdTiersTierIdGatewaysPut
     */
    readonly tierId: string

    /**
     * New images for the tier
     * @type {Array<string>}
     * @memberof UpgradesApiNetworksNetworkIdTiersTierIdGatewaysPut
     */
    readonly tier: Array<string>
}

/**
 * Request parameters for networksNetworkIdTiersTierIdGet operation in UpgradesApi.
 * @export
 * @interface UpgradesApiNetworksNetworkIdTiersTierIdGetRequest
 */
export interface UpgradesApiNetworksNetworkIdTiersTierIdGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof UpgradesApiNetworksNetworkIdTiersTierIdGet
     */
    readonly networkId: string

    /**
     * Tier ID
     * @type {string}
     * @memberof UpgradesApiNetworksNetworkIdTiersTierIdGet
     */
    readonly tierId: string
}

/**
 * Request parameters for networksNetworkIdTiersTierIdImagesGet operation in UpgradesApi.
 * @export
 * @interface UpgradesApiNetworksNetworkIdTiersTierIdImagesGetRequest
 */
export interface UpgradesApiNetworksNetworkIdTiersTierIdImagesGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof UpgradesApiNetworksNetworkIdTiersTierIdImagesGet
     */
    readonly networkId: string

    /**
     * Tier ID
     * @type {string}
     * @memberof UpgradesApiNetworksNetworkIdTiersTierIdImagesGet
     */
    readonly tierId: string
}

/**
 * Request parameters for networksNetworkIdTiersTierIdImagesImageNameDelete operation in UpgradesApi.
 * @export
 * @interface UpgradesApiNetworksNetworkIdTiersTierIdImagesImageNameDeleteRequest
 */
export interface UpgradesApiNetworksNetworkIdTiersTierIdImagesImageNameDeleteRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof UpgradesApiNetworksNetworkIdTiersTierIdImagesImageNameDelete
     */
    readonly networkId: string

    /**
     * Tier ID
     * @type {string}
     * @memberof UpgradesApiNetworksNetworkIdTiersTierIdImagesImageNameDelete
     */
    readonly tierId: string

    /**
     * Name of an image
     * @type {string}
     * @memberof UpgradesApiNetworksNetworkIdTiersTierIdImagesImageNameDelete
     */
    readonly imageName: string
}

/**
 * Request parameters for networksNetworkIdTiersTierIdImagesPost operation in UpgradesApi.
 * @export
 * @interface UpgradesApiNetworksNetworkIdTiersTierIdImagesPostRequest
 */
export interface UpgradesApiNetworksNetworkIdTiersTierIdImagesPostRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof UpgradesApiNetworksNetworkIdTiersTierIdImagesPost
     */
    readonly networkId: string

    /**
     * Tier ID
     * @type {string}
     * @memberof UpgradesApiNetworksNetworkIdTiersTierIdImagesPost
     */
    readonly tierId: string

    /**
     * New image for the tier
     * @type {TierImage}
     * @memberof UpgradesApiNetworksNetworkIdTiersTierIdImagesPost
     */
    readonly image: TierImage
}

/**
 * Request parameters for networksNetworkIdTiersTierIdImagesPut operation in UpgradesApi.
 * @export
 * @interface UpgradesApiNetworksNetworkIdTiersTierIdImagesPutRequest
 */
export interface UpgradesApiNetworksNetworkIdTiersTierIdImagesPutRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof UpgradesApiNetworksNetworkIdTiersTierIdImagesPut
     */
    readonly networkId: string

    /**
     * Tier ID
     * @type {string}
     * @memberof UpgradesApiNetworksNetworkIdTiersTierIdImagesPut
     */
    readonly tierId: string

    /**
     * New images for the tier
     * @type {Array<TierImage>}
     * @memberof UpgradesApiNetworksNetworkIdTiersTierIdImagesPut
     */
    readonly tier: Array<TierImage>
}

/**
 * Request parameters for networksNetworkIdTiersTierIdNameGet operation in UpgradesApi.
 * @export
 * @interface UpgradesApiNetworksNetworkIdTiersTierIdNameGetRequest
 */
export interface UpgradesApiNetworksNetworkIdTiersTierIdNameGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof UpgradesApiNetworksNetworkIdTiersTierIdNameGet
     */
    readonly networkId: string

    /**
     * Tier ID
     * @type {string}
     * @memberof UpgradesApiNetworksNetworkIdTiersTierIdNameGet
     */
    readonly tierId: string
}

/**
 * Request parameters for networksNetworkIdTiersTierIdNamePut operation in UpgradesApi.
 * @export
 * @interface UpgradesApiNetworksNetworkIdTiersTierIdNamePutRequest
 */
export interface UpgradesApiNetworksNetworkIdTiersTierIdNamePutRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof UpgradesApiNetworksNetworkIdTiersTierIdNamePut
     */
    readonly networkId: string

    /**
     * Tier ID
     * @type {string}
     * @memberof UpgradesApiNetworksNetworkIdTiersTierIdNamePut
     */
    readonly tierId: string

    /**
     * New name for the tier
     * @type {string}
     * @memberof UpgradesApiNetworksNetworkIdTiersTierIdNamePut
     */
    readonly name: string
}

/**
 * Request parameters for networksNetworkIdTiersTierIdPut operation in UpgradesApi.
 * @export
 * @interface UpgradesApiNetworksNetworkIdTiersTierIdPutRequest
 */
export interface UpgradesApiNetworksNetworkIdTiersTierIdPutRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof UpgradesApiNetworksNetworkIdTiersTierIdPut
     */
    readonly networkId: string

    /**
     * Tier ID
     * @type {string}
     * @memberof UpgradesApiNetworksNetworkIdTiersTierIdPut
     */
    readonly tierId: string

    /**
     * Configuration of the tier to update
     * @type {Tier}
     * @memberof UpgradesApiNetworksNetworkIdTiersTierIdPut
     */
    readonly tier: Tier
}

/**
 * Request parameters for networksNetworkIdTiersTierIdVersionGet operation in UpgradesApi.
 * @export
 * @interface UpgradesApiNetworksNetworkIdTiersTierIdVersionGetRequest
 */
export interface UpgradesApiNetworksNetworkIdTiersTierIdVersionGetRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof UpgradesApiNetworksNetworkIdTiersTierIdVersionGet
     */
    readonly networkId: string

    /**
     * Tier ID
     * @type {string}
     * @memberof UpgradesApiNetworksNetworkIdTiersTierIdVersionGet
     */
    readonly tierId: string
}

/**
 * Request parameters for networksNetworkIdTiersTierIdVersionPut operation in UpgradesApi.
 * @export
 * @interface UpgradesApiNetworksNetworkIdTiersTierIdVersionPutRequest
 */
export interface UpgradesApiNetworksNetworkIdTiersTierIdVersionPutRequest {
    /**
     * Network ID
     * @type {string}
     * @memberof UpgradesApiNetworksNetworkIdTiersTierIdVersionPut
     */
    readonly networkId: string

    /**
     * Tier ID
     * @type {string}
     * @memberof UpgradesApiNetworksNetworkIdTiersTierIdVersionPut
     */
    readonly tierId: string

    /**
     * New version for the tier
     * @type {string}
     * @memberof UpgradesApiNetworksNetworkIdTiersTierIdVersionPut
     */
    readonly version: string
}

/**
 * UpgradesApi - object-oriented interface
 * @export
 * @class UpgradesApi
 * @extends {BaseAPI}
 */
export class UpgradesApi extends BaseAPI {
    /**
     * 
     * @summary Delete a release channel
     * @param {UpgradesApiChannelsChannelIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UpgradesApi
     */
    public channelsChannelIdDelete(requestParameters: UpgradesApiChannelsChannelIdDeleteRequest, options?: AxiosRequestConfig) {
        return UpgradesApiFp(this.configuration).channelsChannelIdDelete(requestParameters.channelId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get release channel by id
     * @param {UpgradesApiChannelsChannelIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UpgradesApi
     */
    public channelsChannelIdGet(requestParameters: UpgradesApiChannelsChannelIdGetRequest, options?: AxiosRequestConfig) {
        return UpgradesApiFp(this.configuration).channelsChannelIdGet(requestParameters.channelId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a release channel
     * @param {UpgradesApiChannelsChannelIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UpgradesApi
     */
    public channelsChannelIdPut(requestParameters: UpgradesApiChannelsChannelIdPutRequest, options?: AxiosRequestConfig) {
        return UpgradesApiFp(this.configuration).channelsChannelIdPut(requestParameters.channelId, requestParameters.releaseChannel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all release channels
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UpgradesApi
     */
    public channelsGet(options?: AxiosRequestConfig) {
        return UpgradesApiFp(this.configuration).channelsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new release channel
     * @param {UpgradesApiChannelsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UpgradesApi
     */
    public channelsPost(requestParameters: UpgradesApiChannelsPostRequest, options?: AxiosRequestConfig) {
        return UpgradesApiFp(this.configuration).channelsPost(requestParameters.channel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a list of upgrade tiers
     * @param {UpgradesApiNetworksNetworkIdTiersGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UpgradesApi
     */
    public networksNetworkIdTiersGet(requestParameters: UpgradesApiNetworksNetworkIdTiersGetRequest, options?: AxiosRequestConfig) {
        return UpgradesApiFp(this.configuration).networksNetworkIdTiersGet(requestParameters.networkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Register a tier
     * @param {UpgradesApiNetworksNetworkIdTiersPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UpgradesApi
     */
    public networksNetworkIdTiersPost(requestParameters: UpgradesApiNetworksNetworkIdTiersPostRequest, options?: AxiosRequestConfig) {
        return UpgradesApiFp(this.configuration).networksNetworkIdTiersPost(requestParameters.networkId, requestParameters.tier, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete upgrade tier
     * @param {UpgradesApiNetworksNetworkIdTiersTierIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UpgradesApi
     */
    public networksNetworkIdTiersTierIdDelete(requestParameters: UpgradesApiNetworksNetworkIdTiersTierIdDeleteRequest, options?: AxiosRequestConfig) {
        return UpgradesApiFp(this.configuration).networksNetworkIdTiersTierIdDelete(requestParameters.networkId, requestParameters.tierId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove a gateway from tier
     * @param {UpgradesApiNetworksNetworkIdTiersTierIdGatewaysGatewayIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UpgradesApi
     */
    public networksNetworkIdTiersTierIdGatewaysGatewayIdDelete(requestParameters: UpgradesApiNetworksNetworkIdTiersTierIdGatewaysGatewayIdDeleteRequest, options?: AxiosRequestConfig) {
        return UpgradesApiFp(this.configuration).networksNetworkIdTiersTierIdGatewaysGatewayIdDelete(requestParameters.networkId, requestParameters.tierId, requestParameters.gatewayId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get gateways of upgrade tier
     * @param {UpgradesApiNetworksNetworkIdTiersTierIdGatewaysGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UpgradesApi
     */
    public networksNetworkIdTiersTierIdGatewaysGet(requestParameters: UpgradesApiNetworksNetworkIdTiersTierIdGatewaysGetRequest, options?: AxiosRequestConfig) {
        return UpgradesApiFp(this.configuration).networksNetworkIdTiersTierIdGatewaysGet(requestParameters.networkId, requestParameters.tierId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add a gateway to upgrade tier
     * @param {UpgradesApiNetworksNetworkIdTiersTierIdGatewaysPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UpgradesApi
     */
    public networksNetworkIdTiersTierIdGatewaysPost(requestParameters: UpgradesApiNetworksNetworkIdTiersTierIdGatewaysPostRequest, options?: AxiosRequestConfig) {
        return UpgradesApiFp(this.configuration).networksNetworkIdTiersTierIdGatewaysPost(requestParameters.networkId, requestParameters.tierId, requestParameters.gateway, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update upgrade tier gateways
     * @param {UpgradesApiNetworksNetworkIdTiersTierIdGatewaysPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UpgradesApi
     */
    public networksNetworkIdTiersTierIdGatewaysPut(requestParameters: UpgradesApiNetworksNetworkIdTiersTierIdGatewaysPutRequest, options?: AxiosRequestConfig) {
        return UpgradesApiFp(this.configuration).networksNetworkIdTiersTierIdGatewaysPut(requestParameters.networkId, requestParameters.tierId, requestParameters.tier, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get upgrade tier
     * @param {UpgradesApiNetworksNetworkIdTiersTierIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UpgradesApi
     */
    public networksNetworkIdTiersTierIdGet(requestParameters: UpgradesApiNetworksNetworkIdTiersTierIdGetRequest, options?: AxiosRequestConfig) {
        return UpgradesApiFp(this.configuration).networksNetworkIdTiersTierIdGet(requestParameters.networkId, requestParameters.tierId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get images of upgrade tier
     * @param {UpgradesApiNetworksNetworkIdTiersTierIdImagesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UpgradesApi
     */
    public networksNetworkIdTiersTierIdImagesGet(requestParameters: UpgradesApiNetworksNetworkIdTiersTierIdImagesGetRequest, options?: AxiosRequestConfig) {
        return UpgradesApiFp(this.configuration).networksNetworkIdTiersTierIdImagesGet(requestParameters.networkId, requestParameters.tierId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove an image from tier
     * @param {UpgradesApiNetworksNetworkIdTiersTierIdImagesImageNameDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UpgradesApi
     */
    public networksNetworkIdTiersTierIdImagesImageNameDelete(requestParameters: UpgradesApiNetworksNetworkIdTiersTierIdImagesImageNameDeleteRequest, options?: AxiosRequestConfig) {
        return UpgradesApiFp(this.configuration).networksNetworkIdTiersTierIdImagesImageNameDelete(requestParameters.networkId, requestParameters.tierId, requestParameters.imageName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add an image to upgrade tier
     * @param {UpgradesApiNetworksNetworkIdTiersTierIdImagesPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UpgradesApi
     */
    public networksNetworkIdTiersTierIdImagesPost(requestParameters: UpgradesApiNetworksNetworkIdTiersTierIdImagesPostRequest, options?: AxiosRequestConfig) {
        return UpgradesApiFp(this.configuration).networksNetworkIdTiersTierIdImagesPost(requestParameters.networkId, requestParameters.tierId, requestParameters.image, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update upgrade tier images
     * @param {UpgradesApiNetworksNetworkIdTiersTierIdImagesPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UpgradesApi
     */
    public networksNetworkIdTiersTierIdImagesPut(requestParameters: UpgradesApiNetworksNetworkIdTiersTierIdImagesPutRequest, options?: AxiosRequestConfig) {
        return UpgradesApiFp(this.configuration).networksNetworkIdTiersTierIdImagesPut(requestParameters.networkId, requestParameters.tierId, requestParameters.tier, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get name of upgrade tier
     * @param {UpgradesApiNetworksNetworkIdTiersTierIdNameGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UpgradesApi
     */
    public networksNetworkIdTiersTierIdNameGet(requestParameters: UpgradesApiNetworksNetworkIdTiersTierIdNameGetRequest, options?: AxiosRequestConfig) {
        return UpgradesApiFp(this.configuration).networksNetworkIdTiersTierIdNameGet(requestParameters.networkId, requestParameters.tierId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update upgrade tier name
     * @param {UpgradesApiNetworksNetworkIdTiersTierIdNamePutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UpgradesApi
     */
    public networksNetworkIdTiersTierIdNamePut(requestParameters: UpgradesApiNetworksNetworkIdTiersTierIdNamePutRequest, options?: AxiosRequestConfig) {
        return UpgradesApiFp(this.configuration).networksNetworkIdTiersTierIdNamePut(requestParameters.networkId, requestParameters.tierId, requestParameters.name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update upgrade tier
     * @param {UpgradesApiNetworksNetworkIdTiersTierIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UpgradesApi
     */
    public networksNetworkIdTiersTierIdPut(requestParameters: UpgradesApiNetworksNetworkIdTiersTierIdPutRequest, options?: AxiosRequestConfig) {
        return UpgradesApiFp(this.configuration).networksNetworkIdTiersTierIdPut(requestParameters.networkId, requestParameters.tierId, requestParameters.tier, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get version of upgrade tier
     * @param {UpgradesApiNetworksNetworkIdTiersTierIdVersionGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UpgradesApi
     */
    public networksNetworkIdTiersTierIdVersionGet(requestParameters: UpgradesApiNetworksNetworkIdTiersTierIdVersionGetRequest, options?: AxiosRequestConfig) {
        return UpgradesApiFp(this.configuration).networksNetworkIdTiersTierIdVersionGet(requestParameters.networkId, requestParameters.tierId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update upgrade tier version
     * @param {UpgradesApiNetworksNetworkIdTiersTierIdVersionPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UpgradesApi
     */
    public networksNetworkIdTiersTierIdVersionPut(requestParameters: UpgradesApiNetworksNetworkIdTiersTierIdVersionPutRequest, options?: AxiosRequestConfig) {
        return UpgradesApiFp(this.configuration).networksNetworkIdTiersTierIdVersionPut(requestParameters.networkId, requestParameters.tierId, requestParameters.version, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List all usernames
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all the tokens given a user
         * @param {User} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userLoginPost: async (user: User, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('userLoginPost', 'user', user)
            const localVarPath = `/user/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(user, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a user
         * @param {User} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPost: async (user: User, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('userPost', 'user', user)
            const localVarPath = `/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(user, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove a user
         * @param {string} username username
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userUsernameDelete: async (username: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('userUsernameDelete', 'username', username)
            const localVarPath = `/user/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a single user\'s information
         * @param {string} username username
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userUsernameGet: async (username: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('userUsernameGet', 'username', username)
            const localVarPath = `/user/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a user\'s password
         * @param {string} username username
         * @param {UserUsernameDeleteRequest} password New password for user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userUsernamePut: async (username: string, password: UserUsernameDeleteRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('userUsernamePut', 'username', username)
            // verify required parameter 'password' is not null or undefined
            assertParamExists('userUsernamePut', 'password', password)
            const localVarPath = `/user/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(password, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of a user\'s tokens and their respective policies
         * @param {string} username username
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userUsernameTokensGet: async (username: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('userUsernameTokensGet', 'username', username)
            const localVarPath = `/user/{username}/tokens`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add a token/policy to the user\'s existing permissions
         * @param {string} username username
         * @param {Array<Policy>} policies 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userUsernameTokensPost: async (username: string, policies: Array<Policy>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('userUsernameTokensPost', 'username', username)
            // verify required parameter 'policies' is not null or undefined
            assertParamExists('userUsernameTokensPost', 'policies', policies)
            const localVarPath = `/user/{username}/tokens`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(policies, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Revoke the token and its policy from the user
         * @param {string} token 
         * @param {string} username username
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userUsernameTokensTokenDelete: async (token: string, username: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('userUsernameTokensTokenDelete', 'token', token)
            // verify required parameter 'username' is not null or undefined
            assertParamExists('userUsernameTokensTokenDelete', 'username', username)
            const localVarPath = `/user/{username}/tokens/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)))
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List all usernames
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all the tokens given a user
         * @param {User} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userLoginPost(user: User, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userLoginPost(user, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a user
         * @param {User} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userPost(user: User, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userPost(user, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove a user
         * @param {string} username username
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userUsernameDelete(username: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userUsernameDelete(username, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a single user\'s information
         * @param {string} username username
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userUsernameGet(username: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userUsernameGet(username, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a user\'s password
         * @param {string} username username
         * @param {UserUsernameDeleteRequest} password New password for user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userUsernamePut(username: string, password: UserUsernameDeleteRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userUsernamePut(username, password, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a list of a user\'s tokens and their respective policies
         * @param {string} username username
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userUsernameTokensGet(username: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PolicyList>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userUsernameTokensGet(username, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add a token/policy to the user\'s existing permissions
         * @param {string} username username
         * @param {Array<Policy>} policies 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userUsernameTokensPost(username: string, policies: Array<Policy>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userUsernameTokensPost(username, policies, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Revoke the token and its policy from the user
         * @param {string} token 
         * @param {string} username username
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userUsernameTokensTokenDelete(token: string, username: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userUsernameTokensTokenDelete(token, username, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * 
         * @summary List all usernames
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGet(options?: any): AxiosPromise<Array<string>> {
            return localVarFp.userGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all the tokens given a user
         * @param {User} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userLoginPost(user: User, options?: any): AxiosPromise<void> {
            return localVarFp.userLoginPost(user, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a user
         * @param {User} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPost(user: User, options?: any): AxiosPromise<void> {
            return localVarFp.userPost(user, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove a user
         * @param {string} username username
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userUsernameDelete(username: string, options?: any): AxiosPromise<void> {
            return localVarFp.userUsernameDelete(username, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a single user\'s information
         * @param {string} username username
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userUsernameGet(username: string, options?: any): AxiosPromise<string> {
            return localVarFp.userUsernameGet(username, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a user\'s password
         * @param {string} username username
         * @param {UserUsernameDeleteRequest} password New password for user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userUsernamePut(username: string, password: UserUsernameDeleteRequest, options?: any): AxiosPromise<void> {
            return localVarFp.userUsernamePut(username, password, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a list of a user\'s tokens and their respective policies
         * @param {string} username username
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userUsernameTokensGet(username: string, options?: any): AxiosPromise<Array<PolicyList>> {
            return localVarFp.userUsernameTokensGet(username, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add a token/policy to the user\'s existing permissions
         * @param {string} username username
         * @param {Array<Policy>} policies 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userUsernameTokensPost(username: string, policies: Array<Policy>, options?: any): AxiosPromise<void> {
            return localVarFp.userUsernameTokensPost(username, policies, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Revoke the token and its policy from the user
         * @param {string} token 
         * @param {string} username username
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userUsernameTokensTokenDelete(token: string, username: string, options?: any): AxiosPromise<void> {
            return localVarFp.userUsernameTokensTokenDelete(token, username, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for userLoginPost operation in UserApi.
 * @export
 * @interface UserApiUserLoginPostRequest
 */
export interface UserApiUserLoginPostRequest {
    /**
     * 
     * @type {User}
     * @memberof UserApiUserLoginPost
     */
    readonly user: User
}

/**
 * Request parameters for userPost operation in UserApi.
 * @export
 * @interface UserApiUserPostRequest
 */
export interface UserApiUserPostRequest {
    /**
     * 
     * @type {User}
     * @memberof UserApiUserPost
     */
    readonly user: User
}

/**
 * Request parameters for userUsernameDelete operation in UserApi.
 * @export
 * @interface UserApiUserUsernameDeleteRequest
 */
export interface UserApiUserUsernameDeleteRequest {
    /**
     * username
     * @type {string}
     * @memberof UserApiUserUsernameDelete
     */
    readonly username: string
}

/**
 * Request parameters for userUsernameGet operation in UserApi.
 * @export
 * @interface UserApiUserUsernameGetRequest
 */
export interface UserApiUserUsernameGetRequest {
    /**
     * username
     * @type {string}
     * @memberof UserApiUserUsernameGet
     */
    readonly username: string
}

/**
 * Request parameters for userUsernamePut operation in UserApi.
 * @export
 * @interface UserApiUserUsernamePutRequest
 */
export interface UserApiUserUsernamePutRequest {
    /**
     * username
     * @type {string}
     * @memberof UserApiUserUsernamePut
     */
    readonly username: string

    /**
     * New password for user
     * @type {UserUsernameDeleteRequest}
     * @memberof UserApiUserUsernamePut
     */
    readonly password: UserUsernameDeleteRequest
}

/**
 * Request parameters for userUsernameTokensGet operation in UserApi.
 * @export
 * @interface UserApiUserUsernameTokensGetRequest
 */
export interface UserApiUserUsernameTokensGetRequest {
    /**
     * username
     * @type {string}
     * @memberof UserApiUserUsernameTokensGet
     */
    readonly username: string
}

/**
 * Request parameters for userUsernameTokensPost operation in UserApi.
 * @export
 * @interface UserApiUserUsernameTokensPostRequest
 */
export interface UserApiUserUsernameTokensPostRequest {
    /**
     * username
     * @type {string}
     * @memberof UserApiUserUsernameTokensPost
     */
    readonly username: string

    /**
     * 
     * @type {Array<Policy>}
     * @memberof UserApiUserUsernameTokensPost
     */
    readonly policies: Array<Policy>
}

/**
 * Request parameters for userUsernameTokensTokenDelete operation in UserApi.
 * @export
 * @interface UserApiUserUsernameTokensTokenDeleteRequest
 */
export interface UserApiUserUsernameTokensTokenDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof UserApiUserUsernameTokensTokenDelete
     */
    readonly token: string

    /**
     * username
     * @type {string}
     * @memberof UserApiUserUsernameTokensTokenDelete
     */
    readonly username: string
}

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * 
     * @summary List all usernames
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userGet(options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all the tokens given a user
     * @param {UserApiUserLoginPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userLoginPost(requestParameters: UserApiUserLoginPostRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userLoginPost(requestParameters.user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a user
     * @param {UserApiUserPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userPost(requestParameters: UserApiUserPostRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userPost(requestParameters.user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove a user
     * @param {UserApiUserUsernameDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userUsernameDelete(requestParameters: UserApiUserUsernameDeleteRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userUsernameDelete(requestParameters.username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a single user\'s information
     * @param {UserApiUserUsernameGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userUsernameGet(requestParameters: UserApiUserUsernameGetRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userUsernameGet(requestParameters.username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a user\'s password
     * @param {UserApiUserUsernamePutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userUsernamePut(requestParameters: UserApiUserUsernamePutRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userUsernamePut(requestParameters.username, requestParameters.password, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a list of a user\'s tokens and their respective policies
     * @param {UserApiUserUsernameTokensGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userUsernameTokensGet(requestParameters: UserApiUserUsernameTokensGetRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userUsernameTokensGet(requestParameters.username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add a token/policy to the user\'s existing permissions
     * @param {UserApiUserUsernameTokensPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userUsernameTokensPost(requestParameters: UserApiUserUsernameTokensPostRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userUsernameTokensPost(requestParameters.username, requestParameters.policies, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Revoke the token and its policy from the user
     * @param {UserApiUserUsernameTokensTokenDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userUsernameTokensTokenDelete(requestParameters: UserApiUserUsernameTokensTokenDeleteRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userUsernameTokensTokenDelete(requestParameters.token, requestParameters.username, options).then((request) => request(this.axios, this.basePath));
    }
}

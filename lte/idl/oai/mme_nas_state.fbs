enum Constants : uint {
  CHARGING_CHARACTERISTICS_LENGTH_P1 = 5,
}

enum S1Cause : uint {
  S1AP_INVALID_CAUSE = 0,
  S1AP_NAS_NORMAL_RELEASE,
  S1AP_NAS_DETACH,
  S1AP_RADIO_EUTRAN_GENERATED_REASON,
  S1AP_RADIO_UNKNOWN_E_RAB_ID,
  S1AP_IMPLICIT_CONTEXT_RELEASE,
  S1AP_INITIAL_CONTEXT_SETUP_FAILED,
  S1AP_SCTP_SHUTDOWN_OR_RESET,
  S1AP_INVALID_ENB_ID,
  S1AP_INVALID_MME_UE_S1AP_ID,
  S1AP_CSFB_TRIGGERED,
  S1AP_NAS_UE_NOT_AVAILABLE_FOR_PS,
  S1AP_SYSTEM_FAILURE,
  S1AP_RADIO_MULTIPLE_E_RAB_ID,
  S1AP_NAS_MME_OFFLOADING,
  S1AP_NAS_MME_PENDING_OFFLOADING
}

enum MmState : byte {
  UE_UNREGISTERED = 0,
  UE_REGISTERED
}

enum EcmState : byte {
  ECM_IDLE = 0,
  ECM_CONNECTED
}

struct Imsi {
  value:[ubyte:8];
  length:ubyte;
}

struct Imei {
  value:[ubyte:8];
}

struct Imeisv {
  value:[ubyte:8];
}

struct Plmn {
  bytes:[byte:3];
}

struct Tai {
  plmn:Plmn;
  tac:uint16;
}

struct Lai {
  plmn:Plmn;
  lac:uint16;
}

struct Ecgi {
  /// plmn_t
  plmn:Plmn;
  ///  eci_t The ECI shall be of fixed length of 28 bits
  cell_identity:uint;
}

enum PdnTypeValue:ubyte {
  IPv4        = 0,
  IPv6        = 1,
  IPv4_AND_v6 = 2,
  IPv4_OR_v6  = 3,
  IP_MAX
}

struct In6Addr {
  u6_addr8:[byte:16];
}

struct Address {
  ipv4_address_in_addr:uint32;
  ipv6_address:In6Addr;
}

struct IpAddress {
  pdn_type:PdnTypeValue;
  address:Address;
}

enum PreEmptionVulnerability:ubyte {
  PRE_EMPTION_VULNERABILITY_ENABLED  = 0,
  PRE_EMPTION_VULNERABILITY_DISABLED = 1,
  PRE_EMPTION_VULNERABILITY_MAX
}

enum PreEmptionCapability:ubyte {
  PRE_EMPTION_CAPABILITY_ENABLED  = 0,
  PRE_EMPTION_CAPABILITY_DISABLED = 1,
  PRE_EMPTION_CAPABILITY_MAX
}

struct AllocationRetentionPriority {
  priority_level:ubyte;
  pre_emp_vulnerability:PreEmptionVulnerability;
  pre_emp_capability:PreEmptionCapability;
}

struct EpsSubscribedQosProfile {
  qci:ubyte;
  allocation_retention_priority:AllocationRetentionPriority;
}

enum ApnAmbrBitRateUnit:ubyte {
  BPS  = 0,
  KBPS = 1
}

struct Ambr {
  br_unit:ApnAmbrBitRateUnit;
  br_ul:ulong;
  br_dl:ulong;
}

struct ChargingCharacteristics {
  /// CHARGING_CHARACTERISTICS_LENGTH + 1
  value:[ubyte:5];
  length:ubyte;
}

struct ApnConfiguration {
  context_identifier:uint;

  /// Each APN configuration can have 0, 1, or 2 ip address:
  ///  - 0 means subscribed is dynamically allocated by P-GW depending on the
  ///  pdn_type
  ///  - 1 Only one type of IP address is returned by HSS
  ///  - 2 IPv4 and IPv6 address are returned by HSS and are statically
  /// allocated
  nb_ip_address:ubyte;
  ip_address:[IpAddress:2];
  pdn_type:PdnTypeValue;
  service_selection:[byte:100];
  service_selection_length:byte;
  subscribed_qos:EpsSubscribedQosProfile;
  ambr:Ambr;
  charging_characteristics:ChargingCharacteristics;
}

enum AllApnConfInd:ubyte {
  ALL_APN_CONFIGURATIONS_INCLUDED            = 0,
  MODIFIED_ADDED_APN_CONFIGURATIONS_INCLUDED = 1,
  ALL_APN_MAX
}

struct ApnConfigProfile {
  context_identifier:uint;
  all_apn_conf_ind:AllApnConfInd;
  /// Number of APNs provided
  nb_apns:ubyte;
  /// List of APNs configuration 1 to n elements // MAX_APN_PER_UE
  apn_configuration:[ApnConfiguration:10];
}

struct Paa {
  pdn_type:PdnTypeValue;
  ipv4_address:uint;
  ipv6_address:In6Addr;
  /// Note in rel.8 the ipv6 prefix length has a fixed value of /64
  ipv6_prefix_length:ubyte;
  vlan:uint;
}

table PcoProtocolOrContainerId {
  id:ushort;
  /// length:ubyte;
  contents:[ubyte];
}

table ProtocolConfigurationOptions {
  ext:bool;
  configuration_protocol:ubyte;
  /// num_protocol_or_container_id:ubyte;
  /// #define PCO_UNSPEC_MAXIMUM_PROTOCOL_ID_OR_CONTAINER_ID 30
  protocol_or_container_ids:[PcoProtocolOrContainerId];
}

/// ESM procedure transaction states
enum EsmPtState:ubyte {
  ESM_PROCEDURE_TRANSACTION_INACTIVE = 0,
  ESM_PROCEDURE_TRANSACTION_PENDING,
  ESM_PROCEDURE_TRANSACTION_MAX
}

struct EsmPdn {
  pti:ubyte;
  is_emergency:bool;
  ambr:uint32;
  addr_realloc:int;
  n_bearers:ubyte;
  pt_state:EsmPtState;
  esm_cause:int;
}

table PdnContext {
  context_identifier:uint;
  apn_in_use:[ubyte];
  apn_subscribed:[ubyte];
  pdn_type:PdnTypeValue;
  paa:Paa;
  apn_oi_replacement:[ubyte];
  p_gw_address_s5_s8_cp:IpAddress;
  p_gw_teid_s5_s8_cp:uint;
  default_bearer_eps_subscribed_qos_profile:EpsSubscribedQosProfile;
  subscribed_apn_ambr:Ambr;
  p_gw_apn_ambr:Ambr;
  default_ebi:ubyte;
  /// BEARERS_PER_UE = 11
  bearer_contexts:[ubyte];
  s_gw_address_s11_s4:IpAddress;
  s_gw_teid_s11_s4:uint32;
  esm_data:EsmPdn;
  is_active:bool;
  pco:ProtocolConfigurationOptions;
  ue_rej_act_def_ber_req:bool;
  route_s11_messages_to_s8_task:bool;
}

enum EmmProcAttachType:ubyte {
  EMM_ATTACH_TYPE_EPS = 0,
  EMM_ATTACH_TYPE_COMBINED_EPS_IMSI,
  EMM_ATTACH_TYPE_EMERGENCY,
  EMM_ATTACH_TYPE_RESERVED
}

enum EmmFsmState:ubyte {
  ///EMM_STATE_MIN = 0, error: all enum values must be unique: EMM_STATE_MIN and EMM_INVALID are both 0
  EMM_INVALID   = 0,
  EMM_DEREGISTERED,
  EMM_REGISTERED,
  EMM_DEREGISTERED_INITIATED,
  EMM_COMMON_PROCEDURE_INITIATED,
  EMM_STATE_MAX
}

enum AdditionalUpdateType:ubyte {
  NO_ADDITIONAL_INFORMATION = 0,
  SMS_ONLY                  = 1,
  MAX                       = 2,
  SENTINEL_MAX              = 255
}

struct NasProcMessSign {
  puid:uint64;
  //#define NAS_MSG_DIGEST_SIZE 16
  digest:[ubyte:16];
  digest_length:uint32;
  nas_msg_length:uint32;
}

//struct EmmProcedures {
//  emm_specific_proc:NasEmmSpecificProcedure;
//  emm_common_procs:[NasEmmCommonProcedure];
//  cn_procs:[NasCnProcedure];
//  emm_con_mngt_proc:NasEmmConMngtProc;
//  nas_proc_mess_sign_next_location:int;  // next index in array
//  ///#define MAX_NAS_PROC_MESS_SIGN 3
//  nas_proc_mess_sign[NasProcMessSign:3];
//}

struct NasTimer {
  id:uint;
  msec:uint32;
}

table EsmContext {
  n_active_ebrs:uint;
  is_emergency:bool;
  t3489:NasTimer;
  t3489_arg:[ubyte];
  pending_standalone:uint32;
  is_pdn_disconnect:bool;
}

struct AuthVector {
  kasme:[ubyte:32];
  rand:[ubyte:16];
  autn:[ubyte:16];
  xres_size:ubyte;
  xres:[ubyte:16];
}

enum EmmScType:ubyte {
  SECURITY_CTX_TYPE_NOT_AVAILABLE = 0,
  SECURITY_CTX_TYPE_PARTIAL_NATIVE,
  SECURITY_CTX_TYPE_FULL_NATIVE,
  SECURITY_CTX_TYPE_MAPPED
}

// Be carefull, was bitfield
struct Count {
  spare:ubyte;
  overflow:uint16;
  seq_num:ubyte;
}

// Be carefull, was bitfield with quartets
struct SelectedAlgorithms {
  encryption:ubyte;
  integrity:ubyte;
}

struct Capability{
  eps_encryption:ubyte;
  eps_integrity:ubyte;
  umts_encryption:ubyte;
  umts_integrity:ubyte;
  gprs_encryption:ubyte;
  umts_present:ubyte;
  gprs_present:ubyte;
}

struct EmmSecurityContext {
  emm_sc_type:EmmScType;
  eksi:ubyte;
  vector_index:ubyte;
  knas_enc:[ubyte:16];
  knas_int:[ubyte:16];
  dl_count:Count;
  ul_count:Count;
  kenb_ul_count:Count;
  capability:Capability;
  selected_algorithms:SelectedAlgorithms;
  activated:ubyte;
  direction_encode:ubyte;
  direction_decode:ubyte;
  next_hop:[ubyte:32];
  next_hop_chaining_count:ubyte;
}
struct Guti {
  bytes:[ubyte:10];
}

enum TypeOfTaiList:ubyte {
  TRACKING_AREA_IDENTITY_LIST_ONE_PLMN_NON_CONSECUTIVE_TACS = 0,
  TRACKING_AREA_IDENTITY_LIST_ONE_PLMN_CONSECUTIVE_TAC,
  TRACKING_AREA_IDENTITY_LIST_MANY_PLMNS
}

table OnePlmnConsecutiveTacs {
  plmn:Plmn;
  tac:[uint16];
}

table TaiListManyPlmn {
  tai:[Tai];
}

union UTaiList {
  tai_many_plmn:TaiListManyPlmn,
  tai_one_plmn_consecutive_tacs:Tai,
  tai_one_plmn_non_consecutive_tacs:OnePlmnConsecutiveTacs
}

table PartialTaiList {
  typeoflist:TypeOfTaiList;
  numberofelements:ubyte;
  tai_list:UTaiList;
}

table TaiList {
  numberoflists:ubyte;
  partial_tai_list:[PartialTaiList];
}

table UeNetworkCapability {
  bytes:[ubyte];
}

table MsNetworkCapability {
  bytes:[ubyte];
}

struct UeAdditionalSecurityCapability {
  _5g_ea:uint16;
  _5g_ia:uint16;
}

struct NwDetachData {
  ue_id:uint;
  retransmission_count:uint;
  detach_type:ubyte;
}

// Warning, was bitfield
struct DrxParameter {
  splitpgcyclecode:ubyte;
  cnspecificdrxcyclelengthcoefficientanddrxvaluefors1mode:ubyte;
  splitonccch:bool;
  nondrxtimer:ubyte;
}

struct NasMessageDecodeStatus {
  integrity_protected_message:bool;
  ciphered_message:bool;
  mac_matched:bool;
  security_context_available:bool;
  emm_cause:uint;
}

table EmmAttachRequestIes {
  is_initial:bool;
  type:EmmProcAttachType;
  additional_update_type:AdditionalUpdateType;
  is_native_sc:bool;
  ksi:ubyte;
  is_native_guti:bool;
  guti:Guti;
  imsi:Imsi;
  imei:Imei;
  last_visited_registered_tai:Tai;
  originating_tai:Tai;
  originating_ecgi:Ecgi;
  ue_network_capability:UeNetworkCapability;
  ms_network_capability:MsNetworkCapability;
  drx_parameter:DrxParameter;
  esm_msg:string;
  decode_status:NasMessageDecodeStatus;
  //MobileStationClassmark2*
  //    mob_st_clsMark2;
  //voice_domain_preference_and_ue_usage_setting_t*
  //    voicedomainpreferenceandueusagesetting;
  ue_additional_security_capability:UeAdditionalSecurityCapability;
}

table NewAttachInfo {
  mme_ue_s1ap_id:uint32;
  is_mm_ctx_new:bool;
  ies:EmmAttachRequestIes;
}

table EmmContext {
  _imsi64:uint64;
  _imsi:Imsi;
  saved_imsi64:uint64;
  _imei:Imei;
  _imeisv:Imeisv;
  emm_cause:uint;
  _emm_fsm_state:EmmFsmState;
  attach_type:EmmProcAttachType;
  //emm_procedures_t* emm_procedures;
  common_proc_mask:uint32;
  esm_ctx:EsmContext;
  member_present_mask:uint32;
  member_valid_mask:uint32;
  _vector:[AuthVector];
  _security:EmmSecurityContext;
  _non_current_security:EmmSecurityContext;
  is_dynamic:bool;
  is_attached:bool;
  is_initial_identity_imsi:bool;
  is_guti_based_attach:bool;
  is_imsi_only_detach:bool;
  is_emergency:bool;
  additional_update_type:AdditionalUpdateType;
  tau_updt_type:ubyte;
  num_attach_request:uint;
  _guti:Guti;
  _old_guti:Guti;
  _tai_list:TaiList;
  _lvr_tai:Tai;
  originating_tai:Tai;
  ksi:ubyte;
  _ue_network_capability:UeNetworkCapability;
  ue_additional_security_capability:UeAdditionalSecurityCapability;
  t3422_arg_valid:bool;
  t3422_arg:NwDetachData;
  new_attach_info:EmmAttachRequestIes;
}

enum GrantedService:ubyte {
  GRANTED_SERVICE_EPS_ONLY,
  GRANTED_SERVICE_SMS_ONLY,
  GRANTED_SERVICE_CSFB_SMS
}

enum SubscriberStatus:ubyte{
  SS_SERVICE_GRANTED             = 0,
  SS_OPERATOR_DETERMINED_BARRING,
  SS_MAX
}

enum NetworkAccessMode:ubyte {
  NAM_PACKET_AND_CIRCUIT = 0,
  NAM_RESERVED           = 1,
  NAM_ONLY_PACKET        = 2,
  NAM_MAX
}

enum InterfaceType:ubyte {
  S1_U_ENODEB_GTP_U  = 0,
  S1_U_SGW_GTP_U,
  S12_RNC_GTP_U,
  S12_SGW_GTP_U,
  S5_S8_SGW_GTP_U,
  S5_S8_PGW_GTP_U,
  S5_S8_SGW_GTP_C,
  S5_S8_PGW_GTP_C,
  S5_S8_SGW_PMIPv6,
  S5_S8_PGW_PMIPv6,
  S11_MME_GTP_C,
  S11_SGW_GTP_C,
  S10_MME_GTP_C,
  S3_MME_GTP_C,
  S3_SGSN_GTP_C,
  S4_SGSN_GTP_U,
  S4_SGW_GTP_U,
  S4_SGSN_GTP_C,
  S16_SGSN_GTP_C,
  ENODEB_GTP_U_DL_DATA_FORWARDING,
  ENODEB_GTP_U_UL_DATA_FORWARDING,
  RNC_GTP_U_DATA_FORWARDING,
  SGSN_GTP_U_DATA_FORWARDING,
  SGW_GTP_U_DL_DATA_FORWARDING,
  SM_MBMS_GW_GTP_C,
  SN_MBMS_GW_GTP_C,
  SM_MME_GTP_C,
  SN_SGSN_GTP_C,
  SGW_GTP_U_UL_DATA_FORWARDING,
  SN_SGSN_GTP_U,
  S2B_EPDG_GTP_C
}

struct Fteid {
  ipv4:bool;
  ipv6:bool;
  interface_type:InterfaceType;
  teid:uint32;
  ip_address:Address;
}

enum EsmEbrState:ubyte {
  ESM_EBR_INACTIVE = 0,
  ESM_EBR_ACTIVE,
  ESM_EBR_INACTIVE_PENDING,
  ESM_EBR_MODIFY_PENDING,
  ESM_EBR_ACTIVE_PENDING,
  ESM_EBR_STATE_MAX
}

table EsmEbrTimerData {
  //TODO think: struct emm_context_s* ctx;
  ue_id:uint32;
  ebi:ubyte;
  count:uint;
  msg:string;
}

table EsmEbrContext {
  status:EsmEbrState;
  gbr_dl:uint64;
  gbr_ul:uint64;
  mbr_dl:uint64;
  mbr_ul:uint64;
  //traffic_flow_template_t* tft;
  //protocol_configuration_options_t* pco;
  timer:NasTimer;
  args:EsmEbrTimerData;
}

table BearerContext {
  ebi:ubyte;
  transaction_identifier:ubyte;
  s_gw_fteid_s1u:Fteid;
  p_gw_fteid_s5_s8_up:Fteid;

  pdn_cx_id:int;
  esm_ebr_context:EsmEbrContext;
  enb_fteid_s1u:Fteid;
  qci:ubyte;
  priority_level:ubyte;
  preemption_vulnerability:PreEmptionVulnerability;
  preemption_capability:PreEmptionCapability;
}

struct RegionalSubscription {
  zone_code:[ubyte:2];
}

enum OngoingProcedure:ubyte {
  COMBINED_ATTACH,
  COMBINED_TAU
}

enum SgsFsmState:ubyte {
  SGS_INVALID   = 0,
  SGS_NULL,
  SGS_LA_UPDATE_REQUESTED,
  SGS_ASSOCIATED,
  SGS_STATE_MAX
}

table SgsContext {
  sgs_state:SgsFsmState;
  vlr_reliable:bool;
  neaf:bool;
  ts6_1_timer:NasTimer;
  ts8_timer:NasTimer;
  ts8_retransmission_count:uint;
  ts9_timer:NasTimer;
  ts9_retransmission_count:uint;
  ts10_timer:NasTimer;
  ts10_retransmission_count:uint;
  ts13_timer:NasTimer;
  ts13_retransmission_count:uint;
  // MessageDef* message_p;
  sgsap_msg:string;
  ongoing_procedure:OngoingProcedure;
  tau_active_flag:bool;
  service_indicator:ubyte;
  //csfb_service_type_t csfb_service_type;
  call_cancelled:bool;
  mt_call_in_progress:bool;
  is_emergency_call:bool;
}

table UeMmContext {
  msisdn:string;
  ue_context_rel_cause:S1Cause;
  mm_state:MmState;
  ecm_state:EcmState;
  emm_context:EmmContext;
  sctp_assoc_id_key:uint;
  enb_ue_s1ap_id:uint;
  enb_s1ap_id_key:uint;
  mme_ue_s1ap_id:uint;
  attach_type:ubyte;
  sgs_detach_type:ubyte;
  e_utran_cgi:Ecgi;
  cell_age:ulong;
  lai:Lai;
  apn_config_profile:ApnConfigProfile;
  subscriber_status:SubscriberStatus;
  network_access_mode:NetworkAccessMode;
  access_restriction_data:uint;
  apn_oi_replacement:[ubyte];
  mme_teid_s11:uint32;
  subscribed_ue_ambr:Ambr;
  used_ue_ambr:Ambr;
  nb_active_pdn_contexts:ubyte;
  pdn_contexts:[PdnContext];
  bearer_contexts:[BearerContext];
  ue_radio_capability:[ubyte];
  send_ue_purge_request:bool;
  hss_initiated_detach:bool;
  location_info_confirmed_in_hss:bool;
  ppf:bool;
  subscription_known:bool;
  path_switch_req:bool;
  granted_service:GrantedService;
  num_reg_sub:ubyte;
  reg_sub:[RegionalSubscription];
  cs_fallback_indicator:int;
  sgs_context:SgsContext;
  rau_tau_timer:uint;
  time_mobile_reachability_timer_started:uint32;
  time_implicit_detach_timer_started:uint32;
  time_paging_response_timer_started:uint32;
  paging_retx_count:ubyte;
  time_ics_rsp_timer_started:uint32;
}

root_type UeMmContext;

// Code generated by protoc-gen-go. DO NOT EDIT.
// source: lte/protos/mobilityd.proto

package protos

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	protos "magma/orc8r/lib/go/protos"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type IPAddress_IPVersion int32

const (
	IPAddress_IPV4 IPAddress_IPVersion = 0
	IPAddress_IPV6 IPAddress_IPVersion = 1
)

var IPAddress_IPVersion_name = map[int32]string{
	0: "IPV4",
	1: "IPV6",
}

var IPAddress_IPVersion_value = map[string]int32{
	"IPV4": 0,
	"IPV6": 1,
}

func (x IPAddress_IPVersion) String() string {
	return proto.EnumName(IPAddress_IPVersion_name, int32(x))
}

func (IPAddress_IPVersion) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3f226a441609c6cc, []int{0, 0}
}

type IPBlock_IPVersion int32

const (
	IPBlock_IPV4 IPBlock_IPVersion = 0
	IPBlock_IPV6 IPBlock_IPVersion = 1
)

var IPBlock_IPVersion_name = map[int32]string{
	0: "IPV4",
	1: "IPV6",
}

var IPBlock_IPVersion_value = map[string]int32{
	"IPV4": 0,
	"IPV6": 1,
}

func (x IPBlock_IPVersion) String() string {
	return proto.EnumName(IPBlock_IPVersion_name, int32(x))
}

func (IPBlock_IPVersion) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3f226a441609c6cc, []int{3, 0}
}

type AllocateIPRequest_IPVersion int32

const (
	AllocateIPRequest_IPV4   AllocateIPRequest_IPVersion = 0
	AllocateIPRequest_IPV6   AllocateIPRequest_IPVersion = 1
	AllocateIPRequest_IPV4V6 AllocateIPRequest_IPVersion = 2
)

var AllocateIPRequest_IPVersion_name = map[int32]string{
	0: "IPV4",
	1: "IPV6",
	2: "IPV4V6",
}

var AllocateIPRequest_IPVersion_value = map[string]int32{
	"IPV4":   0,
	"IPV6":   1,
	"IPV4V6": 2,
}

func (x AllocateIPRequest_IPVersion) String() string {
	return proto.EnumName(AllocateIPRequest_IPVersion_name, int32(x))
}

func (AllocateIPRequest_IPVersion) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3f226a441609c6cc, []int{7, 0}
}

// --------------------------------------------------------------------------
// IP Address definition. A generic type for both IPv4 and IPv6 addresses.
// --------------------------------------------------------------------------
type IPAddress struct {
	Version              IPAddress_IPVersion `protobuf:"varint,1,opt,name=version,proto3,enum=magma.lte.IPAddress_IPVersion" json:"version,omitempty"`
	Address              []byte              `protobuf:"bytes,2,opt,name=address,proto3" json:"address,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *IPAddress) Reset()         { *m = IPAddress{} }
func (m *IPAddress) String() string { return proto.CompactTextString(m) }
func (*IPAddress) ProtoMessage()    {}
func (*IPAddress) Descriptor() ([]byte, []int) {
	return fileDescriptor_3f226a441609c6cc, []int{0}
}

func (m *IPAddress) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_IPAddress.Unmarshal(m, b)
}
func (m *IPAddress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_IPAddress.Marshal(b, m, deterministic)
}
func (m *IPAddress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IPAddress.Merge(m, src)
}
func (m *IPAddress) XXX_Size() int {
	return xxx_messageInfo_IPAddress.Size(m)
}
func (m *IPAddress) XXX_DiscardUnknown() {
	xxx_messageInfo_IPAddress.DiscardUnknown(m)
}

var xxx_messageInfo_IPAddress proto.InternalMessageInfo

func (m *IPAddress) GetVersion() IPAddress_IPVersion {
	if m != nil {
		return m.Version
	}
	return IPAddress_IPV4
}

func (m *IPAddress) GetAddress() []byte {
	if m != nil {
		return m.Address
	}
	return nil
}

type AllocateIPAddressResponse struct {
	IpAddr               *IPAddress `protobuf:"bytes,1,opt,name=ip_addr,json=ipAddr,proto3" json:"ip_addr,omitempty"`
	Vlan                 string     `protobuf:"bytes,2,opt,name=vlan,proto3" json:"vlan,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *AllocateIPAddressResponse) Reset()         { *m = AllocateIPAddressResponse{} }
func (m *AllocateIPAddressResponse) String() string { return proto.CompactTextString(m) }
func (*AllocateIPAddressResponse) ProtoMessage()    {}
func (*AllocateIPAddressResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3f226a441609c6cc, []int{1}
}

func (m *AllocateIPAddressResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AllocateIPAddressResponse.Unmarshal(m, b)
}
func (m *AllocateIPAddressResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AllocateIPAddressResponse.Marshal(b, m, deterministic)
}
func (m *AllocateIPAddressResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AllocateIPAddressResponse.Merge(m, src)
}
func (m *AllocateIPAddressResponse) XXX_Size() int {
	return xxx_messageInfo_AllocateIPAddressResponse.Size(m)
}
func (m *AllocateIPAddressResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AllocateIPAddressResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AllocateIPAddressResponse proto.InternalMessageInfo

func (m *AllocateIPAddressResponse) GetIpList() []*IPAddress {
	if m != nil {
		return m.IpList
	}
	return nil
}

func (m *AllocateIPAddressResponse) GetVlan() string {
	if m != nil {
		return m.Vlan
	}
	return ""
}

type IPLookupRequest struct {
	Sid                  *SubscriberID `protobuf:"bytes,1,opt,name=sid,proto3" json:"sid,omitempty"`
	Apn                  string        `protobuf:"bytes,2,opt,name=apn,proto3" json:"apn,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *IPLookupRequest) Reset()         { *m = IPLookupRequest{} }
func (m *IPLookupRequest) String() string { return proto.CompactTextString(m) }
func (*IPLookupRequest) ProtoMessage()    {}
func (*IPLookupRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3f226a441609c6cc, []int{2}
}

func (m *IPLookupRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_IPLookupRequest.Unmarshal(m, b)
}
func (m *IPLookupRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_IPLookupRequest.Marshal(b, m, deterministic)
}
func (m *IPLookupRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IPLookupRequest.Merge(m, src)
}
func (m *IPLookupRequest) XXX_Size() int {
	return xxx_messageInfo_IPLookupRequest.Size(m)
}
func (m *IPLookupRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_IPLookupRequest.DiscardUnknown(m)
}

var xxx_messageInfo_IPLookupRequest proto.InternalMessageInfo

func (m *IPLookupRequest) GetSid() *SubscriberID {
	if m != nil {
		return m.Sid
	}
	return nil
}

func (m *IPLookupRequest) GetApn() string {
	if m != nil {
		return m.Apn
	}
	return ""
}

// --------------------------------------------------------------------------
// IP Block definition.
//
// An IP block is a range of IP addresses specified by a network address and
// a prefix-length of the netmask. For example,
//    IPv4 IP block:      192.168.0.0/24
//    IPv6 IP block:      2401:db00:1116:301b::/64
// --------------------------------------------------------------------------
type IPBlock struct {
	Version              IPBlock_IPVersion `protobuf:"varint,1,opt,name=version,proto3,enum=magma.lte.IPBlock_IPVersion" json:"version,omitempty"`
	NetAddress           []byte            `protobuf:"bytes,2,opt,name=net_address,json=netAddress,proto3" json:"net_address,omitempty"`
	PrefixLen            uint32            `protobuf:"varint,3,opt,name=prefix_len,json=prefixLen,proto3" json:"prefix_len,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *IPBlock) Reset()         { *m = IPBlock{} }
func (m *IPBlock) String() string { return proto.CompactTextString(m) }
func (*IPBlock) ProtoMessage()    {}
func (*IPBlock) Descriptor() ([]byte, []int) {
	return fileDescriptor_3f226a441609c6cc, []int{3}
}

func (m *IPBlock) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_IPBlock.Unmarshal(m, b)
}
func (m *IPBlock) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_IPBlock.Marshal(b, m, deterministic)
}
func (m *IPBlock) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IPBlock.Merge(m, src)
}
func (m *IPBlock) XXX_Size() int {
	return xxx_messageInfo_IPBlock.Size(m)
}
func (m *IPBlock) XXX_DiscardUnknown() {
	xxx_messageInfo_IPBlock.DiscardUnknown(m)
}

var xxx_messageInfo_IPBlock proto.InternalMessageInfo

func (m *IPBlock) GetVersion() IPBlock_IPVersion {
	if m != nil {
		return m.Version
	}
	return IPBlock_IPV4
}

func (m *IPBlock) GetNetAddress() []byte {
	if m != nil {
		return m.NetAddress
	}
	return nil
}

func (m *IPBlock) GetPrefixLen() uint32 {
	if m != nil {
		return m.PrefixLen
	}
	return 0
}

type ListAddedIPBlocksResponse struct {
	// List of IP blocks assigned
	IpBlockList          []*IPBlock `protobuf:"bytes,1,rep,name=ip_block_list,json=ipBlockList,proto3" json:"ip_block_list,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *ListAddedIPBlocksResponse) Reset()         { *m = ListAddedIPBlocksResponse{} }
func (m *ListAddedIPBlocksResponse) String() string { return proto.CompactTextString(m) }
func (*ListAddedIPBlocksResponse) ProtoMessage()    {}
func (*ListAddedIPBlocksResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3f226a441609c6cc, []int{4}
}

func (m *ListAddedIPBlocksResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ListAddedIPBlocksResponse.Unmarshal(m, b)
}
func (m *ListAddedIPBlocksResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ListAddedIPBlocksResponse.Marshal(b, m, deterministic)
}
func (m *ListAddedIPBlocksResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListAddedIPBlocksResponse.Merge(m, src)
}
func (m *ListAddedIPBlocksResponse) XXX_Size() int {
	return xxx_messageInfo_ListAddedIPBlocksResponse.Size(m)
}
func (m *ListAddedIPBlocksResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListAddedIPBlocksResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListAddedIPBlocksResponse proto.InternalMessageInfo

func (m *ListAddedIPBlocksResponse) GetIpBlockList() []*IPBlock {
	if m != nil {
		return m.IpBlockList
	}
	return nil
}

// --------------------------------------------------------------------------
// Subscriber IP table definition
// --------------------------------------------------------------------------
type SubscriberIPTableEntry struct {
	Sid                  *SubscriberID `protobuf:"bytes,1,opt,name=sid,proto3" json:"sid,omitempty"`
	Ip                   *IPAddress    `protobuf:"bytes,2,opt,name=ip,proto3" json:"ip,omitempty"`
	Apn                  string        `protobuf:"bytes,3,opt,name=apn,proto3" json:"apn,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *SubscriberIPTableEntry) Reset()         { *m = SubscriberIPTableEntry{} }
func (m *SubscriberIPTableEntry) String() string { return proto.CompactTextString(m) }
func (*SubscriberIPTableEntry) ProtoMessage()    {}
func (*SubscriberIPTableEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_3f226a441609c6cc, []int{5}
}

func (m *SubscriberIPTableEntry) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SubscriberIPTableEntry.Unmarshal(m, b)
}
func (m *SubscriberIPTableEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SubscriberIPTableEntry.Marshal(b, m, deterministic)
}
func (m *SubscriberIPTableEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubscriberIPTableEntry.Merge(m, src)
}
func (m *SubscriberIPTableEntry) XXX_Size() int {
	return xxx_messageInfo_SubscriberIPTableEntry.Size(m)
}
func (m *SubscriberIPTableEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_SubscriberIPTableEntry.DiscardUnknown(m)
}

var xxx_messageInfo_SubscriberIPTableEntry proto.InternalMessageInfo

func (m *SubscriberIPTableEntry) GetSid() *SubscriberID {
	if m != nil {
		return m.Sid
	}
	return nil
}

func (m *SubscriberIPTableEntry) GetIp() *IPAddress {
	if m != nil {
		return m.Ip
	}
	return nil
}

func (m *SubscriberIPTableEntry) GetApn() string {
	if m != nil {
		return m.Apn
	}
	return ""
}

type SubscriberIPTable struct {
	Entries              []*SubscriberIPTableEntry `protobuf:"bytes,1,rep,name=entries,proto3" json:"entries,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                  `json:"-"`
	XXX_unrecognized     []byte                    `json:"-"`
	XXX_sizecache        int32                     `json:"-"`
}

func (m *SubscriberIPTable) Reset()         { *m = SubscriberIPTable{} }
func (m *SubscriberIPTable) String() string { return proto.CompactTextString(m) }
func (*SubscriberIPTable) ProtoMessage()    {}
func (*SubscriberIPTable) Descriptor() ([]byte, []int) {
	return fileDescriptor_3f226a441609c6cc, []int{6}
}

func (m *SubscriberIPTable) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SubscriberIPTable.Unmarshal(m, b)
}
func (m *SubscriberIPTable) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SubscriberIPTable.Marshal(b, m, deterministic)
}
func (m *SubscriberIPTable) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubscriberIPTable.Merge(m, src)
}
func (m *SubscriberIPTable) XXX_Size() int {
	return xxx_messageInfo_SubscriberIPTable.Size(m)
}
func (m *SubscriberIPTable) XXX_DiscardUnknown() {
	xxx_messageInfo_SubscriberIPTable.DiscardUnknown(m)
}

var xxx_messageInfo_SubscriberIPTable proto.InternalMessageInfo

func (m *SubscriberIPTable) GetEntries() []*SubscriberIPTableEntry {
	if m != nil {
		return m.Entries
	}
	return nil
}

// --------------------------------------------------------------------------
// IP allocation service definition
// --------------------------------------------------------------------------
type AllocateIPRequest struct {
	// sid: SubscriberID an IP is allocated for
	// version: IP version requested
	// apn: Access Point Name (e.g., "ims", "internet")
	Sid                  *SubscriberID               `protobuf:"bytes,1,opt,name=sid,proto3" json:"sid,omitempty"`
	Version              AllocateIPRequest_IPVersion `protobuf:"varint,2,opt,name=version,proto3,enum=magma.lte.AllocateIPRequest_IPVersion" json:"version,omitempty"`
	Apn                  string                      `protobuf:"bytes,3,opt,name=apn,proto3" json:"apn,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *AllocateIPRequest) Reset()         { *m = AllocateIPRequest{} }
func (m *AllocateIPRequest) String() string { return proto.CompactTextString(m) }
func (*AllocateIPRequest) ProtoMessage()    {}
func (*AllocateIPRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3f226a441609c6cc, []int{7}
}

func (m *AllocateIPRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AllocateIPRequest.Unmarshal(m, b)
}
func (m *AllocateIPRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AllocateIPRequest.Marshal(b, m, deterministic)
}
func (m *AllocateIPRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AllocateIPRequest.Merge(m, src)
}
func (m *AllocateIPRequest) XXX_Size() int {
	return xxx_messageInfo_AllocateIPRequest.Size(m)
}
func (m *AllocateIPRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AllocateIPRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AllocateIPRequest proto.InternalMessageInfo

func (m *AllocateIPRequest) GetSid() *SubscriberID {
	if m != nil {
		return m.Sid
	}
	return nil
}

func (m *AllocateIPRequest) GetVersion() AllocateIPRequest_IPVersion {
	if m != nil {
		return m.Version
	}
	return AllocateIPRequest_IPV4
}

func (m *AllocateIPRequest) GetApn() string {
	if m != nil {
		return m.Apn
	}
	return ""
}

type ListAllocatedIPsResponse struct {
	// List of IP addresses allocated from a given IP block
	IpList               []*IPAddress `protobuf:"bytes,1,rep,name=ip_list,json=ipList,proto3" json:"ip_list,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *ListAllocatedIPsResponse) Reset()         { *m = ListAllocatedIPsResponse{} }
func (m *ListAllocatedIPsResponse) String() string { return proto.CompactTextString(m) }
func (*ListAllocatedIPsResponse) ProtoMessage()    {}
func (*ListAllocatedIPsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3f226a441609c6cc, []int{8}
}

func (m *ListAllocatedIPsResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ListAllocatedIPsResponse.Unmarshal(m, b)
}
func (m *ListAllocatedIPsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ListAllocatedIPsResponse.Marshal(b, m, deterministic)
}
func (m *ListAllocatedIPsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListAllocatedIPsResponse.Merge(m, src)
}
func (m *ListAllocatedIPsResponse) XXX_Size() int {
	return xxx_messageInfo_ListAllocatedIPsResponse.Size(m)
}
func (m *ListAllocatedIPsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListAllocatedIPsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListAllocatedIPsResponse proto.InternalMessageInfo

func (m *ListAllocatedIPsResponse) GetIpList() []*IPAddress {
	if m != nil {
		return m.IpList
	}
	return nil
}

type ReleaseIPRequest struct {
	// sid: SubscriberID associated with the IP address
	// ip: IP address to release
	// apn: Access Point Name to release apn-specific IP address
	Sid                  *SubscriberID `protobuf:"bytes,1,opt,name=sid,proto3" json:"sid,omitempty"`
	Ip                   *IPAddress    `protobuf:"bytes,2,opt,name=ip,proto3" json:"ip,omitempty"`
	Apn                  string        `protobuf:"bytes,3,opt,name=apn,proto3" json:"apn,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *ReleaseIPRequest) Reset()         { *m = ReleaseIPRequest{} }
func (m *ReleaseIPRequest) String() string { return proto.CompactTextString(m) }
func (*ReleaseIPRequest) ProtoMessage()    {}
func (*ReleaseIPRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3f226a441609c6cc, []int{9}
}

func (m *ReleaseIPRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ReleaseIPRequest.Unmarshal(m, b)
}
func (m *ReleaseIPRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ReleaseIPRequest.Marshal(b, m, deterministic)
}
func (m *ReleaseIPRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReleaseIPRequest.Merge(m, src)
}
func (m *ReleaseIPRequest) XXX_Size() int {
	return xxx_messageInfo_ReleaseIPRequest.Size(m)
}
func (m *ReleaseIPRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ReleaseIPRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ReleaseIPRequest proto.InternalMessageInfo

func (m *ReleaseIPRequest) GetSid() *SubscriberID {
	if m != nil {
		return m.Sid
	}
	return nil
}

func (m *ReleaseIPRequest) GetIp() *IPAddress {
	if m != nil {
		return m.Ip
	}
	return nil
}

func (m *ReleaseIPRequest) GetApn() string {
	if m != nil {
		return m.Apn
	}
	return ""
}

type RemoveIPBlockRequest struct {
	// ip_blocks: List of IP blocks to remove
	IpBlocks []*IPBlock `protobuf:"bytes,1,rep,name=ip_blocks,json=ipBlocks,proto3" json:"ip_blocks,omitempty"`
	// force: If true, remove all IP blocks regardless of whether IPs have been
	// allocated
	Force                bool     `protobuf:"varint,2,opt,name=force,proto3" json:"force,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RemoveIPBlockRequest) Reset()         { *m = RemoveIPBlockRequest{} }
func (m *RemoveIPBlockRequest) String() string { return proto.CompactTextString(m) }
func (*RemoveIPBlockRequest) ProtoMessage()    {}
func (*RemoveIPBlockRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3f226a441609c6cc, []int{10}
}

func (m *RemoveIPBlockRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RemoveIPBlockRequest.Unmarshal(m, b)
}
func (m *RemoveIPBlockRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RemoveIPBlockRequest.Marshal(b, m, deterministic)
}
func (m *RemoveIPBlockRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemoveIPBlockRequest.Merge(m, src)
}
func (m *RemoveIPBlockRequest) XXX_Size() int {
	return xxx_messageInfo_RemoveIPBlockRequest.Size(m)
}
func (m *RemoveIPBlockRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RemoveIPBlockRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RemoveIPBlockRequest proto.InternalMessageInfo

func (m *RemoveIPBlockRequest) GetIpBlocks() []*IPBlock {
	if m != nil {
		return m.IpBlocks
	}
	return nil
}

func (m *RemoveIPBlockRequest) GetForce() bool {
	if m != nil {
		return m.Force
	}
	return false
}

type RemoveIPBlockResponse struct {
	// ip_blocks: List of IP blocks successfully removed
	IpBlocks             []*IPBlock `protobuf:"bytes,1,rep,name=ip_blocks,json=ipBlocks,proto3" json:"ip_blocks,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *RemoveIPBlockResponse) Reset()         { *m = RemoveIPBlockResponse{} }
func (m *RemoveIPBlockResponse) String() string { return proto.CompactTextString(m) }
func (*RemoveIPBlockResponse) ProtoMessage()    {}
func (*RemoveIPBlockResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3f226a441609c6cc, []int{11}
}

func (m *RemoveIPBlockResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RemoveIPBlockResponse.Unmarshal(m, b)
}
func (m *RemoveIPBlockResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RemoveIPBlockResponse.Marshal(b, m, deterministic)
}
func (m *RemoveIPBlockResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemoveIPBlockResponse.Merge(m, src)
}
func (m *RemoveIPBlockResponse) XXX_Size() int {
	return xxx_messageInfo_RemoveIPBlockResponse.Size(m)
}
func (m *RemoveIPBlockResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RemoveIPBlockResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RemoveIPBlockResponse proto.InternalMessageInfo

func (m *RemoveIPBlockResponse) GetIpBlocks() []*IPBlock {
	if m != nil {
		return m.IpBlocks
	}
	return nil
}

// This msg is used for get/set API for mobilityD UplinkGatewayInfo object
// This object has information about Internet Gateway
type GWInfo struct {
	Ip                   *IPAddress `protobuf:"bytes,1,opt,name=ip,proto3" json:"ip,omitempty"`
	Mac                  string     `protobuf:"bytes,2,opt,name=mac,proto3" json:"mac,omitempty"`
	Vlan                 string     `protobuf:"bytes,3,opt,name=vlan,proto3" json:"vlan,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *GWInfo) Reset()         { *m = GWInfo{} }
func (m *GWInfo) String() string { return proto.CompactTextString(m) }
func (*GWInfo) ProtoMessage()    {}
func (*GWInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_3f226a441609c6cc, []int{12}
}

func (m *GWInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GWInfo.Unmarshal(m, b)
}
func (m *GWInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GWInfo.Marshal(b, m, deterministic)
}
func (m *GWInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GWInfo.Merge(m, src)
}
func (m *GWInfo) XXX_Size() int {
	return xxx_messageInfo_GWInfo.Size(m)
}
func (m *GWInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_GWInfo.DiscardUnknown(m)
}

var xxx_messageInfo_GWInfo proto.InternalMessageInfo

func (m *GWInfo) GetIp() *IPAddress {
	if m != nil {
		return m.Ip
	}
	return nil
}

func (m *GWInfo) GetMac() string {
	if m != nil {
		return m.Mac
	}
	return ""
}

func (m *GWInfo) GetVlan() string {
	if m != nil {
		return m.Vlan
	}
	return ""
}

type ListGWInfoResponse struct {
	// List of IP addresses allocated from a given IP block
	GwList               []*GWInfo `protobuf:"bytes,1,rep,name=gw_list,json=gwList,proto3" json:"gw_list,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *ListGWInfoResponse) Reset()         { *m = ListGWInfoResponse{} }
func (m *ListGWInfoResponse) String() string { return proto.CompactTextString(m) }
func (*ListGWInfoResponse) ProtoMessage()    {}
func (*ListGWInfoResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3f226a441609c6cc, []int{13}
}

func (m *ListGWInfoResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ListGWInfoResponse.Unmarshal(m, b)
}
func (m *ListGWInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ListGWInfoResponse.Marshal(b, m, deterministic)
}
func (m *ListGWInfoResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListGWInfoResponse.Merge(m, src)
}
func (m *ListGWInfoResponse) XXX_Size() int {
	return xxx_messageInfo_ListGWInfoResponse.Size(m)
}
func (m *ListGWInfoResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListGWInfoResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListGWInfoResponse proto.InternalMessageInfo

func (m *ListGWInfoResponse) GetGwList() []*GWInfo {
	if m != nil {
		return m.GwList
	}
	return nil
}

func init() {
	proto.RegisterEnum("magma.lte.IPAddress_IPVersion", IPAddress_IPVersion_name, IPAddress_IPVersion_value)
	proto.RegisterEnum("magma.lte.IPBlock_IPVersion", IPBlock_IPVersion_name, IPBlock_IPVersion_value)
	proto.RegisterEnum("magma.lte.AllocateIPRequest_IPVersion", AllocateIPRequest_IPVersion_name, AllocateIPRequest_IPVersion_value)
	proto.RegisterType((*IPAddress)(nil), "magma.lte.IPAddress")
	proto.RegisterType((*AllocateIPAddressResponse)(nil), "magma.lte.AllocateIPAddressResponse")
	proto.RegisterType((*IPLookupRequest)(nil), "magma.lte.IPLookupRequest")
	proto.RegisterType((*IPBlock)(nil), "magma.lte.IPBlock")
	proto.RegisterType((*ListAddedIPBlocksResponse)(nil), "magma.lte.ListAddedIPBlocksResponse")
	proto.RegisterType((*SubscriberIPTableEntry)(nil), "magma.lte.SubscriberIPTableEntry")
	proto.RegisterType((*SubscriberIPTable)(nil), "magma.lte.SubscriberIPTable")
	proto.RegisterType((*AllocateIPRequest)(nil), "magma.lte.AllocateIPRequest")
	proto.RegisterType((*ListAllocatedIPsResponse)(nil), "magma.lte.ListAllocatedIPsResponse")
	proto.RegisterType((*ReleaseIPRequest)(nil), "magma.lte.ReleaseIPRequest")
	proto.RegisterType((*RemoveIPBlockRequest)(nil), "magma.lte.RemoveIPBlockRequest")
	proto.RegisterType((*RemoveIPBlockResponse)(nil), "magma.lte.RemoveIPBlockResponse")
	proto.RegisterType((*GWInfo)(nil), "magma.lte.GWInfo")
	proto.RegisterType((*ListGWInfoResponse)(nil), "magma.lte.ListGWInfoResponse")
}

func init() { proto.RegisterFile("lte/protos/mobilityd.proto", fileDescriptor_3f226a441609c6cc) }

var fileDescriptor_3f226a441609c6cc = []byte{
	// 823 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x56, 0x51, 0x4f, 0xe3, 0x46,
	0x10, 0xae, 0x13, 0x9a, 0x90, 0x49, 0x81, 0xb0, 0x0d, 0x6d, 0x62, 0xa0, 0xa4, 0x2e, 0xaa, 0xd2,
	0x4a, 0x4d, 0xa4, 0x80, 0x22, 0xa4, 0xbe, 0x00, 0x6d, 0x93, 0x5a, 0xc7, 0x21, 0xcb, 0x41, 0x20,
	0x9d, 0x74, 0x17, 0x39, 0xf6, 0x12, 0xad, 0xb0, 0xbd, 0x3e, 0xaf, 0x13, 0x0e, 0xdd, 0xcb, 0xfd,
	0x96, 0x7b, 0xbc, 0xd7, 0xfb, 0x83, 0x27, 0x6f, 0xd6, 0x89, 0xed, 0x38, 0x20, 0x78, 0xca, 0x66,
	0xfd, 0xf9, 0xdb, 0x99, 0x6f, 0xe6, 0x9b, 0x35, 0xc8, 0x76, 0x80, 0xdb, 0x9e, 0x4f, 0x03, 0xca,
	0xda, 0x0e, 0x1d, 0x11, 0x9b, 0x04, 0x0f, 0x56, 0x8b, 0x6f, 0xa0, 0x92, 0x63, 0x8c, 0x1d, 0xa3,
	0x65, 0x07, 0x58, 0xde, 0x8f, 0xc1, 0xd8, 0x64, 0xc4, 0x4c, 0x9f, 0x8c, 0xb0, 0x6f, 0x8d, 0x66,
	0x48, 0xb9, 0x4e, 0x7d, 0xf3, 0xc4, 0x8f, 0x00, 0x26, 0x75, 0x1c, 0xea, 0xce, 0x1e, 0x29, 0x9f,
	0x24, 0x28, 0xa9, 0xda, 0x99, 0x65, 0xf9, 0x98, 0x31, 0x74, 0x02, 0xc5, 0x29, 0xf6, 0x19, 0xa1,
	0x6e, 0x4d, 0x6a, 0x48, 0xcd, 0xcd, 0xce, 0x2f, 0xad, 0xf9, 0x21, 0xad, 0x39, 0xac, 0xa5, 0x6a,
	0xd7, 0x33, 0x94, 0x1e, 0xc1, 0x51, 0x0d, 0x8a, 0xc6, 0xec, 0x69, 0x2d, 0xd7, 0x90, 0x9a, 0x3f,
	0xe8, 0xd1, 0x5f, 0xe5, 0x20, 0x3c, 0x40, 0xe0, 0xd1, 0x3a, 0xac, 0xa9, 0xda, 0xf5, 0x71, 0xe5,
	0x3b, 0xb1, 0xea, 0x56, 0x24, 0xe5, 0x1d, 0xd4, 0xcf, 0x6c, 0x9b, 0x9a, 0x46, 0x80, 0xe7, 0x47,
	0xe8, 0x98, 0x79, 0xd4, 0x65, 0x18, 0xfd, 0x05, 0x45, 0xe2, 0x0d, 0x43, 0x2e, 0x1e, 0x51, 0xb9,
	0x53, 0xcd, 0x8a, 0x48, 0x2f, 0x10, 0x2f, 0x5c, 0x22, 0x04, 0x6b, 0x53, 0xdb, 0x70, 0x79, 0x0c,
	0x25, 0x9d, 0xaf, 0x95, 0x4b, 0xd8, 0x52, 0xb5, 0x0b, 0x4a, 0xef, 0x26, 0x9e, 0x8e, 0xdf, 0x4f,
	0x30, 0x0b, 0xd0, 0x1f, 0x90, 0x67, 0xc4, 0x12, 0x8c, 0x3f, 0xc7, 0x18, 0x07, 0x73, 0xf1, 0xd4,
	0x7f, 0xf5, 0x10, 0x83, 0x2a, 0x90, 0x37, 0xbc, 0x88, 0x30, 0x5c, 0x2a, 0x9f, 0x25, 0x28, 0xaa,
	0xda, 0xb9, 0x4d, 0xcd, 0x3b, 0xd4, 0x4d, 0x0b, 0xb6, 0x97, 0x08, 0x8f, 0x83, 0xb2, 0xe4, 0x3a,
	0x80, 0xb2, 0x8b, 0x83, 0x61, 0x52, 0x32, 0x70, 0x71, 0x10, 0x55, 0x62, 0x1f, 0xc0, 0xf3, 0xf1,
	0x2d, 0xf9, 0x30, 0xb4, 0xb1, 0x5b, 0xcb, 0x37, 0xa4, 0xe6, 0x86, 0x5e, 0x9a, 0xed, 0x5c, 0x60,
	0xf7, 0x69, 0x51, 0x07, 0x50, 0xbf, 0x20, 0x2c, 0xa4, 0xc3, 0x96, 0x88, 0x63, 0x21, 0x6a, 0x17,
	0x36, 0x88, 0x37, 0x1c, 0x85, 0x9b, 0x43, 0x9b, 0xb0, 0xa0, 0x26, 0x35, 0xf2, 0xcd, 0x72, 0x07,
	0x2d, 0xc7, 0xae, 0x97, 0x89, 0xc7, 0x17, 0x21, 0x99, 0xf2, 0x11, 0x7e, 0x8a, 0x09, 0xa4, 0x5d,
	0x19, 0x23, 0x1b, 0xff, 0xe7, 0x06, 0xfe, 0xc3, 0x73, 0x04, 0x3d, 0x84, 0x1c, 0xf1, 0x78, 0xc6,
	0xab, 0x8a, 0x99, 0x23, 0x5e, 0x24, 0x7b, 0x7e, 0x21, 0xbb, 0x06, 0xdb, 0x4b, 0x87, 0xa3, 0xbf,
	0xa1, 0x88, 0xdd, 0xc0, 0x27, 0x98, 0x89, 0x1c, 0x7e, 0xcd, 0x3e, 0x3b, 0x16, 0xab, 0x1e, 0xbd,
	0xa1, 0x7c, 0x95, 0x60, 0x7b, 0xd1, 0x79, 0x2f, 0xe8, 0x8d, 0xd3, 0x45, 0xf5, 0x73, 0xbc, 0xfa,
	0xbf, 0xc7, 0xe0, 0x4b, 0xcc, 0x59, 0x7d, 0xb0, 0x9c, 0xe6, 0x93, 0x95, 0x55, 0xa1, 0xc6, 0x2b,
	0x2b, 0xe8, 0x2d, 0x55, 0x4b, 0xbb, 0x25, 0x56, 0xd2, 0x95, 0x6e, 0xe1, 0xf5, 0x9c, 0x40, 0x45,
	0xc7, 0x36, 0x36, 0xd8, 0xcb, 0xd2, 0x7f, 0x69, 0x25, 0xdf, 0x42, 0x55, 0xc7, 0x0e, 0x9d, 0xe2,
	0xa8, 0xc9, 0xc4, 0xd1, 0x6d, 0x28, 0x45, 0x6d, 0xc9, 0x1e, 0x69, 0xc9, 0x75, 0xd1, 0x92, 0x0c,
	0x55, 0xe1, 0xfb, 0x5b, 0xea, 0x9b, 0x98, 0xc7, 0xb0, 0xae, 0xcf, 0xfe, 0x28, 0xff, 0xc3, 0x4e,
	0x8a, 0x5e, 0xa8, 0xf3, 0x5c, 0x7e, 0xe5, 0x0a, 0x0a, 0xfd, 0x1b, 0xd5, 0xbd, 0xa5, 0x22, 0x55,
	0xe9, 0xe9, 0x54, 0x1d, 0xc3, 0x8c, 0x66, 0x85, 0x63, 0x98, 0xf3, 0x79, 0x94, 0x8f, 0xcd, 0xa3,
	0x53, 0x40, 0xa1, 0xfa, 0x33, 0xe6, 0x79, 0x70, 0x7f, 0x42, 0x71, 0x7c, 0x1f, 0x2f, 0xdd, 0x76,
	0xec, 0x18, 0x81, 0x2d, 0x8c, 0xef, 0xc3, 0x37, 0x3b, 0x5f, 0x0a, 0xb0, 0xf5, 0x5a, 0xdc, 0x06,
	0x03, 0xec, 0x4f, 0x89, 0x89, 0xd1, 0x11, 0xc0, 0x99, 0x15, 0x59, 0x1d, 0x65, 0xe4, 0x25, 0x47,
	0x84, 0xfc, 0x32, 0x68, 0x5d, 0x53, 0x62, 0xa1, 0x4b, 0xf8, 0x31, 0x36, 0x25, 0xa6, 0xc7, 0x42,
	0xd7, 0x65, 0xa4, 0x7c, 0x18, 0x23, 0x5c, 0x3d, 0x58, 0x5e, 0x41, 0x25, 0xdd, 0x9b, 0x99, 0xa1,
	0xfc, 0x96, 0x66, 0xcb, 0x6a, 0xe6, 0x9b, 0xb8, 0x3b, 0xa3, 0xb9, 0xb8, 0xf7, 0x98, 0xc3, 0x12,
	0x51, 0xae, 0xbe, 0x53, 0xce, 0x63, 0x6d, 0x1f, 0xf1, 0xee, 0xc6, 0xde, 0x4c, 0x7b, 0x22, 0x4b,
	0xb9, 0x1e, 0xa0, 0x3e, 0x0e, 0x54, 0xad, 0x47, 0xfd, 0x85, 0x31, 0x90, 0x9c, 0xc8, 0x35, 0x71,
	0xe7, 0xc8, 0x99, 0x6d, 0x83, 0x7a, 0xb0, 0xd3, 0xc7, 0x41, 0xdc, 0x5b, 0x3d, 0x9f, 0x3a, 0xaa,
	0x86, 0x32, 0xe1, 0xf2, 0x2a, 0x43, 0xa2, 0x3e, 0x54, 0x93, 0x3c, 0x62, 0x40, 0x66, 0x94, 0x72,
	0xef, 0xb1, 0x11, 0x89, 0x74, 0xd8, 0x48, 0xb8, 0x07, 0x1d, 0x24, 0x94, 0x59, 0xb6, 0xad, 0xdc,
	0x58, 0x0d, 0x10, 0x82, 0xff, 0x03, 0x5b, 0xbc, 0xe3, 0x8d, 0x00, 0xdf, 0x1b, 0x0f, 0xdc, 0x50,
	0x19, 0x71, 0xed, 0xa7, 0x9a, 0x22, 0x65, 0x90, 0x2e, 0x6c, 0x0e, 0x70, 0x26, 0xc7, 0xc2, 0x21,
	0x19, 0x95, 0x3a, 0xdf, 0x7d, 0x53, 0xe7, 0x7b, 0xed, 0xf0, 0x1b, 0xc9, 0xb4, 0xe9, 0xc4, 0x6a,
	0x8f, 0xa9, 0xf8, 0x16, 0x1a, 0x15, 0xf8, 0xef, 0xd1, 0xb7, 0x00, 0x00, 0x00, 0xff, 0xff, 0x92,
	0x83, 0x0b, 0x6f, 0x68, 0x09, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConnInterface

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion6

// MobilityServiceClient is the client API for MobilityService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MobilityServiceClient interface {
	// Add a range of IP addresses into the free IP pool
	// Throws INVALID_ARGUMENT if IPBlock is invalid
	// Throws FAILED_PRECONDITION if IPBlock overlaps with existing ones
	//
	AddIPBlock(ctx context.Context, in *IPBlock, opts ...grpc.CallOption) (*protos.Void, error)
	// Return a list of assigned IP blocks
	//
	ListAddedIPv4Blocks(ctx context.Context, in *protos.Void, opts ...grpc.CallOption) (*ListAddedIPBlocksResponse, error)
	// Return a list of allocated IPs inside a IP block
	// Throws INVALID_ARGUMENT if IPBlock is invalid
	// Throws FAILED_PRECONDITION if IPBlock is not previously assigned
	//
	ListAllocatedIPs(ctx context.Context, in *IPBlock, opts ...grpc.CallOption) (*ListAllocatedIPsResponse, error)
	// Allocate an IP address from the free IP pool
	// Throws RESOURCE_EXHAUSTED if no free IP available
	// Throws ALREADY_EXISTS if an IP has been allocated for the subscriber
	//
	AllocateIPAddress(ctx context.Context, in *AllocateIPRequest, opts ...grpc.CallOption) (*AllocateIPAddressResponse, error)
	// Release and recycle an allocated IP address
	// Throws NOT_FOUND if the requested (SID, IP) pair is not found
	//
	ReleaseIPAddress(ctx context.Context, in *ReleaseIPRequest, opts ...grpc.CallOption) (*protos.Void, error)
	// Gets subscriber's IP address. Throws NOT_FOUND if it doesn't exist
	GetIPForSubscriber(ctx context.Context, in *IPLookupRequest, opts ...grpc.CallOption) (*IPAddress, error)
	// Gets subscriber's ID from an IP Address.
	// Throws NOT_FOUND if it doesn't exist
	GetSubscriberIDFromIP(ctx context.Context, in *IPAddress, opts ...grpc.CallOption) (*SubscriberID, error)
	// Get the full subscriber table
	GetSubscriberIPTable(ctx context.Context, in *protos.Void, opts ...grpc.CallOption) (*SubscriberIPTable, error)
	// Remove allocated IP blocks
	// Default behavior is to only remove all IP blocks that have no IP addresses
	// allocated from them. If force is set, then will remove all IP blocks,
	// regardless of whether any IPs have been allocated.
	RemoveIPBlock(ctx context.Context, in *RemoveIPBlockRequest, opts ...grpc.CallOption) (*RemoveIPBlockResponse, error)
	// Get Internet Gateway and  mac addresss
	ListGatewayInfo(ctx context.Context, in *protos.Void, opts ...grpc.CallOption) (*ListGWInfoResponse, error)
	// Set ip and mac address of def Internet Gateway
	SetGatewayInfo(ctx context.Context, in *GWInfo, opts ...grpc.CallOption) (*protos.Void, error)
}

type mobilityServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMobilityServiceClient(cc grpc.ClientConnInterface) MobilityServiceClient {
	return &mobilityServiceClient{cc}
}

func (c *mobilityServiceClient) AddIPBlock(ctx context.Context, in *IPBlock, opts ...grpc.CallOption) (*protos.Void, error) {
	out := new(protos.Void)
	err := c.cc.Invoke(ctx, "/magma.lte.MobilityService/AddIPBlock", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobilityServiceClient) ListAddedIPv4Blocks(ctx context.Context, in *protos.Void, opts ...grpc.CallOption) (*ListAddedIPBlocksResponse, error) {
	out := new(ListAddedIPBlocksResponse)
	err := c.cc.Invoke(ctx, "/magma.lte.MobilityService/ListAddedIPv4Blocks", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobilityServiceClient) ListAllocatedIPs(ctx context.Context, in *IPBlock, opts ...grpc.CallOption) (*ListAllocatedIPsResponse, error) {
	out := new(ListAllocatedIPsResponse)
	err := c.cc.Invoke(ctx, "/magma.lte.MobilityService/ListAllocatedIPs", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobilityServiceClient) AllocateIPAddress(ctx context.Context, in *AllocateIPRequest, opts ...grpc.CallOption) (*AllocateIPAddressResponse, error) {
	out := new(AllocateIPAddressResponse)
	err := c.cc.Invoke(ctx, "/magma.lte.MobilityService/AllocateIPAddress", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobilityServiceClient) ReleaseIPAddress(ctx context.Context, in *ReleaseIPRequest, opts ...grpc.CallOption) (*protos.Void, error) {
	out := new(protos.Void)
	err := c.cc.Invoke(ctx, "/magma.lte.MobilityService/ReleaseIPAddress", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobilityServiceClient) GetIPForSubscriber(ctx context.Context, in *IPLookupRequest, opts ...grpc.CallOption) (*IPAddress, error) {
	out := new(IPAddress)
	err := c.cc.Invoke(ctx, "/magma.lte.MobilityService/GetIPForSubscriber", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobilityServiceClient) GetSubscriberIDFromIP(ctx context.Context, in *IPAddress, opts ...grpc.CallOption) (*SubscriberID, error) {
	out := new(SubscriberID)
	err := c.cc.Invoke(ctx, "/magma.lte.MobilityService/GetSubscriberIDFromIP", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobilityServiceClient) GetSubscriberIPTable(ctx context.Context, in *protos.Void, opts ...grpc.CallOption) (*SubscriberIPTable, error) {
	out := new(SubscriberIPTable)
	err := c.cc.Invoke(ctx, "/magma.lte.MobilityService/GetSubscriberIPTable", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobilityServiceClient) RemoveIPBlock(ctx context.Context, in *RemoveIPBlockRequest, opts ...grpc.CallOption) (*RemoveIPBlockResponse, error) {
	out := new(RemoveIPBlockResponse)
	err := c.cc.Invoke(ctx, "/magma.lte.MobilityService/RemoveIPBlock", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobilityServiceClient) ListGatewayInfo(ctx context.Context, in *protos.Void, opts ...grpc.CallOption) (*ListGWInfoResponse, error) {
	out := new(ListGWInfoResponse)
	err := c.cc.Invoke(ctx, "/magma.lte.MobilityService/ListGatewayInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobilityServiceClient) SetGatewayInfo(ctx context.Context, in *GWInfo, opts ...grpc.CallOption) (*protos.Void, error) {
	out := new(protos.Void)
	err := c.cc.Invoke(ctx, "/magma.lte.MobilityService/SetGatewayInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MobilityServiceServer is the server API for MobilityService service.
type MobilityServiceServer interface {
	// Add a range of IP addresses into the free IP pool
	// Throws INVALID_ARGUMENT if IPBlock is invalid
	// Throws FAILED_PRECONDITION if IPBlock overlaps with existing ones
	//
	AddIPBlock(context.Context, *IPBlock) (*protos.Void, error)
	// Return a list of assigned IP blocks
	//
	ListAddedIPv4Blocks(context.Context, *protos.Void) (*ListAddedIPBlocksResponse, error)
	// Return a list of allocated IPs inside a IP block
	// Throws INVALID_ARGUMENT if IPBlock is invalid
	// Throws FAILED_PRECONDITION if IPBlock is not previously assigned
	//
	ListAllocatedIPs(context.Context, *IPBlock) (*ListAllocatedIPsResponse, error)
	// Allocate an IP address from the free IP pool
	// Throws RESOURCE_EXHAUSTED if no free IP available
	// Throws ALREADY_EXISTS if an IP has been allocated for the subscriber
	//
	AllocateIPAddress(context.Context, *AllocateIPRequest) (*AllocateIPAddressResponse, error)
	// Release and recycle an allocated IP address
	// Throws NOT_FOUND if the requested (SID, IP) pair is not found
	//
	ReleaseIPAddress(context.Context, *ReleaseIPRequest) (*protos.Void, error)
	// Gets subscriber's IP address. Throws NOT_FOUND if it doesn't exist
	GetIPForSubscriber(context.Context, *IPLookupRequest) (*IPAddress, error)
	// Gets subscriber's ID from an IP Address.
	// Throws NOT_FOUND if it doesn't exist
	GetSubscriberIDFromIP(context.Context, *IPAddress) (*SubscriberID, error)
	// Get the full subscriber table
	GetSubscriberIPTable(context.Context, *protos.Void) (*SubscriberIPTable, error)
	// Remove allocated IP blocks
	// Default behavior is to only remove all IP blocks that have no IP addresses
	// allocated from them. If force is set, then will remove all IP blocks,
	// regardless of whether any IPs have been allocated.
	RemoveIPBlock(context.Context, *RemoveIPBlockRequest) (*RemoveIPBlockResponse, error)
	// Get Internet Gateway and  mac addresss
	ListGatewayInfo(context.Context, *protos.Void) (*ListGWInfoResponse, error)
	// Set ip and mac address of def Internet Gateway
	SetGatewayInfo(context.Context, *GWInfo) (*protos.Void, error)
}

// UnimplementedMobilityServiceServer can be embedded to have forward compatible implementations.
type UnimplementedMobilityServiceServer struct {
}

func (*UnimplementedMobilityServiceServer) AddIPBlock(ctx context.Context, req *IPBlock) (*protos.Void, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddIPBlock not implemented")
}
func (*UnimplementedMobilityServiceServer) ListAddedIPv4Blocks(ctx context.Context, req *protos.Void) (*ListAddedIPBlocksResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListAddedIPv4Blocks not implemented")
}
func (*UnimplementedMobilityServiceServer) ListAllocatedIPs(ctx context.Context, req *IPBlock) (*ListAllocatedIPsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListAllocatedIPs not implemented")
}
func (*UnimplementedMobilityServiceServer) AllocateIPAddress(ctx context.Context, req *AllocateIPRequest) (*AllocateIPAddressResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AllocateIPAddress not implemented")
}
func (*UnimplementedMobilityServiceServer) ReleaseIPAddress(ctx context.Context, req *ReleaseIPRequest) (*protos.Void, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReleaseIPAddress not implemented")
}
func (*UnimplementedMobilityServiceServer) GetIPForSubscriber(ctx context.Context, req *IPLookupRequest) (*IPAddress, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetIPForSubscriber not implemented")
}
func (*UnimplementedMobilityServiceServer) GetSubscriberIDFromIP(ctx context.Context, req *IPAddress) (*SubscriberID, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSubscriberIDFromIP not implemented")
}
func (*UnimplementedMobilityServiceServer) GetSubscriberIPTable(ctx context.Context, req *protos.Void) (*SubscriberIPTable, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSubscriberIPTable not implemented")
}
func (*UnimplementedMobilityServiceServer) RemoveIPBlock(ctx context.Context, req *RemoveIPBlockRequest) (*RemoveIPBlockResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveIPBlock not implemented")
}
func (*UnimplementedMobilityServiceServer) ListGatewayInfo(ctx context.Context, req *protos.Void) (*ListGWInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListGatewayInfo not implemented")
}
func (*UnimplementedMobilityServiceServer) SetGatewayInfo(ctx context.Context, req *GWInfo) (*protos.Void, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetGatewayInfo not implemented")
}

func RegisterMobilityServiceServer(s *grpc.Server, srv MobilityServiceServer) {
	s.RegisterService(&_MobilityService_serviceDesc, srv)
}

func _MobilityService_AddIPBlock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IPBlock)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobilityServiceServer).AddIPBlock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.lte.MobilityService/AddIPBlock",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobilityServiceServer).AddIPBlock(ctx, req.(*IPBlock))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobilityService_ListAddedIPv4Blocks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(protos.Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobilityServiceServer).ListAddedIPv4Blocks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.lte.MobilityService/ListAddedIPv4Blocks",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobilityServiceServer).ListAddedIPv4Blocks(ctx, req.(*protos.Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobilityService_ListAllocatedIPs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IPBlock)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobilityServiceServer).ListAllocatedIPs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.lte.MobilityService/ListAllocatedIPs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobilityServiceServer).ListAllocatedIPs(ctx, req.(*IPBlock))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobilityService_AllocateIPAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AllocateIPRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobilityServiceServer).AllocateIPAddress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.lte.MobilityService/AllocateIPAddress",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobilityServiceServer).AllocateIPAddress(ctx, req.(*AllocateIPRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobilityService_ReleaseIPAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReleaseIPRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobilityServiceServer).ReleaseIPAddress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.lte.MobilityService/ReleaseIPAddress",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobilityServiceServer).ReleaseIPAddress(ctx, req.(*ReleaseIPRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobilityService_GetIPForSubscriber_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IPLookupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobilityServiceServer).GetIPForSubscriber(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.lte.MobilityService/GetIPForSubscriber",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobilityServiceServer).GetIPForSubscriber(ctx, req.(*IPLookupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobilityService_GetSubscriberIDFromIP_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IPAddress)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobilityServiceServer).GetSubscriberIDFromIP(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.lte.MobilityService/GetSubscriberIDFromIP",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobilityServiceServer).GetSubscriberIDFromIP(ctx, req.(*IPAddress))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobilityService_GetSubscriberIPTable_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(protos.Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobilityServiceServer).GetSubscriberIPTable(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.lte.MobilityService/GetSubscriberIPTable",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobilityServiceServer).GetSubscriberIPTable(ctx, req.(*protos.Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobilityService_RemoveIPBlock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveIPBlockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobilityServiceServer).RemoveIPBlock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.lte.MobilityService/RemoveIPBlock",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobilityServiceServer).RemoveIPBlock(ctx, req.(*RemoveIPBlockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobilityService_ListGatewayInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(protos.Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobilityServiceServer).ListGatewayInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.lte.MobilityService/ListGatewayInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobilityServiceServer).ListGatewayInfo(ctx, req.(*protos.Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobilityService_SetGatewayInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GWInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobilityServiceServer).SetGatewayInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.lte.MobilityService/SetGatewayInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobilityServiceServer).SetGatewayInfo(ctx, req.(*GWInfo))
	}
	return interceptor(ctx, in, info, handler)
}

var _MobilityService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "magma.lte.MobilityService",
	HandlerType: (*MobilityServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddIPBlock",
			Handler:    _MobilityService_AddIPBlock_Handler,
		},
		{
			MethodName: "ListAddedIPv4Blocks",
			Handler:    _MobilityService_ListAddedIPv4Blocks_Handler,
		},
		{
			MethodName: "ListAllocatedIPs",
			Handler:    _MobilityService_ListAllocatedIPs_Handler,
		},
		{
			MethodName: "AllocateIPAddress",
			Handler:    _MobilityService_AllocateIPAddress_Handler,
		},
		{
			MethodName: "ReleaseIPAddress",
			Handler:    _MobilityService_ReleaseIPAddress_Handler,
		},
		{
			MethodName: "GetIPForSubscriber",
			Handler:    _MobilityService_GetIPForSubscriber_Handler,
		},
		{
			MethodName: "GetSubscriberIDFromIP",
			Handler:    _MobilityService_GetSubscriberIDFromIP_Handler,
		},
		{
			MethodName: "GetSubscriberIPTable",
			Handler:    _MobilityService_GetSubscriberIPTable_Handler,
		},
		{
			MethodName: "RemoveIPBlock",
			Handler:    _MobilityService_RemoveIPBlock_Handler,
		},
		{
			MethodName: "ListGatewayInfo",
			Handler:    _MobilityService_ListGatewayInfo_Handler,
		},
		{
			MethodName: "SetGatewayInfo",
			Handler:    _MobilityService_SetGatewayInfo_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "lte/protos/mobilityd.proto",
}

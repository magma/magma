// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// EnodebState Single Enodeb State
//
// swagger:model enodeb_state
type EnodebState struct {

	// enodeb configured
	// Required: true
	EnodebConfigured *bool `json:"enodeb_configured"`

	// enodeb connected
	// Required: true
	EnodebConnected *bool `json:"enodeb_connected"`

	// fsm state
	// Required: true
	FsmState *string `json:"fsm_state"`

	// gps connected
	// Required: true
	GpsConnected *bool `json:"gps_connected"`

	// gps latitude
	// Required: true
	GpsLatitude *string `json:"gps_latitude"`

	// gps longitude
	// Required: true
	GpsLongitude *string `json:"gps_longitude"`

	// ip address
	// Format: ipv4
	IPAddress strfmt.IPv4 `json:"ip_address,omitempty"`

	// mme connected
	// Required: true
	MmeConnected *bool `json:"mme_connected"`

	// opstate enabled
	// Required: true
	OpstateEnabled *bool `json:"opstate_enabled"`

	// ptp connected
	// Required: true
	PtpConnected *bool `json:"ptp_connected"`

	// Gateway ID from which the enodeb state was reported
	ReportingGatewayID string `json:"reporting_gateway_id,omitempty"`

	// rf tx desired
	// Required: true
	RfTxDesired *bool `json:"rf_tx_desired"`

	// rf tx on
	// Required: true
	RfTxOn *bool `json:"rf_tx_on"`

	// Time at which the state was reported in ms
	TimeReported uint64 `json:"time_reported,omitempty"`

	// ues connected
	UesConnected int32 `json:"ues_connected,omitempty"`
}

// Validate validates this enodeb state
func (m *EnodebState) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateEnodebConfigured(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEnodebConnected(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFsmState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateGpsConnected(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateGpsLatitude(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateGpsLongitude(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIPAddress(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMmeConnected(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOpstateEnabled(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePtpConnected(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRfTxDesired(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRfTxOn(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *EnodebState) validateEnodebConfigured(formats strfmt.Registry) error {

	if err := validate.Required("enodeb_configured", "body", m.EnodebConfigured); err != nil {
		return err
	}

	return nil
}

func (m *EnodebState) validateEnodebConnected(formats strfmt.Registry) error {

	if err := validate.Required("enodeb_connected", "body", m.EnodebConnected); err != nil {
		return err
	}

	return nil
}

func (m *EnodebState) validateFsmState(formats strfmt.Registry) error {

	if err := validate.Required("fsm_state", "body", m.FsmState); err != nil {
		return err
	}

	return nil
}

func (m *EnodebState) validateGpsConnected(formats strfmt.Registry) error {

	if err := validate.Required("gps_connected", "body", m.GpsConnected); err != nil {
		return err
	}

	return nil
}

func (m *EnodebState) validateGpsLatitude(formats strfmt.Registry) error {

	if err := validate.Required("gps_latitude", "body", m.GpsLatitude); err != nil {
		return err
	}

	return nil
}

func (m *EnodebState) validateGpsLongitude(formats strfmt.Registry) error {

	if err := validate.Required("gps_longitude", "body", m.GpsLongitude); err != nil {
		return err
	}

	return nil
}

func (m *EnodebState) validateIPAddress(formats strfmt.Registry) error {
	if swag.IsZero(m.IPAddress) { // not required
		return nil
	}

	if err := validate.FormatOf("ip_address", "body", "ipv4", m.IPAddress.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *EnodebState) validateMmeConnected(formats strfmt.Registry) error {

	if err := validate.Required("mme_connected", "body", m.MmeConnected); err != nil {
		return err
	}

	return nil
}

func (m *EnodebState) validateOpstateEnabled(formats strfmt.Registry) error {

	if err := validate.Required("opstate_enabled", "body", m.OpstateEnabled); err != nil {
		return err
	}

	return nil
}

func (m *EnodebState) validatePtpConnected(formats strfmt.Registry) error {

	if err := validate.Required("ptp_connected", "body", m.PtpConnected); err != nil {
		return err
	}

	return nil
}

func (m *EnodebState) validateRfTxDesired(formats strfmt.Registry) error {

	if err := validate.Required("rf_tx_desired", "body", m.RfTxDesired); err != nil {
		return err
	}

	return nil
}

func (m *EnodebState) validateRfTxOn(formats strfmt.Registry) error {

	if err := validate.Required("rf_tx_on", "body", m.RfTxOn); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this enodeb state based on context it is used
func (m *EnodebState) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *EnodebState) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *EnodebState) UnmarshalBinary(b []byte) error {
	var res EnodebState
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_3GPP23003_MAGMA_LTE_TEST_FLAT_BUFFER_H_
#define FLATBUFFERS_GENERATED_3GPP23003_MAGMA_LTE_TEST_FLAT_BUFFER_H_

#include "flatbuffers/flatbuffers.h"

#include "common_types_generated.h"

namespace magma {
namespace lte {
namespace test_flat_buffer {

struct Plmn;

struct Imsi;

struct Gummei;

struct Guti;

struct Imei;

struct Imeisv;

struct Ecgi;

struct Msisdn;

struct ApnNi;

struct ApnOi;

struct Apn;

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(1) Plmn FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t mcc_digit1_;
  uint8_t mcc_digit2_;
  uint8_t mcc_digit3_;
  uint8_t mnc_digit1_;
  uint8_t mnc_digit2_;
  uint8_t mnc_digit3_;

 public:
  Plmn()
      : mcc_digit1_(0),
        mcc_digit2_(0),
        mcc_digit3_(0),
        mnc_digit1_(0),
        mnc_digit2_(0),
        mnc_digit3_(0) {}
  Plmn(
      uint8_t _mcc_digit1, uint8_t _mcc_digit2, uint8_t _mcc_digit3,
      uint8_t _mnc_digit1, uint8_t _mnc_digit2, uint8_t _mnc_digit3)
      : mcc_digit1_(flatbuffers::EndianScalar(_mcc_digit1)),
        mcc_digit2_(flatbuffers::EndianScalar(_mcc_digit2)),
        mcc_digit3_(flatbuffers::EndianScalar(_mcc_digit3)),
        mnc_digit1_(flatbuffers::EndianScalar(_mnc_digit1)),
        mnc_digit2_(flatbuffers::EndianScalar(_mnc_digit2)),
        mnc_digit3_(flatbuffers::EndianScalar(_mnc_digit3)) {}
  uint8_t mcc_digit1() const { return flatbuffers::EndianScalar(mcc_digit1_); }
  void mutate_mcc_digit1(uint8_t _mcc_digit1) {
    flatbuffers::WriteScalar(&mcc_digit1_, _mcc_digit1);
  }
  uint8_t mcc_digit2() const { return flatbuffers::EndianScalar(mcc_digit2_); }
  void mutate_mcc_digit2(uint8_t _mcc_digit2) {
    flatbuffers::WriteScalar(&mcc_digit2_, _mcc_digit2);
  }
  uint8_t mcc_digit3() const { return flatbuffers::EndianScalar(mcc_digit3_); }
  void mutate_mcc_digit3(uint8_t _mcc_digit3) {
    flatbuffers::WriteScalar(&mcc_digit3_, _mcc_digit3);
  }
  uint8_t mnc_digit1() const { return flatbuffers::EndianScalar(mnc_digit1_); }
  void mutate_mnc_digit1(uint8_t _mnc_digit1) {
    flatbuffers::WriteScalar(&mnc_digit1_, _mnc_digit1);
  }
  uint8_t mnc_digit2() const { return flatbuffers::EndianScalar(mnc_digit2_); }
  void mutate_mnc_digit2(uint8_t _mnc_digit2) {
    flatbuffers::WriteScalar(&mnc_digit2_, _mnc_digit2);
  }
  uint8_t mnc_digit3() const { return flatbuffers::EndianScalar(mnc_digit3_); }
  void mutate_mnc_digit3(uint8_t _mnc_digit3) {
    flatbuffers::WriteScalar(&mnc_digit3_, _mnc_digit3);
  }
};
FLATBUFFERS_STRUCT_END(Plmn, 6);

inline bool operator==(const Plmn& lhs, const Plmn& rhs) {
  return (lhs.mcc_digit1() == rhs.mcc_digit1()) &&
         (lhs.mcc_digit2() == rhs.mcc_digit2()) &&
         (lhs.mcc_digit3() == rhs.mcc_digit3()) &&
         (lhs.mnc_digit1() == rhs.mnc_digit1()) &&
         (lhs.mnc_digit2() == rhs.mnc_digit2()) &&
         (lhs.mnc_digit3() == rhs.mnc_digit3());
}

inline bool operator!=(const Plmn& lhs, const Plmn& rhs) {
  return !(lhs == rhs);
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(1) Imsi FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t bytes_[8];
  uint8_t length_;

 public:
  Imsi() : bytes_(), length_(0) {}
  Imsi(uint8_t _length)
      : bytes_(), length_(flatbuffers::EndianScalar(_length)) {}
  Imsi(flatbuffers::span<const uint8_t, 8> _bytes, uint8_t _length)
      : length_(flatbuffers::EndianScalar(_length)) {
    flatbuffers::CastToArray(bytes_).CopyFromSpan(_bytes);
  }
  const flatbuffers::Array<uint8_t, 8>* bytes() const {
    return &flatbuffers::CastToArray(bytes_);
  }
  flatbuffers::Array<uint8_t, 8>* mutable_bytes() {
    return &flatbuffers::CastToArray(bytes_);
  }
  uint8_t length() const { return flatbuffers::EndianScalar(length_); }
  void mutate_length(uint8_t _length) {
    flatbuffers::WriteScalar(&length_, _length);
  }
};
FLATBUFFERS_STRUCT_END(Imsi, 9);

inline bool operator==(const Imsi& lhs, const Imsi& rhs) {
  return (lhs.bytes() == rhs.bytes()) && (lhs.length() == rhs.length());
}

inline bool operator!=(const Imsi& lhs, const Imsi& rhs) {
  return !(lhs == rhs);
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(2) Gummei FLATBUFFERS_FINAL_CLASS {
 private:
  magma::lte::test_flat_buffer::Plmn plmn_;
  uint16_t mme_gid_;
  uint8_t mme_code_;
  int8_t padding0__;

 public:
  Gummei() : plmn_(), mme_gid_(0), mme_code_(0), padding0__(0) {
    (void) padding0__;
  }
  Gummei(
      const magma::lte::test_flat_buffer::Plmn& _plmn, uint16_t _mme_gid,
      uint8_t _mme_code)
      : plmn_(_plmn),
        mme_gid_(flatbuffers::EndianScalar(_mme_gid)),
        mme_code_(flatbuffers::EndianScalar(_mme_code)),
        padding0__(0) {
    (void) padding0__;
  }
  const magma::lte::test_flat_buffer::Plmn& plmn() const { return plmn_; }
  magma::lte::test_flat_buffer::Plmn& mutable_plmn() { return plmn_; }
  uint16_t mme_gid() const { return flatbuffers::EndianScalar(mme_gid_); }
  void mutate_mme_gid(uint16_t _mme_gid) {
    flatbuffers::WriteScalar(&mme_gid_, _mme_gid);
  }
  uint8_t mme_code() const { return flatbuffers::EndianScalar(mme_code_); }
  void mutate_mme_code(uint8_t _mme_code) {
    flatbuffers::WriteScalar(&mme_code_, _mme_code);
  }
};
FLATBUFFERS_STRUCT_END(Gummei, 10);

inline bool operator==(const Gummei& lhs, const Gummei& rhs) {
  return (lhs.plmn() == rhs.plmn()) && (lhs.mme_gid() == rhs.mme_gid()) &&
         (lhs.mme_code() == rhs.mme_code());
}

inline bool operator!=(const Gummei& lhs, const Gummei& rhs) {
  return !(lhs == rhs);
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Guti FLATBUFFERS_FINAL_CLASS {
 private:
  magma::lte::test_flat_buffer::Gummei gummei_;
  int16_t padding0__;
  uint32_t m_tmsi_;

 public:
  Guti() : gummei_(), padding0__(0), m_tmsi_(0) { (void) padding0__; }
  Guti(const magma::lte::test_flat_buffer::Gummei& _gummei, uint32_t _m_tmsi)
      : gummei_(_gummei),
        padding0__(0),
        m_tmsi_(flatbuffers::EndianScalar(_m_tmsi)) {
    (void) padding0__;
  }
  const magma::lte::test_flat_buffer::Gummei& gummei() const { return gummei_; }
  magma::lte::test_flat_buffer::Gummei& mutable_gummei() { return gummei_; }
  uint32_t m_tmsi() const { return flatbuffers::EndianScalar(m_tmsi_); }
  void mutate_m_tmsi(uint32_t _m_tmsi) {
    flatbuffers::WriteScalar(&m_tmsi_, _m_tmsi);
  }
};
FLATBUFFERS_STRUCT_END(Guti, 16);

inline bool operator==(const Guti& lhs, const Guti& rhs) {
  return (lhs.gummei() == rhs.gummei()) && (lhs.m_tmsi() == rhs.m_tmsi());
}

inline bool operator!=(const Guti& lhs, const Guti& rhs) {
  return !(lhs == rhs);
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(1) Imei FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t bytes_[8];

 public:
  Imei() : bytes_() {}
  Imei(flatbuffers::span<const uint8_t, 8> _bytes) {
    flatbuffers::CastToArray(bytes_).CopyFromSpan(_bytes);
  }
  const flatbuffers::Array<uint8_t, 8>* bytes() const {
    return &flatbuffers::CastToArray(bytes_);
  }
  flatbuffers::Array<uint8_t, 8>* mutable_bytes() {
    return &flatbuffers::CastToArray(bytes_);
  }
};
FLATBUFFERS_STRUCT_END(Imei, 8);

inline bool operator==(const Imei& lhs, const Imei& rhs) {
  return (lhs.bytes() == rhs.bytes());
}

inline bool operator!=(const Imei& lhs, const Imei& rhs) {
  return !(lhs == rhs);
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(1) Imeisv FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t bytes_[8];

 public:
  Imeisv() : bytes_() {}
  Imeisv(flatbuffers::span<const uint8_t, 8> _bytes) {
    flatbuffers::CastToArray(bytes_).CopyFromSpan(_bytes);
  }
  const flatbuffers::Array<uint8_t, 8>* bytes() const {
    return &flatbuffers::CastToArray(bytes_);
  }
  flatbuffers::Array<uint8_t, 8>* mutable_bytes() {
    return &flatbuffers::CastToArray(bytes_);
  }
};
FLATBUFFERS_STRUCT_END(Imeisv, 8);

inline bool operator==(const Imeisv& lhs, const Imeisv& rhs) {
  return (lhs.bytes() == rhs.bytes());
}

inline bool operator!=(const Imeisv& lhs, const Imeisv& rhs) {
  return !(lhs == rhs);
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Ecgi FLATBUFFERS_FINAL_CLASS {
 private:
  magma::lte::test_flat_buffer::Plmn plmn_;
  int16_t padding0__;
  uint32_t cell_identity_;

 public:
  Ecgi() : plmn_(), padding0__(0), cell_identity_(0) { (void) padding0__; }
  Ecgi(const magma::lte::test_flat_buffer::Plmn& _plmn, uint32_t _cell_identity)
      : plmn_(_plmn),
        padding0__(0),
        cell_identity_(flatbuffers::EndianScalar(_cell_identity)) {
    (void) padding0__;
  }
  /// plmn_t
  const magma::lte::test_flat_buffer::Plmn& plmn() const { return plmn_; }
  magma::lte::test_flat_buffer::Plmn& mutable_plmn() { return plmn_; }
  ///  eci_t The ECI shall be of fixed length of 28 bits
  uint32_t cell_identity() const {
    return flatbuffers::EndianScalar(cell_identity_);
  }
  void mutate_cell_identity(uint32_t _cell_identity) {
    flatbuffers::WriteScalar(&cell_identity_, _cell_identity);
  }
};
FLATBUFFERS_STRUCT_END(Ecgi, 12);

inline bool operator==(const Ecgi& lhs, const Ecgi& rhs) {
  return (lhs.plmn() == rhs.plmn()) &&
         (lhs.cell_identity() == rhs.cell_identity());
}

inline bool operator!=(const Ecgi& lhs, const Ecgi& rhs) {
  return !(lhs == rhs);
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(1) Msisdn FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t bytes_[15];
  uint8_t length_;

 public:
  Msisdn() : bytes_(), length_(0) {}
  Msisdn(uint8_t _length)
      : bytes_(), length_(flatbuffers::EndianScalar(_length)) {}
  Msisdn(flatbuffers::span<const uint8_t, 15> _bytes, uint8_t _length)
      : length_(flatbuffers::EndianScalar(_length)) {
    flatbuffers::CastToArray(bytes_).CopyFromSpan(_bytes);
  }
  const flatbuffers::Array<uint8_t, 15>* bytes() const {
    return &flatbuffers::CastToArray(bytes_);
  }
  flatbuffers::Array<uint8_t, 15>* mutable_bytes() {
    return &flatbuffers::CastToArray(bytes_);
  }
  uint8_t length() const { return flatbuffers::EndianScalar(length_); }
  void mutate_length(uint8_t _length) {
    flatbuffers::WriteScalar(&length_, _length);
  }
};
FLATBUFFERS_STRUCT_END(Msisdn, 16);

inline bool operator==(const Msisdn& lhs, const Msisdn& rhs) {
  return (lhs.bytes() == rhs.bytes()) && (lhs.length() == rhs.length());
}

inline bool operator!=(const Msisdn& lhs, const Msisdn& rhs) {
  return !(lhs == rhs);
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(1) ApnNi FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t bytes_[63];
  uint8_t length_;

 public:
  ApnNi() : bytes_(), length_(0) {}
  ApnNi(uint8_t _length)
      : bytes_(), length_(flatbuffers::EndianScalar(_length)) {}
  ApnNi(flatbuffers::span<const uint8_t, 63> _bytes, uint8_t _length)
      : length_(flatbuffers::EndianScalar(_length)) {
    flatbuffers::CastToArray(bytes_).CopyFromSpan(_bytes);
  }
  const flatbuffers::Array<uint8_t, 63>* bytes() const {
    return &flatbuffers::CastToArray(bytes_);
  }
  flatbuffers::Array<uint8_t, 63>* mutable_bytes() {
    return &flatbuffers::CastToArray(bytes_);
  }
  uint8_t length() const { return flatbuffers::EndianScalar(length_); }
  void mutate_length(uint8_t _length) {
    flatbuffers::WriteScalar(&length_, _length);
  }
};
FLATBUFFERS_STRUCT_END(ApnNi, 64);

inline bool operator==(const ApnNi& lhs, const ApnNi& rhs) {
  return (lhs.bytes() == rhs.bytes()) && (lhs.length() == rhs.length());
}

inline bool operator!=(const ApnNi& lhs, const ApnNi& rhs) {
  return !(lhs == rhs);
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(1) ApnOi FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t bytes_[100];
  uint8_t length_;

 public:
  ApnOi() : bytes_(), length_(0) {}
  ApnOi(uint8_t _length)
      : bytes_(), length_(flatbuffers::EndianScalar(_length)) {}
  ApnOi(flatbuffers::span<const uint8_t, 100> _bytes, uint8_t _length)
      : length_(flatbuffers::EndianScalar(_length)) {
    flatbuffers::CastToArray(bytes_).CopyFromSpan(_bytes);
  }
  const flatbuffers::Array<uint8_t, 100>* bytes() const {
    return &flatbuffers::CastToArray(bytes_);
  }
  flatbuffers::Array<uint8_t, 100>* mutable_bytes() {
    return &flatbuffers::CastToArray(bytes_);
  }
  uint8_t length() const { return flatbuffers::EndianScalar(length_); }
  void mutate_length(uint8_t _length) {
    flatbuffers::WriteScalar(&length_, _length);
  }
};
FLATBUFFERS_STRUCT_END(ApnOi, 101);

inline bool operator==(const ApnOi& lhs, const ApnOi& rhs) {
  return (lhs.bytes() == rhs.bytes()) && (lhs.length() == rhs.length());
}

inline bool operator!=(const ApnOi& lhs, const ApnOi& rhs) {
  return !(lhs == rhs);
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(1) Apn FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t bytes_[100];
  uint8_t length_;

 public:
  Apn() : bytes_(), length_(0) {}
  Apn(uint8_t _length)
      : bytes_(), length_(flatbuffers::EndianScalar(_length)) {}
  Apn(flatbuffers::span<const uint8_t, 100> _bytes, uint8_t _length)
      : length_(flatbuffers::EndianScalar(_length)) {
    flatbuffers::CastToArray(bytes_).CopyFromSpan(_bytes);
  }
  const flatbuffers::Array<uint8_t, 100>* bytes() const {
    return &flatbuffers::CastToArray(bytes_);
  }
  flatbuffers::Array<uint8_t, 100>* mutable_bytes() {
    return &flatbuffers::CastToArray(bytes_);
  }
  uint8_t length() const { return flatbuffers::EndianScalar(length_); }
  void mutate_length(uint8_t _length) {
    flatbuffers::WriteScalar(&length_, _length);
  }
};
FLATBUFFERS_STRUCT_END(Apn, 101);

inline bool operator==(const Apn& lhs, const Apn& rhs) {
  return (lhs.bytes() == rhs.bytes()) && (lhs.length() == rhs.length());
}

inline bool operator!=(const Apn& lhs, const Apn& rhs) {
  return !(lhs == rhs);
}

}  // namespace test_flat_buffer
}  // namespace lte
}  // namespace magma

#endif  // FLATBUFFERS_GENERATED_3GPP23003_MAGMA_LTE_TEST_FLAT_BUFFER_H_

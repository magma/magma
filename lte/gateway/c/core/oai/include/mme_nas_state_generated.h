// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_MMENASSTATE_MAGMA_LTE_TEST_FLAT_BUFFER_H_
#define FLATBUFFERS_GENERATED_MMENASSTATE_MAGMA_LTE_TEST_FLAT_BUFFER_H_

#include "flatbuffers/flatbuffers.h"

#include "3gpp_23003_generated.h"
#include "common_types_generated.h"
#include "3gpp_29274_generated.h"
#include "3gpp_24008_generated.h"

namespace magma {
namespace lte {
namespace test_flat_buffer {

struct Tai;

struct Lai;

struct EsmPdn;

struct PdnContext;

struct NasProcMessSign;

struct NasTimer;

struct PdnAddr;

struct EsmProcData;

struct EsmContext;

struct AuthVector;

struct Count;

struct SelectedAlgorithms;

struct Capability;

struct EmmSecurityContext;

struct TaiListManyPlmn;

struct PartialTaiList;

struct TaiList;

struct UeNetworkCapability;

struct UeAdditionalSecurityCapability;

struct NwDetachData;

struct DrxParameter;

struct NasMessageDecodeStatus;

struct EsmMsg;

struct EmmAttachRequestIes;

struct NewAttachInfo;

struct EmmContext;

struct EsmEbrTimerData;

struct EsmEbrContext;

enum Constants : uint32_t {
  Constants_CHARGING_CHARACTERISTICS_LENGTH_P1 = 5,
  Constants_MIN = Constants_CHARGING_CHARACTERISTICS_LENGTH_P1,
  Constants_MAX = Constants_CHARGING_CHARACTERISTICS_LENGTH_P1
};

inline const Constants (&EnumValuesConstants())[1] {
  static const Constants values[] = {
      Constants_CHARGING_CHARACTERISTICS_LENGTH_P1};
  return values;
}

inline const char* const* EnumNamesConstants() {
  static const char* const names[2] = {"CHARGING_CHARACTERISTICS_LENGTH_P1",
                                       nullptr};
  return names;
}

inline const char* EnumNameConstants(Constants e) {
  if (flatbuffers::IsOutRange(
          e, Constants_CHARGING_CHARACTERISTICS_LENGTH_P1,
          Constants_CHARGING_CHARACTERISTICS_LENGTH_P1))
    return "";
  const size_t index =
      static_cast<size_t>(e) -
      static_cast<size_t>(Constants_CHARGING_CHARACTERISTICS_LENGTH_P1);
  return EnumNamesConstants()[index];
}

enum S1Cause : uint32_t {
  S1Cause_S1AP_INVALID_CAUSE                 = 0,
  S1Cause_S1AP_NAS_NORMAL_RELEASE            = 1,
  S1Cause_S1AP_NAS_DETACH                    = 2,
  S1Cause_S1AP_RADIO_EUTRAN_GENERATED_REASON = 3,
  S1Cause_S1AP_RADIO_UNKNOWN_E_RAB_ID        = 4,
  S1Cause_S1AP_IMPLICIT_CONTEXT_RELEASE      = 5,
  S1Cause_S1AP_INITIAL_CONTEXT_SETUP_FAILED  = 6,
  S1Cause_S1AP_SCTP_SHUTDOWN_OR_RESET        = 7,
  S1Cause_S1AP_INVALID_ENB_ID                = 8,
  S1Cause_S1AP_INVALID_MME_UE_S1AP_ID        = 9,
  S1Cause_S1AP_CSFB_TRIGGERED                = 10,
  S1Cause_S1AP_NAS_UE_NOT_AVAILABLE_FOR_PS   = 11,
  S1Cause_S1AP_SYSTEM_FAILURE                = 12,
  S1Cause_S1AP_RADIO_MULTIPLE_E_RAB_ID       = 13,
  S1Cause_S1AP_NAS_MME_OFFLOADING            = 14,
  S1Cause_S1AP_NAS_MME_PENDING_OFFLOADING    = 15,
  S1Cause_MIN                                = S1Cause_S1AP_INVALID_CAUSE,
  S1Cause_MAX = S1Cause_S1AP_NAS_MME_PENDING_OFFLOADING
};

inline const S1Cause (&EnumValuesS1Cause())[16] {
  static const S1Cause values[] = {S1Cause_S1AP_INVALID_CAUSE,
                                   S1Cause_S1AP_NAS_NORMAL_RELEASE,
                                   S1Cause_S1AP_NAS_DETACH,
                                   S1Cause_S1AP_RADIO_EUTRAN_GENERATED_REASON,
                                   S1Cause_S1AP_RADIO_UNKNOWN_E_RAB_ID,
                                   S1Cause_S1AP_IMPLICIT_CONTEXT_RELEASE,
                                   S1Cause_S1AP_INITIAL_CONTEXT_SETUP_FAILED,
                                   S1Cause_S1AP_SCTP_SHUTDOWN_OR_RESET,
                                   S1Cause_S1AP_INVALID_ENB_ID,
                                   S1Cause_S1AP_INVALID_MME_UE_S1AP_ID,
                                   S1Cause_S1AP_CSFB_TRIGGERED,
                                   S1Cause_S1AP_NAS_UE_NOT_AVAILABLE_FOR_PS,
                                   S1Cause_S1AP_SYSTEM_FAILURE,
                                   S1Cause_S1AP_RADIO_MULTIPLE_E_RAB_ID,
                                   S1Cause_S1AP_NAS_MME_OFFLOADING,
                                   S1Cause_S1AP_NAS_MME_PENDING_OFFLOADING};
  return values;
}

inline const char* const* EnumNamesS1Cause() {
  static const char* const names[17] = {"S1AP_INVALID_CAUSE",
                                        "S1AP_NAS_NORMAL_RELEASE",
                                        "S1AP_NAS_DETACH",
                                        "S1AP_RADIO_EUTRAN_GENERATED_REASON",
                                        "S1AP_RADIO_UNKNOWN_E_RAB_ID",
                                        "S1AP_IMPLICIT_CONTEXT_RELEASE",
                                        "S1AP_INITIAL_CONTEXT_SETUP_FAILED",
                                        "S1AP_SCTP_SHUTDOWN_OR_RESET",
                                        "S1AP_INVALID_ENB_ID",
                                        "S1AP_INVALID_MME_UE_S1AP_ID",
                                        "S1AP_CSFB_TRIGGERED",
                                        "S1AP_NAS_UE_NOT_AVAILABLE_FOR_PS",
                                        "S1AP_SYSTEM_FAILURE",
                                        "S1AP_RADIO_MULTIPLE_E_RAB_ID",
                                        "S1AP_NAS_MME_OFFLOADING",
                                        "S1AP_NAS_MME_PENDING_OFFLOADING",
                                        nullptr};
  return names;
}

inline const char* EnumNameS1Cause(S1Cause e) {
  if (flatbuffers::IsOutRange(
          e, S1Cause_S1AP_INVALID_CAUSE,
          S1Cause_S1AP_NAS_MME_PENDING_OFFLOADING))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesS1Cause()[index];
}

enum MmState : int8_t {
  MmState_UE_UNREGISTERED = 0,
  MmState_UE_REGISTERED   = 1,
  MmState_MIN             = MmState_UE_UNREGISTERED,
  MmState_MAX             = MmState_UE_REGISTERED
};

inline const MmState (&EnumValuesMmState())[2] {
  static const MmState values[] = {MmState_UE_UNREGISTERED,
                                   MmState_UE_REGISTERED};
  return values;
}

inline const char* const* EnumNamesMmState() {
  static const char* const names[3] = {"UE_UNREGISTERED", "UE_REGISTERED",
                                       nullptr};
  return names;
}

inline const char* EnumNameMmState(MmState e) {
  if (flatbuffers::IsOutRange(
          e, MmState_UE_UNREGISTERED, MmState_UE_REGISTERED))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMmState()[index];
}

enum EcmState : int8_t {
  EcmState_ECM_IDLE      = 0,
  EcmState_ECM_CONNECTED = 1,
  EcmState_MIN           = EcmState_ECM_IDLE,
  EcmState_MAX           = EcmState_ECM_CONNECTED
};

inline const EcmState (&EnumValuesEcmState())[2] {
  static const EcmState values[] = {EcmState_ECM_IDLE, EcmState_ECM_CONNECTED};
  return values;
}

inline const char* const* EnumNamesEcmState() {
  static const char* const names[3] = {"ECM_IDLE", "ECM_CONNECTED", nullptr};
  return names;
}

inline const char* EnumNameEcmState(EcmState e) {
  if (flatbuffers::IsOutRange(e, EcmState_ECM_IDLE, EcmState_ECM_CONNECTED))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesEcmState()[index];
}

/// ESM procedure transaction states
enum EsmPtState : uint8_t {
  EsmPtState_ESM_PROCEDURE_TRANSACTION_INACTIVE = 0,
  EsmPtState_ESM_PROCEDURE_TRANSACTION_PENDING  = 1,
  EsmPtState_ESM_PROCEDURE_TRANSACTION_MAX      = 2,
  EsmPtState_MIN = EsmPtState_ESM_PROCEDURE_TRANSACTION_INACTIVE,
  EsmPtState_MAX = EsmPtState_ESM_PROCEDURE_TRANSACTION_MAX
};

inline const EsmPtState (&EnumValuesEsmPtState())[3] {
  static const EsmPtState values[] = {
      EsmPtState_ESM_PROCEDURE_TRANSACTION_INACTIVE,
      EsmPtState_ESM_PROCEDURE_TRANSACTION_PENDING,
      EsmPtState_ESM_PROCEDURE_TRANSACTION_MAX};
  return values;
}

inline const char* const* EnumNamesEsmPtState() {
  static const char* const names[4] = {
      "ESM_PROCEDURE_TRANSACTION_INACTIVE", "ESM_PROCEDURE_TRANSACTION_PENDING",
      "ESM_PROCEDURE_TRANSACTION_MAX", nullptr};
  return names;
}

inline const char* EnumNameEsmPtState(EsmPtState e) {
  if (flatbuffers::IsOutRange(
          e, EsmPtState_ESM_PROCEDURE_TRANSACTION_INACTIVE,
          EsmPtState_ESM_PROCEDURE_TRANSACTION_MAX))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesEsmPtState()[index];
}

enum EmmProcAttachType : uint8_t {
  EmmProcAttachType_EMM_ATTACH_TYPE_EPS               = 0,
  EmmProcAttachType_EMM_ATTACH_TYPE_COMBINED_EPS_IMSI = 1,
  EmmProcAttachType_EMM_ATTACH_TYPE_EMERGENCY         = 2,
  EmmProcAttachType_EMM_ATTACH_TYPE_RESERVED          = 3,
  EmmProcAttachType_MIN = EmmProcAttachType_EMM_ATTACH_TYPE_EPS,
  EmmProcAttachType_MAX = EmmProcAttachType_EMM_ATTACH_TYPE_RESERVED
};

inline const EmmProcAttachType (&EnumValuesEmmProcAttachType())[4] {
  static const EmmProcAttachType values[] = {
      EmmProcAttachType_EMM_ATTACH_TYPE_EPS,
      EmmProcAttachType_EMM_ATTACH_TYPE_COMBINED_EPS_IMSI,
      EmmProcAttachType_EMM_ATTACH_TYPE_EMERGENCY,
      EmmProcAttachType_EMM_ATTACH_TYPE_RESERVED};
  return values;
}

inline const char* const* EnumNamesEmmProcAttachType() {
  static const char* const names[5] = {
      "EMM_ATTACH_TYPE_EPS", "EMM_ATTACH_TYPE_COMBINED_EPS_IMSI",
      "EMM_ATTACH_TYPE_EMERGENCY", "EMM_ATTACH_TYPE_RESERVED", nullptr};
  return names;
}

inline const char* EnumNameEmmProcAttachType(EmmProcAttachType e) {
  if (flatbuffers::IsOutRange(
          e, EmmProcAttachType_EMM_ATTACH_TYPE_EPS,
          EmmProcAttachType_EMM_ATTACH_TYPE_RESERVED))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesEmmProcAttachType()[index];
}

enum EmmFsmState : uint8_t {
  /// EMM_STATE_MIN = 0, error: all enum values must be unique: EMM_STATE_MIN
  /// and EMM_INVALID are both 0
  EmmFsmState_EMM_INVALID                    = 0,
  EmmFsmState_EMM_DEREGISTERED               = 1,
  EmmFsmState_EMM_REGISTERED                 = 2,
  EmmFsmState_EMM_DEREGISTERED_INITIATED     = 3,
  EmmFsmState_EMM_COMMON_PROCEDURE_INITIATED = 4,
  EmmFsmState_EMM_STATE_MAX                  = 5,
  EmmFsmState_MIN                            = EmmFsmState_EMM_INVALID,
  EmmFsmState_MAX                            = EmmFsmState_EMM_STATE_MAX
};

inline const EmmFsmState (&EnumValuesEmmFsmState())[6] {
  static const EmmFsmState values[] = {
      EmmFsmState_EMM_INVALID,
      EmmFsmState_EMM_DEREGISTERED,
      EmmFsmState_EMM_REGISTERED,
      EmmFsmState_EMM_DEREGISTERED_INITIATED,
      EmmFsmState_EMM_COMMON_PROCEDURE_INITIATED,
      EmmFsmState_EMM_STATE_MAX};
  return values;
}

inline const char* const* EnumNamesEmmFsmState() {
  static const char* const names[7] = {"EMM_INVALID",
                                       "EMM_DEREGISTERED",
                                       "EMM_REGISTERED",
                                       "EMM_DEREGISTERED_INITIATED",
                                       "EMM_COMMON_PROCEDURE_INITIATED",
                                       "EMM_STATE_MAX",
                                       nullptr};
  return names;
}

inline const char* EnumNameEmmFsmState(EmmFsmState e) {
  if (flatbuffers::IsOutRange(
          e, EmmFsmState_EMM_INVALID, EmmFsmState_EMM_STATE_MAX))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesEmmFsmState()[index];
}

enum AdditionalUpdateType : uint8_t {
  AdditionalUpdateType_NO_ADDITIONAL_INFORMATION = 0,
  AdditionalUpdateType_SMS_ONLY                  = 1,
  AdditionalUpdateType_MAX_                      = 2,
  AdditionalUpdateType_SENTINEL_MAX              = 255,
  AdditionalUpdateType_MIN = AdditionalUpdateType_NO_ADDITIONAL_INFORMATION,
  AdditionalUpdateType_MAX = AdditionalUpdateType_SENTINEL_MAX
};

inline const AdditionalUpdateType (&EnumValuesAdditionalUpdateType())[4] {
  static const AdditionalUpdateType values[] = {
      AdditionalUpdateType_NO_ADDITIONAL_INFORMATION,
      AdditionalUpdateType_SMS_ONLY, AdditionalUpdateType_MAX_,
      AdditionalUpdateType_SENTINEL_MAX};
  return values;
}

inline const char* EnumNameAdditionalUpdateType(AdditionalUpdateType e) {
  switch (e) {
    case AdditionalUpdateType_NO_ADDITIONAL_INFORMATION:
      return "NO_ADDITIONAL_INFORMATION";
    case AdditionalUpdateType_SMS_ONLY:
      return "SMS_ONLY";
    case AdditionalUpdateType_MAX_:
      return "MAX_";
    case AdditionalUpdateType_SENTINEL_MAX:
      return "SENTINEL_MAX";
    default:
      return "";
  }
}

enum EmmScType : uint8_t {
  EmmScType_SECURITY_CTX_TYPE_NOT_AVAILABLE  = 0,
  EmmScType_SECURITY_CTX_TYPE_PARTIAL_NATIVE = 1,
  EmmScType_SECURITY_CTX_TYPE_FULL_NATIVE    = 2,
  EmmScType_SECURITY_CTX_TYPE_MAPPED         = 3,
  EmmScType_MIN = EmmScType_SECURITY_CTX_TYPE_NOT_AVAILABLE,
  EmmScType_MAX = EmmScType_SECURITY_CTX_TYPE_MAPPED
};

inline const EmmScType (&EnumValuesEmmScType())[4] {
  static const EmmScType values[] = {EmmScType_SECURITY_CTX_TYPE_NOT_AVAILABLE,
                                     EmmScType_SECURITY_CTX_TYPE_PARTIAL_NATIVE,
                                     EmmScType_SECURITY_CTX_TYPE_FULL_NATIVE,
                                     EmmScType_SECURITY_CTX_TYPE_MAPPED};
  return values;
}

inline const char* const* EnumNamesEmmScType() {
  static const char* const names[5] = {
      "SECURITY_CTX_TYPE_NOT_AVAILABLE", "SECURITY_CTX_TYPE_PARTIAL_NATIVE",
      "SECURITY_CTX_TYPE_FULL_NATIVE", "SECURITY_CTX_TYPE_MAPPED", nullptr};
  return names;
}

inline const char* EnumNameEmmScType(EmmScType e) {
  if (flatbuffers::IsOutRange(
          e, EmmScType_SECURITY_CTX_TYPE_NOT_AVAILABLE,
          EmmScType_SECURITY_CTX_TYPE_MAPPED))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesEmmScType()[index];
}

enum TypeOfTaiList : uint8_t {
  TypeOfTaiList_TRACKING_AREA_IDENTITY_LIST_ONE_PLMN_NON_CONSECUTIVE_TACS = 0,
  TypeOfTaiList_TRACKING_AREA_IDENTITY_LIST_ONE_PLMN_CONSECUTIVE_TAC      = 1,
  TypeOfTaiList_TRACKING_AREA_IDENTITY_LIST_MANY_PLMNS                    = 2,
  TypeOfTaiList_MIN =
      TypeOfTaiList_TRACKING_AREA_IDENTITY_LIST_ONE_PLMN_NON_CONSECUTIVE_TACS,
  TypeOfTaiList_MAX = TypeOfTaiList_TRACKING_AREA_IDENTITY_LIST_MANY_PLMNS
};

inline const TypeOfTaiList (&EnumValuesTypeOfTaiList())[3] {
  static const TypeOfTaiList values[] = {
      TypeOfTaiList_TRACKING_AREA_IDENTITY_LIST_ONE_PLMN_NON_CONSECUTIVE_TACS,
      TypeOfTaiList_TRACKING_AREA_IDENTITY_LIST_ONE_PLMN_CONSECUTIVE_TAC,
      TypeOfTaiList_TRACKING_AREA_IDENTITY_LIST_MANY_PLMNS};
  return values;
}

inline const char* const* EnumNamesTypeOfTaiList() {
  static const char* const names[4] = {
      "TRACKING_AREA_IDENTITY_LIST_ONE_PLMN_NON_CONSECUTIVE_TACS",
      "TRACKING_AREA_IDENTITY_LIST_ONE_PLMN_CONSECUTIVE_TAC",
      "TRACKING_AREA_IDENTITY_LIST_MANY_PLMNS", nullptr};
  return names;
}

inline const char* EnumNameTypeOfTaiList(TypeOfTaiList e) {
  if (flatbuffers::IsOutRange(
          e,
          TypeOfTaiList_TRACKING_AREA_IDENTITY_LIST_ONE_PLMN_NON_CONSECUTIVE_TACS,
          TypeOfTaiList_TRACKING_AREA_IDENTITY_LIST_MANY_PLMNS))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTypeOfTaiList()[index];
}

enum NetworkAccessMode : uint8_t {
  NetworkAccessMode_NAM_PACKET_AND_CIRCUIT = 0,
  NetworkAccessMode_NAM_RESERVED           = 1,
  NetworkAccessMode_NAM_ONLY_PACKET        = 2,
  NetworkAccessMode_NAM_MAX                = 3,
  NetworkAccessMode_MIN = NetworkAccessMode_NAM_PACKET_AND_CIRCUIT,
  NetworkAccessMode_MAX = NetworkAccessMode_NAM_MAX
};

inline const NetworkAccessMode (&EnumValuesNetworkAccessMode())[4] {
  static const NetworkAccessMode values[] = {
      NetworkAccessMode_NAM_PACKET_AND_CIRCUIT, NetworkAccessMode_NAM_RESERVED,
      NetworkAccessMode_NAM_ONLY_PACKET, NetworkAccessMode_NAM_MAX};
  return values;
}

inline const char* const* EnumNamesNetworkAccessMode() {
  static const char* const names[5] = {"NAM_PACKET_AND_CIRCUIT", "NAM_RESERVED",
                                       "NAM_ONLY_PACKET", "NAM_MAX", nullptr};
  return names;
}

inline const char* EnumNameNetworkAccessMode(NetworkAccessMode e) {
  if (flatbuffers::IsOutRange(
          e, NetworkAccessMode_NAM_PACKET_AND_CIRCUIT,
          NetworkAccessMode_NAM_MAX))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesNetworkAccessMode()[index];
}

enum EsmEbrState : uint8_t {
  EsmEbrState_ESM_EBR_INACTIVE         = 0,
  EsmEbrState_ESM_EBR_ACTIVE           = 1,
  EsmEbrState_ESM_EBR_INACTIVE_PENDING = 2,
  EsmEbrState_ESM_EBR_MODIFY_PENDING   = 3,
  EsmEbrState_ESM_EBR_ACTIVE_PENDING   = 4,
  EsmEbrState_ESM_EBR_STATE_MAX        = 5,
  EsmEbrState_MIN                      = EsmEbrState_ESM_EBR_INACTIVE,
  EsmEbrState_MAX                      = EsmEbrState_ESM_EBR_STATE_MAX
};

inline const EsmEbrState (&EnumValuesEsmEbrState())[6] {
  static const EsmEbrState values[] = {
      EsmEbrState_ESM_EBR_INACTIVE,         EsmEbrState_ESM_EBR_ACTIVE,
      EsmEbrState_ESM_EBR_INACTIVE_PENDING, EsmEbrState_ESM_EBR_MODIFY_PENDING,
      EsmEbrState_ESM_EBR_ACTIVE_PENDING,   EsmEbrState_ESM_EBR_STATE_MAX};
  return values;
}

inline const char* const* EnumNamesEsmEbrState() {
  static const char* const names[7] = {"ESM_EBR_INACTIVE",
                                       "ESM_EBR_ACTIVE",
                                       "ESM_EBR_INACTIVE_PENDING",
                                       "ESM_EBR_MODIFY_PENDING",
                                       "ESM_EBR_ACTIVE_PENDING",
                                       "ESM_EBR_STATE_MAX",
                                       nullptr};
  return names;
}

inline const char* EnumNameEsmEbrState(EsmEbrState e) {
  if (flatbuffers::IsOutRange(
          e, EsmEbrState_ESM_EBR_INACTIVE, EsmEbrState_ESM_EBR_STATE_MAX))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesEsmEbrState()[index];
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(2) Tai FLATBUFFERS_FINAL_CLASS {
 private:
  magma::lte::test_flat_buffer::Plmn plmn_;
  uint16_t tac_;

 public:
  Tai() : plmn_(), tac_(0) {}
  Tai(const magma::lte::test_flat_buffer::Plmn& _plmn, uint16_t _tac)
      : plmn_(_plmn), tac_(flatbuffers::EndianScalar(_tac)) {}
  const magma::lte::test_flat_buffer::Plmn& plmn() const { return plmn_; }
  magma::lte::test_flat_buffer::Plmn& mutable_plmn() { return plmn_; }
  uint16_t tac() const { return flatbuffers::EndianScalar(tac_); }
  void mutate_tac(uint16_t _tac) { flatbuffers::WriteScalar(&tac_, _tac); }
};
FLATBUFFERS_STRUCT_END(Tai, 8);

inline bool operator==(const Tai& lhs, const Tai& rhs) {
  return (lhs.plmn() == rhs.plmn()) && (lhs.tac() == rhs.tac());
}

inline bool operator!=(const Tai& lhs, const Tai& rhs) {
  return !(lhs == rhs);
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(2) Lai FLATBUFFERS_FINAL_CLASS {
 private:
  magma::lte::test_flat_buffer::Plmn plmn_;
  uint16_t lac_;

 public:
  Lai() : plmn_(), lac_(0) {}
  Lai(const magma::lte::test_flat_buffer::Plmn& _plmn, uint16_t _lac)
      : plmn_(_plmn), lac_(flatbuffers::EndianScalar(_lac)) {}
  const magma::lte::test_flat_buffer::Plmn& plmn() const { return plmn_; }
  magma::lte::test_flat_buffer::Plmn& mutable_plmn() { return plmn_; }
  uint16_t lac() const { return flatbuffers::EndianScalar(lac_); }
  void mutate_lac(uint16_t _lac) { flatbuffers::WriteScalar(&lac_, _lac); }
};
FLATBUFFERS_STRUCT_END(Lai, 8);

inline bool operator==(const Lai& lhs, const Lai& rhs) {
  return (lhs.plmn() == rhs.plmn()) && (lhs.lac() == rhs.lac());
}

inline bool operator!=(const Lai& lhs, const Lai& rhs) {
  return !(lhs == rhs);
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) EsmPdn FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t pti_;
  uint8_t is_emergency_;
  int16_t padding0__;
  uint32_t ambr_;
  int32_t addr_realloc_;
  uint8_t n_bearers_;
  uint8_t pt_state_;
  int16_t padding1__;
  int32_t esm_cause_;

 public:
  EsmPdn()
      : pti_(0),
        is_emergency_(0),
        padding0__(0),
        ambr_(0),
        addr_realloc_(0),
        n_bearers_(0),
        pt_state_(0),
        padding1__(0),
        esm_cause_(0) {
    (void) padding0__;
    (void) padding1__;
  }
  EsmPdn(
      uint8_t _pti, bool _is_emergency, uint32_t _ambr, int32_t _addr_realloc,
      uint8_t _n_bearers, magma::lte::test_flat_buffer::EsmPtState _pt_state,
      int32_t _esm_cause)
      : pti_(flatbuffers::EndianScalar(_pti)),
        is_emergency_(
            flatbuffers::EndianScalar(static_cast<uint8_t>(_is_emergency))),
        padding0__(0),
        ambr_(flatbuffers::EndianScalar(_ambr)),
        addr_realloc_(flatbuffers::EndianScalar(_addr_realloc)),
        n_bearers_(flatbuffers::EndianScalar(_n_bearers)),
        pt_state_(flatbuffers::EndianScalar(static_cast<uint8_t>(_pt_state))),
        padding1__(0),
        esm_cause_(flatbuffers::EndianScalar(_esm_cause)) {
    (void) padding0__;
    (void) padding1__;
  }
  uint8_t pti() const { return flatbuffers::EndianScalar(pti_); }
  void mutate_pti(uint8_t _pti) { flatbuffers::WriteScalar(&pti_, _pti); }
  bool is_emergency() const {
    return flatbuffers::EndianScalar(is_emergency_) != 0;
  }
  void mutate_is_emergency(bool _is_emergency) {
    flatbuffers::WriteScalar(
        &is_emergency_, static_cast<uint8_t>(_is_emergency));
  }
  uint32_t ambr() const { return flatbuffers::EndianScalar(ambr_); }
  void mutate_ambr(uint32_t _ambr) { flatbuffers::WriteScalar(&ambr_, _ambr); }
  int32_t addr_realloc() const {
    return flatbuffers::EndianScalar(addr_realloc_);
  }
  void mutate_addr_realloc(int32_t _addr_realloc) {
    flatbuffers::WriteScalar(&addr_realloc_, _addr_realloc);
  }
  uint8_t n_bearers() const { return flatbuffers::EndianScalar(n_bearers_); }
  void mutate_n_bearers(uint8_t _n_bearers) {
    flatbuffers::WriteScalar(&n_bearers_, _n_bearers);
  }
  magma::lte::test_flat_buffer::EsmPtState pt_state() const {
    return static_cast<magma::lte::test_flat_buffer::EsmPtState>(
        flatbuffers::EndianScalar(pt_state_));
  }
  void mutate_pt_state(magma::lte::test_flat_buffer::EsmPtState _pt_state) {
    flatbuffers::WriteScalar(&pt_state_, static_cast<uint8_t>(_pt_state));
  }
  int32_t esm_cause() const { return flatbuffers::EndianScalar(esm_cause_); }
  void mutate_esm_cause(int32_t _esm_cause) {
    flatbuffers::WriteScalar(&esm_cause_, _esm_cause);
  }
};
FLATBUFFERS_STRUCT_END(EsmPdn, 20);

inline bool operator==(const EsmPdn& lhs, const EsmPdn& rhs) {
  return (lhs.pti() == rhs.pti()) &&
         (lhs.is_emergency() == rhs.is_emergency()) &&
         (lhs.ambr() == rhs.ambr()) &&
         (lhs.addr_realloc() == rhs.addr_realloc()) &&
         (lhs.n_bearers() == rhs.n_bearers()) &&
         (lhs.pt_state() == rhs.pt_state()) &&
         (lhs.esm_cause() == rhs.esm_cause());
}

inline bool operator!=(const EsmPdn& lhs, const EsmPdn& rhs) {
  return !(lhs == rhs);
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) PdnContext FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t context_identifier_;
  magma::lte::test_flat_buffer::Apn apn_in_use_;
  magma::lte::test_flat_buffer::Apn apn_subscribed_;
  uint8_t pdn_type_;
  int8_t padding0__;
  magma::lte::test_flat_buffer::Paa paa_;
  magma::lte::test_flat_buffer::ApnOi apn_oi_replacement_;
  int8_t padding1__;
  int16_t padding2__;
  magma::lte::test_flat_buffer::IpAddress p_gw_address_s5_s8_cp_;
  uint32_t p_gw_teid_s5_s8_cp_;
  magma::lte::test_flat_buffer::EpsSubscribedQosProfile
      default_bearer_eps_subscribed_qos_profile_;
  magma::lte::test_flat_buffer::Ambr subscribed_apn_ambr_;
  magma::lte::test_flat_buffer::Ambr p_gw_apn_ambr_;
  uint8_t default_ebi_;
  uint8_t bearer_contexts_[11];
  uint8_t num_bearer_contexts_;
  int8_t padding3__;
  int16_t padding4__;
  magma::lte::test_flat_buffer::IpAddress s_gw_address_s11_s4_;
  uint32_t s_gw_teid_s11_s4_;
  magma::lte::test_flat_buffer::EsmPdn esm_data_;
  uint8_t is_active_;
  int8_t padding5__;
  magma::lte::test_flat_buffer::ProtocolConfigurationOptions pco_;
  uint8_t ue_rej_act_def_ber_req_;
  uint8_t route_s11_messages_to_s8_task_;

 public:
  PdnContext()
      : context_identifier_(0),
        apn_in_use_(),
        apn_subscribed_(),
        pdn_type_(0),
        padding0__(0),
        paa_(),
        apn_oi_replacement_(),
        padding1__(0),
        padding2__(0),
        p_gw_address_s5_s8_cp_(),
        p_gw_teid_s5_s8_cp_(0),
        default_bearer_eps_subscribed_qos_profile_(),
        subscribed_apn_ambr_(),
        p_gw_apn_ambr_(),
        default_ebi_(0),
        bearer_contexts_(),
        num_bearer_contexts_(0),
        padding3__(0),
        padding4__(0),
        s_gw_address_s11_s4_(),
        s_gw_teid_s11_s4_(0),
        esm_data_(),
        is_active_(0),
        padding5__(0),
        pco_(),
        ue_rej_act_def_ber_req_(0),
        route_s11_messages_to_s8_task_(0) {
    (void) padding0__;
    (void) padding1__;
    (void) padding2__;
    (void) padding3__;
    (void) padding4__;
    (void) padding5__;
  }
  PdnContext(
      uint32_t _context_identifier,
      const magma::lte::test_flat_buffer::Apn& _apn_in_use,
      const magma::lte::test_flat_buffer::Apn& _apn_subscribed,
      magma::lte::test_flat_buffer::PdnTypeValue _pdn_type,
      const magma::lte::test_flat_buffer::Paa& _paa,
      const magma::lte::test_flat_buffer::ApnOi& _apn_oi_replacement,
      const magma::lte::test_flat_buffer::IpAddress& _p_gw_address_s5_s8_cp,
      uint32_t _p_gw_teid_s5_s8_cp,
      const magma::lte::test_flat_buffer::EpsSubscribedQosProfile&
          _default_bearer_eps_subscribed_qos_profile,
      const magma::lte::test_flat_buffer::Ambr& _subscribed_apn_ambr,
      const magma::lte::test_flat_buffer::Ambr& _p_gw_apn_ambr,
      uint8_t _default_ebi, uint8_t _num_bearer_contexts,
      const magma::lte::test_flat_buffer::IpAddress& _s_gw_address_s11_s4,
      uint32_t _s_gw_teid_s11_s4,
      const magma::lte::test_flat_buffer::EsmPdn& _esm_data, bool _is_active,
      const magma::lte::test_flat_buffer::ProtocolConfigurationOptions& _pco,
      bool _ue_rej_act_def_ber_req, bool _route_s11_messages_to_s8_task)
      : context_identifier_(flatbuffers::EndianScalar(_context_identifier)),
        apn_in_use_(_apn_in_use),
        apn_subscribed_(_apn_subscribed),
        pdn_type_(flatbuffers::EndianScalar(static_cast<uint8_t>(_pdn_type))),
        padding0__(0),
        paa_(_paa),
        apn_oi_replacement_(_apn_oi_replacement),
        padding1__(0),
        padding2__(0),
        p_gw_address_s5_s8_cp_(_p_gw_address_s5_s8_cp),
        p_gw_teid_s5_s8_cp_(flatbuffers::EndianScalar(_p_gw_teid_s5_s8_cp)),
        default_bearer_eps_subscribed_qos_profile_(
            _default_bearer_eps_subscribed_qos_profile),
        subscribed_apn_ambr_(_subscribed_apn_ambr),
        p_gw_apn_ambr_(_p_gw_apn_ambr),
        default_ebi_(flatbuffers::EndianScalar(_default_ebi)),
        bearer_contexts_(),
        num_bearer_contexts_(flatbuffers::EndianScalar(_num_bearer_contexts)),
        padding3__(0),
        padding4__(0),
        s_gw_address_s11_s4_(_s_gw_address_s11_s4),
        s_gw_teid_s11_s4_(flatbuffers::EndianScalar(_s_gw_teid_s11_s4)),
        esm_data_(_esm_data),
        is_active_(flatbuffers::EndianScalar(static_cast<uint8_t>(_is_active))),
        padding5__(0),
        pco_(_pco),
        ue_rej_act_def_ber_req_(flatbuffers::EndianScalar(
            static_cast<uint8_t>(_ue_rej_act_def_ber_req))),
        route_s11_messages_to_s8_task_(flatbuffers::EndianScalar(
            static_cast<uint8_t>(_route_s11_messages_to_s8_task))) {
    (void) padding0__;
    (void) padding1__;
    (void) padding2__;
    (void) padding3__;
    (void) padding4__;
    (void) padding5__;
  }
  PdnContext(
      uint32_t _context_identifier,
      const magma::lte::test_flat_buffer::Apn& _apn_in_use,
      const magma::lte::test_flat_buffer::Apn& _apn_subscribed,
      magma::lte::test_flat_buffer::PdnTypeValue _pdn_type,
      const magma::lte::test_flat_buffer::Paa& _paa,
      const magma::lte::test_flat_buffer::ApnOi& _apn_oi_replacement,
      const magma::lte::test_flat_buffer::IpAddress& _p_gw_address_s5_s8_cp,
      uint32_t _p_gw_teid_s5_s8_cp,
      const magma::lte::test_flat_buffer::EpsSubscribedQosProfile&
          _default_bearer_eps_subscribed_qos_profile,
      const magma::lte::test_flat_buffer::Ambr& _subscribed_apn_ambr,
      const magma::lte::test_flat_buffer::Ambr& _p_gw_apn_ambr,
      uint8_t _default_ebi,
      flatbuffers::span<const uint8_t, 11> _bearer_contexts,
      uint8_t _num_bearer_contexts,
      const magma::lte::test_flat_buffer::IpAddress& _s_gw_address_s11_s4,
      uint32_t _s_gw_teid_s11_s4,
      const magma::lte::test_flat_buffer::EsmPdn& _esm_data, bool _is_active,
      const magma::lte::test_flat_buffer::ProtocolConfigurationOptions& _pco,
      bool _ue_rej_act_def_ber_req, bool _route_s11_messages_to_s8_task)
      : context_identifier_(flatbuffers::EndianScalar(_context_identifier)),
        apn_in_use_(_apn_in_use),
        apn_subscribed_(_apn_subscribed),
        pdn_type_(flatbuffers::EndianScalar(static_cast<uint8_t>(_pdn_type))),
        padding0__(0),
        paa_(_paa),
        apn_oi_replacement_(_apn_oi_replacement),
        padding1__(0),
        padding2__(0),
        p_gw_address_s5_s8_cp_(_p_gw_address_s5_s8_cp),
        p_gw_teid_s5_s8_cp_(flatbuffers::EndianScalar(_p_gw_teid_s5_s8_cp)),
        default_bearer_eps_subscribed_qos_profile_(
            _default_bearer_eps_subscribed_qos_profile),
        subscribed_apn_ambr_(_subscribed_apn_ambr),
        p_gw_apn_ambr_(_p_gw_apn_ambr),
        default_ebi_(flatbuffers::EndianScalar(_default_ebi)),
        num_bearer_contexts_(flatbuffers::EndianScalar(_num_bearer_contexts)),
        padding3__(0),
        padding4__(0),
        s_gw_address_s11_s4_(_s_gw_address_s11_s4),
        s_gw_teid_s11_s4_(flatbuffers::EndianScalar(_s_gw_teid_s11_s4)),
        esm_data_(_esm_data),
        is_active_(flatbuffers::EndianScalar(static_cast<uint8_t>(_is_active))),
        padding5__(0),
        pco_(_pco),
        ue_rej_act_def_ber_req_(flatbuffers::EndianScalar(
            static_cast<uint8_t>(_ue_rej_act_def_ber_req))),
        route_s11_messages_to_s8_task_(flatbuffers::EndianScalar(
            static_cast<uint8_t>(_route_s11_messages_to_s8_task))) {
    (void) padding0__;
    (void) padding1__;
    (void) padding2__;
    flatbuffers::CastToArray(bearer_contexts_).CopyFromSpan(_bearer_contexts);
    (void) padding3__;
    (void) padding4__;
    (void) padding5__;
  }
  uint32_t context_identifier() const {
    return flatbuffers::EndianScalar(context_identifier_);
  }
  void mutate_context_identifier(uint32_t _context_identifier) {
    flatbuffers::WriteScalar(&context_identifier_, _context_identifier);
  }
  const magma::lte::test_flat_buffer::Apn& apn_in_use() const {
    return apn_in_use_;
  }
  magma::lte::test_flat_buffer::Apn& mutable_apn_in_use() {
    return apn_in_use_;
  }
  const magma::lte::test_flat_buffer::Apn& apn_subscribed() const {
    return apn_subscribed_;
  }
  magma::lte::test_flat_buffer::Apn& mutable_apn_subscribed() {
    return apn_subscribed_;
  }
  magma::lte::test_flat_buffer::PdnTypeValue pdn_type() const {
    return static_cast<magma::lte::test_flat_buffer::PdnTypeValue>(
        flatbuffers::EndianScalar(pdn_type_));
  }
  void mutate_pdn_type(magma::lte::test_flat_buffer::PdnTypeValue _pdn_type) {
    flatbuffers::WriteScalar(&pdn_type_, static_cast<uint8_t>(_pdn_type));
  }
  const magma::lte::test_flat_buffer::Paa& paa() const { return paa_; }
  magma::lte::test_flat_buffer::Paa& mutable_paa() { return paa_; }
  const magma::lte::test_flat_buffer::ApnOi& apn_oi_replacement() const {
    return apn_oi_replacement_;
  }
  magma::lte::test_flat_buffer::ApnOi& mutable_apn_oi_replacement() {
    return apn_oi_replacement_;
  }
  const magma::lte::test_flat_buffer::IpAddress& p_gw_address_s5_s8_cp() const {
    return p_gw_address_s5_s8_cp_;
  }
  magma::lte::test_flat_buffer::IpAddress& mutable_p_gw_address_s5_s8_cp() {
    return p_gw_address_s5_s8_cp_;
  }
  uint32_t p_gw_teid_s5_s8_cp() const {
    return flatbuffers::EndianScalar(p_gw_teid_s5_s8_cp_);
  }
  void mutate_p_gw_teid_s5_s8_cp(uint32_t _p_gw_teid_s5_s8_cp) {
    flatbuffers::WriteScalar(&p_gw_teid_s5_s8_cp_, _p_gw_teid_s5_s8_cp);
  }
  const magma::lte::test_flat_buffer::EpsSubscribedQosProfile&
  default_bearer_eps_subscribed_qos_profile() const {
    return default_bearer_eps_subscribed_qos_profile_;
  }
  magma::lte::test_flat_buffer::EpsSubscribedQosProfile&
  mutable_default_bearer_eps_subscribed_qos_profile() {
    return default_bearer_eps_subscribed_qos_profile_;
  }
  const magma::lte::test_flat_buffer::Ambr& subscribed_apn_ambr() const {
    return subscribed_apn_ambr_;
  }
  magma::lte::test_flat_buffer::Ambr& mutable_subscribed_apn_ambr() {
    return subscribed_apn_ambr_;
  }
  const magma::lte::test_flat_buffer::Ambr& p_gw_apn_ambr() const {
    return p_gw_apn_ambr_;
  }
  magma::lte::test_flat_buffer::Ambr& mutable_p_gw_apn_ambr() {
    return p_gw_apn_ambr_;
  }
  uint8_t default_ebi() const {
    return flatbuffers::EndianScalar(default_ebi_);
  }
  void mutate_default_ebi(uint8_t _default_ebi) {
    flatbuffers::WriteScalar(&default_ebi_, _default_ebi);
  }
  /// BEARERS_PER_UE = 11
  const flatbuffers::Array<uint8_t, 11>* bearer_contexts() const {
    return &flatbuffers::CastToArray(bearer_contexts_);
  }
  flatbuffers::Array<uint8_t, 11>* mutable_bearer_contexts() {
    return &flatbuffers::CastToArray(bearer_contexts_);
  }
  uint8_t num_bearer_contexts() const {
    return flatbuffers::EndianScalar(num_bearer_contexts_);
  }
  void mutate_num_bearer_contexts(uint8_t _num_bearer_contexts) {
    flatbuffers::WriteScalar(&num_bearer_contexts_, _num_bearer_contexts);
  }
  const magma::lte::test_flat_buffer::IpAddress& s_gw_address_s11_s4() const {
    return s_gw_address_s11_s4_;
  }
  magma::lte::test_flat_buffer::IpAddress& mutable_s_gw_address_s11_s4() {
    return s_gw_address_s11_s4_;
  }
  uint32_t s_gw_teid_s11_s4() const {
    return flatbuffers::EndianScalar(s_gw_teid_s11_s4_);
  }
  void mutate_s_gw_teid_s11_s4(uint32_t _s_gw_teid_s11_s4) {
    flatbuffers::WriteScalar(&s_gw_teid_s11_s4_, _s_gw_teid_s11_s4);
  }
  const magma::lte::test_flat_buffer::EsmPdn& esm_data() const {
    return esm_data_;
  }
  magma::lte::test_flat_buffer::EsmPdn& mutable_esm_data() { return esm_data_; }
  bool is_active() const { return flatbuffers::EndianScalar(is_active_) != 0; }
  void mutate_is_active(bool _is_active) {
    flatbuffers::WriteScalar(&is_active_, static_cast<uint8_t>(_is_active));
  }
  const magma::lte::test_flat_buffer::ProtocolConfigurationOptions& pco()
      const {
    return pco_;
  }
  magma::lte::test_flat_buffer::ProtocolConfigurationOptions& mutable_pco() {
    return pco_;
  }
  bool ue_rej_act_def_ber_req() const {
    return flatbuffers::EndianScalar(ue_rej_act_def_ber_req_) != 0;
  }
  void mutate_ue_rej_act_def_ber_req(bool _ue_rej_act_def_ber_req) {
    flatbuffers::WriteScalar(
        &ue_rej_act_def_ber_req_,
        static_cast<uint8_t>(_ue_rej_act_def_ber_req));
  }
  bool route_s11_messages_to_s8_task() const {
    return flatbuffers::EndianScalar(route_s11_messages_to_s8_task_) != 0;
  }
  void mutate_route_s11_messages_to_s8_task(
      bool _route_s11_messages_to_s8_task) {
    flatbuffers::WriteScalar(
        &route_s11_messages_to_s8_task_,
        static_cast<uint8_t>(_route_s11_messages_to_s8_task));
  }
};
FLATBUFFERS_STRUCT_END(PdnContext, 2536);

inline bool operator==(const PdnContext& lhs, const PdnContext& rhs) {
  return (lhs.context_identifier() == rhs.context_identifier()) &&
         (lhs.apn_in_use() == rhs.apn_in_use()) &&
         (lhs.apn_subscribed() == rhs.apn_subscribed()) &&
         (lhs.pdn_type() == rhs.pdn_type()) && (lhs.paa() == rhs.paa()) &&
         (lhs.apn_oi_replacement() == rhs.apn_oi_replacement()) &&
         (lhs.p_gw_address_s5_s8_cp() == rhs.p_gw_address_s5_s8_cp()) &&
         (lhs.p_gw_teid_s5_s8_cp() == rhs.p_gw_teid_s5_s8_cp()) &&
         (lhs.default_bearer_eps_subscribed_qos_profile() ==
          rhs.default_bearer_eps_subscribed_qos_profile()) &&
         (lhs.subscribed_apn_ambr() == rhs.subscribed_apn_ambr()) &&
         (lhs.p_gw_apn_ambr() == rhs.p_gw_apn_ambr()) &&
         (lhs.default_ebi() == rhs.default_ebi()) &&
         (lhs.bearer_contexts() == rhs.bearer_contexts()) &&
         (lhs.num_bearer_contexts() == rhs.num_bearer_contexts()) &&
         (lhs.s_gw_address_s11_s4() == rhs.s_gw_address_s11_s4()) &&
         (lhs.s_gw_teid_s11_s4() == rhs.s_gw_teid_s11_s4()) &&
         (lhs.esm_data() == rhs.esm_data()) &&
         (lhs.is_active() == rhs.is_active()) && (lhs.pco() == rhs.pco()) &&
         (lhs.ue_rej_act_def_ber_req() == rhs.ue_rej_act_def_ber_req()) &&
         (lhs.route_s11_messages_to_s8_task() ==
          rhs.route_s11_messages_to_s8_task());
}

inline bool operator!=(const PdnContext& lhs, const PdnContext& rhs) {
  return !(lhs == rhs);
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) NasProcMessSign FLATBUFFERS_FINAL_CLASS {
 private:
  uint64_t puid_;
  uint8_t digest_[16];
  uint32_t digest_length_;
  uint16_t nas_msg_length_;
  int16_t padding0__;

 public:
  NasProcMessSign()
      : puid_(0),
        digest_(),
        digest_length_(0),
        nas_msg_length_(0),
        padding0__(0) {
    (void) padding0__;
  }
  NasProcMessSign(
      uint64_t _puid, uint32_t _digest_length, uint16_t _nas_msg_length)
      : puid_(flatbuffers::EndianScalar(_puid)),
        digest_(),
        digest_length_(flatbuffers::EndianScalar(_digest_length)),
        nas_msg_length_(flatbuffers::EndianScalar(_nas_msg_length)),
        padding0__(0) {
    (void) padding0__;
  }
  NasProcMessSign(
      uint64_t _puid, flatbuffers::span<const uint8_t, 16> _digest,
      uint32_t _digest_length, uint16_t _nas_msg_length)
      : puid_(flatbuffers::EndianScalar(_puid)),
        digest_length_(flatbuffers::EndianScalar(_digest_length)),
        nas_msg_length_(flatbuffers::EndianScalar(_nas_msg_length)),
        padding0__(0) {
    flatbuffers::CastToArray(digest_).CopyFromSpan(_digest);
    (void) padding0__;
  }
  uint64_t puid() const { return flatbuffers::EndianScalar(puid_); }
  void mutate_puid(uint64_t _puid) { flatbuffers::WriteScalar(&puid_, _puid); }
  const flatbuffers::Array<uint8_t, 16>* digest() const {
    return &flatbuffers::CastToArray(digest_);
  }
  flatbuffers::Array<uint8_t, 16>* mutable_digest() {
    return &flatbuffers::CastToArray(digest_);
  }
  uint32_t digest_length() const {
    return flatbuffers::EndianScalar(digest_length_);
  }
  void mutate_digest_length(uint32_t _digest_length) {
    flatbuffers::WriteScalar(&digest_length_, _digest_length);
  }
  uint16_t nas_msg_length() const {
    return flatbuffers::EndianScalar(nas_msg_length_);
  }
  void mutate_nas_msg_length(uint16_t _nas_msg_length) {
    flatbuffers::WriteScalar(&nas_msg_length_, _nas_msg_length);
  }
};
FLATBUFFERS_STRUCT_END(NasProcMessSign, 32);

inline bool operator==(const NasProcMessSign& lhs, const NasProcMessSign& rhs) {
  return (lhs.puid() == rhs.puid()) && (lhs.digest() == rhs.digest()) &&
         (lhs.digest_length() == rhs.digest_length()) &&
         (lhs.nas_msg_length() == rhs.nas_msg_length());
}

inline bool operator!=(const NasProcMessSign& lhs, const NasProcMessSign& rhs) {
  return !(lhs == rhs);
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) NasTimer FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t id_;
  uint32_t msec_;

 public:
  NasTimer() : id_(0), msec_(0) {}
  NasTimer(uint32_t _id, uint32_t _msec)
      : id_(flatbuffers::EndianScalar(_id)),
        msec_(flatbuffers::EndianScalar(_msec)) {}
  uint32_t id() const { return flatbuffers::EndianScalar(id_); }
  void mutate_id(uint32_t _id) { flatbuffers::WriteScalar(&id_, _id); }
  uint32_t msec() const { return flatbuffers::EndianScalar(msec_); }
  void mutate_msec(uint32_t _msec) { flatbuffers::WriteScalar(&msec_, _msec); }
};
FLATBUFFERS_STRUCT_END(NasTimer, 8);

inline bool operator==(const NasTimer& lhs, const NasTimer& rhs) {
  return (lhs.id() == rhs.id()) && (lhs.msec() == rhs.msec());
}

inline bool operator!=(const NasTimer& lhs, const NasTimer& rhs) {
  return !(lhs == rhs);
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(1) PdnAddr FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t bytes_[16];
  uint8_t length_;

 public:
  PdnAddr() : bytes_(), length_(0) {}
  PdnAddr(uint8_t _length)
      : bytes_(), length_(flatbuffers::EndianScalar(_length)) {}
  PdnAddr(flatbuffers::span<const uint8_t, 16> _bytes, uint8_t _length)
      : length_(flatbuffers::EndianScalar(_length)) {
    flatbuffers::CastToArray(bytes_).CopyFromSpan(_bytes);
  }
  const flatbuffers::Array<uint8_t, 16>* bytes() const {
    return &flatbuffers::CastToArray(bytes_);
  }
  flatbuffers::Array<uint8_t, 16>* mutable_bytes() {
    return &flatbuffers::CastToArray(bytes_);
  }
  uint8_t length() const { return flatbuffers::EndianScalar(length_); }
  void mutate_length(uint8_t _length) {
    flatbuffers::WriteScalar(&length_, _length);
  }
};
FLATBUFFERS_STRUCT_END(PdnAddr, 17);

inline bool operator==(const PdnAddr& lhs, const PdnAddr& rhs) {
  return (lhs.bytes() == rhs.bytes()) && (lhs.length() == rhs.length());
}

inline bool operator!=(const PdnAddr& lhs, const PdnAddr& rhs) {
  return !(lhs == rhs);
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) EsmProcData FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t pti_;
  uint8_t request_type_;
  magma::lte::test_flat_buffer::Apn apn_;
  int8_t padding0__;
  int32_t pdn_cid_;
  uint8_t pdn_type_;
  magma::lte::test_flat_buffer::PdnAddr pdn_addr_;
  int16_t padding1__;
  magma::lte::test_flat_buffer::BearerQos bearer_qos_;
  magma::lte::test_flat_buffer::ProtocolConfigurationOptions pco_;
  int32_t padding2__;

 public:
  EsmProcData()
      : pti_(0),
        request_type_(0),
        apn_(),
        padding0__(0),
        pdn_cid_(0),
        pdn_type_(0),
        pdn_addr_(),
        padding1__(0),
        bearer_qos_(),
        pco_(),
        padding2__(0) {
    (void) padding0__;
    (void) padding1__;
    (void) padding2__;
  }
  EsmProcData(
      uint8_t _pti, uint8_t _request_type,
      const magma::lte::test_flat_buffer::Apn& _apn, int32_t _pdn_cid,
      magma::lte::test_flat_buffer::PdnTypeValue _pdn_type,
      const magma::lte::test_flat_buffer::PdnAddr& _pdn_addr,
      const magma::lte::test_flat_buffer::BearerQos& _bearer_qos,
      const magma::lte::test_flat_buffer::ProtocolConfigurationOptions& _pco)
      : pti_(flatbuffers::EndianScalar(_pti)),
        request_type_(flatbuffers::EndianScalar(_request_type)),
        apn_(_apn),
        padding0__(0),
        pdn_cid_(flatbuffers::EndianScalar(_pdn_cid)),
        pdn_type_(flatbuffers::EndianScalar(static_cast<uint8_t>(_pdn_type))),
        pdn_addr_(_pdn_addr),
        padding1__(0),
        bearer_qos_(_bearer_qos),
        pco_(_pco),
        padding2__(0) {
    (void) padding0__;
    (void) padding1__;
    (void) padding2__;
  }
  uint8_t pti() const { return flatbuffers::EndianScalar(pti_); }
  void mutate_pti(uint8_t _pti) { flatbuffers::WriteScalar(&pti_, _pti); }
  uint8_t request_type() const {
    return flatbuffers::EndianScalar(request_type_);
  }
  void mutate_request_type(uint8_t _request_type) {
    flatbuffers::WriteScalar(&request_type_, _request_type);
  }
  const magma::lte::test_flat_buffer::Apn& apn() const { return apn_; }
  magma::lte::test_flat_buffer::Apn& mutable_apn() { return apn_; }
  int32_t pdn_cid() const { return flatbuffers::EndianScalar(pdn_cid_); }
  void mutate_pdn_cid(int32_t _pdn_cid) {
    flatbuffers::WriteScalar(&pdn_cid_, _pdn_cid);
  }
  magma::lte::test_flat_buffer::PdnTypeValue pdn_type() const {
    return static_cast<magma::lte::test_flat_buffer::PdnTypeValue>(
        flatbuffers::EndianScalar(pdn_type_));
  }
  void mutate_pdn_type(magma::lte::test_flat_buffer::PdnTypeValue _pdn_type) {
    flatbuffers::WriteScalar(&pdn_type_, static_cast<uint8_t>(_pdn_type));
  }
  const magma::lte::test_flat_buffer::PdnAddr& pdn_addr() const {
    return pdn_addr_;
  }
  magma::lte::test_flat_buffer::PdnAddr& mutable_pdn_addr() {
    return pdn_addr_;
  }
  const magma::lte::test_flat_buffer::BearerQos& bearer_qos() const {
    return bearer_qos_;
  }
  magma::lte::test_flat_buffer::BearerQos& mutable_bearer_qos() {
    return bearer_qos_;
  }
  const magma::lte::test_flat_buffer::ProtocolConfigurationOptions& pco()
      const {
    return pco_;
  }
  magma::lte::test_flat_buffer::ProtocolConfigurationOptions& mutable_pco() {
    return pco_;
  }
};
FLATBUFFERS_STRUCT_END(EsmProcData, 2232);

inline bool operator==(const EsmProcData& lhs, const EsmProcData& rhs) {
  return (lhs.pti() == rhs.pti()) &&
         (lhs.request_type() == rhs.request_type()) &&
         (lhs.apn() == rhs.apn()) && (lhs.pdn_cid() == rhs.pdn_cid()) &&
         (lhs.pdn_type() == rhs.pdn_type()) &&
         (lhs.pdn_addr() == rhs.pdn_addr()) &&
         (lhs.bearer_qos() == rhs.bearer_qos()) && (lhs.pco() == rhs.pco());
}

inline bool operator!=(const EsmProcData& lhs, const EsmProcData& rhs) {
  return !(lhs == rhs);
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) EsmContext FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t n_active_ebrs_;
  uint8_t is_emergency_;
  int8_t padding0__;
  int16_t padding1__;
  magma::lte::test_flat_buffer::NasTimer t3489_;
  uint8_t t3489_arg_[32];
  uint8_t t3489_arg_length_;
  int8_t padding2__;
  int16_t padding3__;
  uint32_t pending_standalone_;
  uint8_t is_pdn_disconnect_;
  int8_t padding4__;
  int16_t padding5__;
  int32_t padding6__;
  magma::lte::test_flat_buffer::EsmProcData esm_proc_data_;

 public:
  EsmContext()
      : n_active_ebrs_(0),
        is_emergency_(0),
        padding0__(0),
        padding1__(0),
        t3489_(),
        t3489_arg_(),
        t3489_arg_length_(0),
        padding2__(0),
        padding3__(0),
        pending_standalone_(0),
        is_pdn_disconnect_(0),
        padding4__(0),
        padding5__(0),
        padding6__(0),
        esm_proc_data_() {
    (void) padding0__;
    (void) padding1__;
    (void) padding2__;
    (void) padding3__;
    (void) padding4__;
    (void) padding5__;
    (void) padding6__;
  }
  EsmContext(
      uint32_t _n_active_ebrs, bool _is_emergency,
      const magma::lte::test_flat_buffer::NasTimer& _t3489,
      uint8_t _t3489_arg_length, uint32_t _pending_standalone,
      bool _is_pdn_disconnect,
      const magma::lte::test_flat_buffer::EsmProcData& _esm_proc_data)
      : n_active_ebrs_(flatbuffers::EndianScalar(_n_active_ebrs)),
        is_emergency_(
            flatbuffers::EndianScalar(static_cast<uint8_t>(_is_emergency))),
        padding0__(0),
        padding1__(0),
        t3489_(_t3489),
        t3489_arg_(),
        t3489_arg_length_(flatbuffers::EndianScalar(_t3489_arg_length)),
        padding2__(0),
        padding3__(0),
        pending_standalone_(flatbuffers::EndianScalar(_pending_standalone)),
        is_pdn_disconnect_(flatbuffers::EndianScalar(
            static_cast<uint8_t>(_is_pdn_disconnect))),
        padding4__(0),
        padding5__(0),
        padding6__(0),
        esm_proc_data_(_esm_proc_data) {
    (void) padding0__;
    (void) padding1__;
    (void) padding2__;
    (void) padding3__;
    (void) padding4__;
    (void) padding5__;
    (void) padding6__;
  }
  EsmContext(
      uint32_t _n_active_ebrs, bool _is_emergency,
      const magma::lte::test_flat_buffer::NasTimer& _t3489,
      flatbuffers::span<const uint8_t, 32> _t3489_arg,
      uint8_t _t3489_arg_length, uint32_t _pending_standalone,
      bool _is_pdn_disconnect,
      const magma::lte::test_flat_buffer::EsmProcData& _esm_proc_data)
      : n_active_ebrs_(flatbuffers::EndianScalar(_n_active_ebrs)),
        is_emergency_(
            flatbuffers::EndianScalar(static_cast<uint8_t>(_is_emergency))),
        padding0__(0),
        padding1__(0),
        t3489_(_t3489),
        t3489_arg_length_(flatbuffers::EndianScalar(_t3489_arg_length)),
        padding2__(0),
        padding3__(0),
        pending_standalone_(flatbuffers::EndianScalar(_pending_standalone)),
        is_pdn_disconnect_(flatbuffers::EndianScalar(
            static_cast<uint8_t>(_is_pdn_disconnect))),
        padding4__(0),
        padding5__(0),
        padding6__(0),
        esm_proc_data_(_esm_proc_data) {
    (void) padding0__;
    (void) padding1__;
    flatbuffers::CastToArray(t3489_arg_).CopyFromSpan(_t3489_arg);
    (void) padding2__;
    (void) padding3__;
    (void) padding4__;
    (void) padding5__;
    (void) padding6__;
  }
  uint32_t n_active_ebrs() const {
    return flatbuffers::EndianScalar(n_active_ebrs_);
  }
  void mutate_n_active_ebrs(uint32_t _n_active_ebrs) {
    flatbuffers::WriteScalar(&n_active_ebrs_, _n_active_ebrs);
  }
  bool is_emergency() const {
    return flatbuffers::EndianScalar(is_emergency_) != 0;
  }
  void mutate_is_emergency(bool _is_emergency) {
    flatbuffers::WriteScalar(
        &is_emergency_, static_cast<uint8_t>(_is_emergency));
  }
  const magma::lte::test_flat_buffer::NasTimer& t3489() const { return t3489_; }
  magma::lte::test_flat_buffer::NasTimer& mutable_t3489() { return t3489_; }
  const flatbuffers::Array<uint8_t, 32>* t3489_arg() const {
    return &flatbuffers::CastToArray(t3489_arg_);
  }
  flatbuffers::Array<uint8_t, 32>* mutable_t3489_arg() {
    return &flatbuffers::CastToArray(t3489_arg_);
  }
  uint8_t t3489_arg_length() const {
    return flatbuffers::EndianScalar(t3489_arg_length_);
  }
  void mutate_t3489_arg_length(uint8_t _t3489_arg_length) {
    flatbuffers::WriteScalar(&t3489_arg_length_, _t3489_arg_length);
  }
  uint32_t pending_standalone() const {
    return flatbuffers::EndianScalar(pending_standalone_);
  }
  void mutate_pending_standalone(uint32_t _pending_standalone) {
    flatbuffers::WriteScalar(&pending_standalone_, _pending_standalone);
  }
  bool is_pdn_disconnect() const {
    return flatbuffers::EndianScalar(is_pdn_disconnect_) != 0;
  }
  void mutate_is_pdn_disconnect(bool _is_pdn_disconnect) {
    flatbuffers::WriteScalar(
        &is_pdn_disconnect_, static_cast<uint8_t>(_is_pdn_disconnect));
  }
  const magma::lte::test_flat_buffer::EsmProcData& esm_proc_data() const {
    return esm_proc_data_;
  }
  magma::lte::test_flat_buffer::EsmProcData& mutable_esm_proc_data() {
    return esm_proc_data_;
  }
};
FLATBUFFERS_STRUCT_END(EsmContext, 2296);

inline bool operator==(const EsmContext& lhs, const EsmContext& rhs) {
  return (lhs.n_active_ebrs() == rhs.n_active_ebrs()) &&
         (lhs.is_emergency() == rhs.is_emergency()) &&
         (lhs.t3489() == rhs.t3489()) && (lhs.t3489_arg() == rhs.t3489_arg()) &&
         (lhs.t3489_arg_length() == rhs.t3489_arg_length()) &&
         (lhs.pending_standalone() == rhs.pending_standalone()) &&
         (lhs.is_pdn_disconnect() == rhs.is_pdn_disconnect()) &&
         (lhs.esm_proc_data() == rhs.esm_proc_data());
}

inline bool operator!=(const EsmContext& lhs, const EsmContext& rhs) {
  return !(lhs == rhs);
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(1) AuthVector FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t kasme_[32];
  uint8_t rand_[16];
  uint8_t autn_[16];
  uint8_t xres_size_;
  uint8_t xres_[16];

 public:
  AuthVector() : kasme_(), rand_(), autn_(), xres_size_(0), xres_() {}
  AuthVector(uint8_t _xres_size)
      : kasme_(),
        rand_(),
        autn_(),
        xres_size_(flatbuffers::EndianScalar(_xres_size)),
        xres_() {}
  AuthVector(
      flatbuffers::span<const uint8_t, 32> _kasme,
      flatbuffers::span<const uint8_t, 16> _rand,
      flatbuffers::span<const uint8_t, 16> _autn, uint8_t _xres_size,
      flatbuffers::span<const uint8_t, 16> _xres)
      : xres_size_(flatbuffers::EndianScalar(_xres_size)) {
    flatbuffers::CastToArray(kasme_).CopyFromSpan(_kasme);
    flatbuffers::CastToArray(rand_).CopyFromSpan(_rand);
    flatbuffers::CastToArray(autn_).CopyFromSpan(_autn);
    flatbuffers::CastToArray(xres_).CopyFromSpan(_xres);
  }
  const flatbuffers::Array<uint8_t, 32>* kasme() const {
    return &flatbuffers::CastToArray(kasme_);
  }
  flatbuffers::Array<uint8_t, 32>* mutable_kasme() {
    return &flatbuffers::CastToArray(kasme_);
  }
  const flatbuffers::Array<uint8_t, 16>* rand() const {
    return &flatbuffers::CastToArray(rand_);
  }
  flatbuffers::Array<uint8_t, 16>* mutable_rand() {
    return &flatbuffers::CastToArray(rand_);
  }
  const flatbuffers::Array<uint8_t, 16>* autn() const {
    return &flatbuffers::CastToArray(autn_);
  }
  flatbuffers::Array<uint8_t, 16>* mutable_autn() {
    return &flatbuffers::CastToArray(autn_);
  }
  uint8_t xres_size() const { return flatbuffers::EndianScalar(xres_size_); }
  void mutate_xres_size(uint8_t _xres_size) {
    flatbuffers::WriteScalar(&xres_size_, _xres_size);
  }
  const flatbuffers::Array<uint8_t, 16>* xres() const {
    return &flatbuffers::CastToArray(xres_);
  }
  flatbuffers::Array<uint8_t, 16>* mutable_xres() {
    return &flatbuffers::CastToArray(xres_);
  }
};
FLATBUFFERS_STRUCT_END(AuthVector, 81);

inline bool operator==(const AuthVector& lhs, const AuthVector& rhs) {
  return (lhs.kasme() == rhs.kasme()) && (lhs.rand() == rhs.rand()) &&
         (lhs.autn() == rhs.autn()) && (lhs.xres_size() == rhs.xres_size()) &&
         (lhs.xres() == rhs.xres());
}

inline bool operator!=(const AuthVector& lhs, const AuthVector& rhs) {
  return !(lhs == rhs);
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(2) Count FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t spare_;
  int8_t padding0__;
  uint16_t overflow_;
  uint8_t seq_num_;
  int8_t padding1__;

 public:
  Count() : spare_(0), padding0__(0), overflow_(0), seq_num_(0), padding1__(0) {
    (void) padding0__;
    (void) padding1__;
  }
  Count(uint8_t _spare, uint16_t _overflow, uint8_t _seq_num)
      : spare_(flatbuffers::EndianScalar(_spare)),
        padding0__(0),
        overflow_(flatbuffers::EndianScalar(_overflow)),
        seq_num_(flatbuffers::EndianScalar(_seq_num)),
        padding1__(0) {
    (void) padding0__;
    (void) padding1__;
  }
  uint8_t spare() const { return flatbuffers::EndianScalar(spare_); }
  void mutate_spare(uint8_t _spare) {
    flatbuffers::WriteScalar(&spare_, _spare);
  }
  uint16_t overflow() const { return flatbuffers::EndianScalar(overflow_); }
  void mutate_overflow(uint16_t _overflow) {
    flatbuffers::WriteScalar(&overflow_, _overflow);
  }
  uint8_t seq_num() const { return flatbuffers::EndianScalar(seq_num_); }
  void mutate_seq_num(uint8_t _seq_num) {
    flatbuffers::WriteScalar(&seq_num_, _seq_num);
  }
};
FLATBUFFERS_STRUCT_END(Count, 6);

inline bool operator==(const Count& lhs, const Count& rhs) {
  return (lhs.spare() == rhs.spare()) && (lhs.overflow() == rhs.overflow()) &&
         (lhs.seq_num() == rhs.seq_num());
}

inline bool operator!=(const Count& lhs, const Count& rhs) {
  return !(lhs == rhs);
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(1)
SelectedAlgorithms FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t encryption_;
  uint8_t integrity_;

 public:
  SelectedAlgorithms() : encryption_(0), integrity_(0) {}
  SelectedAlgorithms(uint8_t _encryption, uint8_t _integrity)
      : encryption_(flatbuffers::EndianScalar(_encryption)),
        integrity_(flatbuffers::EndianScalar(_integrity)) {}
  uint8_t encryption() const { return flatbuffers::EndianScalar(encryption_); }
  void mutate_encryption(uint8_t _encryption) {
    flatbuffers::WriteScalar(&encryption_, _encryption);
  }
  uint8_t integrity() const { return flatbuffers::EndianScalar(integrity_); }
  void mutate_integrity(uint8_t _integrity) {
    flatbuffers::WriteScalar(&integrity_, _integrity);
  }
};
FLATBUFFERS_STRUCT_END(SelectedAlgorithms, 2);

inline bool operator==(
    const SelectedAlgorithms& lhs, const SelectedAlgorithms& rhs) {
  return (lhs.encryption() == rhs.encryption()) &&
         (lhs.integrity() == rhs.integrity());
}

inline bool operator!=(
    const SelectedAlgorithms& lhs, const SelectedAlgorithms& rhs) {
  return !(lhs == rhs);
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(1) Capability FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t eps_encryption_;
  uint8_t eps_integrity_;
  uint8_t umts_encryption_;
  uint8_t umts_integrity_;
  uint8_t gprs_encryption_;
  uint8_t umts_present_;
  uint8_t gprs_present_;

 public:
  Capability()
      : eps_encryption_(0),
        eps_integrity_(0),
        umts_encryption_(0),
        umts_integrity_(0),
        gprs_encryption_(0),
        umts_present_(0),
        gprs_present_(0) {}
  Capability(
      uint8_t _eps_encryption, uint8_t _eps_integrity, uint8_t _umts_encryption,
      uint8_t _umts_integrity, uint8_t _gprs_encryption, uint8_t _umts_present,
      uint8_t _gprs_present)
      : eps_encryption_(flatbuffers::EndianScalar(_eps_encryption)),
        eps_integrity_(flatbuffers::EndianScalar(_eps_integrity)),
        umts_encryption_(flatbuffers::EndianScalar(_umts_encryption)),
        umts_integrity_(flatbuffers::EndianScalar(_umts_integrity)),
        gprs_encryption_(flatbuffers::EndianScalar(_gprs_encryption)),
        umts_present_(flatbuffers::EndianScalar(_umts_present)),
        gprs_present_(flatbuffers::EndianScalar(_gprs_present)) {}
  uint8_t eps_encryption() const {
    return flatbuffers::EndianScalar(eps_encryption_);
  }
  void mutate_eps_encryption(uint8_t _eps_encryption) {
    flatbuffers::WriteScalar(&eps_encryption_, _eps_encryption);
  }
  uint8_t eps_integrity() const {
    return flatbuffers::EndianScalar(eps_integrity_);
  }
  void mutate_eps_integrity(uint8_t _eps_integrity) {
    flatbuffers::WriteScalar(&eps_integrity_, _eps_integrity);
  }
  uint8_t umts_encryption() const {
    return flatbuffers::EndianScalar(umts_encryption_);
  }
  void mutate_umts_encryption(uint8_t _umts_encryption) {
    flatbuffers::WriteScalar(&umts_encryption_, _umts_encryption);
  }
  uint8_t umts_integrity() const {
    return flatbuffers::EndianScalar(umts_integrity_);
  }
  void mutate_umts_integrity(uint8_t _umts_integrity) {
    flatbuffers::WriteScalar(&umts_integrity_, _umts_integrity);
  }
  uint8_t gprs_encryption() const {
    return flatbuffers::EndianScalar(gprs_encryption_);
  }
  void mutate_gprs_encryption(uint8_t _gprs_encryption) {
    flatbuffers::WriteScalar(&gprs_encryption_, _gprs_encryption);
  }
  uint8_t umts_present() const {
    return flatbuffers::EndianScalar(umts_present_);
  }
  void mutate_umts_present(uint8_t _umts_present) {
    flatbuffers::WriteScalar(&umts_present_, _umts_present);
  }
  uint8_t gprs_present() const {
    return flatbuffers::EndianScalar(gprs_present_);
  }
  void mutate_gprs_present(uint8_t _gprs_present) {
    flatbuffers::WriteScalar(&gprs_present_, _gprs_present);
  }
};
FLATBUFFERS_STRUCT_END(Capability, 7);

inline bool operator==(const Capability& lhs, const Capability& rhs) {
  return (lhs.eps_encryption() == rhs.eps_encryption()) &&
         (lhs.eps_integrity() == rhs.eps_integrity()) &&
         (lhs.umts_encryption() == rhs.umts_encryption()) &&
         (lhs.umts_integrity() == rhs.umts_integrity()) &&
         (lhs.gprs_encryption() == rhs.gprs_encryption()) &&
         (lhs.umts_present() == rhs.umts_present()) &&
         (lhs.gprs_present() == rhs.gprs_present());
}

inline bool operator!=(const Capability& lhs, const Capability& rhs) {
  return !(lhs == rhs);
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(2)
EmmSecurityContext FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t emm_sc_type_;
  uint8_t eksi_;
  uint8_t vector_index_;
  uint8_t knas_enc_[16];
  uint8_t knas_int_[16];
  int8_t padding0__;
  magma::lte::test_flat_buffer::Count dl_count_;
  magma::lte::test_flat_buffer::Count ul_count_;
  magma::lte::test_flat_buffer::Count kenb_ul_count_;
  magma::lte::test_flat_buffer::Capability capability_;
  magma::lte::test_flat_buffer::SelectedAlgorithms selected_algorithms_;
  uint8_t activated_;
  uint8_t direction_encode_;
  uint8_t direction_decode_;
  uint8_t next_hop_[32];
  uint8_t next_hop_chaining_count_;
  int8_t padding1__;

 public:
  EmmSecurityContext()
      : emm_sc_type_(0),
        eksi_(0),
        vector_index_(0),
        knas_enc_(),
        knas_int_(),
        padding0__(0),
        dl_count_(),
        ul_count_(),
        kenb_ul_count_(),
        capability_(),
        selected_algorithms_(),
        activated_(0),
        direction_encode_(0),
        direction_decode_(0),
        next_hop_(),
        next_hop_chaining_count_(0),
        padding1__(0) {
    (void) padding0__;
    (void) padding1__;
  }
  EmmSecurityContext(
      magma::lte::test_flat_buffer::EmmScType _emm_sc_type, uint8_t _eksi,
      uint8_t _vector_index,
      const magma::lte::test_flat_buffer::Count& _dl_count,
      const magma::lte::test_flat_buffer::Count& _ul_count,
      const magma::lte::test_flat_buffer::Count& _kenb_ul_count,
      const magma::lte::test_flat_buffer::Capability& _capability,
      const magma::lte::test_flat_buffer::SelectedAlgorithms&
          _selected_algorithms,
      uint8_t _activated, uint8_t _direction_encode, uint8_t _direction_decode,
      uint8_t _next_hop_chaining_count)
      : emm_sc_type_(
            flatbuffers::EndianScalar(static_cast<uint8_t>(_emm_sc_type))),
        eksi_(flatbuffers::EndianScalar(_eksi)),
        vector_index_(flatbuffers::EndianScalar(_vector_index)),
        knas_enc_(),
        knas_int_(),
        padding0__(0),
        dl_count_(_dl_count),
        ul_count_(_ul_count),
        kenb_ul_count_(_kenb_ul_count),
        capability_(_capability),
        selected_algorithms_(_selected_algorithms),
        activated_(flatbuffers::EndianScalar(_activated)),
        direction_encode_(flatbuffers::EndianScalar(_direction_encode)),
        direction_decode_(flatbuffers::EndianScalar(_direction_decode)),
        next_hop_(),
        next_hop_chaining_count_(
            flatbuffers::EndianScalar(_next_hop_chaining_count)),
        padding1__(0) {
    (void) padding0__;
    (void) padding1__;
  }
  EmmSecurityContext(
      magma::lte::test_flat_buffer::EmmScType _emm_sc_type, uint8_t _eksi,
      uint8_t _vector_index, flatbuffers::span<const uint8_t, 16> _knas_enc,
      flatbuffers::span<const uint8_t, 16> _knas_int,
      const magma::lte::test_flat_buffer::Count& _dl_count,
      const magma::lte::test_flat_buffer::Count& _ul_count,
      const magma::lte::test_flat_buffer::Count& _kenb_ul_count,
      const magma::lte::test_flat_buffer::Capability& _capability,
      const magma::lte::test_flat_buffer::SelectedAlgorithms&
          _selected_algorithms,
      uint8_t _activated, uint8_t _direction_encode, uint8_t _direction_decode,
      flatbuffers::span<const uint8_t, 32> _next_hop,
      uint8_t _next_hop_chaining_count)
      : emm_sc_type_(
            flatbuffers::EndianScalar(static_cast<uint8_t>(_emm_sc_type))),
        eksi_(flatbuffers::EndianScalar(_eksi)),
        vector_index_(flatbuffers::EndianScalar(_vector_index)),
        padding0__(0),
        dl_count_(_dl_count),
        ul_count_(_ul_count),
        kenb_ul_count_(_kenb_ul_count),
        capability_(_capability),
        selected_algorithms_(_selected_algorithms),
        activated_(flatbuffers::EndianScalar(_activated)),
        direction_encode_(flatbuffers::EndianScalar(_direction_encode)),
        direction_decode_(flatbuffers::EndianScalar(_direction_decode)),
        next_hop_chaining_count_(
            flatbuffers::EndianScalar(_next_hop_chaining_count)),
        padding1__(0) {
    flatbuffers::CastToArray(knas_enc_).CopyFromSpan(_knas_enc);
    flatbuffers::CastToArray(knas_int_).CopyFromSpan(_knas_int);
    (void) padding0__;
    flatbuffers::CastToArray(next_hop_).CopyFromSpan(_next_hop);
    (void) padding1__;
  }
  magma::lte::test_flat_buffer::EmmScType emm_sc_type() const {
    return static_cast<magma::lte::test_flat_buffer::EmmScType>(
        flatbuffers::EndianScalar(emm_sc_type_));
  }
  void mutate_emm_sc_type(
      magma::lte::test_flat_buffer::EmmScType _emm_sc_type) {
    flatbuffers::WriteScalar(&emm_sc_type_, static_cast<uint8_t>(_emm_sc_type));
  }
  uint8_t eksi() const { return flatbuffers::EndianScalar(eksi_); }
  void mutate_eksi(uint8_t _eksi) { flatbuffers::WriteScalar(&eksi_, _eksi); }
  uint8_t vector_index() const {
    return flatbuffers::EndianScalar(vector_index_);
  }
  void mutate_vector_index(uint8_t _vector_index) {
    flatbuffers::WriteScalar(&vector_index_, _vector_index);
  }
  const flatbuffers::Array<uint8_t, 16>* knas_enc() const {
    return &flatbuffers::CastToArray(knas_enc_);
  }
  flatbuffers::Array<uint8_t, 16>* mutable_knas_enc() {
    return &flatbuffers::CastToArray(knas_enc_);
  }
  const flatbuffers::Array<uint8_t, 16>* knas_int() const {
    return &flatbuffers::CastToArray(knas_int_);
  }
  flatbuffers::Array<uint8_t, 16>* mutable_knas_int() {
    return &flatbuffers::CastToArray(knas_int_);
  }
  const magma::lte::test_flat_buffer::Count& dl_count() const {
    return dl_count_;
  }
  magma::lte::test_flat_buffer::Count& mutable_dl_count() { return dl_count_; }
  const magma::lte::test_flat_buffer::Count& ul_count() const {
    return ul_count_;
  }
  magma::lte::test_flat_buffer::Count& mutable_ul_count() { return ul_count_; }
  const magma::lte::test_flat_buffer::Count& kenb_ul_count() const {
    return kenb_ul_count_;
  }
  magma::lte::test_flat_buffer::Count& mutable_kenb_ul_count() {
    return kenb_ul_count_;
  }
  const magma::lte::test_flat_buffer::Capability& capability() const {
    return capability_;
  }
  magma::lte::test_flat_buffer::Capability& mutable_capability() {
    return capability_;
  }
  const magma::lte::test_flat_buffer::SelectedAlgorithms& selected_algorithms()
      const {
    return selected_algorithms_;
  }
  magma::lte::test_flat_buffer::SelectedAlgorithms&
  mutable_selected_algorithms() {
    return selected_algorithms_;
  }
  uint8_t activated() const { return flatbuffers::EndianScalar(activated_); }
  void mutate_activated(uint8_t _activated) {
    flatbuffers::WriteScalar(&activated_, _activated);
  }
  uint8_t direction_encode() const {
    return flatbuffers::EndianScalar(direction_encode_);
  }
  void mutate_direction_encode(uint8_t _direction_encode) {
    flatbuffers::WriteScalar(&direction_encode_, _direction_encode);
  }
  uint8_t direction_decode() const {
    return flatbuffers::EndianScalar(direction_decode_);
  }
  void mutate_direction_decode(uint8_t _direction_decode) {
    flatbuffers::WriteScalar(&direction_decode_, _direction_decode);
  }
  const flatbuffers::Array<uint8_t, 32>* next_hop() const {
    return &flatbuffers::CastToArray(next_hop_);
  }
  flatbuffers::Array<uint8_t, 32>* mutable_next_hop() {
    return &flatbuffers::CastToArray(next_hop_);
  }
  uint8_t next_hop_chaining_count() const {
    return flatbuffers::EndianScalar(next_hop_chaining_count_);
  }
  void mutate_next_hop_chaining_count(uint8_t _next_hop_chaining_count) {
    flatbuffers::WriteScalar(
        &next_hop_chaining_count_, _next_hop_chaining_count);
  }
};
FLATBUFFERS_STRUCT_END(EmmSecurityContext, 100);

inline bool operator==(
    const EmmSecurityContext& lhs, const EmmSecurityContext& rhs) {
  return (lhs.emm_sc_type() == rhs.emm_sc_type()) &&
         (lhs.eksi() == rhs.eksi()) &&
         (lhs.vector_index() == rhs.vector_index()) &&
         (lhs.knas_enc() == rhs.knas_enc()) &&
         (lhs.knas_int() == rhs.knas_int()) &&
         (lhs.dl_count() == rhs.dl_count()) &&
         (lhs.ul_count() == rhs.ul_count()) &&
         (lhs.kenb_ul_count() == rhs.kenb_ul_count()) &&
         (lhs.capability() == rhs.capability()) &&
         (lhs.selected_algorithms() == rhs.selected_algorithms()) &&
         (lhs.activated() == rhs.activated()) &&
         (lhs.direction_encode() == rhs.direction_encode()) &&
         (lhs.direction_decode() == rhs.direction_decode()) &&
         (lhs.next_hop() == rhs.next_hop()) &&
         (lhs.next_hop_chaining_count() == rhs.next_hop_chaining_count());
}

inline bool operator!=(
    const EmmSecurityContext& lhs, const EmmSecurityContext& rhs) {
  return !(lhs == rhs);
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(2) TaiListManyPlmn FLATBUFFERS_FINAL_CLASS {
 private:
  magma::lte::test_flat_buffer::Tai tai_[16];
  uint8_t num_tais_;
  int8_t padding0__;

 public:
  TaiListManyPlmn() : tai_(), num_tais_(0), padding0__(0) { (void) padding0__; }
  TaiListManyPlmn(uint8_t _num_tais)
      : tai_(), num_tais_(flatbuffers::EndianScalar(_num_tais)), padding0__(0) {
    (void) padding0__;
  }
  TaiListManyPlmn(
      flatbuffers::span<const magma::lte::test_flat_buffer::Tai, 16> _tai,
      uint8_t _num_tais)
      : num_tais_(flatbuffers::EndianScalar(_num_tais)), padding0__(0) {
    flatbuffers::CastToArray(tai_).CopyFromSpan(_tai);
    (void) padding0__;
  }
  const flatbuffers::Array<magma::lte::test_flat_buffer::Tai, 16>* tai() const {
    return &flatbuffers::CastToArray(tai_);
  }
  flatbuffers::Array<magma::lte::test_flat_buffer::Tai, 16>* mutable_tai() {
    return &flatbuffers::CastToArray(tai_);
  }
  uint8_t num_tais() const { return flatbuffers::EndianScalar(num_tais_); }
  void mutate_num_tais(uint8_t _num_tais) {
    flatbuffers::WriteScalar(&num_tais_, _num_tais);
  }
};
FLATBUFFERS_STRUCT_END(TaiListManyPlmn, 130);

inline bool operator==(const TaiListManyPlmn& lhs, const TaiListManyPlmn& rhs) {
  return (lhs.tai() == rhs.tai()) && (lhs.num_tais() == rhs.num_tais());
}

inline bool operator!=(const TaiListManyPlmn& lhs, const TaiListManyPlmn& rhs) {
  return !(lhs == rhs);
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(2) PartialTaiList FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t typeoflist_;
  uint8_t numberofelements_;
  magma::lte::test_flat_buffer::TaiListManyPlmn tai_list_;

 public:
  PartialTaiList() : typeoflist_(0), numberofelements_(0), tai_list_() {}
  PartialTaiList(
      magma::lte::test_flat_buffer::TypeOfTaiList _typeoflist,
      uint8_t _numberofelements,
      const magma::lte::test_flat_buffer::TaiListManyPlmn& _tai_list)
      : typeoflist_(
            flatbuffers::EndianScalar(static_cast<uint8_t>(_typeoflist))),
        numberofelements_(flatbuffers::EndianScalar(_numberofelements)),
        tai_list_(_tai_list) {}
  magma::lte::test_flat_buffer::TypeOfTaiList typeoflist() const {
    return static_cast<magma::lte::test_flat_buffer::TypeOfTaiList>(
        flatbuffers::EndianScalar(typeoflist_));
  }
  void mutate_typeoflist(
      magma::lte::test_flat_buffer::TypeOfTaiList _typeoflist) {
    flatbuffers::WriteScalar(&typeoflist_, static_cast<uint8_t>(_typeoflist));
  }
  uint8_t numberofelements() const {
    return flatbuffers::EndianScalar(numberofelements_);
  }
  void mutate_numberofelements(uint8_t _numberofelements) {
    flatbuffers::WriteScalar(&numberofelements_, _numberofelements);
  }
  const magma::lte::test_flat_buffer::TaiListManyPlmn& tai_list() const {
    return tai_list_;
  }
  magma::lte::test_flat_buffer::TaiListManyPlmn& mutable_tai_list() {
    return tai_list_;
  }
};
FLATBUFFERS_STRUCT_END(PartialTaiList, 132);

inline bool operator==(const PartialTaiList& lhs, const PartialTaiList& rhs) {
  return (lhs.typeoflist() == rhs.typeoflist()) &&
         (lhs.numberofelements() == rhs.numberofelements()) &&
         (lhs.tai_list() == rhs.tai_list());
}

inline bool operator!=(const PartialTaiList& lhs, const PartialTaiList& rhs) {
  return !(lhs == rhs);
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(2) TaiList FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t numberoflists_;
  int8_t padding0__;
  magma::lte::test_flat_buffer::PartialTaiList partial_tai_list_[16];
  uint8_t partial_tai_list_length_;
  int8_t padding1__;

 public:
  TaiList()
      : numberoflists_(0),
        padding0__(0),
        partial_tai_list_(),
        partial_tai_list_length_(0),
        padding1__(0) {
    (void) padding0__;
    (void) padding1__;
  }
  TaiList(uint8_t _numberoflists, uint8_t _partial_tai_list_length)
      : numberoflists_(flatbuffers::EndianScalar(_numberoflists)),
        padding0__(0),
        partial_tai_list_(),
        partial_tai_list_length_(
            flatbuffers::EndianScalar(_partial_tai_list_length)),
        padding1__(0) {
    (void) padding0__;
    (void) padding1__;
  }
  TaiList(
      uint8_t _numberoflists,
      flatbuffers::span<const magma::lte::test_flat_buffer::PartialTaiList, 16>
          _partial_tai_list,
      uint8_t _partial_tai_list_length)
      : numberoflists_(flatbuffers::EndianScalar(_numberoflists)),
        padding0__(0),
        partial_tai_list_length_(
            flatbuffers::EndianScalar(_partial_tai_list_length)),
        padding1__(0) {
    (void) padding0__;
    flatbuffers::CastToArray(partial_tai_list_).CopyFromSpan(_partial_tai_list);
    (void) padding1__;
  }
  uint8_t numberoflists() const {
    return flatbuffers::EndianScalar(numberoflists_);
  }
  void mutate_numberoflists(uint8_t _numberoflists) {
    flatbuffers::WriteScalar(&numberoflists_, _numberoflists);
  }
  const flatbuffers::Array<magma::lte::test_flat_buffer::PartialTaiList, 16>*
  partial_tai_list() const {
    return &flatbuffers::CastToArray(partial_tai_list_);
  }
  flatbuffers::Array<magma::lte::test_flat_buffer::PartialTaiList, 16>*
  mutable_partial_tai_list() {
    return &flatbuffers::CastToArray(partial_tai_list_);
  }
  uint8_t partial_tai_list_length() const {
    return flatbuffers::EndianScalar(partial_tai_list_length_);
  }
  void mutate_partial_tai_list_length(uint8_t _partial_tai_list_length) {
    flatbuffers::WriteScalar(
        &partial_tai_list_length_, _partial_tai_list_length);
  }
};
FLATBUFFERS_STRUCT_END(TaiList, 2116);

inline bool operator==(const TaiList& lhs, const TaiList& rhs) {
  return (lhs.numberoflists() == rhs.numberoflists()) &&
         (lhs.partial_tai_list() == rhs.partial_tai_list()) &&
         (lhs.partial_tai_list_length() == rhs.partial_tai_list_length());
}

inline bool operator!=(const TaiList& lhs, const TaiList& rhs) {
  return !(lhs == rhs);
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(1)
UeNetworkCapability FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t bytes_[15];
  uint8_t length_;

 public:
  UeNetworkCapability() : bytes_(), length_(0) {}
  UeNetworkCapability(uint8_t _length)
      : bytes_(), length_(flatbuffers::EndianScalar(_length)) {}
  UeNetworkCapability(
      flatbuffers::span<const uint8_t, 15> _bytes, uint8_t _length)
      : length_(flatbuffers::EndianScalar(_length)) {
    flatbuffers::CastToArray(bytes_).CopyFromSpan(_bytes);
  }
  const flatbuffers::Array<uint8_t, 15>* bytes() const {
    return &flatbuffers::CastToArray(bytes_);
  }
  flatbuffers::Array<uint8_t, 15>* mutable_bytes() {
    return &flatbuffers::CastToArray(bytes_);
  }
  uint8_t length() const { return flatbuffers::EndianScalar(length_); }
  void mutate_length(uint8_t _length) {
    flatbuffers::WriteScalar(&length_, _length);
  }
};
FLATBUFFERS_STRUCT_END(UeNetworkCapability, 16);

inline bool operator==(
    const UeNetworkCapability& lhs, const UeNetworkCapability& rhs) {
  return (lhs.bytes() == rhs.bytes()) && (lhs.length() == rhs.length());
}

inline bool operator!=(
    const UeNetworkCapability& lhs, const UeNetworkCapability& rhs) {
  return !(lhs == rhs);
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(2)
UeAdditionalSecurityCapability FLATBUFFERS_FINAL_CLASS {
 private:
  uint16_t _5g_ea_;
  uint16_t _5g_ia_;

 public:
  UeAdditionalSecurityCapability() : _5g_ea_(0), _5g_ia_(0) {}
  UeAdditionalSecurityCapability(uint16_t __5g_ea, uint16_t __5g_ia)
      : _5g_ea_(flatbuffers::EndianScalar(__5g_ea)),
        _5g_ia_(flatbuffers::EndianScalar(__5g_ia)) {}
  uint16_t _5g_ea() const { return flatbuffers::EndianScalar(_5g_ea_); }
  void mutate__5g_ea(uint16_t __5g_ea) {
    flatbuffers::WriteScalar(&_5g_ea_, __5g_ea);
  }
  uint16_t _5g_ia() const { return flatbuffers::EndianScalar(_5g_ia_); }
  void mutate__5g_ia(uint16_t __5g_ia) {
    flatbuffers::WriteScalar(&_5g_ia_, __5g_ia);
  }
};
FLATBUFFERS_STRUCT_END(UeAdditionalSecurityCapability, 4);

inline bool operator==(
    const UeAdditionalSecurityCapability& lhs,
    const UeAdditionalSecurityCapability& rhs) {
  return (lhs._5g_ea() == rhs._5g_ea()) && (lhs._5g_ia() == rhs._5g_ia());
}

inline bool operator!=(
    const UeAdditionalSecurityCapability& lhs,
    const UeAdditionalSecurityCapability& rhs) {
  return !(lhs == rhs);
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) NwDetachData FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t ue_id_;
  uint32_t retransmission_count_;
  uint8_t detach_type_;
  int8_t padding0__;
  int16_t padding1__;

 public:
  NwDetachData()
      : ue_id_(0),
        retransmission_count_(0),
        detach_type_(0),
        padding0__(0),
        padding1__(0) {
    (void) padding0__;
    (void) padding1__;
  }
  NwDetachData(
      uint32_t _ue_id, uint32_t _retransmission_count, uint8_t _detach_type)
      : ue_id_(flatbuffers::EndianScalar(_ue_id)),
        retransmission_count_(flatbuffers::EndianScalar(_retransmission_count)),
        detach_type_(flatbuffers::EndianScalar(_detach_type)),
        padding0__(0),
        padding1__(0) {
    (void) padding0__;
    (void) padding1__;
  }
  uint32_t ue_id() const { return flatbuffers::EndianScalar(ue_id_); }
  void mutate_ue_id(uint32_t _ue_id) {
    flatbuffers::WriteScalar(&ue_id_, _ue_id);
  }
  uint32_t retransmission_count() const {
    return flatbuffers::EndianScalar(retransmission_count_);
  }
  void mutate_retransmission_count(uint32_t _retransmission_count) {
    flatbuffers::WriteScalar(&retransmission_count_, _retransmission_count);
  }
  uint8_t detach_type() const {
    return flatbuffers::EndianScalar(detach_type_);
  }
  void mutate_detach_type(uint8_t _detach_type) {
    flatbuffers::WriteScalar(&detach_type_, _detach_type);
  }
};
FLATBUFFERS_STRUCT_END(NwDetachData, 12);

inline bool operator==(const NwDetachData& lhs, const NwDetachData& rhs) {
  return (lhs.ue_id() == rhs.ue_id()) &&
         (lhs.retransmission_count() == rhs.retransmission_count()) &&
         (lhs.detach_type() == rhs.detach_type());
}

inline bool operator!=(const NwDetachData& lhs, const NwDetachData& rhs) {
  return !(lhs == rhs);
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(1) DrxParameter FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t splitpgcyclecode_;
  uint8_t cnspecificdrxcyclelengthcoefficientanddrxvaluefors1mode_;
  uint8_t splitonccch_;
  uint8_t nondrxtimer_;

 public:
  DrxParameter()
      : splitpgcyclecode_(0),
        cnspecificdrxcyclelengthcoefficientanddrxvaluefors1mode_(0),
        splitonccch_(0),
        nondrxtimer_(0) {}
  DrxParameter(
      uint8_t _splitpgcyclecode,
      uint8_t _cnspecificdrxcyclelengthcoefficientanddrxvaluefors1mode,
      bool _splitonccch, uint8_t _nondrxtimer)
      : splitpgcyclecode_(flatbuffers::EndianScalar(_splitpgcyclecode)),
        cnspecificdrxcyclelengthcoefficientanddrxvaluefors1mode_(
            flatbuffers::EndianScalar(
                _cnspecificdrxcyclelengthcoefficientanddrxvaluefors1mode)),
        splitonccch_(
            flatbuffers::EndianScalar(static_cast<uint8_t>(_splitonccch))),
        nondrxtimer_(flatbuffers::EndianScalar(_nondrxtimer)) {}
  uint8_t splitpgcyclecode() const {
    return flatbuffers::EndianScalar(splitpgcyclecode_);
  }
  void mutate_splitpgcyclecode(uint8_t _splitpgcyclecode) {
    flatbuffers::WriteScalar(&splitpgcyclecode_, _splitpgcyclecode);
  }
  uint8_t cnspecificdrxcyclelengthcoefficientanddrxvaluefors1mode() const {
    return flatbuffers::EndianScalar(
        cnspecificdrxcyclelengthcoefficientanddrxvaluefors1mode_);
  }
  void mutate_cnspecificdrxcyclelengthcoefficientanddrxvaluefors1mode(
      uint8_t _cnspecificdrxcyclelengthcoefficientanddrxvaluefors1mode) {
    flatbuffers::WriteScalar(
        &cnspecificdrxcyclelengthcoefficientanddrxvaluefors1mode_,
        _cnspecificdrxcyclelengthcoefficientanddrxvaluefors1mode);
  }
  bool splitonccch() const {
    return flatbuffers::EndianScalar(splitonccch_) != 0;
  }
  void mutate_splitonccch(bool _splitonccch) {
    flatbuffers::WriteScalar(&splitonccch_, static_cast<uint8_t>(_splitonccch));
  }
  uint8_t nondrxtimer() const {
    return flatbuffers::EndianScalar(nondrxtimer_);
  }
  void mutate_nondrxtimer(uint8_t _nondrxtimer) {
    flatbuffers::WriteScalar(&nondrxtimer_, _nondrxtimer);
  }
};
FLATBUFFERS_STRUCT_END(DrxParameter, 4);

inline bool operator==(const DrxParameter& lhs, const DrxParameter& rhs) {
  return (lhs.splitpgcyclecode() == rhs.splitpgcyclecode()) &&
         (lhs.cnspecificdrxcyclelengthcoefficientanddrxvaluefors1mode() ==
          rhs.cnspecificdrxcyclelengthcoefficientanddrxvaluefors1mode()) &&
         (lhs.splitonccch() == rhs.splitonccch()) &&
         (lhs.nondrxtimer() == rhs.nondrxtimer());
}

inline bool operator!=(const DrxParameter& lhs, const DrxParameter& rhs) {
  return !(lhs == rhs);
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4)
NasMessageDecodeStatus FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t integrity_protected_message_;
  uint8_t ciphered_message_;
  uint8_t mac_matched_;
  uint8_t security_context_available_;
  uint32_t emm_cause_;

 public:
  NasMessageDecodeStatus()
      : integrity_protected_message_(0),
        ciphered_message_(0),
        mac_matched_(0),
        security_context_available_(0),
        emm_cause_(0) {}
  NasMessageDecodeStatus(
      bool _integrity_protected_message, bool _ciphered_message,
      bool _mac_matched, bool _security_context_available, uint32_t _emm_cause)
      : integrity_protected_message_(flatbuffers::EndianScalar(
            static_cast<uint8_t>(_integrity_protected_message))),
        ciphered_message_(
            flatbuffers::EndianScalar(static_cast<uint8_t>(_ciphered_message))),
        mac_matched_(
            flatbuffers::EndianScalar(static_cast<uint8_t>(_mac_matched))),
        security_context_available_(flatbuffers::EndianScalar(
            static_cast<uint8_t>(_security_context_available))),
        emm_cause_(flatbuffers::EndianScalar(_emm_cause)) {}
  bool integrity_protected_message() const {
    return flatbuffers::EndianScalar(integrity_protected_message_) != 0;
  }
  void mutate_integrity_protected_message(bool _integrity_protected_message) {
    flatbuffers::WriteScalar(
        &integrity_protected_message_,
        static_cast<uint8_t>(_integrity_protected_message));
  }
  bool ciphered_message() const {
    return flatbuffers::EndianScalar(ciphered_message_) != 0;
  }
  void mutate_ciphered_message(bool _ciphered_message) {
    flatbuffers::WriteScalar(
        &ciphered_message_, static_cast<uint8_t>(_ciphered_message));
  }
  bool mac_matched() const {
    return flatbuffers::EndianScalar(mac_matched_) != 0;
  }
  void mutate_mac_matched(bool _mac_matched) {
    flatbuffers::WriteScalar(&mac_matched_, static_cast<uint8_t>(_mac_matched));
  }
  bool security_context_available() const {
    return flatbuffers::EndianScalar(security_context_available_) != 0;
  }
  void mutate_security_context_available(bool _security_context_available) {
    flatbuffers::WriteScalar(
        &security_context_available_,
        static_cast<uint8_t>(_security_context_available));
  }
  uint32_t emm_cause() const { return flatbuffers::EndianScalar(emm_cause_); }
  void mutate_emm_cause(uint32_t _emm_cause) {
    flatbuffers::WriteScalar(&emm_cause_, _emm_cause);
  }
};
FLATBUFFERS_STRUCT_END(NasMessageDecodeStatus, 8);

inline bool operator==(
    const NasMessageDecodeStatus& lhs, const NasMessageDecodeStatus& rhs) {
  return (lhs.integrity_protected_message() ==
          rhs.integrity_protected_message()) &&
         (lhs.ciphered_message() == rhs.ciphered_message()) &&
         (lhs.mac_matched() == rhs.mac_matched()) &&
         (lhs.security_context_available() ==
          rhs.security_context_available()) &&
         (lhs.emm_cause() == rhs.emm_cause());
}

inline bool operator!=(
    const NasMessageDecodeStatus& lhs, const NasMessageDecodeStatus& rhs) {
  return !(lhs == rhs);
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(2) EsmMsg FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t bytes_[512];
  uint16_t length_;

 public:
  EsmMsg() : bytes_(), length_(0) {}
  EsmMsg(uint16_t _length)
      : bytes_(), length_(flatbuffers::EndianScalar(_length)) {}
  EsmMsg(flatbuffers::span<const uint8_t, 512> _bytes, uint16_t _length)
      : length_(flatbuffers::EndianScalar(_length)) {
    flatbuffers::CastToArray(bytes_).CopyFromSpan(_bytes);
  }
  const flatbuffers::Array<uint8_t, 512>* bytes() const {
    return &flatbuffers::CastToArray(bytes_);
  }
  flatbuffers::Array<uint8_t, 512>* mutable_bytes() {
    return &flatbuffers::CastToArray(bytes_);
  }
  uint16_t length() const { return flatbuffers::EndianScalar(length_); }
  void mutate_length(uint16_t _length) {
    flatbuffers::WriteScalar(&length_, _length);
  }
};
FLATBUFFERS_STRUCT_END(EsmMsg, 514);

inline bool operator==(const EsmMsg& lhs, const EsmMsg& rhs) {
  return (lhs.bytes() == rhs.bytes()) && (lhs.length() == rhs.length());
}

inline bool operator!=(const EsmMsg& lhs, const EsmMsg& rhs) {
  return !(lhs == rhs);
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4)
EmmAttachRequestIes FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t is_initial_;
  uint8_t type_;
  uint8_t additional_update_type_;
  uint8_t is_native_sc_;
  uint8_t ksi_;
  uint8_t is_native_guti_;
  int16_t padding0__;
  magma::lte::test_flat_buffer::Guti guti_;
  magma::lte::test_flat_buffer::Imsi imsi_;
  magma::lte::test_flat_buffer::Imei imei_;
  int8_t padding1__;
  magma::lte::test_flat_buffer::Tai last_visited_registered_tai_;
  magma::lte::test_flat_buffer::Tai originating_tai_;
  int16_t padding2__;
  magma::lte::test_flat_buffer::Ecgi originating_ecgi_;
  magma::lte::test_flat_buffer::UeNetworkCapability ue_network_capability_;
  magma::lte::test_flat_buffer::MsNetworkCapability ms_network_capability_;
  magma::lte::test_flat_buffer::DrxParameter drx_parameter_;
  int8_t padding3__;
  magma::lte::test_flat_buffer::EsmMsg esm_msg_;
  int16_t padding4__;
  magma::lte::test_flat_buffer::NasMessageDecodeStatus decode_status_;
  magma::lte::test_flat_buffer::UeAdditionalSecurityCapability
      ue_additional_security_capability_;

 public:
  EmmAttachRequestIes()
      : is_initial_(0),
        type_(0),
        additional_update_type_(0),
        is_native_sc_(0),
        ksi_(0),
        is_native_guti_(0),
        padding0__(0),
        guti_(),
        imsi_(),
        imei_(),
        padding1__(0),
        last_visited_registered_tai_(),
        originating_tai_(),
        padding2__(0),
        originating_ecgi_(),
        ue_network_capability_(),
        ms_network_capability_(),
        drx_parameter_(),
        padding3__(0),
        esm_msg_(),
        padding4__(0),
        decode_status_(),
        ue_additional_security_capability_() {
    (void) padding0__;
    (void) padding1__;
    (void) padding2__;
    (void) padding3__;
    (void) padding4__;
  }
  EmmAttachRequestIes(
      bool _is_initial, magma::lte::test_flat_buffer::EmmProcAttachType _type,
      magma::lte::test_flat_buffer::AdditionalUpdateType
          _additional_update_type,
      bool _is_native_sc, uint8_t _ksi, bool _is_native_guti,
      const magma::lte::test_flat_buffer::Guti& _guti,
      const magma::lte::test_flat_buffer::Imsi& _imsi,
      const magma::lte::test_flat_buffer::Imei& _imei,
      const magma::lte::test_flat_buffer::Tai& _last_visited_registered_tai,
      const magma::lte::test_flat_buffer::Tai& _originating_tai,
      const magma::lte::test_flat_buffer::Ecgi& _originating_ecgi,
      const magma::lte::test_flat_buffer::UeNetworkCapability&
          _ue_network_capability,
      const magma::lte::test_flat_buffer::MsNetworkCapability&
          _ms_network_capability,
      const magma::lte::test_flat_buffer::DrxParameter& _drx_parameter,
      const magma::lte::test_flat_buffer::EsmMsg& _esm_msg,
      const magma::lte::test_flat_buffer::NasMessageDecodeStatus&
          _decode_status,
      const magma::lte::test_flat_buffer::UeAdditionalSecurityCapability&
          _ue_additional_security_capability)
      : is_initial_(
            flatbuffers::EndianScalar(static_cast<uint8_t>(_is_initial))),
        type_(flatbuffers::EndianScalar(static_cast<uint8_t>(_type))),
        additional_update_type_(flatbuffers::EndianScalar(
            static_cast<uint8_t>(_additional_update_type))),
        is_native_sc_(
            flatbuffers::EndianScalar(static_cast<uint8_t>(_is_native_sc))),
        ksi_(flatbuffers::EndianScalar(_ksi)),
        is_native_guti_(
            flatbuffers::EndianScalar(static_cast<uint8_t>(_is_native_guti))),
        padding0__(0),
        guti_(_guti),
        imsi_(_imsi),
        imei_(_imei),
        padding1__(0),
        last_visited_registered_tai_(_last_visited_registered_tai),
        originating_tai_(_originating_tai),
        padding2__(0),
        originating_ecgi_(_originating_ecgi),
        ue_network_capability_(_ue_network_capability),
        ms_network_capability_(_ms_network_capability),
        drx_parameter_(_drx_parameter),
        padding3__(0),
        esm_msg_(_esm_msg),
        padding4__(0),
        decode_status_(_decode_status),
        ue_additional_security_capability_(_ue_additional_security_capability) {
    (void) padding0__;
    (void) padding1__;
    (void) padding2__;
    (void) padding3__;
    (void) padding4__;
  }
  bool is_initial() const {
    return flatbuffers::EndianScalar(is_initial_) != 0;
  }
  void mutate_is_initial(bool _is_initial) {
    flatbuffers::WriteScalar(&is_initial_, static_cast<uint8_t>(_is_initial));
  }
  magma::lte::test_flat_buffer::EmmProcAttachType type() const {
    return static_cast<magma::lte::test_flat_buffer::EmmProcAttachType>(
        flatbuffers::EndianScalar(type_));
  }
  void mutate_type(magma::lte::test_flat_buffer::EmmProcAttachType _type) {
    flatbuffers::WriteScalar(&type_, static_cast<uint8_t>(_type));
  }
  magma::lte::test_flat_buffer::AdditionalUpdateType additional_update_type()
      const {
    return static_cast<magma::lte::test_flat_buffer::AdditionalUpdateType>(
        flatbuffers::EndianScalar(additional_update_type_));
  }
  void mutate_additional_update_type(
      magma::lte::test_flat_buffer::AdditionalUpdateType
          _additional_update_type) {
    flatbuffers::WriteScalar(
        &additional_update_type_,
        static_cast<uint8_t>(_additional_update_type));
  }
  bool is_native_sc() const {
    return flatbuffers::EndianScalar(is_native_sc_) != 0;
  }
  void mutate_is_native_sc(bool _is_native_sc) {
    flatbuffers::WriteScalar(
        &is_native_sc_, static_cast<uint8_t>(_is_native_sc));
  }
  uint8_t ksi() const { return flatbuffers::EndianScalar(ksi_); }
  void mutate_ksi(uint8_t _ksi) { flatbuffers::WriteScalar(&ksi_, _ksi); }
  bool is_native_guti() const {
    return flatbuffers::EndianScalar(is_native_guti_) != 0;
  }
  void mutate_is_native_guti(bool _is_native_guti) {
    flatbuffers::WriteScalar(
        &is_native_guti_, static_cast<uint8_t>(_is_native_guti));
  }
  const magma::lte::test_flat_buffer::Guti& guti() const { return guti_; }
  magma::lte::test_flat_buffer::Guti& mutable_guti() { return guti_; }
  const magma::lte::test_flat_buffer::Imsi& imsi() const { return imsi_; }
  magma::lte::test_flat_buffer::Imsi& mutable_imsi() { return imsi_; }
  const magma::lte::test_flat_buffer::Imei& imei() const { return imei_; }
  magma::lte::test_flat_buffer::Imei& mutable_imei() { return imei_; }
  const magma::lte::test_flat_buffer::Tai& last_visited_registered_tai() const {
    return last_visited_registered_tai_;
  }
  magma::lte::test_flat_buffer::Tai& mutable_last_visited_registered_tai() {
    return last_visited_registered_tai_;
  }
  const magma::lte::test_flat_buffer::Tai& originating_tai() const {
    return originating_tai_;
  }
  magma::lte::test_flat_buffer::Tai& mutable_originating_tai() {
    return originating_tai_;
  }
  const magma::lte::test_flat_buffer::Ecgi& originating_ecgi() const {
    return originating_ecgi_;
  }
  magma::lte::test_flat_buffer::Ecgi& mutable_originating_ecgi() {
    return originating_ecgi_;
  }
  const magma::lte::test_flat_buffer::UeNetworkCapability&
  ue_network_capability() const {
    return ue_network_capability_;
  }
  magma::lte::test_flat_buffer::UeNetworkCapability&
  mutable_ue_network_capability() {
    return ue_network_capability_;
  }
  const magma::lte::test_flat_buffer::MsNetworkCapability&
  ms_network_capability() const {
    return ms_network_capability_;
  }
  magma::lte::test_flat_buffer::MsNetworkCapability&
  mutable_ms_network_capability() {
    return ms_network_capability_;
  }
  const magma::lte::test_flat_buffer::DrxParameter& drx_parameter() const {
    return drx_parameter_;
  }
  magma::lte::test_flat_buffer::DrxParameter& mutable_drx_parameter() {
    return drx_parameter_;
  }
  const magma::lte::test_flat_buffer::EsmMsg& esm_msg() const {
    return esm_msg_;
  }
  magma::lte::test_flat_buffer::EsmMsg& mutable_esm_msg() { return esm_msg_; }
  const magma::lte::test_flat_buffer::NasMessageDecodeStatus& decode_status()
      const {
    return decode_status_;
  }
  magma::lte::test_flat_buffer::NasMessageDecodeStatus&
  mutable_decode_status() {
    return decode_status_;
  }
  const magma::lte::test_flat_buffer::UeAdditionalSecurityCapability&
  ue_additional_security_capability() const {
    return ue_additional_security_capability_;
  }
  magma::lte::test_flat_buffer::UeAdditionalSecurityCapability&
  mutable_ue_additional_security_capability() {
    return ue_additional_security_capability_;
  }
};
FLATBUFFERS_STRUCT_END(EmmAttachRequestIes, 632);

inline bool operator==(
    const EmmAttachRequestIes& lhs, const EmmAttachRequestIes& rhs) {
  return (lhs.is_initial() == rhs.is_initial()) && (lhs.type() == rhs.type()) &&
         (lhs.additional_update_type() == rhs.additional_update_type()) &&
         (lhs.is_native_sc() == rhs.is_native_sc()) &&
         (lhs.ksi() == rhs.ksi()) &&
         (lhs.is_native_guti() == rhs.is_native_guti()) &&
         (lhs.guti() == rhs.guti()) && (lhs.imsi() == rhs.imsi()) &&
         (lhs.imei() == rhs.imei()) &&
         (lhs.last_visited_registered_tai() ==
          rhs.last_visited_registered_tai()) &&
         (lhs.originating_tai() == rhs.originating_tai()) &&
         (lhs.originating_ecgi() == rhs.originating_ecgi()) &&
         (lhs.ue_network_capability() == rhs.ue_network_capability()) &&
         (lhs.ms_network_capability() == rhs.ms_network_capability()) &&
         (lhs.drx_parameter() == rhs.drx_parameter()) &&
         (lhs.esm_msg() == rhs.esm_msg()) &&
         (lhs.decode_status() == rhs.decode_status()) &&
         (lhs.ue_additional_security_capability() ==
          rhs.ue_additional_security_capability());
}

inline bool operator!=(
    const EmmAttachRequestIes& lhs, const EmmAttachRequestIes& rhs) {
  return !(lhs == rhs);
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) NewAttachInfo FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t mme_ue_s1ap_id_;
  uint8_t is_mm_ctx_new_;
  int8_t padding0__;
  int16_t padding1__;
  magma::lte::test_flat_buffer::EmmAttachRequestIes ies_;

 public:
  NewAttachInfo()
      : mme_ue_s1ap_id_(0),
        is_mm_ctx_new_(0),
        padding0__(0),
        padding1__(0),
        ies_() {
    (void) padding0__;
    (void) padding1__;
  }
  NewAttachInfo(
      uint32_t _mme_ue_s1ap_id, bool _is_mm_ctx_new,
      const magma::lte::test_flat_buffer::EmmAttachRequestIes& _ies)
      : mme_ue_s1ap_id_(flatbuffers::EndianScalar(_mme_ue_s1ap_id)),
        is_mm_ctx_new_(
            flatbuffers::EndianScalar(static_cast<uint8_t>(_is_mm_ctx_new))),
        padding0__(0),
        padding1__(0),
        ies_(_ies) {
    (void) padding0__;
    (void) padding1__;
  }
  uint32_t mme_ue_s1ap_id() const {
    return flatbuffers::EndianScalar(mme_ue_s1ap_id_);
  }
  void mutate_mme_ue_s1ap_id(uint32_t _mme_ue_s1ap_id) {
    flatbuffers::WriteScalar(&mme_ue_s1ap_id_, _mme_ue_s1ap_id);
  }
  bool is_mm_ctx_new() const {
    return flatbuffers::EndianScalar(is_mm_ctx_new_) != 0;
  }
  void mutate_is_mm_ctx_new(bool _is_mm_ctx_new) {
    flatbuffers::WriteScalar(
        &is_mm_ctx_new_, static_cast<uint8_t>(_is_mm_ctx_new));
  }
  const magma::lte::test_flat_buffer::EmmAttachRequestIes& ies() const {
    return ies_;
  }
  magma::lte::test_flat_buffer::EmmAttachRequestIes& mutable_ies() {
    return ies_;
  }
};
FLATBUFFERS_STRUCT_END(NewAttachInfo, 640);

inline bool operator==(const NewAttachInfo& lhs, const NewAttachInfo& rhs) {
  return (lhs.mme_ue_s1ap_id() == rhs.mme_ue_s1ap_id()) &&
         (lhs.is_mm_ctx_new() == rhs.is_mm_ctx_new()) &&
         (lhs.ies() == rhs.ies());
}

inline bool operator!=(const NewAttachInfo& lhs, const NewAttachInfo& rhs) {
  return !(lhs == rhs);
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) EmmContext FLATBUFFERS_FINAL_CLASS {
 private:
  uint64_t _imsi64_;
  magma::lte::test_flat_buffer::Imsi _imsi_;
  int8_t padding0__;
  int16_t padding1__;
  int32_t padding2__;
  uint64_t saved_imsi64_;
  magma::lte::test_flat_buffer::Imei _imei_;
  magma::lte::test_flat_buffer::Imeisv _imeisv_;
  uint32_t emm_cause_;
  uint8_t _emm_fsm_state_;
  uint8_t attach_type_;
  int16_t padding3__;
  uint32_t common_proc_mask_;
  int32_t padding4__;
  magma::lte::test_flat_buffer::EsmContext esm_ctx_;
  uint32_t member_present_mask_;
  uint32_t member_valid_mask_;
  magma::lte::test_flat_buffer::AuthVector _vector_;
  int8_t padding5__;
  magma::lte::test_flat_buffer::EmmSecurityContext _security_;
  magma::lte::test_flat_buffer::EmmSecurityContext _non_current_security_;
  uint8_t is_dynamic_;
  uint8_t is_attached_;
  uint8_t is_initial_identity_imsi_;
  uint8_t is_guti_based_attach_;
  uint8_t is_imsi_only_detach_;
  uint8_t is_emergency_;
  uint8_t additional_update_type_;
  uint8_t tau_updt_type_;
  int16_t padding6__;
  uint32_t num_attach_request_;
  magma::lte::test_flat_buffer::Guti _guti_;
  magma::lte::test_flat_buffer::Guti _old_guti_;
  magma::lte::test_flat_buffer::TaiList _tai_list_;
  magma::lte::test_flat_buffer::Tai _lvr_tai_;
  magma::lte::test_flat_buffer::Tai originating_tai_;
  uint8_t ksi_;
  magma::lte::test_flat_buffer::UeNetworkCapability _ue_network_capability_;
  int8_t padding7__;
  magma::lte::test_flat_buffer::UeAdditionalSecurityCapability
      ue_additional_security_capability_;
  uint8_t t3422_arg_valid_;
  int8_t padding8__;
  magma::lte::test_flat_buffer::NwDetachData t3422_arg_;
  magma::lte::test_flat_buffer::EmmAttachRequestIes new_attach_info_;

 public:
  EmmContext()
      : _imsi64_(0),
        _imsi_(),
        padding0__(0),
        padding1__(0),
        padding2__(0),
        saved_imsi64_(0),
        _imei_(),
        _imeisv_(),
        emm_cause_(0),
        _emm_fsm_state_(0),
        attach_type_(0),
        padding3__(0),
        common_proc_mask_(0),
        padding4__(0),
        esm_ctx_(),
        member_present_mask_(0),
        member_valid_mask_(0),
        _vector_(),
        padding5__(0),
        _security_(),
        _non_current_security_(),
        is_dynamic_(0),
        is_attached_(0),
        is_initial_identity_imsi_(0),
        is_guti_based_attach_(0),
        is_imsi_only_detach_(0),
        is_emergency_(0),
        additional_update_type_(0),
        tau_updt_type_(0),
        padding6__(0),
        num_attach_request_(0),
        _guti_(),
        _old_guti_(),
        _tai_list_(),
        _lvr_tai_(),
        originating_tai_(),
        ksi_(0),
        _ue_network_capability_(),
        padding7__(0),
        ue_additional_security_capability_(),
        t3422_arg_valid_(0),
        padding8__(0),
        t3422_arg_(),
        new_attach_info_() {
    (void) padding0__;
    (void) padding1__;
    (void) padding2__;
    (void) padding3__;
    (void) padding4__;
    (void) padding5__;
    (void) padding6__;
    (void) padding7__;
    (void) padding8__;
  }
  EmmContext(
      uint64_t __imsi64, const magma::lte::test_flat_buffer::Imsi& __imsi,
      uint64_t _saved_imsi64, const magma::lte::test_flat_buffer::Imei& __imei,
      const magma::lte::test_flat_buffer::Imeisv& __imeisv, uint32_t _emm_cause,
      magma::lte::test_flat_buffer::EmmFsmState __emm_fsm_state,
      magma::lte::test_flat_buffer::EmmProcAttachType _attach_type,
      uint32_t _common_proc_mask,
      const magma::lte::test_flat_buffer::EsmContext& _esm_ctx,
      uint32_t _member_present_mask, uint32_t _member_valid_mask,
      const magma::lte::test_flat_buffer::AuthVector& __vector,
      const magma::lte::test_flat_buffer::EmmSecurityContext& __security,
      const magma::lte::test_flat_buffer::EmmSecurityContext&
          __non_current_security,
      bool _is_dynamic, bool _is_attached, bool _is_initial_identity_imsi,
      bool _is_guti_based_attach, bool _is_imsi_only_detach, bool _is_emergency,
      magma::lte::test_flat_buffer::AdditionalUpdateType
          _additional_update_type,
      uint8_t _tau_updt_type, uint32_t _num_attach_request,
      const magma::lte::test_flat_buffer::Guti& __guti,
      const magma::lte::test_flat_buffer::Guti& __old_guti,
      const magma::lte::test_flat_buffer::TaiList& __tai_list,
      const magma::lte::test_flat_buffer::Tai& __lvr_tai,
      const magma::lte::test_flat_buffer::Tai& _originating_tai, uint8_t _ksi,
      const magma::lte::test_flat_buffer::UeNetworkCapability&
          __ue_network_capability,
      const magma::lte::test_flat_buffer::UeAdditionalSecurityCapability&
          _ue_additional_security_capability,
      bool _t3422_arg_valid,
      const magma::lte::test_flat_buffer::NwDetachData& _t3422_arg,
      const magma::lte::test_flat_buffer::EmmAttachRequestIes& _new_attach_info)
      : _imsi64_(flatbuffers::EndianScalar(__imsi64)),
        _imsi_(__imsi),
        padding0__(0),
        padding1__(0),
        padding2__(0),
        saved_imsi64_(flatbuffers::EndianScalar(_saved_imsi64)),
        _imei_(__imei),
        _imeisv_(__imeisv),
        emm_cause_(flatbuffers::EndianScalar(_emm_cause)),
        _emm_fsm_state_(
            flatbuffers::EndianScalar(static_cast<uint8_t>(__emm_fsm_state))),
        attach_type_(
            flatbuffers::EndianScalar(static_cast<uint8_t>(_attach_type))),
        padding3__(0),
        common_proc_mask_(flatbuffers::EndianScalar(_common_proc_mask)),
        padding4__(0),
        esm_ctx_(_esm_ctx),
        member_present_mask_(flatbuffers::EndianScalar(_member_present_mask)),
        member_valid_mask_(flatbuffers::EndianScalar(_member_valid_mask)),
        _vector_(__vector),
        padding5__(0),
        _security_(__security),
        _non_current_security_(__non_current_security),
        is_dynamic_(
            flatbuffers::EndianScalar(static_cast<uint8_t>(_is_dynamic))),
        is_attached_(
            flatbuffers::EndianScalar(static_cast<uint8_t>(_is_attached))),
        is_initial_identity_imsi_(flatbuffers::EndianScalar(
            static_cast<uint8_t>(_is_initial_identity_imsi))),
        is_guti_based_attach_(flatbuffers::EndianScalar(
            static_cast<uint8_t>(_is_guti_based_attach))),
        is_imsi_only_detach_(flatbuffers::EndianScalar(
            static_cast<uint8_t>(_is_imsi_only_detach))),
        is_emergency_(
            flatbuffers::EndianScalar(static_cast<uint8_t>(_is_emergency))),
        additional_update_type_(flatbuffers::EndianScalar(
            static_cast<uint8_t>(_additional_update_type))),
        tau_updt_type_(flatbuffers::EndianScalar(_tau_updt_type)),
        padding6__(0),
        num_attach_request_(flatbuffers::EndianScalar(_num_attach_request)),
        _guti_(__guti),
        _old_guti_(__old_guti),
        _tai_list_(__tai_list),
        _lvr_tai_(__lvr_tai),
        originating_tai_(_originating_tai),
        ksi_(flatbuffers::EndianScalar(_ksi)),
        _ue_network_capability_(__ue_network_capability),
        padding7__(0),
        ue_additional_security_capability_(_ue_additional_security_capability),
        t3422_arg_valid_(
            flatbuffers::EndianScalar(static_cast<uint8_t>(_t3422_arg_valid))),
        padding8__(0),
        t3422_arg_(_t3422_arg),
        new_attach_info_(_new_attach_info) {
    (void) padding0__;
    (void) padding1__;
    (void) padding2__;
    (void) padding3__;
    (void) padding4__;
    (void) padding5__;
    (void) padding6__;
    (void) padding7__;
    (void) padding8__;
  }
  uint64_t _imsi64() const { return flatbuffers::EndianScalar(_imsi64_); }
  void mutate__imsi64(uint64_t __imsi64) {
    flatbuffers::WriteScalar(&_imsi64_, __imsi64);
  }
  const magma::lte::test_flat_buffer::Imsi& _imsi() const { return _imsi_; }
  magma::lte::test_flat_buffer::Imsi& mutable__imsi() { return _imsi_; }
  uint64_t saved_imsi64() const {
    return flatbuffers::EndianScalar(saved_imsi64_);
  }
  void mutate_saved_imsi64(uint64_t _saved_imsi64) {
    flatbuffers::WriteScalar(&saved_imsi64_, _saved_imsi64);
  }
  const magma::lte::test_flat_buffer::Imei& _imei() const { return _imei_; }
  magma::lte::test_flat_buffer::Imei& mutable__imei() { return _imei_; }
  const magma::lte::test_flat_buffer::Imeisv& _imeisv() const {
    return _imeisv_;
  }
  magma::lte::test_flat_buffer::Imeisv& mutable__imeisv() { return _imeisv_; }
  uint32_t emm_cause() const { return flatbuffers::EndianScalar(emm_cause_); }
  void mutate_emm_cause(uint32_t _emm_cause) {
    flatbuffers::WriteScalar(&emm_cause_, _emm_cause);
  }
  magma::lte::test_flat_buffer::EmmFsmState _emm_fsm_state() const {
    return static_cast<magma::lte::test_flat_buffer::EmmFsmState>(
        flatbuffers::EndianScalar(_emm_fsm_state_));
  }
  void mutate__emm_fsm_state(
      magma::lte::test_flat_buffer::EmmFsmState __emm_fsm_state) {
    flatbuffers::WriteScalar(
        &_emm_fsm_state_, static_cast<uint8_t>(__emm_fsm_state));
  }
  magma::lte::test_flat_buffer::EmmProcAttachType attach_type() const {
    return static_cast<magma::lte::test_flat_buffer::EmmProcAttachType>(
        flatbuffers::EndianScalar(attach_type_));
  }
  void mutate_attach_type(
      magma::lte::test_flat_buffer::EmmProcAttachType _attach_type) {
    flatbuffers::WriteScalar(&attach_type_, static_cast<uint8_t>(_attach_type));
  }
  uint32_t common_proc_mask() const {
    return flatbuffers::EndianScalar(common_proc_mask_);
  }
  void mutate_common_proc_mask(uint32_t _common_proc_mask) {
    flatbuffers::WriteScalar(&common_proc_mask_, _common_proc_mask);
  }
  const magma::lte::test_flat_buffer::EsmContext& esm_ctx() const {
    return esm_ctx_;
  }
  magma::lte::test_flat_buffer::EsmContext& mutable_esm_ctx() {
    return esm_ctx_;
  }
  uint32_t member_present_mask() const {
    return flatbuffers::EndianScalar(member_present_mask_);
  }
  void mutate_member_present_mask(uint32_t _member_present_mask) {
    flatbuffers::WriteScalar(&member_present_mask_, _member_present_mask);
  }
  uint32_t member_valid_mask() const {
    return flatbuffers::EndianScalar(member_valid_mask_);
  }
  void mutate_member_valid_mask(uint32_t _member_valid_mask) {
    flatbuffers::WriteScalar(&member_valid_mask_, _member_valid_mask);
  }
  const magma::lte::test_flat_buffer::AuthVector& _vector() const {
    return _vector_;
  }
  magma::lte::test_flat_buffer::AuthVector& mutable__vector() {
    return _vector_;
  }
  const magma::lte::test_flat_buffer::EmmSecurityContext& _security() const {
    return _security_;
  }
  magma::lte::test_flat_buffer::EmmSecurityContext& mutable__security() {
    return _security_;
  }
  const magma::lte::test_flat_buffer::EmmSecurityContext&
  _non_current_security() const {
    return _non_current_security_;
  }
  magma::lte::test_flat_buffer::EmmSecurityContext&
  mutable__non_current_security() {
    return _non_current_security_;
  }
  bool is_dynamic() const {
    return flatbuffers::EndianScalar(is_dynamic_) != 0;
  }
  void mutate_is_dynamic(bool _is_dynamic) {
    flatbuffers::WriteScalar(&is_dynamic_, static_cast<uint8_t>(_is_dynamic));
  }
  bool is_attached() const {
    return flatbuffers::EndianScalar(is_attached_) != 0;
  }
  void mutate_is_attached(bool _is_attached) {
    flatbuffers::WriteScalar(&is_attached_, static_cast<uint8_t>(_is_attached));
  }
  bool is_initial_identity_imsi() const {
    return flatbuffers::EndianScalar(is_initial_identity_imsi_) != 0;
  }
  void mutate_is_initial_identity_imsi(bool _is_initial_identity_imsi) {
    flatbuffers::WriteScalar(
        &is_initial_identity_imsi_,
        static_cast<uint8_t>(_is_initial_identity_imsi));
  }
  bool is_guti_based_attach() const {
    return flatbuffers::EndianScalar(is_guti_based_attach_) != 0;
  }
  void mutate_is_guti_based_attach(bool _is_guti_based_attach) {
    flatbuffers::WriteScalar(
        &is_guti_based_attach_, static_cast<uint8_t>(_is_guti_based_attach));
  }
  bool is_imsi_only_detach() const {
    return flatbuffers::EndianScalar(is_imsi_only_detach_) != 0;
  }
  void mutate_is_imsi_only_detach(bool _is_imsi_only_detach) {
    flatbuffers::WriteScalar(
        &is_imsi_only_detach_, static_cast<uint8_t>(_is_imsi_only_detach));
  }
  bool is_emergency() const {
    return flatbuffers::EndianScalar(is_emergency_) != 0;
  }
  void mutate_is_emergency(bool _is_emergency) {
    flatbuffers::WriteScalar(
        &is_emergency_, static_cast<uint8_t>(_is_emergency));
  }
  magma::lte::test_flat_buffer::AdditionalUpdateType additional_update_type()
      const {
    return static_cast<magma::lte::test_flat_buffer::AdditionalUpdateType>(
        flatbuffers::EndianScalar(additional_update_type_));
  }
  void mutate_additional_update_type(
      magma::lte::test_flat_buffer::AdditionalUpdateType
          _additional_update_type) {
    flatbuffers::WriteScalar(
        &additional_update_type_,
        static_cast<uint8_t>(_additional_update_type));
  }
  uint8_t tau_updt_type() const {
    return flatbuffers::EndianScalar(tau_updt_type_);
  }
  void mutate_tau_updt_type(uint8_t _tau_updt_type) {
    flatbuffers::WriteScalar(&tau_updt_type_, _tau_updt_type);
  }
  uint32_t num_attach_request() const {
    return flatbuffers::EndianScalar(num_attach_request_);
  }
  void mutate_num_attach_request(uint32_t _num_attach_request) {
    flatbuffers::WriteScalar(&num_attach_request_, _num_attach_request);
  }
  const magma::lte::test_flat_buffer::Guti& _guti() const { return _guti_; }
  magma::lte::test_flat_buffer::Guti& mutable__guti() { return _guti_; }
  const magma::lte::test_flat_buffer::Guti& _old_guti() const {
    return _old_guti_;
  }
  magma::lte::test_flat_buffer::Guti& mutable__old_guti() { return _old_guti_; }
  const magma::lte::test_flat_buffer::TaiList& _tai_list() const {
    return _tai_list_;
  }
  magma::lte::test_flat_buffer::TaiList& mutable__tai_list() {
    return _tai_list_;
  }
  const magma::lte::test_flat_buffer::Tai& _lvr_tai() const {
    return _lvr_tai_;
  }
  magma::lte::test_flat_buffer::Tai& mutable__lvr_tai() { return _lvr_tai_; }
  const magma::lte::test_flat_buffer::Tai& originating_tai() const {
    return originating_tai_;
  }
  magma::lte::test_flat_buffer::Tai& mutable_originating_tai() {
    return originating_tai_;
  }
  uint8_t ksi() const { return flatbuffers::EndianScalar(ksi_); }
  void mutate_ksi(uint8_t _ksi) { flatbuffers::WriteScalar(&ksi_, _ksi); }
  const magma::lte::test_flat_buffer::UeNetworkCapability&
  _ue_network_capability() const {
    return _ue_network_capability_;
  }
  magma::lte::test_flat_buffer::UeNetworkCapability&
  mutable__ue_network_capability() {
    return _ue_network_capability_;
  }
  const magma::lte::test_flat_buffer::UeAdditionalSecurityCapability&
  ue_additional_security_capability() const {
    return ue_additional_security_capability_;
  }
  magma::lte::test_flat_buffer::UeAdditionalSecurityCapability&
  mutable_ue_additional_security_capability() {
    return ue_additional_security_capability_;
  }
  bool t3422_arg_valid() const {
    return flatbuffers::EndianScalar(t3422_arg_valid_) != 0;
  }
  void mutate_t3422_arg_valid(bool _t3422_arg_valid) {
    flatbuffers::WriteScalar(
        &t3422_arg_valid_, static_cast<uint8_t>(_t3422_arg_valid));
  }
  const magma::lte::test_flat_buffer::NwDetachData& t3422_arg() const {
    return t3422_arg_;
  }
  magma::lte::test_flat_buffer::NwDetachData& mutable_t3422_arg() {
    return t3422_arg_;
  }
  const magma::lte::test_flat_buffer::EmmAttachRequestIes& new_attach_info()
      const {
    return new_attach_info_;
  }
  magma::lte::test_flat_buffer::EmmAttachRequestIes& mutable_new_attach_info() {
    return new_attach_info_;
  }
};
FLATBUFFERS_STRUCT_END(EmmContext, 5496);

inline bool operator==(const EmmContext& lhs, const EmmContext& rhs) {
  return (lhs._imsi64() == rhs._imsi64()) && (lhs._imsi() == rhs._imsi()) &&
         (lhs.saved_imsi64() == rhs.saved_imsi64()) &&
         (lhs._imei() == rhs._imei()) && (lhs._imeisv() == rhs._imeisv()) &&
         (lhs.emm_cause() == rhs.emm_cause()) &&
         (lhs._emm_fsm_state() == rhs._emm_fsm_state()) &&
         (lhs.attach_type() == rhs.attach_type()) &&
         (lhs.common_proc_mask() == rhs.common_proc_mask()) &&
         (lhs.esm_ctx() == rhs.esm_ctx()) &&
         (lhs.member_present_mask() == rhs.member_present_mask()) &&
         (lhs.member_valid_mask() == rhs.member_valid_mask()) &&
         (lhs._vector() == rhs._vector()) &&
         (lhs._security() == rhs._security()) &&
         (lhs._non_current_security() == rhs._non_current_security()) &&
         (lhs.is_dynamic() == rhs.is_dynamic()) &&
         (lhs.is_attached() == rhs.is_attached()) &&
         (lhs.is_initial_identity_imsi() == rhs.is_initial_identity_imsi()) &&
         (lhs.is_guti_based_attach() == rhs.is_guti_based_attach()) &&
         (lhs.is_imsi_only_detach() == rhs.is_imsi_only_detach()) &&
         (lhs.is_emergency() == rhs.is_emergency()) &&
         (lhs.additional_update_type() == rhs.additional_update_type()) &&
         (lhs.tau_updt_type() == rhs.tau_updt_type()) &&
         (lhs.num_attach_request() == rhs.num_attach_request()) &&
         (lhs._guti() == rhs._guti()) && (lhs._old_guti() == rhs._old_guti()) &&
         (lhs._tai_list() == rhs._tai_list()) &&
         (lhs._lvr_tai() == rhs._lvr_tai()) &&
         (lhs.originating_tai() == rhs.originating_tai()) &&
         (lhs.ksi() == rhs.ksi()) &&
         (lhs._ue_network_capability() == rhs._ue_network_capability()) &&
         (lhs.ue_additional_security_capability() ==
          rhs.ue_additional_security_capability()) &&
         (lhs.t3422_arg_valid() == rhs.t3422_arg_valid()) &&
         (lhs.t3422_arg() == rhs.t3422_arg()) &&
         (lhs.new_attach_info() == rhs.new_attach_info());
}

inline bool operator!=(const EmmContext& lhs, const EmmContext& rhs) {
  return !(lhs == rhs);
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) EsmEbrTimerData FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t ue_id_;
  uint8_t ebi_;
  int8_t padding0__;
  int16_t padding1__;
  uint32_t count_;
  magma::lte::test_flat_buffer::EsmMsg msg_;
  int16_t padding2__;

 public:
  EsmEbrTimerData()
      : ue_id_(0),
        ebi_(0),
        padding0__(0),
        padding1__(0),
        count_(0),
        msg_(),
        padding2__(0) {
    (void) padding0__;
    (void) padding1__;
    (void) padding2__;
  }
  EsmEbrTimerData(
      uint32_t _ue_id, uint8_t _ebi, uint32_t _count,
      const magma::lte::test_flat_buffer::EsmMsg& _msg)
      : ue_id_(flatbuffers::EndianScalar(_ue_id)),
        ebi_(flatbuffers::EndianScalar(_ebi)),
        padding0__(0),
        padding1__(0),
        count_(flatbuffers::EndianScalar(_count)),
        msg_(_msg),
        padding2__(0) {
    (void) padding0__;
    (void) padding1__;
    (void) padding2__;
  }
  uint32_t ue_id() const { return flatbuffers::EndianScalar(ue_id_); }
  void mutate_ue_id(uint32_t _ue_id) {
    flatbuffers::WriteScalar(&ue_id_, _ue_id);
  }
  uint8_t ebi() const { return flatbuffers::EndianScalar(ebi_); }
  void mutate_ebi(uint8_t _ebi) { flatbuffers::WriteScalar(&ebi_, _ebi); }
  uint32_t count() const { return flatbuffers::EndianScalar(count_); }
  void mutate_count(uint32_t _count) {
    flatbuffers::WriteScalar(&count_, _count);
  }
  const magma::lte::test_flat_buffer::EsmMsg& msg() const { return msg_; }
  magma::lte::test_flat_buffer::EsmMsg& mutable_msg() { return msg_; }
};
FLATBUFFERS_STRUCT_END(EsmEbrTimerData, 528);

inline bool operator==(const EsmEbrTimerData& lhs, const EsmEbrTimerData& rhs) {
  return (lhs.ue_id() == rhs.ue_id()) && (lhs.ebi() == rhs.ebi()) &&
         (lhs.count() == rhs.count()) && (lhs.msg() == rhs.msg());
}

inline bool operator!=(const EsmEbrTimerData& lhs, const EsmEbrTimerData& rhs) {
  return !(lhs == rhs);
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) EsmEbrContext FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t status_;
  int8_t padding0__;
  int16_t padding1__;
  int32_t padding2__;
  uint64_t gbr_dl_;
  uint64_t gbr_ul_;
  uint64_t mbr_dl_;
  uint64_t mbr_ul_;
  magma::lte::test_flat_buffer::NasTimer timer_;
  magma::lte::test_flat_buffer::EsmEbrTimerData args_;

 public:
  EsmEbrContext()
      : status_(0),
        padding0__(0),
        padding1__(0),
        padding2__(0),
        gbr_dl_(0),
        gbr_ul_(0),
        mbr_dl_(0),
        mbr_ul_(0),
        timer_(),
        args_() {
    (void) padding0__;
    (void) padding1__;
    (void) padding2__;
  }
  EsmEbrContext(
      magma::lte::test_flat_buffer::EsmEbrState _status, uint64_t _gbr_dl,
      uint64_t _gbr_ul, uint64_t _mbr_dl, uint64_t _mbr_ul,
      const magma::lte::test_flat_buffer::NasTimer& _timer,
      const magma::lte::test_flat_buffer::EsmEbrTimerData& _args)
      : status_(flatbuffers::EndianScalar(static_cast<uint8_t>(_status))),
        padding0__(0),
        padding1__(0),
        padding2__(0),
        gbr_dl_(flatbuffers::EndianScalar(_gbr_dl)),
        gbr_ul_(flatbuffers::EndianScalar(_gbr_ul)),
        mbr_dl_(flatbuffers::EndianScalar(_mbr_dl)),
        mbr_ul_(flatbuffers::EndianScalar(_mbr_ul)),
        timer_(_timer),
        args_(_args) {
    (void) padding0__;
    (void) padding1__;
    (void) padding2__;
  }
  magma::lte::test_flat_buffer::EsmEbrState status() const {
    return static_cast<magma::lte::test_flat_buffer::EsmEbrState>(
        flatbuffers::EndianScalar(status_));
  }
  void mutate_status(magma::lte::test_flat_buffer::EsmEbrState _status) {
    flatbuffers::WriteScalar(&status_, static_cast<uint8_t>(_status));
  }
  uint64_t gbr_dl() const { return flatbuffers::EndianScalar(gbr_dl_); }
  void mutate_gbr_dl(uint64_t _gbr_dl) {
    flatbuffers::WriteScalar(&gbr_dl_, _gbr_dl);
  }
  uint64_t gbr_ul() const { return flatbuffers::EndianScalar(gbr_ul_); }
  void mutate_gbr_ul(uint64_t _gbr_ul) {
    flatbuffers::WriteScalar(&gbr_ul_, _gbr_ul);
  }
  uint64_t mbr_dl() const { return flatbuffers::EndianScalar(mbr_dl_); }
  void mutate_mbr_dl(uint64_t _mbr_dl) {
    flatbuffers::WriteScalar(&mbr_dl_, _mbr_dl);
  }
  uint64_t mbr_ul() const { return flatbuffers::EndianScalar(mbr_ul_); }
  void mutate_mbr_ul(uint64_t _mbr_ul) {
    flatbuffers::WriteScalar(&mbr_ul_, _mbr_ul);
  }
  const magma::lte::test_flat_buffer::NasTimer& timer() const { return timer_; }
  magma::lte::test_flat_buffer::NasTimer& mutable_timer() { return timer_; }
  const magma::lte::test_flat_buffer::EsmEbrTimerData& args() const {
    return args_;
  }
  magma::lte::test_flat_buffer::EsmEbrTimerData& mutable_args() {
    return args_;
  }
};
FLATBUFFERS_STRUCT_END(EsmEbrContext, 576);

inline bool operator==(const EsmEbrContext& lhs, const EsmEbrContext& rhs) {
  return (lhs.status() == rhs.status()) && (lhs.gbr_dl() == rhs.gbr_dl()) &&
         (lhs.gbr_ul() == rhs.gbr_ul()) && (lhs.mbr_dl() == rhs.mbr_dl()) &&
         (lhs.mbr_ul() == rhs.mbr_ul()) && (lhs.timer() == rhs.timer()) &&
         (lhs.args() == rhs.args());
}

inline bool operator!=(const EsmEbrContext& lhs, const EsmEbrContext& rhs) {
  return !(lhs == rhs);
}

}  // namespace test_flat_buffer
}  // namespace lte
}  // namespace magma

#endif  // FLATBUFFERS_GENERATED_MMENASSTATE_MAGMA_LTE_TEST_FLAT_BUFFER_H_

// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_COMMONTYPES_MAGMA_LTE_TEST_FLAT_BUFFER_H_
#define FLATBUFFERS_GENERATED_COMMONTYPES_MAGMA_LTE_TEST_FLAT_BUFFER_H_

#include "flatbuffers/flatbuffers.h"

namespace magma {
namespace lte {
namespace test_flat_buffer {

struct In6Addr;

struct Address;

struct IpAddress;

struct Ambr;

struct Fteid;

struct Paa;

struct RegionalSubscription;

struct AllocationRetentionPriority;

struct EpsSubscribedQosProfile;

struct ChargingCharacteristics;

struct ApnConfiguration;

struct ApnConfigProfile;

enum InterfaceType : uint8_t {
  InterfaceType_S1_U_ENODEB_GTP_U               = 0,
  InterfaceType_S1_U_SGW_GTP_U                  = 1,
  InterfaceType_S12_RNC_GTP_U                   = 2,
  InterfaceType_S12_SGW_GTP_U                   = 3,
  InterfaceType_S5_S8_SGW_GTP_U                 = 4,
  InterfaceType_S5_S8_PGW_GTP_U                 = 5,
  InterfaceType_S5_S8_SGW_GTP_C                 = 6,
  InterfaceType_S5_S8_PGW_GTP_C                 = 7,
  InterfaceType_S5_S8_SGW_PMIPv6                = 8,
  InterfaceType_S5_S8_PGW_PMIPv6                = 9,
  InterfaceType_S11_MME_GTP_C                   = 10,
  InterfaceType_S11_SGW_GTP_C                   = 11,
  InterfaceType_S10_MME_GTP_C                   = 12,
  InterfaceType_S3_MME_GTP_C                    = 13,
  InterfaceType_S3_SGSN_GTP_C                   = 14,
  InterfaceType_S4_SGSN_GTP_U                   = 15,
  InterfaceType_S4_SGW_GTP_U                    = 16,
  InterfaceType_S4_SGSN_GTP_C                   = 17,
  InterfaceType_S16_SGSN_GTP_C                  = 18,
  InterfaceType_ENODEB_GTP_U_DL_DATA_FORWARDING = 19,
  InterfaceType_ENODEB_GTP_U_UL_DATA_FORWARDING = 20,
  InterfaceType_RNC_GTP_U_DATA_FORWARDING       = 21,
  InterfaceType_SGSN_GTP_U_DATA_FORWARDING      = 22,
  InterfaceType_SGW_GTP_U_DL_DATA_FORWARDING    = 23,
  InterfaceType_SM_MBMS_GW_GTP_C                = 24,
  InterfaceType_SN_MBMS_GW_GTP_C                = 25,
  InterfaceType_SM_MME_GTP_C                    = 26,
  InterfaceType_SN_SGSN_GTP_C                   = 27,
  InterfaceType_SGW_GTP_U_UL_DATA_FORWARDING    = 28,
  InterfaceType_SN_SGSN_GTP_U                   = 29,
  InterfaceType_S2B_EPDG_GTP_C                  = 30,
  InterfaceType_MIN = InterfaceType_S1_U_ENODEB_GTP_U,
  InterfaceType_MAX = InterfaceType_S2B_EPDG_GTP_C
};

inline const InterfaceType (&EnumValuesInterfaceType())[31] {
  static const InterfaceType values[] = {
      InterfaceType_S1_U_ENODEB_GTP_U,
      InterfaceType_S1_U_SGW_GTP_U,
      InterfaceType_S12_RNC_GTP_U,
      InterfaceType_S12_SGW_GTP_U,
      InterfaceType_S5_S8_SGW_GTP_U,
      InterfaceType_S5_S8_PGW_GTP_U,
      InterfaceType_S5_S8_SGW_GTP_C,
      InterfaceType_S5_S8_PGW_GTP_C,
      InterfaceType_S5_S8_SGW_PMIPv6,
      InterfaceType_S5_S8_PGW_PMIPv6,
      InterfaceType_S11_MME_GTP_C,
      InterfaceType_S11_SGW_GTP_C,
      InterfaceType_S10_MME_GTP_C,
      InterfaceType_S3_MME_GTP_C,
      InterfaceType_S3_SGSN_GTP_C,
      InterfaceType_S4_SGSN_GTP_U,
      InterfaceType_S4_SGW_GTP_U,
      InterfaceType_S4_SGSN_GTP_C,
      InterfaceType_S16_SGSN_GTP_C,
      InterfaceType_ENODEB_GTP_U_DL_DATA_FORWARDING,
      InterfaceType_ENODEB_GTP_U_UL_DATA_FORWARDING,
      InterfaceType_RNC_GTP_U_DATA_FORWARDING,
      InterfaceType_SGSN_GTP_U_DATA_FORWARDING,
      InterfaceType_SGW_GTP_U_DL_DATA_FORWARDING,
      InterfaceType_SM_MBMS_GW_GTP_C,
      InterfaceType_SN_MBMS_GW_GTP_C,
      InterfaceType_SM_MME_GTP_C,
      InterfaceType_SN_SGSN_GTP_C,
      InterfaceType_SGW_GTP_U_UL_DATA_FORWARDING,
      InterfaceType_SN_SGSN_GTP_U,
      InterfaceType_S2B_EPDG_GTP_C};
  return values;
}

inline const char* const* EnumNamesInterfaceType() {
  static const char* const names[32] = {"S1_U_ENODEB_GTP_U",
                                        "S1_U_SGW_GTP_U",
                                        "S12_RNC_GTP_U",
                                        "S12_SGW_GTP_U",
                                        "S5_S8_SGW_GTP_U",
                                        "S5_S8_PGW_GTP_U",
                                        "S5_S8_SGW_GTP_C",
                                        "S5_S8_PGW_GTP_C",
                                        "S5_S8_SGW_PMIPv6",
                                        "S5_S8_PGW_PMIPv6",
                                        "S11_MME_GTP_C",
                                        "S11_SGW_GTP_C",
                                        "S10_MME_GTP_C",
                                        "S3_MME_GTP_C",
                                        "S3_SGSN_GTP_C",
                                        "S4_SGSN_GTP_U",
                                        "S4_SGW_GTP_U",
                                        "S4_SGSN_GTP_C",
                                        "S16_SGSN_GTP_C",
                                        "ENODEB_GTP_U_DL_DATA_FORWARDING",
                                        "ENODEB_GTP_U_UL_DATA_FORWARDING",
                                        "RNC_GTP_U_DATA_FORWARDING",
                                        "SGSN_GTP_U_DATA_FORWARDING",
                                        "SGW_GTP_U_DL_DATA_FORWARDING",
                                        "SM_MBMS_GW_GTP_C",
                                        "SN_MBMS_GW_GTP_C",
                                        "SM_MME_GTP_C",
                                        "SN_SGSN_GTP_C",
                                        "SGW_GTP_U_UL_DATA_FORWARDING",
                                        "SN_SGSN_GTP_U",
                                        "S2B_EPDG_GTP_C",
                                        nullptr};
  return names;
}

inline const char* EnumNameInterfaceType(InterfaceType e) {
  if (flatbuffers::IsOutRange(
          e, InterfaceType_S1_U_ENODEB_GTP_U, InterfaceType_S2B_EPDG_GTP_C))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesInterfaceType()[index];
}

enum GrantedService : uint8_t {
  GrantedService_GRANTED_SERVICE_EPS_ONLY = 0,
  GrantedService_GRANTED_SERVICE_SMS_ONLY = 1,
  GrantedService_GRANTED_SERVICE_CSFB_SMS = 2,
  GrantedService_MIN = GrantedService_GRANTED_SERVICE_EPS_ONLY,
  GrantedService_MAX = GrantedService_GRANTED_SERVICE_CSFB_SMS
};

inline const GrantedService (&EnumValuesGrantedService())[3] {
  static const GrantedService values[] = {
      GrantedService_GRANTED_SERVICE_EPS_ONLY,
      GrantedService_GRANTED_SERVICE_SMS_ONLY,
      GrantedService_GRANTED_SERVICE_CSFB_SMS};
  return values;
}

inline const char* const* EnumNamesGrantedService() {
  static const char* const names[4] = {"GRANTED_SERVICE_EPS_ONLY",
                                       "GRANTED_SERVICE_SMS_ONLY",
                                       "GRANTED_SERVICE_CSFB_SMS", nullptr};
  return names;
}

inline const char* EnumNameGrantedService(GrantedService e) {
  if (flatbuffers::IsOutRange(
          e, GrantedService_GRANTED_SERVICE_EPS_ONLY,
          GrantedService_GRANTED_SERVICE_CSFB_SMS))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesGrantedService()[index];
}

enum SubscriberStatus : uint8_t {
  SubscriberStatus_SS_SERVICE_GRANTED             = 0,
  SubscriberStatus_SS_OPERATOR_DETERMINED_BARRING = 1,
  SubscriberStatus_SS_MAX                         = 2,
  SubscriberStatus_MIN = SubscriberStatus_SS_SERVICE_GRANTED,
  SubscriberStatus_MAX = SubscriberStatus_SS_MAX
};

inline const SubscriberStatus (&EnumValuesSubscriberStatus())[3] {
  static const SubscriberStatus values[] = {
      SubscriberStatus_SS_SERVICE_GRANTED,
      SubscriberStatus_SS_OPERATOR_DETERMINED_BARRING, SubscriberStatus_SS_MAX};
  return values;
}

inline const char* const* EnumNamesSubscriberStatus() {
  static const char* const names[4] = {"SS_SERVICE_GRANTED",
                                       "SS_OPERATOR_DETERMINED_BARRING",
                                       "SS_MAX", nullptr};
  return names;
}

inline const char* EnumNameSubscriberStatus(SubscriberStatus e) {
  if (flatbuffers::IsOutRange(
          e, SubscriberStatus_SS_SERVICE_GRANTED, SubscriberStatus_SS_MAX))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSubscriberStatus()[index];
}

enum PdnTypeValue : uint8_t {
  PdnTypeValue_IPv4        = 0,
  PdnTypeValue_IPv6        = 1,
  PdnTypeValue_IPv4_AND_v6 = 2,
  PdnTypeValue_IPv4_OR_v6  = 3,
  PdnTypeValue_IP_MAX      = 4,
  PdnTypeValue_MIN         = PdnTypeValue_IPv4,
  PdnTypeValue_MAX         = PdnTypeValue_IP_MAX
};

inline const PdnTypeValue (&EnumValuesPdnTypeValue())[5] {
  static const PdnTypeValue values[] = {
      PdnTypeValue_IPv4, PdnTypeValue_IPv6, PdnTypeValue_IPv4_AND_v6,
      PdnTypeValue_IPv4_OR_v6, PdnTypeValue_IP_MAX};
  return values;
}

inline const char* const* EnumNamesPdnTypeValue() {
  static const char* const names[6] = {"IPv4",       "IPv6",   "IPv4_AND_v6",
                                       "IPv4_OR_v6", "IP_MAX", nullptr};
  return names;
}

inline const char* EnumNamePdnTypeValue(PdnTypeValue e) {
  if (flatbuffers::IsOutRange(e, PdnTypeValue_IPv4, PdnTypeValue_IP_MAX))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPdnTypeValue()[index];
}

enum ApnAmbrBitRateUnit : uint8_t {
  ApnAmbrBitRateUnit_BPS  = 0,
  ApnAmbrBitRateUnit_KBPS = 1,
  ApnAmbrBitRateUnit_MIN  = ApnAmbrBitRateUnit_BPS,
  ApnAmbrBitRateUnit_MAX  = ApnAmbrBitRateUnit_KBPS
};

inline const ApnAmbrBitRateUnit (&EnumValuesApnAmbrBitRateUnit())[2] {
  static const ApnAmbrBitRateUnit values[] = {ApnAmbrBitRateUnit_BPS,
                                              ApnAmbrBitRateUnit_KBPS};
  return values;
}

inline const char* const* EnumNamesApnAmbrBitRateUnit() {
  static const char* const names[3] = {"BPS", "KBPS", nullptr};
  return names;
}

inline const char* EnumNameApnAmbrBitRateUnit(ApnAmbrBitRateUnit e) {
  if (flatbuffers::IsOutRange(
          e, ApnAmbrBitRateUnit_BPS, ApnAmbrBitRateUnit_KBPS))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesApnAmbrBitRateUnit()[index];
}

enum PreEmptionVulnerability : uint8_t {
  PreEmptionVulnerability_PRE_EMPTION_VULNERABILITY_ENABLED  = 0,
  PreEmptionVulnerability_PRE_EMPTION_VULNERABILITY_DISABLED = 1,
  PreEmptionVulnerability_PRE_EMPTION_VULNERABILITY_MAX      = 2,
  PreEmptionVulnerability_MIN =
      PreEmptionVulnerability_PRE_EMPTION_VULNERABILITY_ENABLED,
  PreEmptionVulnerability_MAX =
      PreEmptionVulnerability_PRE_EMPTION_VULNERABILITY_MAX
};

inline const PreEmptionVulnerability (&EnumValuesPreEmptionVulnerability())[3] {
  static const PreEmptionVulnerability values[] = {
      PreEmptionVulnerability_PRE_EMPTION_VULNERABILITY_ENABLED,
      PreEmptionVulnerability_PRE_EMPTION_VULNERABILITY_DISABLED,
      PreEmptionVulnerability_PRE_EMPTION_VULNERABILITY_MAX};
  return values;
}

inline const char* const* EnumNamesPreEmptionVulnerability() {
  static const char* const names[4] = {
      "PRE_EMPTION_VULNERABILITY_ENABLED", "PRE_EMPTION_VULNERABILITY_DISABLED",
      "PRE_EMPTION_VULNERABILITY_MAX", nullptr};
  return names;
}

inline const char* EnumNamePreEmptionVulnerability(PreEmptionVulnerability e) {
  if (flatbuffers::IsOutRange(
          e, PreEmptionVulnerability_PRE_EMPTION_VULNERABILITY_ENABLED,
          PreEmptionVulnerability_PRE_EMPTION_VULNERABILITY_MAX))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPreEmptionVulnerability()[index];
}

enum PreEmptionCapability : uint8_t {
  PreEmptionCapability_PRE_EMPTION_CAPABILITY_ENABLED  = 0,
  PreEmptionCapability_PRE_EMPTION_CAPABILITY_DISABLED = 1,
  PreEmptionCapability_PRE_EMPTION_CAPABILITY_MAX      = 2,
  PreEmptionCapability_MIN =
      PreEmptionCapability_PRE_EMPTION_CAPABILITY_ENABLED,
  PreEmptionCapability_MAX = PreEmptionCapability_PRE_EMPTION_CAPABILITY_MAX
};

inline const PreEmptionCapability (&EnumValuesPreEmptionCapability())[3] {
  static const PreEmptionCapability values[] = {
      PreEmptionCapability_PRE_EMPTION_CAPABILITY_ENABLED,
      PreEmptionCapability_PRE_EMPTION_CAPABILITY_DISABLED,
      PreEmptionCapability_PRE_EMPTION_CAPABILITY_MAX};
  return values;
}

inline const char* const* EnumNamesPreEmptionCapability() {
  static const char* const names[4] = {"PRE_EMPTION_CAPABILITY_ENABLED",
                                       "PRE_EMPTION_CAPABILITY_DISABLED",
                                       "PRE_EMPTION_CAPABILITY_MAX", nullptr};
  return names;
}

inline const char* EnumNamePreEmptionCapability(PreEmptionCapability e) {
  if (flatbuffers::IsOutRange(
          e, PreEmptionCapability_PRE_EMPTION_CAPABILITY_ENABLED,
          PreEmptionCapability_PRE_EMPTION_CAPABILITY_MAX))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPreEmptionCapability()[index];
}

enum AllApnConfInd : uint8_t {
  AllApnConfInd_ALL_APN_CONFIGURATIONS_INCLUDED            = 0,
  AllApnConfInd_MODIFIED_ADDED_APN_CONFIGURATIONS_INCLUDED = 1,
  AllApnConfInd_ALL_APN_MAX                                = 2,
  AllApnConfInd_MIN = AllApnConfInd_ALL_APN_CONFIGURATIONS_INCLUDED,
  AllApnConfInd_MAX = AllApnConfInd_ALL_APN_MAX
};

inline const AllApnConfInd (&EnumValuesAllApnConfInd())[3] {
  static const AllApnConfInd values[] = {
      AllApnConfInd_ALL_APN_CONFIGURATIONS_INCLUDED,
      AllApnConfInd_MODIFIED_ADDED_APN_CONFIGURATIONS_INCLUDED,
      AllApnConfInd_ALL_APN_MAX};
  return values;
}

inline const char* const* EnumNamesAllApnConfInd() {
  static const char* const names[4] = {
      "ALL_APN_CONFIGURATIONS_INCLUDED",
      "MODIFIED_ADDED_APN_CONFIGURATIONS_INCLUDED", "ALL_APN_MAX", nullptr};
  return names;
}

inline const char* EnumNameAllApnConfInd(AllApnConfInd e) {
  if (flatbuffers::IsOutRange(
          e, AllApnConfInd_ALL_APN_CONFIGURATIONS_INCLUDED,
          AllApnConfInd_ALL_APN_MAX))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAllApnConfInd()[index];
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(1) In6Addr FLATBUFFERS_FINAL_CLASS {
 private:
  int8_t u6_addr8_[16];

 public:
  In6Addr() : u6_addr8_() {}
  In6Addr(flatbuffers::span<const int8_t, 16> _u6_addr8) {
    flatbuffers::CastToArray(u6_addr8_).CopyFromSpan(_u6_addr8);
  }
  const flatbuffers::Array<int8_t, 16>* u6_addr8() const {
    return &flatbuffers::CastToArray(u6_addr8_);
  }
  flatbuffers::Array<int8_t, 16>* mutable_u6_addr8() {
    return &flatbuffers::CastToArray(u6_addr8_);
  }
};
FLATBUFFERS_STRUCT_END(In6Addr, 16);

inline bool operator==(const In6Addr& lhs, const In6Addr& rhs) {
  return (lhs.u6_addr8() == rhs.u6_addr8());
}

inline bool operator!=(const In6Addr& lhs, const In6Addr& rhs) {
  return !(lhs == rhs);
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Address FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t ipv4_address_in_addr_;
  magma::lte::test_flat_buffer::In6Addr ipv6_address_;

 public:
  Address() : ipv4_address_in_addr_(0), ipv6_address_() {}
  Address(
      uint32_t _ipv4_address_in_addr,
      const magma::lte::test_flat_buffer::In6Addr& _ipv6_address)
      : ipv4_address_in_addr_(flatbuffers::EndianScalar(_ipv4_address_in_addr)),
        ipv6_address_(_ipv6_address) {}
  uint32_t ipv4_address_in_addr() const {
    return flatbuffers::EndianScalar(ipv4_address_in_addr_);
  }
  void mutate_ipv4_address_in_addr(uint32_t _ipv4_address_in_addr) {
    flatbuffers::WriteScalar(&ipv4_address_in_addr_, _ipv4_address_in_addr);
  }
  const magma::lte::test_flat_buffer::In6Addr& ipv6_address() const {
    return ipv6_address_;
  }
  magma::lte::test_flat_buffer::In6Addr& mutable_ipv6_address() {
    return ipv6_address_;
  }
};
FLATBUFFERS_STRUCT_END(Address, 20);

inline bool operator==(const Address& lhs, const Address& rhs) {
  return (lhs.ipv4_address_in_addr() == rhs.ipv4_address_in_addr()) &&
         (lhs.ipv6_address() == rhs.ipv6_address());
}

inline bool operator!=(const Address& lhs, const Address& rhs) {
  return !(lhs == rhs);
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) IpAddress FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t pdn_type_;
  int8_t padding0__;
  int16_t padding1__;
  magma::lte::test_flat_buffer::Address address_;

 public:
  IpAddress() : pdn_type_(0), padding0__(0), padding1__(0), address_() {
    (void) padding0__;
    (void) padding1__;
  }
  IpAddress(
      magma::lte::test_flat_buffer::PdnTypeValue _pdn_type,
      const magma::lte::test_flat_buffer::Address& _address)
      : pdn_type_(flatbuffers::EndianScalar(static_cast<uint8_t>(_pdn_type))),
        padding0__(0),
        padding1__(0),
        address_(_address) {
    (void) padding0__;
    (void) padding1__;
  }
  magma::lte::test_flat_buffer::PdnTypeValue pdn_type() const {
    return static_cast<magma::lte::test_flat_buffer::PdnTypeValue>(
        flatbuffers::EndianScalar(pdn_type_));
  }
  void mutate_pdn_type(magma::lte::test_flat_buffer::PdnTypeValue _pdn_type) {
    flatbuffers::WriteScalar(&pdn_type_, static_cast<uint8_t>(_pdn_type));
  }
  const magma::lte::test_flat_buffer::Address& address() const {
    return address_;
  }
  magma::lte::test_flat_buffer::Address& mutable_address() { return address_; }
};
FLATBUFFERS_STRUCT_END(IpAddress, 24);

inline bool operator==(const IpAddress& lhs, const IpAddress& rhs) {
  return (lhs.pdn_type() == rhs.pdn_type()) && (lhs.address() == rhs.address());
}

inline bool operator!=(const IpAddress& lhs, const IpAddress& rhs) {
  return !(lhs == rhs);
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) Ambr FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t br_unit_;
  int8_t padding0__;
  int16_t padding1__;
  int32_t padding2__;
  uint64_t br_ul_;
  uint64_t br_dl_;

 public:
  Ambr()
      : br_unit_(0),
        padding0__(0),
        padding1__(0),
        padding2__(0),
        br_ul_(0),
        br_dl_(0) {
    (void) padding0__;
    (void) padding1__;
    (void) padding2__;
  }
  Ambr(
      magma::lte::test_flat_buffer::ApnAmbrBitRateUnit _br_unit,
      uint64_t _br_ul, uint64_t _br_dl)
      : br_unit_(flatbuffers::EndianScalar(static_cast<uint8_t>(_br_unit))),
        padding0__(0),
        padding1__(0),
        padding2__(0),
        br_ul_(flatbuffers::EndianScalar(_br_ul)),
        br_dl_(flatbuffers::EndianScalar(_br_dl)) {
    (void) padding0__;
    (void) padding1__;
    (void) padding2__;
  }
  magma::lte::test_flat_buffer::ApnAmbrBitRateUnit br_unit() const {
    return static_cast<magma::lte::test_flat_buffer::ApnAmbrBitRateUnit>(
        flatbuffers::EndianScalar(br_unit_));
  }
  void mutate_br_unit(
      magma::lte::test_flat_buffer::ApnAmbrBitRateUnit _br_unit) {
    flatbuffers::WriteScalar(&br_unit_, static_cast<uint8_t>(_br_unit));
  }
  uint64_t br_ul() const { return flatbuffers::EndianScalar(br_ul_); }
  void mutate_br_ul(uint64_t _br_ul) {
    flatbuffers::WriteScalar(&br_ul_, _br_ul);
  }
  uint64_t br_dl() const { return flatbuffers::EndianScalar(br_dl_); }
  void mutate_br_dl(uint64_t _br_dl) {
    flatbuffers::WriteScalar(&br_dl_, _br_dl);
  }
};
FLATBUFFERS_STRUCT_END(Ambr, 24);

inline bool operator==(const Ambr& lhs, const Ambr& rhs) {
  return (lhs.br_unit() == rhs.br_unit()) && (lhs.br_ul() == rhs.br_ul()) &&
         (lhs.br_dl() == rhs.br_dl());
}

inline bool operator!=(const Ambr& lhs, const Ambr& rhs) {
  return !(lhs == rhs);
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Fteid FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t ipv4_;
  uint8_t ipv6_;
  uint8_t interface_type_;
  int8_t padding0__;
  uint32_t teid_;
  magma::lte::test_flat_buffer::Address ip_address_;

 public:
  Fteid()
      : ipv4_(0),
        ipv6_(0),
        interface_type_(0),
        padding0__(0),
        teid_(0),
        ip_address_() {
    (void) padding0__;
  }
  Fteid(
      bool _ipv4, bool _ipv6,
      magma::lte::test_flat_buffer::InterfaceType _interface_type,
      uint32_t _teid, const magma::lte::test_flat_buffer::Address& _ip_address)
      : ipv4_(flatbuffers::EndianScalar(static_cast<uint8_t>(_ipv4))),
        ipv6_(flatbuffers::EndianScalar(static_cast<uint8_t>(_ipv6))),
        interface_type_(
            flatbuffers::EndianScalar(static_cast<uint8_t>(_interface_type))),
        padding0__(0),
        teid_(flatbuffers::EndianScalar(_teid)),
        ip_address_(_ip_address) {
    (void) padding0__;
  }
  bool ipv4() const { return flatbuffers::EndianScalar(ipv4_) != 0; }
  void mutate_ipv4(bool _ipv4) {
    flatbuffers::WriteScalar(&ipv4_, static_cast<uint8_t>(_ipv4));
  }
  bool ipv6() const { return flatbuffers::EndianScalar(ipv6_) != 0; }
  void mutate_ipv6(bool _ipv6) {
    flatbuffers::WriteScalar(&ipv6_, static_cast<uint8_t>(_ipv6));
  }
  magma::lte::test_flat_buffer::InterfaceType interface_type() const {
    return static_cast<magma::lte::test_flat_buffer::InterfaceType>(
        flatbuffers::EndianScalar(interface_type_));
  }
  void mutate_interface_type(
      magma::lte::test_flat_buffer::InterfaceType _interface_type) {
    flatbuffers::WriteScalar(
        &interface_type_, static_cast<uint8_t>(_interface_type));
  }
  uint32_t teid() const { return flatbuffers::EndianScalar(teid_); }
  void mutate_teid(uint32_t _teid) { flatbuffers::WriteScalar(&teid_, _teid); }
  const magma::lte::test_flat_buffer::Address& ip_address() const {
    return ip_address_;
  }
  magma::lte::test_flat_buffer::Address& mutable_ip_address() {
    return ip_address_;
  }
};
FLATBUFFERS_STRUCT_END(Fteid, 28);

inline bool operator==(const Fteid& lhs, const Fteid& rhs) {
  return (lhs.ipv4() == rhs.ipv4()) && (lhs.ipv6() == rhs.ipv6()) &&
         (lhs.interface_type() == rhs.interface_type()) &&
         (lhs.teid() == rhs.teid()) && (lhs.ip_address() == rhs.ip_address());
}

inline bool operator!=(const Fteid& lhs, const Fteid& rhs) {
  return !(lhs == rhs);
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Paa FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t pdn_type_;
  int8_t padding0__;
  int16_t padding1__;
  uint32_t ipv4_address_;
  magma::lte::test_flat_buffer::In6Addr ipv6_address_;
  uint8_t ipv6_prefix_length_;
  int8_t padding2__;
  int16_t padding3__;
  uint32_t vlan_;

 public:
  Paa()
      : pdn_type_(0),
        padding0__(0),
        padding1__(0),
        ipv4_address_(0),
        ipv6_address_(),
        ipv6_prefix_length_(0),
        padding2__(0),
        padding3__(0),
        vlan_(0) {
    (void) padding0__;
    (void) padding1__;
    (void) padding2__;
    (void) padding3__;
  }
  Paa(magma::lte::test_flat_buffer::PdnTypeValue _pdn_type,
      uint32_t _ipv4_address,
      const magma::lte::test_flat_buffer::In6Addr& _ipv6_address,
      uint8_t _ipv6_prefix_length, uint32_t _vlan)
      : pdn_type_(flatbuffers::EndianScalar(static_cast<uint8_t>(_pdn_type))),
        padding0__(0),
        padding1__(0),
        ipv4_address_(flatbuffers::EndianScalar(_ipv4_address)),
        ipv6_address_(_ipv6_address),
        ipv6_prefix_length_(flatbuffers::EndianScalar(_ipv6_prefix_length)),
        padding2__(0),
        padding3__(0),
        vlan_(flatbuffers::EndianScalar(_vlan)) {
    (void) padding0__;
    (void) padding1__;
    (void) padding2__;
    (void) padding3__;
  }
  magma::lte::test_flat_buffer::PdnTypeValue pdn_type() const {
    return static_cast<magma::lte::test_flat_buffer::PdnTypeValue>(
        flatbuffers::EndianScalar(pdn_type_));
  }
  void mutate_pdn_type(magma::lte::test_flat_buffer::PdnTypeValue _pdn_type) {
    flatbuffers::WriteScalar(&pdn_type_, static_cast<uint8_t>(_pdn_type));
  }
  uint32_t ipv4_address() const {
    return flatbuffers::EndianScalar(ipv4_address_);
  }
  void mutate_ipv4_address(uint32_t _ipv4_address) {
    flatbuffers::WriteScalar(&ipv4_address_, _ipv4_address);
  }
  const magma::lte::test_flat_buffer::In6Addr& ipv6_address() const {
    return ipv6_address_;
  }
  magma::lte::test_flat_buffer::In6Addr& mutable_ipv6_address() {
    return ipv6_address_;
  }
  /// Note in rel.8 the ipv6 prefix length has a fixed value of /64
  uint8_t ipv6_prefix_length() const {
    return flatbuffers::EndianScalar(ipv6_prefix_length_);
  }
  void mutate_ipv6_prefix_length(uint8_t _ipv6_prefix_length) {
    flatbuffers::WriteScalar(&ipv6_prefix_length_, _ipv6_prefix_length);
  }
  uint32_t vlan() const { return flatbuffers::EndianScalar(vlan_); }
  void mutate_vlan(uint32_t _vlan) { flatbuffers::WriteScalar(&vlan_, _vlan); }
};
FLATBUFFERS_STRUCT_END(Paa, 32);

inline bool operator==(const Paa& lhs, const Paa& rhs) {
  return (lhs.pdn_type() == rhs.pdn_type()) &&
         (lhs.ipv4_address() == rhs.ipv4_address()) &&
         (lhs.ipv6_address() == rhs.ipv6_address()) &&
         (lhs.ipv6_prefix_length() == rhs.ipv6_prefix_length()) &&
         (lhs.vlan() == rhs.vlan());
}

inline bool operator!=(const Paa& lhs, const Paa& rhs) {
  return !(lhs == rhs);
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(1)
RegionalSubscription FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t zone_code_[2];

 public:
  RegionalSubscription() : zone_code_() {}
  RegionalSubscription(flatbuffers::span<const uint8_t, 2> _zone_code) {
    flatbuffers::CastToArray(zone_code_).CopyFromSpan(_zone_code);
  }
  const flatbuffers::Array<uint8_t, 2>* zone_code() const {
    return &flatbuffers::CastToArray(zone_code_);
  }
  flatbuffers::Array<uint8_t, 2>* mutable_zone_code() {
    return &flatbuffers::CastToArray(zone_code_);
  }
};
FLATBUFFERS_STRUCT_END(RegionalSubscription, 2);

inline bool operator==(
    const RegionalSubscription& lhs, const RegionalSubscription& rhs) {
  return (lhs.zone_code() == rhs.zone_code());
}

inline bool operator!=(
    const RegionalSubscription& lhs, const RegionalSubscription& rhs) {
  return !(lhs == rhs);
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(1)
AllocationRetentionPriority FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t priority_level_;
  uint8_t pre_emp_vulnerability_;
  uint8_t pre_emp_capability_;

 public:
  AllocationRetentionPriority()
      : priority_level_(0), pre_emp_vulnerability_(0), pre_emp_capability_(0) {}
  AllocationRetentionPriority(
      uint8_t _priority_level,
      magma::lte::test_flat_buffer::PreEmptionVulnerability
          _pre_emp_vulnerability,
      magma::lte::test_flat_buffer::PreEmptionCapability _pre_emp_capability)
      : priority_level_(flatbuffers::EndianScalar(_priority_level)),
        pre_emp_vulnerability_(flatbuffers::EndianScalar(
            static_cast<uint8_t>(_pre_emp_vulnerability))),
        pre_emp_capability_(flatbuffers::EndianScalar(
            static_cast<uint8_t>(_pre_emp_capability))) {}
  uint8_t priority_level() const {
    return flatbuffers::EndianScalar(priority_level_);
  }
  void mutate_priority_level(uint8_t _priority_level) {
    flatbuffers::WriteScalar(&priority_level_, _priority_level);
  }
  magma::lte::test_flat_buffer::PreEmptionVulnerability pre_emp_vulnerability()
      const {
    return static_cast<magma::lte::test_flat_buffer::PreEmptionVulnerability>(
        flatbuffers::EndianScalar(pre_emp_vulnerability_));
  }
  void mutate_pre_emp_vulnerability(
      magma::lte::test_flat_buffer::PreEmptionVulnerability
          _pre_emp_vulnerability) {
    flatbuffers::WriteScalar(
        &pre_emp_vulnerability_, static_cast<uint8_t>(_pre_emp_vulnerability));
  }
  magma::lte::test_flat_buffer::PreEmptionCapability pre_emp_capability()
      const {
    return static_cast<magma::lte::test_flat_buffer::PreEmptionCapability>(
        flatbuffers::EndianScalar(pre_emp_capability_));
  }
  void mutate_pre_emp_capability(
      magma::lte::test_flat_buffer::PreEmptionCapability _pre_emp_capability) {
    flatbuffers::WriteScalar(
        &pre_emp_capability_, static_cast<uint8_t>(_pre_emp_capability));
  }
};
FLATBUFFERS_STRUCT_END(AllocationRetentionPriority, 3);

inline bool operator==(
    const AllocationRetentionPriority& lhs,
    const AllocationRetentionPriority& rhs) {
  return (lhs.priority_level() == rhs.priority_level()) &&
         (lhs.pre_emp_vulnerability() == rhs.pre_emp_vulnerability()) &&
         (lhs.pre_emp_capability() == rhs.pre_emp_capability());
}

inline bool operator!=(
    const AllocationRetentionPriority& lhs,
    const AllocationRetentionPriority& rhs) {
  return !(lhs == rhs);
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(1)
EpsSubscribedQosProfile FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t qci_;
  magma::lte::test_flat_buffer::AllocationRetentionPriority
      allocation_retention_priority_;

 public:
  EpsSubscribedQosProfile() : qci_(0), allocation_retention_priority_() {}
  EpsSubscribedQosProfile(
      uint8_t _qci,
      const magma::lte::test_flat_buffer::AllocationRetentionPriority&
          _allocation_retention_priority)
      : qci_(flatbuffers::EndianScalar(_qci)),
        allocation_retention_priority_(_allocation_retention_priority) {}
  uint8_t qci() const { return flatbuffers::EndianScalar(qci_); }
  void mutate_qci(uint8_t _qci) { flatbuffers::WriteScalar(&qci_, _qci); }
  const magma::lte::test_flat_buffer::AllocationRetentionPriority&
  allocation_retention_priority() const {
    return allocation_retention_priority_;
  }
  magma::lte::test_flat_buffer::AllocationRetentionPriority&
  mutable_allocation_retention_priority() {
    return allocation_retention_priority_;
  }
};
FLATBUFFERS_STRUCT_END(EpsSubscribedQosProfile, 4);

inline bool operator==(
    const EpsSubscribedQosProfile& lhs, const EpsSubscribedQosProfile& rhs) {
  return (lhs.qci() == rhs.qci()) && (lhs.allocation_retention_priority() ==
                                      rhs.allocation_retention_priority());
}

inline bool operator!=(
    const EpsSubscribedQosProfile& lhs, const EpsSubscribedQosProfile& rhs) {
  return !(lhs == rhs);
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(1)
ChargingCharacteristics FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t value_[5];
  uint8_t length_;

 public:
  ChargingCharacteristics() : value_(), length_(0) {}
  ChargingCharacteristics(uint8_t _length)
      : value_(), length_(flatbuffers::EndianScalar(_length)) {}
  ChargingCharacteristics(
      flatbuffers::span<const uint8_t, 5> _value, uint8_t _length)
      : length_(flatbuffers::EndianScalar(_length)) {
    flatbuffers::CastToArray(value_).CopyFromSpan(_value);
  }
  /// CHARGING_CHARACTERISTICS_LENGTH + 1
  const flatbuffers::Array<uint8_t, 5>* value() const {
    return &flatbuffers::CastToArray(value_);
  }
  flatbuffers::Array<uint8_t, 5>* mutable_value() {
    return &flatbuffers::CastToArray(value_);
  }
  uint8_t length() const { return flatbuffers::EndianScalar(length_); }
  void mutate_length(uint8_t _length) {
    flatbuffers::WriteScalar(&length_, _length);
  }
};
FLATBUFFERS_STRUCT_END(ChargingCharacteristics, 6);

inline bool operator==(
    const ChargingCharacteristics& lhs, const ChargingCharacteristics& rhs) {
  return (lhs.value() == rhs.value()) && (lhs.length() == rhs.length());
}

inline bool operator!=(
    const ChargingCharacteristics& lhs, const ChargingCharacteristics& rhs) {
  return !(lhs == rhs);
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8)
ApnConfiguration FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t context_identifier_;
  uint8_t nb_ip_address_;
  int8_t padding0__;
  int16_t padding1__;
  magma::lte::test_flat_buffer::IpAddress ip_address_[2];
  uint8_t pdn_type_;
  int8_t service_selection_[100];
  int8_t service_selection_length_;
  magma::lte::test_flat_buffer::EpsSubscribedQosProfile subscribed_qos_;
  int16_t padding2__;
  int32_t padding3__;
  magma::lte::test_flat_buffer::Ambr ambr_;
  magma::lte::test_flat_buffer::ChargingCharacteristics
      charging_characteristics_;
  int16_t padding4__;

 public:
  ApnConfiguration()
      : context_identifier_(0),
        nb_ip_address_(0),
        padding0__(0),
        padding1__(0),
        ip_address_(),
        pdn_type_(0),
        service_selection_(),
        service_selection_length_(0),
        subscribed_qos_(),
        padding2__(0),
        padding3__(0),
        ambr_(),
        charging_characteristics_(),
        padding4__(0) {
    (void) padding0__;
    (void) padding1__;
    (void) padding2__;
    (void) padding3__;
    (void) padding4__;
  }
  ApnConfiguration(
      uint32_t _context_identifier, uint8_t _nb_ip_address,
      magma::lte::test_flat_buffer::PdnTypeValue _pdn_type,
      int8_t _service_selection_length,
      const magma::lte::test_flat_buffer::EpsSubscribedQosProfile&
          _subscribed_qos,
      const magma::lte::test_flat_buffer::Ambr& _ambr,
      const magma::lte::test_flat_buffer::ChargingCharacteristics&
          _charging_characteristics)
      : context_identifier_(flatbuffers::EndianScalar(_context_identifier)),
        nb_ip_address_(flatbuffers::EndianScalar(_nb_ip_address)),
        padding0__(0),
        padding1__(0),
        ip_address_(),
        pdn_type_(flatbuffers::EndianScalar(static_cast<uint8_t>(_pdn_type))),
        service_selection_(),
        service_selection_length_(
            flatbuffers::EndianScalar(_service_selection_length)),
        subscribed_qos_(_subscribed_qos),
        padding2__(0),
        padding3__(0),
        ambr_(_ambr),
        charging_characteristics_(_charging_characteristics),
        padding4__(0) {
    (void) padding0__;
    (void) padding1__;
    (void) padding2__;
    (void) padding3__;
    (void) padding4__;
  }
  ApnConfiguration(
      uint32_t _context_identifier, uint8_t _nb_ip_address,
      flatbuffers::span<const magma::lte::test_flat_buffer::IpAddress, 2>
          _ip_address,
      magma::lte::test_flat_buffer::PdnTypeValue _pdn_type,
      flatbuffers::span<const int8_t, 100> _service_selection,
      int8_t _service_selection_length,
      const magma::lte::test_flat_buffer::EpsSubscribedQosProfile&
          _subscribed_qos,
      const magma::lte::test_flat_buffer::Ambr& _ambr,
      const magma::lte::test_flat_buffer::ChargingCharacteristics&
          _charging_characteristics)
      : context_identifier_(flatbuffers::EndianScalar(_context_identifier)),
        nb_ip_address_(flatbuffers::EndianScalar(_nb_ip_address)),
        padding0__(0),
        padding1__(0),
        pdn_type_(flatbuffers::EndianScalar(static_cast<uint8_t>(_pdn_type))),
        service_selection_length_(
            flatbuffers::EndianScalar(_service_selection_length)),
        subscribed_qos_(_subscribed_qos),
        padding2__(0),
        padding3__(0),
        ambr_(_ambr),
        charging_characteristics_(_charging_characteristics),
        padding4__(0) {
    (void) padding0__;
    (void) padding1__;
    flatbuffers::CastToArray(ip_address_).CopyFromSpan(_ip_address);
    flatbuffers::CastToArray(service_selection_)
        .CopyFromSpan(_service_selection);
    (void) padding2__;
    (void) padding3__;
    (void) padding4__;
  }
  uint32_t context_identifier() const {
    return flatbuffers::EndianScalar(context_identifier_);
  }
  void mutate_context_identifier(uint32_t _context_identifier) {
    flatbuffers::WriteScalar(&context_identifier_, _context_identifier);
  }
  /// Each APN configuration can have 0, 1, or 2 ip address:
  ///  - 0 means subscribed is dynamically allocated by P-GW depending on the
  ///  pdn_type
  ///  - 1 Only one type of IP address is returned by HSS
  ///  - 2 IPv4 and IPv6 address are returned by HSS and are statically
  /// allocated
  uint8_t nb_ip_address() const {
    return flatbuffers::EndianScalar(nb_ip_address_);
  }
  void mutate_nb_ip_address(uint8_t _nb_ip_address) {
    flatbuffers::WriteScalar(&nb_ip_address_, _nb_ip_address);
  }
  const flatbuffers::Array<magma::lte::test_flat_buffer::IpAddress, 2>*
  ip_address() const {
    return &flatbuffers::CastToArray(ip_address_);
  }
  flatbuffers::Array<magma::lte::test_flat_buffer::IpAddress, 2>*
  mutable_ip_address() {
    return &flatbuffers::CastToArray(ip_address_);
  }
  magma::lte::test_flat_buffer::PdnTypeValue pdn_type() const {
    return static_cast<magma::lte::test_flat_buffer::PdnTypeValue>(
        flatbuffers::EndianScalar(pdn_type_));
  }
  void mutate_pdn_type(magma::lte::test_flat_buffer::PdnTypeValue _pdn_type) {
    flatbuffers::WriteScalar(&pdn_type_, static_cast<uint8_t>(_pdn_type));
  }
  const flatbuffers::Array<int8_t, 100>* service_selection() const {
    return &flatbuffers::CastToArray(service_selection_);
  }
  flatbuffers::Array<int8_t, 100>* mutable_service_selection() {
    return &flatbuffers::CastToArray(service_selection_);
  }
  int8_t service_selection_length() const {
    return flatbuffers::EndianScalar(service_selection_length_);
  }
  void mutate_service_selection_length(int8_t _service_selection_length) {
    flatbuffers::WriteScalar(
        &service_selection_length_, _service_selection_length);
  }
  const magma::lte::test_flat_buffer::EpsSubscribedQosProfile& subscribed_qos()
      const {
    return subscribed_qos_;
  }
  magma::lte::test_flat_buffer::EpsSubscribedQosProfile&
  mutable_subscribed_qos() {
    return subscribed_qos_;
  }
  const magma::lte::test_flat_buffer::Ambr& ambr() const { return ambr_; }
  magma::lte::test_flat_buffer::Ambr& mutable_ambr() { return ambr_; }
  const magma::lte::test_flat_buffer::ChargingCharacteristics&
  charging_characteristics() const {
    return charging_characteristics_;
  }
  magma::lte::test_flat_buffer::ChargingCharacteristics&
  mutable_charging_characteristics() {
    return charging_characteristics_;
  }
};
FLATBUFFERS_STRUCT_END(ApnConfiguration, 200);

inline bool operator==(
    const ApnConfiguration& lhs, const ApnConfiguration& rhs) {
  return (lhs.context_identifier() == rhs.context_identifier()) &&
         (lhs.nb_ip_address() == rhs.nb_ip_address()) &&
         (lhs.ip_address() == rhs.ip_address()) &&
         (lhs.pdn_type() == rhs.pdn_type()) &&
         (lhs.service_selection() == rhs.service_selection()) &&
         (lhs.service_selection_length() == rhs.service_selection_length()) &&
         (lhs.subscribed_qos() == rhs.subscribed_qos()) &&
         (lhs.ambr() == rhs.ambr()) &&
         (lhs.charging_characteristics() == rhs.charging_characteristics());
}

inline bool operator!=(
    const ApnConfiguration& lhs, const ApnConfiguration& rhs) {
  return !(lhs == rhs);
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8)
ApnConfigProfile FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t context_identifier_;
  uint8_t all_apn_conf_ind_;
  uint8_t nb_apns_;
  int16_t padding0__;
  magma::lte::test_flat_buffer::ApnConfiguration apn_configuration_[10];

 public:
  ApnConfigProfile()
      : context_identifier_(0),
        all_apn_conf_ind_(0),
        nb_apns_(0),
        padding0__(0),
        apn_configuration_() {
    (void) padding0__;
  }
  ApnConfigProfile(
      uint32_t _context_identifier,
      magma::lte::test_flat_buffer::AllApnConfInd _all_apn_conf_ind,
      uint8_t _nb_apns)
      : context_identifier_(flatbuffers::EndianScalar(_context_identifier)),
        all_apn_conf_ind_(
            flatbuffers::EndianScalar(static_cast<uint8_t>(_all_apn_conf_ind))),
        nb_apns_(flatbuffers::EndianScalar(_nb_apns)),
        padding0__(0),
        apn_configuration_() {
    (void) padding0__;
  }
  ApnConfigProfile(
      uint32_t _context_identifier,
      magma::lte::test_flat_buffer::AllApnConfInd _all_apn_conf_ind,
      uint8_t _nb_apns,
      flatbuffers::span<
          const magma::lte::test_flat_buffer::ApnConfiguration, 10>
          _apn_configuration)
      : context_identifier_(flatbuffers::EndianScalar(_context_identifier)),
        all_apn_conf_ind_(
            flatbuffers::EndianScalar(static_cast<uint8_t>(_all_apn_conf_ind))),
        nb_apns_(flatbuffers::EndianScalar(_nb_apns)),
        padding0__(0) {
    (void) padding0__;
    flatbuffers::CastToArray(apn_configuration_)
        .CopyFromSpan(_apn_configuration);
  }
  uint32_t context_identifier() const {
    return flatbuffers::EndianScalar(context_identifier_);
  }
  void mutate_context_identifier(uint32_t _context_identifier) {
    flatbuffers::WriteScalar(&context_identifier_, _context_identifier);
  }
  magma::lte::test_flat_buffer::AllApnConfInd all_apn_conf_ind() const {
    return static_cast<magma::lte::test_flat_buffer::AllApnConfInd>(
        flatbuffers::EndianScalar(all_apn_conf_ind_));
  }
  void mutate_all_apn_conf_ind(
      magma::lte::test_flat_buffer::AllApnConfInd _all_apn_conf_ind) {
    flatbuffers::WriteScalar(
        &all_apn_conf_ind_, static_cast<uint8_t>(_all_apn_conf_ind));
  }
  /// Number of APNs provided
  uint8_t nb_apns() const { return flatbuffers::EndianScalar(nb_apns_); }
  void mutate_nb_apns(uint8_t _nb_apns) {
    flatbuffers::WriteScalar(&nb_apns_, _nb_apns);
  }
  /// List of APNs configuration 1 to n elements // MAX_APN_PER_UE
  const flatbuffers::Array<magma::lte::test_flat_buffer::ApnConfiguration, 10>*
  apn_configuration() const {
    return &flatbuffers::CastToArray(apn_configuration_);
  }
  flatbuffers::Array<magma::lte::test_flat_buffer::ApnConfiguration, 10>*
  mutable_apn_configuration() {
    return &flatbuffers::CastToArray(apn_configuration_);
  }
};
FLATBUFFERS_STRUCT_END(ApnConfigProfile, 2008);

inline bool operator==(
    const ApnConfigProfile& lhs, const ApnConfigProfile& rhs) {
  return (lhs.context_identifier() == rhs.context_identifier()) &&
         (lhs.all_apn_conf_ind() == rhs.all_apn_conf_ind()) &&
         (lhs.nb_apns() == rhs.nb_apns()) &&
         (lhs.apn_configuration() == rhs.apn_configuration());
}

inline bool operator!=(
    const ApnConfigProfile& lhs, const ApnConfigProfile& rhs) {
  return !(lhs == rhs);
}

}  // namespace test_flat_buffer
}  // namespace lte
}  // namespace magma

#endif  // FLATBUFFERS_GENERATED_COMMONTYPES_MAGMA_LTE_TEST_FLAT_BUFFER_H_

// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_3GPP36413_MAGMA_LTE_TEST_FLAT_BUFFER_H_
#define FLATBUFFERS_GENERATED_3GPP36413_MAGMA_LTE_TEST_FLAT_BUFFER_H_

#include "flatbuffers/flatbuffers.h"

namespace magma {
namespace lte {
namespace test_flat_buffer {

struct UeRadioCapability;

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(2)
UeRadioCapability FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t bytes_[4096];
  uint16_t length_;

 public:
  UeRadioCapability() : bytes_(), length_(0) {}
  UeRadioCapability(uint16_t _length)
      : bytes_(), length_(flatbuffers::EndianScalar(_length)) {}
  UeRadioCapability(
      flatbuffers::span<const uint8_t, 4096> _bytes, uint16_t _length)
      : length_(flatbuffers::EndianScalar(_length)) {
    flatbuffers::CastToArray(bytes_).CopyFromSpan(_bytes);
  }
  const flatbuffers::Array<uint8_t, 4096>* bytes() const {
    return &flatbuffers::CastToArray(bytes_);
  }
  flatbuffers::Array<uint8_t, 4096>* mutable_bytes() {
    return &flatbuffers::CastToArray(bytes_);
  }
  uint16_t length() const { return flatbuffers::EndianScalar(length_); }
  void mutate_length(uint16_t _length) {
    flatbuffers::WriteScalar(&length_, _length);
  }
};
FLATBUFFERS_STRUCT_END(UeRadioCapability, 4098);

inline bool operator==(
    const UeRadioCapability& lhs, const UeRadioCapability& rhs) {
  return (lhs.bytes() == rhs.bytes()) && (lhs.length() == rhs.length());
}

inline bool operator!=(
    const UeRadioCapability& lhs, const UeRadioCapability& rhs) {
  return !(lhs == rhs);
}

}  // namespace test_flat_buffer
}  // namespace lte
}  // namespace magma

#endif  // FLATBUFFERS_GENERATED_3GPP36413_MAGMA_LTE_TEST_FLAT_BUFFER_H_

/*
Copyright 2020 The Magma Authors.

This source code is licensed under the BSD-style license found in the
LICENSE file in the root directory of this source tree.

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

syntax = "proto3";

import "orc8r/protos/certifier.proto";
import "orc8r/protos/identity.proto";
import "google/protobuf/timestamp.proto";

package magma.orc8r;
option go_package = "magma/orc8r/lib/go/protos";

// --------------------------------------------------------------------------
// Protos for Bootstrapper servicer
// --------------------------------------------------------------------------
message Challenge {
  ChallengeKey.KeyType key_type = 1;
  bytes challenge = 2;
}

// Challenge key stores the key used for challenge-response during bootstrap.
message ChallengeKey {
  enum KeyType {
    ECHO = 0;
    SOFTWARE_RSA_SHA256 = 1;
    SOFTWARE_ECDSA_SHA256 = 2;
  }

  KeyType key_type = 1;
  // Public key encoded in DER format
  bytes key = 2;
}

message Response {
  message Echo {
    bytes response = 1;
  }
  message RSA {
    bytes signature = 1;
  }
  message ECDSA {
    bytes r = 1;
    bytes s = 2;
  }

  AccessGatewayID hw_id = 1;
  bytes challenge = 2;
  oneof response {
    Echo echo_response = 3;
    RSA rsa_response = 4;
    ECDSA ecdsa_response = 5;
  }
  CSR csr = 6;
}

// Note that the security of this service is dependent on TLS to protect
// against MITM and replay attacks
service Bootstrapper {
  // get the challange for gateway specified in hw_id (AccessGatewayID)
  rpc GetChallenge (AccessGatewayID) returns (Challenge) {}

  // send back response and csr for signing
  // Returns signed certificate.
  rpc RequestSign (Response) returns (Certificate) {}
}

// --------------------------------------------------------------------------
// Protos for CloudRegistration and Registration servicer
// --------------------------------------------------------------------------
/**
// Operator Side Registration
Operator->REST API:
  GET_gateway(network_id, logical_id)

  REST API<->CloudRegistration:
    GetToken(network_id, logical_id, refresh): nonce, timeout

  REST API<->CloudRegistration:
    GetInfoForGatewayRegistration(): domain_name, root_ca

Operator<-REST API:
  GatewaySwaggerObject{..., registration_field{nonce, timeout, domain_name, root_ca}}

// AGW Side Registration
Operator->AGW:
  passes nonce, domain_name, root_ca

AGW->Registration:
  Register(nonce, hwid, challenge_key)

  Registration<->CloudRegistration:
    GetGatewayRegistrationInfo(nonce): network_id, logical_id

  Registration->Device:
    RegisterDevices(network_id, hwid)

Registration->AGW:control_proxy
 */

service CloudRegistration {
  // GetToken saves and sends out a token related to input:networkID and input:logicalID
  // It will refresh the token if input:refresh is true or token is expired
  rpc GetToken(GetTokenRequest) returns (GetTokenResponse) {}

  // GetInfoForGatewayRegistration sends out information needed for gateways to register themselves
  rpc GetGatewayRegistrationInfo(GetGatewayRegistrationInfoRequest) returns (GetGatewayRegistrationInfoResponse) {}

  // GetGatewayPreregisterInfo sends out information that has been set when the operator preregistered
  // the device with networkID and logicalID
  rpc GetGatewayDeviceInfo(GetGatewayDeviceInfoRequest) returns (GetGatewayDeviceInfoResponse) {}
}

service Registration {
  // Register should be called by the gateway device
  rpc Register(RegisterRequest) returns (RegisterResponse) {}
}

message GetTokenRequest {
  GatewayDeviceInfo gateway_device_info = 1;
  // refresh is true if a new token should be generated regardless of old token timeout
  bool refresh = 2;
}

message GetTokenResponse {
  // token is a nonce prepended by bootstrapper.tokenPrepend
  string token = 1;
  google.protobuf.Timestamp timeout = 2;
}

message GetGatewayRegistrationInfoRequest {
}

message GetGatewayRegistrationInfoResponse {
  string root_ca = 1;
  string domain_name = 2;
}

message GetGatewayDeviceInfoRequest {
  // token is a nonce prepended by bootstrapper.tokenPrepend
  string token = 1;
}

message GetGatewayDeviceInfoResponse {
  oneof response {
    GatewayDeviceInfo gateway_device_info = 1;
    string error = 2;
  }
}

message RegisterRequest {
  // token is a nonce prepended by bootstrapper.tokenPrepend
  string token = 1;
  AccessGatewayID hwid = 2;
  // challenge_key is gateway's long-term public key
  ChallengeKey challenge_key = 3;
}

message RegisterResponse {
  oneof response {
    // control_proxy is the OK that the gateway has registered properly
    // EG magma/lte/gateway/configs/control_proxy.yml
    string control_proxy = 1;
    string error = 2;
  }
}

message GatewayDeviceInfo {
  string network_id = 1;
  string logical_id = 2;
}

message TokenInfo {
  GatewayDeviceInfo gateway_device_info = 1;
  string nonce = 2;
  google.protobuf.Timestamp timeout = 3;
}

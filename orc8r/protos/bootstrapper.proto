/*
Copyright 2020 The Magma Authors.

This source code is licensed under the BSD-style license found in the
LICENSE file in the root directory of this source tree.

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

syntax = "proto3";

import "orc8r/protos/certifier.proto";
import "orc8r/protos/identity.proto";
import "google/protobuf/timestamp.proto";

package magma.orc8r;
option go_package = "magma/orc8r/lib/go/protos";

// --------------------------------------------------------------------------
// Protos for Bootstrapper servicer
// --------------------------------------------------------------------------
message Challenge {
  ChallengeKey.KeyType key_type = 1;
  bytes challenge = 2;
}

// Challenge key stores the key used for challenge-response during bootstrap.
message ChallengeKey {
  enum KeyType {
    ECHO = 0;
    SOFTWARE_RSA_SHA256 = 1;
    SOFTWARE_ECDSA_SHA256 = 2;
  }

  KeyType key_type = 1;
  // Public key encoded in DER format
  bytes key = 2;
}

message Response {
  message Echo {
    bytes response = 1;
  }
  message RSA {
    bytes signature = 1;
  }
  message ECDSA {
    bytes r = 1;
    bytes s = 2;
  }

  AccessGatewayID hw_id = 1;
  bytes challenge = 2;
  oneof response {
    Echo echo_response = 3;
    RSA rsa_response = 4;
    ECDSA ecdsa_response = 5;
  }
  CSR csr = 6;
}

// Note that the security of this service is dependent on TLS to protect
// against MITM and replay attacks
service Bootstrapper {
  // get the challange for gateway specified in hw_id (AccessGatewayID)
  rpc GetChallenge (AccessGatewayID) returns (Challenge) {}

  // send back response and csr for signing
  // Returns signed certificate.
  rpc RequestSign (Response) returns (Certificate) {}
}

// --------------------------------------------------------------------------
// Protos for CloudRegistration and Registration servicer
// --------------------------------------------------------------------------
service CloudRegistration {
  // GetToken saves and sends out a token related to input:networkID and input:logicalID
  // It will refresh the token if input:refresh is true or token is expired
  rpc GetToken(GetTokenRequest) returns (GetTokenResponse) {}

  // GetInfoForGatewayRegistration sends out information needed for gateways to register themselves
  rpc GetInfoForGatewayRegistration(GetInfoForGatewayRegistrationRequest) returns (GetInfoForGatewayRegistrationResponse) {}

  // GetGatewayPreregisterInfo sends out information that has been set when the operator preregistered
  // the device with networkID and logicalID
  rpc GetGatewayPreregisterInfo(GetGatewayPreregisterInfoRequest) returns (GetGatewayPreregisterInfoResponse) {}
}

service Registration {
  rpc Register(RegisterRequest) returns (RegisterResponse) {}
}

message GetTokenRequest {
  GatewayPreregisterInfo gateway_preregister_info = 1;
  // refresh is true if a new token should be generated regardless of old token timeout
  bool refresh = 2;
}

message GetTokenResponse {
  // token is a nonce prepended by bootstrapper.tokenPrepend
  string token = 1;
  google.protobuf.Timestamp timeout = 2;
}

message GetInfoForGatewayRegistrationRequest {
}

message GetInfoForGatewayRegistrationResponse {
  string root_ca = 1;
  string domain_name = 2;
}

message GetGatewayPreregisterInfoRequest {
  // token is a nonce prepended by bootstrapper.tokenPrepend
  string token = 1;
}

message GetGatewayPreregisterInfoResponse {
  oneof response {
    GatewayPreregisterInfo gateway_preregister_info = 1;
    string error = 2;
  }
}

message RegisterRequest {
  // token is a nonce prepended by bootstrapper.tokenPrepend
  string token = 1;
  AccessGatewayID hwid = 2;
  // challenge_key is gateway's long-term public key
  ChallengeKey challenge_key = 3;
}

message RegisterResponse {
  oneof response {
    // control_proxy is the OK that the gateway has registered properly
    string control_proxy = 1;
    string error = 2;
  }
}

message GatewayPreregisterInfo {
  string network_id = 1;
  string logical_id = 2;
}

message TokenInfo {
  GatewayPreregisterInfo gateway_preregister_info = 1;
  string nonce = 2;
  google.protobuf.Timestamp timeout = 3;
}

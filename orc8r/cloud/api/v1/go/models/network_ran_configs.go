// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// NetworkRanConfigs RAN (radio access network) cellular configuration for a network
//
// swagger:model network_ran_configs
type NetworkRanConfigs struct {

	// bandwidth mhz
	// Example: 20
	// Required: true
	// Enum: [3 5 10 15 20]
	BandwidthMhz uint32 `json:"bandwidth_mhz"`

	// fdd config
	FddConfig *NetworkRanConfigsFddConfig `json:"fdd_config,omitempty" magma_alt_name:"NetworkRANConfigFDDConfig"`

	// tdd config
	TddConfig *NetworkRanConfigsTddConfig `json:"tdd_config,omitempty" magma_alt_name:"NetworkRANConfigTDDConfig"`
}

// Validate validates this network ran configs
func (m *NetworkRanConfigs) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBandwidthMhz(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFddConfig(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTddConfig(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var networkRanConfigsTypeBandwidthMhzPropEnum []interface{}

func init() {
	var res []uint32
	if err := json.Unmarshal([]byte(`[3,5,10,15,20]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		networkRanConfigsTypeBandwidthMhzPropEnum = append(networkRanConfigsTypeBandwidthMhzPropEnum, v)
	}
}

// prop value enum
func (m *NetworkRanConfigs) validateBandwidthMhzEnum(path, location string, value uint32) error {
	if err := validate.EnumCase(path, location, value, networkRanConfigsTypeBandwidthMhzPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *NetworkRanConfigs) validateBandwidthMhz(formats strfmt.Registry) error {

	if err := validate.Required("bandwidth_mhz", "body", uint32(m.BandwidthMhz)); err != nil {
		return err
	}

	// value enum
	if err := m.validateBandwidthMhzEnum("bandwidth_mhz", "body", m.BandwidthMhz); err != nil {
		return err
	}

	return nil
}

func (m *NetworkRanConfigs) validateFddConfig(formats strfmt.Registry) error {
	if swag.IsZero(m.FddConfig) { // not required
		return nil
	}

	if m.FddConfig != nil {
		if err := m.FddConfig.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("fdd_config")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("fdd_config")
			}
			return err
		}
	}

	return nil
}

func (m *NetworkRanConfigs) validateTddConfig(formats strfmt.Registry) error {
	if swag.IsZero(m.TddConfig) { // not required
		return nil
	}

	if m.TddConfig != nil {
		if err := m.TddConfig.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("tdd_config")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("tdd_config")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this network ran configs based on the context it is used
func (m *NetworkRanConfigs) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateFddConfig(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTddConfig(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NetworkRanConfigs) contextValidateFddConfig(ctx context.Context, formats strfmt.Registry) error {

	if m.FddConfig != nil {
		if err := m.FddConfig.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("fdd_config")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("fdd_config")
			}
			return err
		}
	}

	return nil
}

func (m *NetworkRanConfigs) contextValidateTddConfig(ctx context.Context, formats strfmt.Registry) error {

	if m.TddConfig != nil {
		if err := m.TddConfig.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("tdd_config")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("tdd_config")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *NetworkRanConfigs) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NetworkRanConfigs) UnmarshalBinary(b []byte) error {
	var res NetworkRanConfigs
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NetworkRanConfigsFddConfig network ran configs fdd config
//
// swagger:model NetworkRanConfigsFddConfig
type NetworkRanConfigsFddConfig struct {

	// earfcndl
	// Example: 0
	// Required: true
	Earfcndl uint32 `json:"earfcndl"`

	// earfcnul
	// Example: 18000
	// Required: true
	// Minimum: > 0
	Earfcnul uint32 `json:"earfcnul"`
}

// Validate validates this network ran configs fdd config
func (m *NetworkRanConfigsFddConfig) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateEarfcndl(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEarfcnul(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NetworkRanConfigsFddConfig) validateEarfcndl(formats strfmt.Registry) error {

	if err := validate.Required("fdd_config"+"."+"earfcndl", "body", uint32(m.Earfcndl)); err != nil {
		return err
	}

	return nil
}

func (m *NetworkRanConfigsFddConfig) validateEarfcnul(formats strfmt.Registry) error {

	if err := validate.Required("fdd_config"+"."+"earfcnul", "body", uint32(m.Earfcnul)); err != nil {
		return err
	}

	if err := validate.MinimumUint("fdd_config"+"."+"earfcnul", "body", uint64(m.Earfcnul), 0, true); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this network ran configs fdd config based on context it is used
func (m *NetworkRanConfigsFddConfig) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *NetworkRanConfigsFddConfig) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NetworkRanConfigsFddConfig) UnmarshalBinary(b []byte) error {
	var res NetworkRanConfigsFddConfig
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NetworkRanConfigsTddConfig network ran configs tdd config
//
// swagger:model NetworkRanConfigsTddConfig
type NetworkRanConfigsTddConfig struct {

	// earfcndl
	// Example: 44590
	// Required: true
	Earfcndl uint32 `json:"earfcndl"`

	// special subframe pattern
	// Example: 7
	// Required: true
	// Maximum: 9
	SpecialSubframePattern uint32 `json:"special_subframe_pattern"`

	// subframe assignment
	// Example: 2
	// Required: true
	// Maximum: 6
	SubframeAssignment uint32 `json:"subframe_assignment"`
}

// Validate validates this network ran configs tdd config
func (m *NetworkRanConfigsTddConfig) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateEarfcndl(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSpecialSubframePattern(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSubframeAssignment(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NetworkRanConfigsTddConfig) validateEarfcndl(formats strfmt.Registry) error {

	if err := validate.Required("tdd_config"+"."+"earfcndl", "body", uint32(m.Earfcndl)); err != nil {
		return err
	}

	return nil
}

func (m *NetworkRanConfigsTddConfig) validateSpecialSubframePattern(formats strfmt.Registry) error {

	if err := validate.Required("tdd_config"+"."+"special_subframe_pattern", "body", uint32(m.SpecialSubframePattern)); err != nil {
		return err
	}

	if err := validate.MaximumUint("tdd_config"+"."+"special_subframe_pattern", "body", uint64(m.SpecialSubframePattern), 9, false); err != nil {
		return err
	}

	return nil
}

func (m *NetworkRanConfigsTddConfig) validateSubframeAssignment(formats strfmt.Registry) error {

	if err := validate.Required("tdd_config"+"."+"subframe_assignment", "body", uint32(m.SubframeAssignment)); err != nil {
		return err
	}

	if err := validate.MaximumUint("tdd_config"+"."+"subframe_assignment", "body", uint64(m.SubframeAssignment), 6, false); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this network ran configs tdd config based on context it is used
func (m *NetworkRanConfigsTddConfig) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *NetworkRanConfigsTddConfig) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NetworkRanConfigsTddConfig) UnmarshalBinary(b []byte) error {
	var res NetworkRanConfigsTddConfig
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

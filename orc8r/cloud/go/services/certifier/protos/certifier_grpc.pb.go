// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package protos

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	protos "magma/orc8r/lib/go/protos"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// CertifierClient is the client API for Certifier service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CertifierClient interface {
	// Returns the cert of the requested CA
	GetCA(ctx context.Context, in *GetCARequest, opts ...grpc.CallOption) (*protos.CACert, error)
	// Signs and adds a new certificate to the store.
	// Returns signed certificate.
	//
	SignAddCertificate(ctx context.Context, in *protos.CSR, opts ...grpc.CallOption) (*protos.Certificate, error)
	// Returns the CertificateInfo for a certificate.
	// Throws NOT_FOUND if the certificate is missing.
	//
	GetIdentity(ctx context.Context, in *protos.Certificate_SN, opts ...grpc.CallOption) (*CertificateInfo, error)
	// Revoke an existing certificate.
	// If the certificate does not exist or is expired, this request is ignored.
	//
	RevokeCertificate(ctx context.Context, in *protos.Certificate_SN, opts ...grpc.CallOption) (*protos.Void, error)
	// Add provided Certificate (AddCertRequest.cert_der) into Certifier table and
	// associates its Serial Number with given Identity (AddCertRequest.id)
	AddCertificate(ctx context.Context, in *AddCertRequest, opts ...grpc.CallOption) (*protos.Void, error)
	// Finds & returns Serial Numbers of all Certificates associated with the
	// given Identity
	FindCertificates(ctx context.Context, in *protos.Identity, opts ...grpc.CallOption) (*SerialNumbers, error)
	// Returns serial numbers of all certificates in the table
	ListCertificates(ctx context.Context, in *protos.Void, opts ...grpc.CallOption) (*SerialNumbers, error)
	// Returns all registered Certificates
	GetAll(ctx context.Context, in *protos.Void, opts ...grpc.CallOption) (*CertificateInfoMap, error)
	// cleanup expired certificates
	CollectGarbage(ctx context.Context, in *protos.Void, opts ...grpc.CallOption) (*protos.Void, error)
	// Returns a policy decision given a token, the request method's action
	// (read/write), and the requested resource
	GetPolicyDecision(ctx context.Context, in *GetPolicyDecisionRequest, opts ...grpc.CallOption) (*GetPolicyDecisionResponse, error)
	// Create a new user with their username and password
	CreateUser(ctx context.Context, in *CreateUserRequest, opts ...grpc.CallOption) (*CreateUserResponse, error)
	// List all users and their information
	ListUsers(ctx context.Context, in *ListUsersRequest, opts ...grpc.CallOption) (*ListUsersResponse, error)
	// Get a user based on their username
	GetUser(ctx context.Context, in *GetUserRequest, opts ...grpc.CallOption) (*GetUserResponse, error)
	// Update a user's authentication information
	UpdateUser(ctx context.Context, in *UpdateUserRequest, opts ...grpc.CallOption) (*UpdateUserResponse, error)
	// Delete a user
	DeleteUser(ctx context.Context, in *DeleteUserRequest, opts ...grpc.CallOption) (*DeleteUserResponse, error)
	// List a user's tokens with their policies
	ListUserTokens(ctx context.Context, in *ListUserTokensRequest, opts ...grpc.CallOption) (*ListUserTokensResponse, error)
	// Add a token to user's existing set of tokens
	AddUserToken(ctx context.Context, in *AddUserTokenRequest, opts ...grpc.CallOption) (*AddUserTokenResponse, error)
	// Revoke a user's token and removes the policy associated with the token
	DeleteUserToken(ctx context.Context, in *DeleteUserTokenRequest, opts ...grpc.CallOption) (*DeleteUserTokenResponse, error)
	// Authenticates a user by checking their password and return a list of their
	// Tokens
	Login(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (*LoginResponse, error)
}

type certifierClient struct {
	cc grpc.ClientConnInterface
}

func NewCertifierClient(cc grpc.ClientConnInterface) CertifierClient {
	return &certifierClient{cc}
}

func (c *certifierClient) GetCA(ctx context.Context, in *GetCARequest, opts ...grpc.CallOption) (*protos.CACert, error) {
	out := new(protos.CACert)
	err := c.cc.Invoke(ctx, "/magma.orc8r.certifier.Certifier/GetCA", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *certifierClient) SignAddCertificate(ctx context.Context, in *protos.CSR, opts ...grpc.CallOption) (*protos.Certificate, error) {
	out := new(protos.Certificate)
	err := c.cc.Invoke(ctx, "/magma.orc8r.certifier.Certifier/SignAddCertificate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *certifierClient) GetIdentity(ctx context.Context, in *protos.Certificate_SN, opts ...grpc.CallOption) (*CertificateInfo, error) {
	out := new(CertificateInfo)
	err := c.cc.Invoke(ctx, "/magma.orc8r.certifier.Certifier/GetIdentity", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *certifierClient) RevokeCertificate(ctx context.Context, in *protos.Certificate_SN, opts ...grpc.CallOption) (*protos.Void, error) {
	out := new(protos.Void)
	err := c.cc.Invoke(ctx, "/magma.orc8r.certifier.Certifier/RevokeCertificate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *certifierClient) AddCertificate(ctx context.Context, in *AddCertRequest, opts ...grpc.CallOption) (*protos.Void, error) {
	out := new(protos.Void)
	err := c.cc.Invoke(ctx, "/magma.orc8r.certifier.Certifier/AddCertificate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *certifierClient) FindCertificates(ctx context.Context, in *protos.Identity, opts ...grpc.CallOption) (*SerialNumbers, error) {
	out := new(SerialNumbers)
	err := c.cc.Invoke(ctx, "/magma.orc8r.certifier.Certifier/FindCertificates", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *certifierClient) ListCertificates(ctx context.Context, in *protos.Void, opts ...grpc.CallOption) (*SerialNumbers, error) {
	out := new(SerialNumbers)
	err := c.cc.Invoke(ctx, "/magma.orc8r.certifier.Certifier/ListCertificates", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *certifierClient) GetAll(ctx context.Context, in *protos.Void, opts ...grpc.CallOption) (*CertificateInfoMap, error) {
	out := new(CertificateInfoMap)
	err := c.cc.Invoke(ctx, "/magma.orc8r.certifier.Certifier/GetAll", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *certifierClient) CollectGarbage(ctx context.Context, in *protos.Void, opts ...grpc.CallOption) (*protos.Void, error) {
	out := new(protos.Void)
	err := c.cc.Invoke(ctx, "/magma.orc8r.certifier.Certifier/CollectGarbage", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *certifierClient) GetPolicyDecision(ctx context.Context, in *GetPolicyDecisionRequest, opts ...grpc.CallOption) (*GetPolicyDecisionResponse, error) {
	out := new(GetPolicyDecisionResponse)
	err := c.cc.Invoke(ctx, "/magma.orc8r.certifier.Certifier/GetPolicyDecision", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *certifierClient) CreateUser(ctx context.Context, in *CreateUserRequest, opts ...grpc.CallOption) (*CreateUserResponse, error) {
	out := new(CreateUserResponse)
	err := c.cc.Invoke(ctx, "/magma.orc8r.certifier.Certifier/CreateUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *certifierClient) ListUsers(ctx context.Context, in *ListUsersRequest, opts ...grpc.CallOption) (*ListUsersResponse, error) {
	out := new(ListUsersResponse)
	err := c.cc.Invoke(ctx, "/magma.orc8r.certifier.Certifier/ListUsers", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *certifierClient) GetUser(ctx context.Context, in *GetUserRequest, opts ...grpc.CallOption) (*GetUserResponse, error) {
	out := new(GetUserResponse)
	err := c.cc.Invoke(ctx, "/magma.orc8r.certifier.Certifier/GetUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *certifierClient) UpdateUser(ctx context.Context, in *UpdateUserRequest, opts ...grpc.CallOption) (*UpdateUserResponse, error) {
	out := new(UpdateUserResponse)
	err := c.cc.Invoke(ctx, "/magma.orc8r.certifier.Certifier/UpdateUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *certifierClient) DeleteUser(ctx context.Context, in *DeleteUserRequest, opts ...grpc.CallOption) (*DeleteUserResponse, error) {
	out := new(DeleteUserResponse)
	err := c.cc.Invoke(ctx, "/magma.orc8r.certifier.Certifier/DeleteUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *certifierClient) ListUserTokens(ctx context.Context, in *ListUserTokensRequest, opts ...grpc.CallOption) (*ListUserTokensResponse, error) {
	out := new(ListUserTokensResponse)
	err := c.cc.Invoke(ctx, "/magma.orc8r.certifier.Certifier/ListUserTokens", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *certifierClient) AddUserToken(ctx context.Context, in *AddUserTokenRequest, opts ...grpc.CallOption) (*AddUserTokenResponse, error) {
	out := new(AddUserTokenResponse)
	err := c.cc.Invoke(ctx, "/magma.orc8r.certifier.Certifier/AddUserToken", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *certifierClient) DeleteUserToken(ctx context.Context, in *DeleteUserTokenRequest, opts ...grpc.CallOption) (*DeleteUserTokenResponse, error) {
	out := new(DeleteUserTokenResponse)
	err := c.cc.Invoke(ctx, "/magma.orc8r.certifier.Certifier/DeleteUserToken", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *certifierClient) Login(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (*LoginResponse, error) {
	out := new(LoginResponse)
	err := c.cc.Invoke(ctx, "/magma.orc8r.certifier.Certifier/Login", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CertifierServer is the server API for Certifier service.
// All implementations should embed UnimplementedCertifierServer
// for forward compatibility
type CertifierServer interface {
	// Returns the cert of the requested CA
	GetCA(context.Context, *GetCARequest) (*protos.CACert, error)
	// Signs and adds a new certificate to the store.
	// Returns signed certificate.
	//
	SignAddCertificate(context.Context, *protos.CSR) (*protos.Certificate, error)
	// Returns the CertificateInfo for a certificate.
	// Throws NOT_FOUND if the certificate is missing.
	//
	GetIdentity(context.Context, *protos.Certificate_SN) (*CertificateInfo, error)
	// Revoke an existing certificate.
	// If the certificate does not exist or is expired, this request is ignored.
	//
	RevokeCertificate(context.Context, *protos.Certificate_SN) (*protos.Void, error)
	// Add provided Certificate (AddCertRequest.cert_der) into Certifier table and
	// associates its Serial Number with given Identity (AddCertRequest.id)
	AddCertificate(context.Context, *AddCertRequest) (*protos.Void, error)
	// Finds & returns Serial Numbers of all Certificates associated with the
	// given Identity
	FindCertificates(context.Context, *protos.Identity) (*SerialNumbers, error)
	// Returns serial numbers of all certificates in the table
	ListCertificates(context.Context, *protos.Void) (*SerialNumbers, error)
	// Returns all registered Certificates
	GetAll(context.Context, *protos.Void) (*CertificateInfoMap, error)
	// cleanup expired certificates
	CollectGarbage(context.Context, *protos.Void) (*protos.Void, error)
	// Returns a policy decision given a token, the request method's action
	// (read/write), and the requested resource
	GetPolicyDecision(context.Context, *GetPolicyDecisionRequest) (*GetPolicyDecisionResponse, error)
	// Create a new user with their username and password
	CreateUser(context.Context, *CreateUserRequest) (*CreateUserResponse, error)
	// List all users and their information
	ListUsers(context.Context, *ListUsersRequest) (*ListUsersResponse, error)
	// Get a user based on their username
	GetUser(context.Context, *GetUserRequest) (*GetUserResponse, error)
	// Update a user's authentication information
	UpdateUser(context.Context, *UpdateUserRequest) (*UpdateUserResponse, error)
	// Delete a user
	DeleteUser(context.Context, *DeleteUserRequest) (*DeleteUserResponse, error)
	// List a user's tokens with their policies
	ListUserTokens(context.Context, *ListUserTokensRequest) (*ListUserTokensResponse, error)
	// Add a token to user's existing set of tokens
	AddUserToken(context.Context, *AddUserTokenRequest) (*AddUserTokenResponse, error)
	// Revoke a user's token and removes the policy associated with the token
	DeleteUserToken(context.Context, *DeleteUserTokenRequest) (*DeleteUserTokenResponse, error)
	// Authenticates a user by checking their password and return a list of their
	// Tokens
	Login(context.Context, *LoginRequest) (*LoginResponse, error)
}

// UnimplementedCertifierServer should be embedded to have forward compatible implementations.
type UnimplementedCertifierServer struct {
}

func (UnimplementedCertifierServer) GetCA(context.Context, *GetCARequest) (*protos.CACert, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCA not implemented")
}
func (UnimplementedCertifierServer) SignAddCertificate(context.Context, *protos.CSR) (*protos.Certificate, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SignAddCertificate not implemented")
}
func (UnimplementedCertifierServer) GetIdentity(context.Context, *protos.Certificate_SN) (*CertificateInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetIdentity not implemented")
}
func (UnimplementedCertifierServer) RevokeCertificate(context.Context, *protos.Certificate_SN) (*protos.Void, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RevokeCertificate not implemented")
}
func (UnimplementedCertifierServer) AddCertificate(context.Context, *AddCertRequest) (*protos.Void, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddCertificate not implemented")
}
func (UnimplementedCertifierServer) FindCertificates(context.Context, *protos.Identity) (*SerialNumbers, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FindCertificates not implemented")
}
func (UnimplementedCertifierServer) ListCertificates(context.Context, *protos.Void) (*SerialNumbers, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListCertificates not implemented")
}
func (UnimplementedCertifierServer) GetAll(context.Context, *protos.Void) (*CertificateInfoMap, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAll not implemented")
}
func (UnimplementedCertifierServer) CollectGarbage(context.Context, *protos.Void) (*protos.Void, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CollectGarbage not implemented")
}
func (UnimplementedCertifierServer) GetPolicyDecision(context.Context, *GetPolicyDecisionRequest) (*GetPolicyDecisionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPolicyDecision not implemented")
}
func (UnimplementedCertifierServer) CreateUser(context.Context, *CreateUserRequest) (*CreateUserResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateUser not implemented")
}
func (UnimplementedCertifierServer) ListUsers(context.Context, *ListUsersRequest) (*ListUsersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListUsers not implemented")
}
func (UnimplementedCertifierServer) GetUser(context.Context, *GetUserRequest) (*GetUserResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUser not implemented")
}
func (UnimplementedCertifierServer) UpdateUser(context.Context, *UpdateUserRequest) (*UpdateUserResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateUser not implemented")
}
func (UnimplementedCertifierServer) DeleteUser(context.Context, *DeleteUserRequest) (*DeleteUserResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteUser not implemented")
}
func (UnimplementedCertifierServer) ListUserTokens(context.Context, *ListUserTokensRequest) (*ListUserTokensResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListUserTokens not implemented")
}
func (UnimplementedCertifierServer) AddUserToken(context.Context, *AddUserTokenRequest) (*AddUserTokenResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddUserToken not implemented")
}
func (UnimplementedCertifierServer) DeleteUserToken(context.Context, *DeleteUserTokenRequest) (*DeleteUserTokenResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteUserToken not implemented")
}
func (UnimplementedCertifierServer) Login(context.Context, *LoginRequest) (*LoginResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Login not implemented")
}

// UnsafeCertifierServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CertifierServer will
// result in compilation errors.
type UnsafeCertifierServer interface {
	mustEmbedUnimplementedCertifierServer()
}

func RegisterCertifierServer(s grpc.ServiceRegistrar, srv CertifierServer) {
	s.RegisterService(&Certifier_ServiceDesc, srv)
}

func _Certifier_GetCA_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCARequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CertifierServer).GetCA(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.orc8r.certifier.Certifier/GetCA",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CertifierServer).GetCA(ctx, req.(*GetCARequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Certifier_SignAddCertificate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(protos.CSR)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CertifierServer).SignAddCertificate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.orc8r.certifier.Certifier/SignAddCertificate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CertifierServer).SignAddCertificate(ctx, req.(*protos.CSR))
	}
	return interceptor(ctx, in, info, handler)
}

func _Certifier_GetIdentity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(protos.Certificate_SN)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CertifierServer).GetIdentity(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.orc8r.certifier.Certifier/GetIdentity",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CertifierServer).GetIdentity(ctx, req.(*protos.Certificate_SN))
	}
	return interceptor(ctx, in, info, handler)
}

func _Certifier_RevokeCertificate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(protos.Certificate_SN)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CertifierServer).RevokeCertificate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.orc8r.certifier.Certifier/RevokeCertificate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CertifierServer).RevokeCertificate(ctx, req.(*protos.Certificate_SN))
	}
	return interceptor(ctx, in, info, handler)
}

func _Certifier_AddCertificate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddCertRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CertifierServer).AddCertificate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.orc8r.certifier.Certifier/AddCertificate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CertifierServer).AddCertificate(ctx, req.(*AddCertRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Certifier_FindCertificates_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(protos.Identity)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CertifierServer).FindCertificates(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.orc8r.certifier.Certifier/FindCertificates",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CertifierServer).FindCertificates(ctx, req.(*protos.Identity))
	}
	return interceptor(ctx, in, info, handler)
}

func _Certifier_ListCertificates_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(protos.Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CertifierServer).ListCertificates(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.orc8r.certifier.Certifier/ListCertificates",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CertifierServer).ListCertificates(ctx, req.(*protos.Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _Certifier_GetAll_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(protos.Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CertifierServer).GetAll(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.orc8r.certifier.Certifier/GetAll",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CertifierServer).GetAll(ctx, req.(*protos.Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _Certifier_CollectGarbage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(protos.Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CertifierServer).CollectGarbage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.orc8r.certifier.Certifier/CollectGarbage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CertifierServer).CollectGarbage(ctx, req.(*protos.Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _Certifier_GetPolicyDecision_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPolicyDecisionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CertifierServer).GetPolicyDecision(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.orc8r.certifier.Certifier/GetPolicyDecision",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CertifierServer).GetPolicyDecision(ctx, req.(*GetPolicyDecisionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Certifier_CreateUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CertifierServer).CreateUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.orc8r.certifier.Certifier/CreateUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CertifierServer).CreateUser(ctx, req.(*CreateUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Certifier_ListUsers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListUsersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CertifierServer).ListUsers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.orc8r.certifier.Certifier/ListUsers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CertifierServer).ListUsers(ctx, req.(*ListUsersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Certifier_GetUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CertifierServer).GetUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.orc8r.certifier.Certifier/GetUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CertifierServer).GetUser(ctx, req.(*GetUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Certifier_UpdateUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CertifierServer).UpdateUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.orc8r.certifier.Certifier/UpdateUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CertifierServer).UpdateUser(ctx, req.(*UpdateUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Certifier_DeleteUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CertifierServer).DeleteUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.orc8r.certifier.Certifier/DeleteUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CertifierServer).DeleteUser(ctx, req.(*DeleteUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Certifier_ListUserTokens_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListUserTokensRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CertifierServer).ListUserTokens(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.orc8r.certifier.Certifier/ListUserTokens",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CertifierServer).ListUserTokens(ctx, req.(*ListUserTokensRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Certifier_AddUserToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddUserTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CertifierServer).AddUserToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.orc8r.certifier.Certifier/AddUserToken",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CertifierServer).AddUserToken(ctx, req.(*AddUserTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Certifier_DeleteUserToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteUserTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CertifierServer).DeleteUserToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.orc8r.certifier.Certifier/DeleteUserToken",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CertifierServer).DeleteUserToken(ctx, req.(*DeleteUserTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Certifier_Login_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoginRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CertifierServer).Login(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.orc8r.certifier.Certifier/Login",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CertifierServer).Login(ctx, req.(*LoginRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Certifier_ServiceDesc is the grpc.ServiceDesc for Certifier service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Certifier_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "magma.orc8r.certifier.Certifier",
	HandlerType: (*CertifierServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetCA",
			Handler:    _Certifier_GetCA_Handler,
		},
		{
			MethodName: "SignAddCertificate",
			Handler:    _Certifier_SignAddCertificate_Handler,
		},
		{
			MethodName: "GetIdentity",
			Handler:    _Certifier_GetIdentity_Handler,
		},
		{
			MethodName: "RevokeCertificate",
			Handler:    _Certifier_RevokeCertificate_Handler,
		},
		{
			MethodName: "AddCertificate",
			Handler:    _Certifier_AddCertificate_Handler,
		},
		{
			MethodName: "FindCertificates",
			Handler:    _Certifier_FindCertificates_Handler,
		},
		{
			MethodName: "ListCertificates",
			Handler:    _Certifier_ListCertificates_Handler,
		},
		{
			MethodName: "GetAll",
			Handler:    _Certifier_GetAll_Handler,
		},
		{
			MethodName: "CollectGarbage",
			Handler:    _Certifier_CollectGarbage_Handler,
		},
		{
			MethodName: "GetPolicyDecision",
			Handler:    _Certifier_GetPolicyDecision_Handler,
		},
		{
			MethodName: "CreateUser",
			Handler:    _Certifier_CreateUser_Handler,
		},
		{
			MethodName: "ListUsers",
			Handler:    _Certifier_ListUsers_Handler,
		},
		{
			MethodName: "GetUser",
			Handler:    _Certifier_GetUser_Handler,
		},
		{
			MethodName: "UpdateUser",
			Handler:    _Certifier_UpdateUser_Handler,
		},
		{
			MethodName: "DeleteUser",
			Handler:    _Certifier_DeleteUser_Handler,
		},
		{
			MethodName: "ListUserTokens",
			Handler:    _Certifier_ListUserTokens_Handler,
		},
		{
			MethodName: "AddUserToken",
			Handler:    _Certifier_AddUserToken_Handler,
		},
		{
			MethodName: "DeleteUserToken",
			Handler:    _Certifier_DeleteUserToken_Handler,
		},
		{
			MethodName: "Login",
			Handler:    _Certifier_Login_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "orc8r/cloud/go/services/certifier/protos/certifier.proto",
}

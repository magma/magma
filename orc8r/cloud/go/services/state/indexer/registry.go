/*
 Copyright (c) Facebook, Inc. and its affiliates.
 All rights reserved.

 This source code is licensed under the BSD-style license found in the
 LICENSE file in the root directory of this source tree.
*/

// File registry.go provides an indexer registry by forwarding calls to
// the service registry.

package indexer

import (
	"strconv"
	"strings"
	"testing"

	"github.com/pkg/errors"
	"github.com/thoas/go-funk"

	"magma/orc8r/cloud/go/orc8r"
	"magma/orc8r/lib/go/registry"
)

// GetIndexer returns the remote indexer for a desired service.
// Returns nil if not found.
func GetIndexer(serviceName string) (Indexer, error) {
	x, err := getIndexer(serviceName)
	if err != nil {
		return nil, errors.Wrapf(err, "get indexer for service %s", err)
	}
	return x, nil
}

// GetIndexers returns all registered indexers.
func GetIndexers() ([]Indexer, error) {
	indexingServices := registry.FindServices(orc8r.StateIndexerLabel)

	var ret []Indexer
	for _, serviceName := range indexingServices {
		x, err := getIndexer(serviceName)
		if err != nil {
			return nil, err
		}
		ret = append(ret, x)
	}
	return ret, nil
}

// GetIndexersForState returns all registered indexers which handle the passed
// state type.
func GetIndexersForState(stateType string) ([]Indexer, error) {
	indexers, err := GetIndexers()
	if err != nil {
		return nil, err
	}

	var filtered []Indexer
	for _, x := range indexers {
		if funk.Contains(x.GetTypes(), stateType) {
			filtered = append(filtered, x)
		}

	}
	return filtered, nil
}

// getIndexer returns a new remote indexer generated by parsing
// service metadata.
func getIndexer(serviceName string) (Indexer, error) {
	versionVal, err := registry.GetAnnotation(serviceName, orc8r.StateIndexerVersionAnnotation)
	if err != nil {
		return nil, err
	}
	versionInt, err := strconv.Atoi(versionVal)
	if err != nil {
		return nil, errors.Wrapf(err, "convert indexer version %v to int for service %s", versionVal, serviceName)
	}
	version, err := NewIndexerVersion(int64(versionInt))
	if err != nil {
		return nil, err
	}

	typesVal, err := registry.GetAnnotation(serviceName, orc8r.StateIndexerTypesAnnotation)
	if err != nil {
		return nil, err
	}
	types := strings.Split(typesVal, orc8r.AnnotationListSeparator)
	// Splitting an empty string returns len(types) = 1, which we don't want
	if len(typesVal) == 0 {
		types = nil
	}

	return NewRemoteIndexer(serviceName, version, types...), nil
}

// DeregisterAllForTest deregisters all previously-registered indexers.
// This should only be called by test code.
func DeregisterAllForTest(t *testing.T) {
	if t == nil {
		panic("for tests only")
	}
	registry.RemoveServicesWithLabel(orc8r.StateIndexerLabel)
}

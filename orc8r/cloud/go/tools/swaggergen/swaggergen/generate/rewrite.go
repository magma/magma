/*
 * Copyright 2020 The Magma Authors.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package generate

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/printer"
	"go/token"
	"io/ioutil"
	"os"
	"path/filepath"
	"sort"

	"github.com/thoas/go-funk"
	"golang.org/x/tools/go/ast/astutil"
)

// RewriteGeneratedRefs rewrites the Go files generated by go-swagger by
// updating the type identifiers for generated types owned by dependency
// swagger specs to the packages where those types are generated into.
//
// This function will add appropriate imports and rewrite all references.
// After rewriting the generated files, all files for types that aren't owned
// by the target swagger spec will be removed from the output directory as
// well.
func RewriteGeneratedRefs(targetFilepath string, rootDir string, configs map[string]MagmaSwaggerSpec) error {
	absTargetFilepath, err := filepath.Abs(targetFilepath)
	if err != nil {
		return fmt.Errorf("target filepath %s is invalid: %w", targetFilepath, err)
	}
	targetConfig := configs[absTargetFilepath]
	targetOutputDir, err := filepath.Abs(filepath.Join(
		rootDir,
		targetConfig.MagmaGenMeta.OutputDir,
		"models", // go-swagger puts all model definitions under a `models` subpackage
	))
	if err != nil {
		return fmt.Errorf("could not compute output dir: %w", err)
	}

	// Gather owned types: map from ident to package import
	// (name and full path) and filename
	filesToRewrite, err := getFilesToRewrite(targetConfig, targetOutputDir)
	if err != nil {
		return fmt.Errorf("get files to rewrite generated swagger bindings for %s: %w", absTargetFilepath, err)
	}
	validDependencyTypes := gatherAllValidDependentTypes(absTargetFilepath, configs)

	// Rewrite all generated files
	for _, filename := range filesToRewrite {
		err = rewriteGeneratedModelBinding(filename, validDependencyTypes)
		if err != nil {
			return fmt.Errorf("rewrite generated file at %s: %w", filename, err)
		}
	}

	// Delete all files for models that aren't owned by the target swagger spec
	for _, dependency := range validDependencyTypes {
		// Ignore errors since not all dependent types are guaranteed to have
		// been generated (only those referenced)
		_ = os.Remove(filepath.Join(targetOutputDir, dependency.filename))
	}
	return nil
}

func getFilesToRewrite(targetConfig MagmaSwaggerSpec, outputDir string) ([]string, error) {
	// This depends on go-swagger generating exactly 1 type into each file
	filesToRewrite := make([]string, 0, len(targetConfig.MagmaGenMeta.Types))
	for _, typeSpec := range targetConfig.MagmaGenMeta.Types {
		filesToRewrite = append(filesToRewrite, filepath.Join(outputDir, typeSpec.Filename))
	}
	return filesToRewrite, nil
}

type swaggerTypeDependency struct {
	goPackage     string
	filename      string
	packageNumber int
}

func gatherAllValidDependentTypes(absTargetFilepath string, allConfigs map[string]MagmaSwaggerSpec) map[string]swaggerTypeDependency {
	dependentTypes := map[string]swaggerTypeDependency{}

	sortedPaths := funk.Keys(allConfigs).([]string)
	sort.Strings(sortedPaths)
	for i, path := range sortedPaths {
		if path == absTargetFilepath {
			continue
		}

		for _, t := range allConfigs[path].MagmaGenMeta.Types {
			dependentTypes[t.GoStructName] = swaggerTypeDependency{
				goPackage:     allConfigs[path].MagmaGenMeta.GoPackage,
				filename:      t.Filename,
				packageNumber: i + 1,
			}
		}
	}
	return dependentTypes
}

func rewriteGeneratedModelBinding(filename string, dependentTypes map[string]swaggerTypeDependency) error {
	fset := token.NewFileSet()
	fileNode, err := parser.ParseFile(fset, filename, nil, parser.ParseComments)
	if err != nil {
		return fmt.Errorf("parse Go file: %w", err)
	}

	// Find the idents to replace, add imports as needed, rewrite the idents
	targetIdents := findIdentsToChange(fset, fileNode, dependentTypes)
	updateImports(fset, fileNode, targetIdents, dependentTypes)
	updatedFileNode := updateIdents(fileNode, targetIdents, dependentTypes)

	err = writeFinalFile(filename, fset, updatedFileNode)
	if err != nil {
		return err
	}

	return nil
}

func findIdentsToChange(fset *token.FileSet, fileNode ast.Node, validDependentTypes map[string]swaggerTypeDependency) map[*ast.Ident]bool {
	// Map keys are intentionally pointer types, as the AST doesn't change
	// across traversals
	identsToChange := map[*ast.Ident]bool{}
	ast.Inspect(fileNode, func(n ast.Node) bool {
		switch n.(type) {
		case *ast.TypeSpec:
			// Arbitrary-depth type declarations, within type definitions for structs or arrays
			// Example: type MagmadGateways []models.MagmadGateway
			typeSpec := n.(*ast.TypeSpec)
			switch typeSpec.Type.(type) {
			case *ast.StructType:
				for _, field := range typeSpec.Type.(*ast.StructType).Fields.List {
					ident := findLeafIdent(fset, field)
					if ident == nil {
						break
					}
					if _, shouldReplace := validDependentTypes[ident.Name]; shouldReplace {
						identsToChange[ident] = true
					}
				}
			case *ast.ArrayType:
				ident := findLeafIdent(fset, typeSpec.Type)
				if ident == nil {
					break
				}
				if _, shouldReplace := validDependentTypes[ident.Name]; shouldReplace {
					identsToChange[ident] = true
				}
			}
		case *ast.CallExpr:
			// Single-depth explicit type conversions
			// Example: models.MagmadGateway(m.Gateway)
			callFun := n.(*ast.CallExpr).Fun
			ident, ok := callFun.(*ast.Ident)
			if !ok {
				break
			}
			if _, shouldReplace := validDependentTypes[ident.Name]; shouldReplace {
				identsToChange[ident] = true
			}
		}
		return true
	})
	return identsToChange
}

func findLeafIdent(fset *token.FileSet, n ast.Node) *ast.Ident {
	// We have a simple assumption that go-swagger will not generate types that
	// will be referenced by a selector expression (i.e. all swagger-defined
	// types are local to the package that models are generated into).
	switch t := n.(type) {
	case *ast.Ident:
		return t
	case *ast.Field:
		return findLeafIdent(fset, t.Type)
	case *ast.StarExpr:
		return findLeafIdent(fset, t.X)
	case *ast.ArrayType:
		return findLeafIdent(fset, t.Elt)
	case *ast.MapType:
		// Again making a quick hacky assumption that generated types won't be
		// used as map keys
		return findLeafIdent(fset, t.Value)
	case *ast.SelectorExpr, *ast.InterfaceType:
		return nil
	default:
		panic(fmt.Sprintf("Unsupported AST type %T; implement support yourself!", t))
	}
}

func updateImports(fset *token.FileSet, fileNode *ast.File, targetIdents map[*ast.Ident]bool, validDependentTypes map[string]swaggerTypeDependency) {
	sortedIdents := funk.Keys(targetIdents).([]*ast.Ident)
	sort.Slice(sortedIdents, func(i, j int) bool { return sortedIdents[i].Name < sortedIdents[j].Name })
	for _, ident := range sortedIdents {
		dependency := validDependentTypes[ident.Name]
		importName := getUniqueNameForImport(dependency)
		astutil.AddNamedImport(fset, fileNode, importName, dependency.goPackage)
	}
}

func getUniqueNameForImport(dependency swaggerTypeDependency) string {
	return fmt.Sprintf("models%d", dependency.packageNumber)
}

func updateIdents(fileNode *ast.File, targetIdents map[*ast.Ident]bool, validDependentTypes map[string]swaggerTypeDependency) ast.Node {
	applyFn := func(c *astutil.Cursor) bool {
		ident, ok := c.Node().(*ast.Ident)
		if !ok {
			return true
		}
		_, found := targetIdents[ident]
		if !found {
			return true
		}
		actualDependency := validDependentTypes[ident.Name]
		c.Replace(
			// The right way to do this is to replace the node with
			// *ast.SelectorExpr, but this is easy and it works
			ast.NewIdent(fmt.Sprintf("%s.%s", getUniqueNameForImport(actualDependency), ident.Name)),
		)
		return true
	}
	return astutil.Apply(fileNode, applyFn, nil)
}

// writeFinalFile writes the updated AST to file.
//
// There used to be a bug requiring us to write the AST first to an
// intermediate buffer. Seems to be fixed as of Go 1.13. If it crops up
// again, revert this function to its previous double-write.
// Ref: https://github.com/golang/go/issues/23771
func writeFinalFile(filename string, fset *token.FileSet, fileNode ast.Node) error {
	buf := &bytes.Buffer{}
	err := printer.Fprint(buf, fset, fileNode)
	if err != nil {
		return fmt.Errorf("write final AST to intermediate buffer: %w", err)
	}

	formattedOutput, err := format.Source(buf.Bytes())
	if err != nil {
		return fmt.Errorf("gofmt final source code: %w", err)
	}

	err = ioutil.WriteFile(filename, formattedOutput, 0664)
	if err != nil {
		return fmt.Errorf("write formatted source code to output file: %w", err)
	}

	return nil
}

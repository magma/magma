From 5ebb47b96f0ccd1d948646ad35940f2ba541c596 Mon Sep 17 00:00:00 2001
From: Nick Yurchenko <urchennko@gmail.com>
Date: Mon, 13 Sep 2021 18:44:22 +0000
Subject: [PATCH 19/19] Add GTP IPv6 support

---
 datapath/linux/compat/gtp.c    | 227 ++++++++++++++++++++++++++-------
 tests/system-layer3-tunnels.at |  81 +++++++++++-
 2 files changed, 259 insertions(+), 49 deletions(-)

diff --git a/datapath/linux/compat/gtp.c b/datapath/linux/compat/gtp.c
index 16c06f91e..430f94b4e 100644
--- a/datapath/linux/compat/gtp.c
+++ b/datapath/linux/compat/gtp.c
@@ -27,6 +27,7 @@
 #include <net/ip.h>
 #include <net/udp.h>
 #include <net/udp_tunnel.h>
+#include <net/ipv6_stubs.h>
 #include <net/icmp.h>
 #include <net/xfrm.h>
 #include <net/genetlink.h>
@@ -62,6 +63,7 @@ struct gtp_dev {
 
 	struct net_device	*dev;
 	struct sock		*sk1u;
+	struct sock		*sk1u_v6;
 
 	__be16			gtph_port;
 };
@@ -81,7 +83,7 @@ static int check_header(struct sk_buff *skb, int len)
 	return 0;
 }
 
-static int gtp_rx(struct gtp_dev *gtp, struct sk_buff *skb,
+static int gtp_rx(struct sock *sk, struct gtp_dev *gtp, struct sk_buff *skb,
 			unsigned int hdrlen, u8 gtp_version,
 			__be64 tid, u8 flags, u8 type)
 {
@@ -104,10 +106,10 @@ static int gtp_rx(struct gtp_dev *gtp, struct sk_buff *skb,
         }
 #ifndef USE_UPSTREAM_TUNNEL
         //udp_tun_rx_dst
-        ovs_udp_tun_rx_dst(tun_dst, skb, gtp->sk1u->sk_family, TUNNEL_KEY, tid, opts_len);
+        ovs_udp_tun_rx_dst(tun_dst, skb, sk->sk_family, TUNNEL_KEY, tid, opts_len);
 #else
         struct metadata_dst *tun_dst =
-            udp_tun_rx_dst(skb, gtp->sk1u->sk_family, TUNNEL_KEY, tid, opts_len);
+            udp_tun_rx_dst(skb, sk->sk_family, TUNNEL_KEY, tid, opts_len);
 #endif
         netdev_dbg(gtp->dev, "attaching metadata_dst to skb, gtp ver %d hdrlen %d\n", gtp_version, hdrlen);
         if (unlikely(opts_len)) {
@@ -124,7 +126,7 @@ static int gtp_rx(struct gtp_dev *gtp, struct sk_buff *skb,
         }
         /* Get rid of the GTP + UDP headers. */
         if (iptunnel_pull_header(skb, hdrlen, skb->protocol,
-                    !net_eq(sock_net(gtp->sk1u), dev_net(gtp->dev)))) {
+                    !net_eq(sock_net(sk), dev_net(gtp->dev)))) {
             err = -1;
             gtp->dev->stats.rx_length_errors++;
             goto err;
@@ -175,7 +177,7 @@ err:
 
 /* 1 means pass up to the stack, -1 means drop and 0 means decapsulated. */
 
-static int gtp1u_udp_encap_recv(struct gtp_dev *gtp, struct sk_buff *skb)
+static int gtp1u_udp_encap_recv(struct sock *sk, struct gtp_dev *gtp, struct sk_buff *skb)
 {
 	unsigned int hdrlen = sizeof(struct udphdr) +
 			      sizeof(struct gtp1_header);
@@ -229,7 +231,7 @@ static int gtp1u_udp_encap_recv(struct gtp_dev *gtp, struct sk_buff *skb)
 
 	gtp1 = (struct gtp1_header *)(skb->data + sizeof(struct udphdr));
 
-	return gtp_rx(gtp, skb, hdrlen, GTP_V1, key32_to_tunnel_id(gtp1->tid), gtp1->flags, gtp1->type);
+	return gtp_rx(sk, gtp, skb, hdrlen, GTP_V1, key32_to_tunnel_id(gtp1->tid), gtp1->flags, gtp1->type);
 }
 
 static void __gtp_encap_destroy(struct sock *sk)
@@ -240,6 +242,7 @@ static void __gtp_encap_destroy(struct sock *sk)
 	gtp = sk->sk_user_data;
 	if (gtp) {
 		gtp->sk1u = NULL;
+		gtp->sk1u_v6 = NULL;
 		udp_sk(sk)->encap_type = 0;
 		rcu_assign_sk_user_data(sk, NULL);
 		sock_put(sk);
@@ -263,6 +266,7 @@ static void gtp_encap_disable_sock(struct sock *sk)
 static void gtp_encap_disable(struct gtp_dev *gtp)
 {
 	gtp_encap_disable_sock(gtp->sk1u);
+	gtp_encap_disable_sock(gtp->sk1u_v6);
 }
 
 /* UDP encapsulation receive handler. See net/ipv4/udp.c.
@@ -279,7 +283,7 @@ static int gtp_encap_recv(struct sock *sk, struct sk_buff *skb)
 
 	netdev_dbg(gtp->dev, "encap_recv sk=%p type %d\n", sk, udp_sk(sk)->encap_type);
 
-	ret = gtp1u_udp_encap_recv(gtp, skb);
+	ret = gtp1u_udp_encap_recv(sk, gtp, skb);
 	switch (ret) {
 	case 1:
 		netdev_dbg(gtp->dev, "pass up to the process\n");
@@ -430,12 +434,48 @@ static struct rtable *gtp_get_v4_rt(struct sk_buff *skb,
 	return rt;
 }
 
+static struct dst_entry *gtp_get_v6_rt(struct sk_buff *skb,
+                                       struct net_device *dev,
+                                       struct sock *gs6,
+                                       struct flowi6 *fl6,
+                                       const struct ip_tunnel_info *info)
+{
+	struct dst_entry *ndst;
+
+	if (!gs6)
+		return ERR_PTR(-EIO);
+
+	memset(fl6, 0, sizeof(*fl6));
+	fl6->flowi6_mark = skb->mark;
+	fl6->flowi6_proto = IPPROTO_UDP;
+	fl6->daddr = info->key.u.ipv6.dst;
+	fl6->saddr = info->key.u.ipv6.src;
+	fl6->flowlabel = ip6_make_flowinfo(RT_TOS(info->key.tos), info->key.label);
+
+	ndst = ipv6_stub->ipv6_dst_lookup_flow(dev_net(dev), gs6,
+					       fl6, NULL);
+	if (IS_ERR(ndst)) {
+		netdev_dbg(dev, "no route to %pI6\n", &fl6->daddr);
+		return ERR_PTR(-ENETUNREACH);
+	}
+
+	if (unlikely(ndst->dev == dev)) {
+		netdev_dbg(dev, "circular route to %pI6\n", &fl6->daddr);
+		dst_release(ndst);
+		return ERR_PTR(-ELOOP);
+	}
+
+	return ndst;
+}
+
 static netdev_tx_t gtp_dev_xmit_fb(struct sk_buff *skb, struct net_device *dev)
 {
 	struct ip_tunnel_info *info = skb_tunnel_info(skb);
 	struct gtp_dev *gtp = netdev_priv(dev);
+	struct dst_entry *ndst = NULL;
 	struct rtable *rt;
 	struct flowi4 fl4;
+	struct flowi6 fl6;
 	__be16 df;
         __u8 ttl;
         __u8 set_qfi = 0;
@@ -450,14 +490,17 @@ static netdev_tx_t gtp_dev_xmit_fb(struct sk_buff *skb, struct net_device *dev)
 		netdev_dbg(dev, "no info for FB tunnel xmit\n");
 		goto err;
 	}
-	rt = gtp_get_v4_rt(skb, dev, gtp->sk1u, &fl4, info);
-	if (IS_ERR(rt)) {
-		netdev_dbg(dev, "no route to SSGN %pI4\n", &fl4.daddr);
-		dev->stats.tx_carrier_errors++;
-		goto err;
-	}
 
-	skb_dst_drop(skb);
+	if (ip_tunnel_info_af(info) == AF_INET) {
+	    rt = gtp_get_v4_rt(skb, dev, gtp->sk1u, &fl4, info);
+
+        if (IS_ERR(rt)) {
+            netdev_dbg(dev, "no route to SSGN %pI4\n", &fl4.daddr);
+            dev->stats.tx_carrier_errors++;
+            goto err;
+        }
+
+        skb_dst_drop(skb);
         csum = !!(info->key.tun_flags & TUNNEL_CSUM);
         err = udp_tunnel_handle_offloads(skb, csum);
         if (err)
@@ -483,16 +526,59 @@ static netdev_tx_t gtp_dev_xmit_fb(struct sk_buff *skb, struct net_device *dev)
                         netdev_info(dev, "cntr pkt error %d", err);
                         goto err_rt;
                 }
-	} else {
-                netdev_dbg(dev, "Missing tunnel OPT");
-                goto err_rt;
+        } else {
+                    netdev_dbg(dev, "Missing tunnel OPT");
+                    goto err_rt;
+            }
+        udp_tunnel_xmit_skb(rt, gtp->sk1u, skb,
+                    fl4.saddr, fl4.daddr, fl4.flowi4_tos, ttl, df,
+                    gtp->gtph_port, gtp->gtph_port,
+                    !net_eq(sock_net(gtp->sk1u), dev_net(dev)),
+                                !csum);
+    } else {
+        ndst = gtp_get_v6_rt(skb, dev, gtp->sk1u_v6, &fl6, info);
+
+        if (IS_ERR(ndst)) {
+            netdev_dbg(dev, "no route to SSGN %pI4\n", &fl4.daddr);
+            dev->stats.tx_carrier_errors++;
+            goto err;
         }
-	udp_tunnel_xmit_skb(rt, gtp->sk1u, skb,
-			    fl4.saddr, fl4.daddr, fl4.flowi4_tos, ttl, df,
-			    gtp->gtph_port, gtp->gtph_port,
-			    !net_eq(sock_net(gtp->sk1u), dev_net(dev)),
-                            !csum);
 
+        skb_dst_drop(skb);
+        csum = !!(info->key.tun_flags & TUNNEL_CSUM);
+        err = udp_tunnel_handle_offloads(skb, csum);
+        if (err)
+                goto err_rt;
+        netdev_dbg(dev, "skb->protocol %d\n", skb->protocol);
+        ovs_skb_set_inner_protocol(skb, cpu_to_be16(ETH_P_IPV6));
+
+        ttl = info->key.ttl;
+		skb_scrub_packet(skb, !net_eq(sock_net(gtp->sk1u), dev_net(dev)));
+        netdev_dbg(dev, "packet with opt len %d", info->options_len);
+        if (info->options_len == 0) {
+            if (info->key.tun_flags & TUNNEL_OAM) {
+               set_qfi = 5;
+            }
+            gtp1_push_header(skb, tunnel_id_to_key32(info->key.tun_id), set_qfi);
+        } else if (info->key.tun_flags & TUNNEL_GTPU_OPT) {
+                struct gtpu_metadata *opts = ip_tunnel_info_opts(info);
+                __be32 tid = tunnel_id_to_key32(info->key.tun_id);
+                int err;
+
+                err = gtp1_push_control_header(skb, tid, opts, dev);
+               if (err) {
+                        netdev_info(dev, "cntr pkt error %d", err);
+                        goto err_rt;
+                }
+        } else {
+                    netdev_dbg(dev, "Missing tunnel OPT");
+                    goto err_rt;
+            }
+        udp_tunnel6_xmit_skb(ndst, gtp->sk1u_v6, skb, dev,
+                    &fl6.saddr, &fl6.daddr, RT_TOS(info->key.tos), ttl,
+                    info->key.label, gtp->gtph_port, gtp->gtph_port,
+                                !csum);
+    }
 	return NETDEV_TX_OK;
 err_rt:
 	ip_rt_put(rt);
@@ -534,42 +620,73 @@ static int gtp_change_mtu(struct net_device *dev, int new_mtu, bool strict)
         return 0;
 }
 
-static int gtp_dev_open(struct net_device *dev)
+static struct socket *gtp_create_sock(struct net *net, bool ipv6)
 {
-	struct gtp_dev *gtp = netdev_priv(dev);
-	struct net *net = dev_net(dev);
-	struct socket *sock1u;
-	struct udp_tunnel_sock_cfg tunnel_cfg;
+	struct socket *sock;
 	struct udp_port_cfg udp_conf;
 	int err;
 
-	if (gtp->sk1u) {
-		sock_hold(gtp->sk1u);
-		return 0;
-	}
+    memset(&udp_conf, 0, sizeof(udp_conf));
 
-	memset(&udp_conf, 0, sizeof(udp_conf));
+    if (ipv6) {
+        udp_conf.family = AF_INET6;
+        udp_conf.ipv6_v6only = 1;
+    } else {
+        udp_conf.family = AF_INET;
+    }
+    udp_conf.local_ip.s_addr = htonl(INADDR_ANY);
+    udp_conf.local_udp_port = htons(GTP1U_PORT);
 
-	udp_conf.family = AF_INET;
-	udp_conf.local_ip.s_addr = htonl(INADDR_ANY);
-	udp_conf.local_udp_port = htons(GTP1U_PORT);
+    err = udp_sock_create(net, &udp_conf, &sock);
+    if (err < 0)
+        return err;
 
-	err = udp_sock_create(dev_net(dev), &udp_conf, &sock1u);
-	if (err < 0)
-		return err;
+	return sock;
+}
 
-	memset(&tunnel_cfg, 0, sizeof(tunnel_cfg));
-	tunnel_cfg.sk_user_data = gtp;
-	tunnel_cfg.encap_rcv = gtp_encap_recv;
-	tunnel_cfg.encap_destroy = gtp_encap_destroy;
-	tunnel_cfg.encap_type = UDP_ENCAP_GTP1U;
 
-	setup_udp_tunnel_sock(net, sock1u, &tunnel_cfg);
+static void gtp_setup_sock(struct gtp_dev *gtp,
+                                     struct net *net,
+                                     struct socket *sock)
+{
+	struct udp_tunnel_sock_cfg tunnel_cfg;
 
-	sock_hold(sock1u->sk);
+    memset(&tunnel_cfg, 0, sizeof(tunnel_cfg));
+    tunnel_cfg.sk_user_data = gtp;
+    tunnel_cfg.encap_rcv = gtp_encap_recv;
+    tunnel_cfg.encap_destroy = gtp_encap_destroy;
+    tunnel_cfg.encap_type = UDP_ENCAP_GTP1U;
 
-	gtp->sk1u = sock1u->sk;
-	gtp->gtph_port = htons(GTP1U_PORT);
+    setup_udp_tunnel_sock(net, sock, &tunnel_cfg);
+
+    sock_hold(sock->sk);
+}
+
+
+static int gtp_dev_open(struct net_device *dev)
+{
+	struct gtp_dev *gtp = netdev_priv(dev);
+	struct net *net = dev_net(dev);
+	struct socket *sock1u;
+	struct socket *sock1u_v6;
+
+	if (gtp->sk1u) {
+		sock_hold(gtp->sk1u);
+	} else {
+        sock1u = gtp_create_sock(net, false);
+        gtp_setup_sock(gtp, net, sock1u);
+        gtp->sk1u = sock1u->sk;
+	}
+
+	if (gtp->sk1u_v6) {
+		sock_hold(gtp->sk1u_v6);
+    } else {
+        sock1u_v6 = gtp_create_sock(net, true);
+        gtp_setup_sock(gtp, net, sock1u_v6);
+        gtp->sk1u_v6 = sock1u_v6->sk;
+    }
+
+    gtp->gtph_port = htons(GTP1U_PORT);
 
 	return 0;
 }
@@ -577,10 +694,11 @@ static int gtp_dev_open(struct net_device *dev)
 static int gtp_dev_stop(struct net_device *dev)
 {
 	struct gtp_dev *gtp = netdev_priv(dev);
+	struct sock *sk;
 
 	ASSERT_RTNL();
 	if (gtp->sk1u) {
-		struct sock *sk = gtp->sk1u;
+		sk = gtp->sk1u;
 
 		sock_put(sk);
 #ifdef HAVE_SOCK_REFCNT
@@ -592,6 +710,19 @@ static int gtp_dev_stop(struct net_device *dev)
 		}
 	}
 
+	if (gtp->sk1u_v6) {
+		sk = gtp->sk1u_v6;
+
+		sock_put(sk);
+#ifdef HAVE_SOCK_REFCNT
+		if (refcount_read(&sk->sk_refcnt) == 2) {
+#else
+		if (atomic_read(&sk->sk_refcnt) == 2) {
+#endif
+			udp_tunnel_sock_release(gtp->sk1u_v6->sk_socket);
+		}
+	}
+
 	return 0;
 }
 
diff --git a/tests/system-layer3-tunnels.at b/tests/system-layer3-tunnels.at
index 7fcc785cb..430c44757 100644
--- a/tests/system-layer3-tunnels.at
+++ b/tests/system-layer3-tunnels.at
@@ -247,6 +247,9 @@ NS_CHECK_EXEC([at_ns0], [ping -q -c 3 -i 0.3 -w 2 10.1.1.2 | FORMAT_PING], [0],
 NS_CHECK_EXEC([at_ns1], [ping -q -c 3 -i 0.3 -w 2 10.1.1.1 | FORMAT_PING], [0], [dnl
 3 packets transmitted, 3 received, 0% packet loss, time 0ms
 ])
+
+
+
 OVS_TRAFFIC_VSWITCHD_STOP
 AT_CLEANUP
 
@@ -313,7 +316,83 @@ NS_CHECK_EXEC([at_ns0], [ping -s 3200 -q -c 3 -i 0.3 -w 2 10.1.1.2 | FORMAT_PING
 3 packets transmitted, 3 received, 0% packet loss, time 0ms
 ])
 
-dnl sleep 1000 
+dnl sleep 10000
+OVS_TRAFFIC_VSWITCHD_STOP
+AT_CLEANUP
+
+AT_SETUP([layer3 - IPv6 packets over GTP])
+OVS_TRAFFIC_VSWITCHD_START([set Bridge br0 other-config:hwaddr="00:12:34:56:78:bb"])
+OVS_CHECK_GTP_L3()
+OVS_CHECK_MIN_KERNEL(4,10)
+
+ADD_BR([br-underlay])
+
+ADD_NAMESPACES(at_ns0)
+
+dnl Set up underlay link from host into the namespace using veth pair.
+ADD_VETH(p0, at_ns0, br-underlay, "fc00::55:0:111/48")
+AT_CHECK([ip -6 addr add dev br-underlay "fc00::55:0:211/48"])
+AT_CHECK([ip -6 link set dev br-underlay up])
+dnl NS_CHECK_EXEC([at_ns0], [ip -6 route add default dev p0 via fc00::55:0:211])
+AT_CHECK([modprobe vport_gtp])
+
+dnl Set up tunnel endpoints on OVS outside the namespace and with a native
+dnl linux device inside the namespace.
+
+ADD_OVS_TUNNEL([gtpu], [br0], [at_gtp0], [fc00::55:0:111], [2001::2/64])
+AT_CHECK([ip -6 neigh add 2001::1 lladdr 00:12:34:56:78:aa dev br0])
+
+NS_CHECK_EXEC([at_ns0], [ip link set dev lo up])
+NS_CHECK_EXEC([at_ns0], [ip -6 addr add dev lo 2005:cafe::92/64])
+
+AT_CHECK([ovs-ofctl add-flow br-underlay "actions=normal"])
+
+AT_CHECK([ovs-appctl vlog/set dbg], [0], [ignore])
+AT_CHECK([echo 'module openvswitch +p' > /sys/kernel/debug/dynamic_debug/control])
+
+dnl Now add rules for OVS to forward to the tunnel and local port
+AT_CHECK([ovs-ofctl add-flow br0 "priority=1 action=drop"])
+AT_CHECK([ovs-ofctl add-flow br0 "priority=100 ip6,ipv6_dst=2001::1 action=output:at_gtp0"])
+AT_CHECK([ovs-ofctl add-flow br0 "priority=100 ip6,ipv6_dst=2001::2 action=drop"])
+
+AT_CHECK([ovs-ofctl dump-flows br0 | grep "ipv6" | ofctl_strip], [0], [dnl
+ priority=100,ipv6,ipv6_dst=2001::1 actions=output:1
+ priority=100,ipv6,ipv6_dst=2001::2 actions=drop
+])
+
+dnl AT_CHECK([tcpdump -l -n -xx -U ip6 -i br0 > ipv6_rx.pcap 2>/dev/null &])
+NS_CHECK_EXEC([at_ns0], [python3 $srcdir/gtp-packet.py fc00::55:0:111 fc00::55:0:211 2001::1 2001::2 5555 p0 2>/dev/null], [0], [dnl
+.
+Sent 1 packets.
+])
+NS_CHECK_EXEC([at_ns0], [python3 $srcdir/gtp-packet.py fc00::55:0:111 fc00::55:0:211 2001::1 2001::2 5555 p0 2>/dev/null], [0], [dnl
+.
+Sent 1 packets.
+])
+
+dnl OVS_WAIT_UNTIL([cat ipv6_rx.pcap | egrep "IP6 2001::1.5555 > 2001::2.5555: UDP, length 34" 2>&1 1>/dev/null])
+
+AT_CHECK([ovs-ofctl dump-flows br0 | ofctl_strip | grep ipv6 ], [0], [dnl
+ priority=100,ipv6,ipv6_dst=2001::1 actions=output:1
+ n_packets=1, n_bytes=82, priority=100,ipv6,ipv6_dst=2001::2 actions=drop
+])
+
+dnl AT_CHECK([ip -6 neigh add 2001::1 lladdr 46:b0:af:a7:38:02 dev br0])
+NS_CHECK_EXEC([at_ns0], [tcpdump -l -n -xx -U ip6 host fc00::55:0:111 -i p0 > ipv6_xmit.pcap  2>/dev/null &])
+
+sleep 1
+AT_CHECK([ping -6 2001::1 -q -c 3 -I br0 2>/dev/null | FORMAT_PING], [0], [dnl
+3 packets transmitted, 0 received, 100% packet loss, time 0ms
+])
+
+OVS_WAIT_UNTIL([cat ipv6_xmit.pcap | egrep "IP6 fc00::55:0:211.2152 > fc00::55:0:111.2152: UDP, length 112" 2>&1 1>/dev/null])
+
+AT_CHECK([ovs-ofctl dump-flows br0 | ofctl_strip | grep ipv6 ], [0], [dnl
+ n_packets=3, n_bytes=354, priority=100,ipv6,ipv6_dst=2001::1 actions=output:1
+ n_packets=1, n_bytes=82, priority=100,ipv6,ipv6_dst=2001::2 actions=drop
+])
+
+dnl sleep 1000
 OVS_TRAFFIC_VSWITCHD_STOP
 AT_CLEANUP
 
-- 
2.25.1


From 523519e3a84add450a4121ba3973bf93c2917fa5 Mon Sep 17 00:00:00 2001
From: Pravin B Shelar <pbshelar@fb.com>
Date: Mon, 29 Jun 2020 02:45:36 +0000
Subject: [PATCH 05/19] OVS: gtp echo handling

This uses OVS BFD module to send ech msgs.

testing done using ./tests/test-gtp 1.11.1.1 3201000a0000000000010000ff0003000a01

Signed-off-by: Pravin B Shelar <pbshelar@fb.com>
---
 include/openvswitch/packets.h  |  16 ++
 lib/bfd.c                      |  81 ++++++++--
 lib/bfd.h                      |   4 +-
 lib/netdev-provider.h          |   8 +
 lib/netdev-vport-private.h     |   1 +
 lib/netdev-vport.c             | 267 +++++++++++++++++++++++++++++++-
 lib/netdev.c                   |  38 +++++
 lib/netdev.h                   |  11 ++
 ofproto/ofproto-dpif-monitor.c |  13 +-
 ofproto/ofproto-dpif-xlate.c   |  35 +++--
 ofproto/ofproto-dpif-xlate.h   |   2 +
 ofproto/ofproto-dpif.c         |  17 ++
 ofproto/ofproto-dpif.h         |   2 +
 tests/automake.mk              |   3 +
 tests/system-common-macros.at  |  19 +++
 tests/system-layer3-tunnels.at | 273 ++++++++++++++++++++++++++-------
 tests/test-gtp.c               | 111 ++++++++++++++
 17 files changed, 818 insertions(+), 83 deletions(-)
 create mode 100644 tests/test-gtp.c

diff --git a/include/openvswitch/packets.h b/include/openvswitch/packets.h
index 236ae26cc..2f3fa3191 100644
--- a/include/openvswitch/packets.h
+++ b/include/openvswitch/packets.h
@@ -93,6 +93,22 @@ struct ovs_key_nsh {
 
 #define FLOW_NSH_F_MASK ((1 << 2) - 1)
 
+/* GTP protocol stuff used by userspace. */
+struct gtp1_cntr_echo_req_header {
+    ovs_be16	    seq;
+    // we do not need rest of header.
+} __attribute__ ((packed));
+
+struct gtpv1_tlv {
+    uint8_t type;
+    uint8_t value;
+}__attribute__ ((packed));
+
+struct gtp1_cntr_echo_rsp_header {
+    ovs_be16	        seq;
+    struct gtpv1_tlv    recovery;
+} __attribute__ ((packed));
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/lib/bfd.c b/lib/bfd.c
index 3c965699a..8433de86a 100644
--- a/lib/bfd.c
+++ b/lib/bfd.c
@@ -15,6 +15,7 @@
 #include <config.h>
 #include "bfd.h"
 
+#include <errno.h>
 #include <sys/types.h>
 #include <netinet/in.h>
 #include <arpa/inet.h>
@@ -521,6 +522,7 @@ long long int
 bfd_wake_time(const struct bfd *bfd) OVS_EXCLUDED(mutex)
 {
     long long int retval;
+    bool ret;
 
     if (!bfd) {
         return LLONG_MAX;
@@ -530,9 +532,14 @@ bfd_wake_time(const struct bfd *bfd) OVS_EXCLUDED(mutex)
     if (bfd->flags & FLAG_FINAL) {
         retval = 0;
     } else {
-        retval = bfd->next_tx;
-        if (bfd->state > STATE_DOWN) {
-            retval = MIN(bfd->detect_time, retval);
+        if (netdev_should_send_keep_alive_pkt(bfd->netdev, &ret) != EOPNOTSUPP) {
+            // do not change time interval for keep alive
+            retval =  time_msec() + bfd_tx_interval(bfd);
+        } else {
+            retval = bfd->next_tx;
+            if (bfd->state > STATE_DOWN) {
+                retval = MIN(bfd->detect_time, retval);
+            }
         }
     }
     ovs_mutex_unlock(&mutex);
@@ -574,20 +581,26 @@ bfd_should_send_packet(const struct bfd *bfd) OVS_EXCLUDED(mutex)
 {
     bool ret;
     ovs_mutex_lock(&mutex);
-    ret = bfd->flags & FLAG_FINAL || time_msec() >= bfd->next_tx;
+    if (netdev_should_send_keep_alive_pkt(bfd->netdev, &ret) != EOPNOTSUPP) {
+        ret = (bfd->flags & FLAG_FINAL) || ret;
+    } else {
+        ret = bfd->flags & FLAG_FINAL || time_msec() >= bfd->next_tx;
+    }
     ovs_mutex_unlock(&mutex);
     return ret;
 }
 
-void
+int
 bfd_put_packet(struct bfd *bfd, struct dp_packet *p,
-               const struct eth_addr eth_src, bool *oam) OVS_EXCLUDED(mutex)
+               const struct eth_addr eth_src, struct ofpbuf *ofpacts) OVS_EXCLUDED(mutex)
 {
     long long int min_tx, min_rx;
     struct udp_header *udp;
     struct eth_header *eth;
     struct ip_header *ip;
     struct msg *msg;
+    bool more_pkts = false;
+    int ret;
 
     ovs_mutex_lock(&mutex);
     if (bfd->next_tx) {
@@ -612,6 +625,25 @@ bfd_put_packet(struct bfd *bfd, struct dp_packet *p,
         ? eth_addr_bfd : bfd->local_eth_dst;
     eth->eth_type = htons(ETH_TYPE_IP);
 
+    ret = netdev_build_keep_alive_pkt(bfd->netdev, p, ofpacts, &more_pkts);
+    VLOG_DBG("%s ret %d more_pkts %d\n",__func__, (int)ret, (int) more_pkts);
+    if (ret != EOPNOTSUPP) {
+        if (ret == 0) {
+                if (more_pkts == false) {
+                    bfd->flags &= ~FLAG_FINAL;
+                }
+                VLOG_DBG("%s: Sending GTP echo packet", bfd->name);
+                goto send_pkt;
+        }
+        // error
+        if (ret == ENOENT) {
+            bfd->flags &= ~FLAG_FINAL;
+        }
+        VLOG_DBG("%s could not build keep alive packet: %d \n",__func__, ret);
+        goto unlock;
+    }
+
+    ret = 0;
     ip = dp_packet_put_zeros(p, sizeof *ip);
     ip->ip_ihl_ver = IP_IHL_VER(5, 4);
     ip->ip_tot_len = htons(sizeof *ip + sizeof *udp + sizeof *msg);
@@ -650,13 +682,20 @@ bfd_put_packet(struct bfd *bfd, struct dp_packet *p,
     msg->min_rx = htonl(min_rx * 1000);
 
     bfd->flags &= ~FLAG_FINAL;
-    *oam = bfd->oam;
-
+    if (bfd->oam) {
+        const ovs_be16 flag = htons(NX_TUN_FLAG_OAM);
+        ofpact_put_set_field(ofpacts, mf_from_id(MFF_TUN_FLAGS),
+                              &flag, &flag);
+    }
     log_msg(VLL_DBG, msg, "Sending BFD Message", bfd);
 
+send_pkt:
+
     bfd->last_tx = time_msec();
     bfd_set_next_tx(bfd);
+unlock:
     ovs_mutex_unlock(&mutex);
+    return ret;
 }
 
 bool
@@ -664,6 +703,14 @@ bfd_should_process_flow(const struct bfd *bfd_, const struct flow *flow,
                         struct flow_wildcards *wc)
 {
     struct bfd *bfd = CONST_CAST(struct bfd *, bfd_);
+    bool res;
+
+    if (!netdev_is_keep_alive_pkt(bfd->netdev, flow, wc, &res)) {
+        if (res) {
+            bfd->flags |= FLAG_FINAL;
+        }
+        return res;
+    }
 
     if (!eth_addr_is_zero(bfd->rmt_eth_dst)) {
         memset(&wc->masks.dl_dst, 0xff, sizeof wc->masks.dl_dst);
@@ -708,15 +755,21 @@ bfd_process_packet(struct bfd *bfd, const struct flow *flow,
     enum flags flags;
     uint8_t version;
     struct msg *msg;
-    const uint8_t *l7 = dp_packet_get_udp_payload(p);
+    const uint8_t *l7;
+
+    ovs_mutex_lock(&mutex);
+    if (netdev_process_keep_alive_pkt(bfd->netdev, flow, p) == 0) {
+        VLOG_DBG_RL(&rl, "%s: Received GTP echo packet", bfd->name);
+        goto unlock;
+    }
 
+    l7 = dp_packet_get_udp_payload(p);
     if (!l7) {
-        return; /* No UDP payload. */
+        goto unlock;     /* No UDP payload. */
     }
 
     /* This function is designed to follow section RFC 5880 6.8.6 closely. */
 
-    ovs_mutex_lock(&mutex);
     /* Increments the decay rx counter. */
     bfd->decay_rx_ctl++;
 
@@ -726,7 +779,6 @@ bfd_process_packet(struct bfd *bfd, const struct flow *flow,
         /* XXX Should drop in the kernel to prevent DOS. */
         goto out;
     }
-
     msg = dp_packet_at(p, l7 - (uint8_t *)dp_packet_data(p), BFD_PACKET_LEN);
     if (!msg) {
         VLOG_INFO_RL(&rl, "%s: Received too-short BFD control message (only "
@@ -888,6 +940,7 @@ bfd_process_packet(struct bfd *bfd, const struct flow *flow,
 
 out:
     bfd_forwarding__(bfd);
+unlock:
     ovs_mutex_unlock(&mutex);
 }
 
@@ -966,6 +1019,10 @@ bfd_in_poll(const struct bfd *bfd) OVS_REQUIRES(mutex)
 static void
 bfd_poll(struct bfd *bfd) OVS_REQUIRES(mutex)
 {
+    bool ret;
+    if (netdev_should_send_keep_alive_pkt(bfd->netdev, &ret) != EOPNOTSUPP) {
+        return;
+    }
     if (bfd->state > STATE_DOWN && !bfd_in_poll(bfd)
         && !(bfd->flags & FLAG_FINAL)) {
         bfd->poll_min_tx = bfd->cfg_min_tx;
diff --git a/lib/bfd.h b/lib/bfd.h
index 9d32327fb..fcbd8554d 100644
--- a/lib/bfd.h
+++ b/lib/bfd.h
@@ -35,8 +35,8 @@ long long int bfd_wait(const struct bfd *);
 void bfd_run(struct bfd *);
 
 bool bfd_should_send_packet(const struct bfd *);
-void bfd_put_packet(struct bfd *bfd, struct dp_packet *packet,
-                    const struct eth_addr eth_src, bool *oam);
+int bfd_put_packet(struct bfd *bfd, struct dp_packet *packet,
+                    const struct eth_addr eth_src, struct ofpbuf *ofpacts);
 
 bool bfd_should_process_flow(const struct bfd *, const struct flow *,
                              struct flow_wildcards *);
diff --git a/lib/netdev-provider.h b/lib/netdev-provider.h
index 73dce2fca..d6adcedc8 100644
--- a/lib/netdev-provider.h
+++ b/lib/netdev-provider.h
@@ -834,6 +834,14 @@ struct netdev_class {
     /* Get a block_id from the netdev.
      * Returns the block_id or 0 if none exists for netdev. */
     uint32_t (*get_block_id)(struct netdev *);
+
+    int (*should_send_keep_alive_pkt) (struct netdev *, bool *res);
+    int (*is_keep_alive_pkt) (struct netdev *, const struct flow *flow,
+                               struct flow_wildcards *wc, bool *res);
+    int  (*process_keep_alive_pkt) (struct netdev *, const struct flow *flow,
+                               const struct dp_packet *p);
+    int (*build_keep_alive_pkt) (struct netdev *, struct dp_packet *p,
+                                struct ofpbuf *ofpacts, bool *more_pkts);
 };
 
 int netdev_register_provider(const struct netdev_class *);
diff --git a/lib/netdev-vport-private.h b/lib/netdev-vport-private.h
index d89a28c66..3c82d5837 100644
--- a/lib/netdev-vport-private.h
+++ b/lib/netdev-vport-private.h
@@ -40,6 +40,7 @@ struct netdev_vport {
 
     /* Patch Ports. */
     char *peer;
+    struct hmap keep_alives;
 };
 
 int netdev_vport_construct(struct netdev *);
diff --git a/lib/netdev-vport.c b/lib/netdev-vport.c
index 0f3d587e0..1db1b7c0d 100644
--- a/lib/netdev-vport.c
+++ b/lib/netdev-vport.c
@@ -29,6 +29,7 @@
 #include <sys/ioctl.h>
 
 #include "byte-order.h"
+#include "csum.h"
 #include "daemon.h"
 #include "dirs.h"
 #include "dpif.h"
@@ -36,6 +37,7 @@
 #include "netdev-native-tnl.h"
 #include "netdev-provider.h"
 #include "netdev-vport-private.h"
+#include "odp-util.h"
 #include "openvswitch/dynamic-string.h"
 #include "ovs-router.h"
 #include "packets.h"
@@ -198,6 +200,7 @@ netdev_vport_construct(struct netdev *netdev_)
 
     ovs_mutex_init(&dev->mutex);
     eth_addr_random(&dev->etheraddr);
+    hmap_init(&dev->keep_alives);
 
     if (name && dpif_port && (strlen(name) > strlen(dpif_port) + 1) &&
         (!strncmp(name, dpif_port, strlen(dpif_port)))) {
@@ -573,7 +576,8 @@ set_tunnel_config(struct netdev *dev_, const struct smap *args, char **errp)
     int err;
 
     has_csum = strstr(type, "gre") || strstr(type, "geneve") ||
-               strstr(type, "stt") || strstr(type, "vxlan");
+               strstr(type, "stt") || strstr(type, "vxlan") ||
+               strstr(type, "gtpu");
     has_seq = strstr(type, "gre");
     memset(&tnl_cfg, 0, sizeof tnl_cfg);
 
@@ -1129,6 +1133,256 @@ netdev_vport_get_pt_mode(const struct netdev *netdev)
 
 
 #ifdef __linux__
+
+struct keep_alive_info {
+    struct hmap_node hmap_node;
+    ovs_be32 ip_src;
+    __u8 flags;
+    int seq;
+    bool csum;
+    long long int timestamp;
+    bool need_to_send;
+    long rx_cnt;
+    long tx_cnt;
+};
+
+int keep_alive_info_max = 1000;
+
+// TODO implement LRU cache to avoid manual purge
+//
+static void
+gtp_get_remote_info(struct netdev_vport *dev, struct ds *ds)
+{
+    struct keep_alive_info *kai;
+
+    HMAP_FOR_EACH(kai, hmap_node, &dev->keep_alives) {
+        ds_put_format(ds, "\t%s: RX: %ld TX: %ld remote ip: "IP_FMT", seq %d, pending send %d\n",
+                      xastrftime_msec("%H:%M:%S.###", kai->timestamp, true), kai->rx_cnt, kai->tx_cnt,
+                      IP_ARGS(kai->ip_src), kai->seq, (int)kai->need_to_send );
+    }
+}
+
+static void
+gtp_del_remote_end_points_info(struct netdev_vport *dev)
+{
+    struct keep_alive_info *kai, *next;
+
+    HMAP_FOR_EACH_SAFE(kai, next, hmap_node, &dev->keep_alives) {
+        hmap_remove(&dev->keep_alives, &kai->hmap_node);
+        free(kai);
+    }
+}
+
+/* This function is for packet TX.
+ * currently we do not support sending keep alive packets. */
+static int gtp_should_send_keep_alive_pkt(struct netdev *netdev OVS_UNUSED, bool *res)
+{
+    *res = false;
+    return 0;
+}
+
+static int
+gtp_is_keep_alive_pkt(struct netdev *netdev, const struct flow *flow,
+                      struct flow_wildcards *wc, bool *res)
+{
+    struct netdev_vport *dev = netdev_vport_cast(netdev);
+
+    if (wc) {
+        memset(&wc->masks.tunnel.gtpu_msgtype, 0xff, sizeof wc->masks.tunnel.gtpu_msgtype);
+        memset(&wc->masks.tunnel.ip_dst, 0xff, sizeof wc->masks.tunnel.ip_dst);
+    }
+    
+    VLOG_DBG("gtp flags %x msg_type %d dev->tnl_cfg.dst_port %d == (%d, %d) flow "IP_FMT" cfg "IP_FMT,
+            flow->tunnel.gtpu_flags, flow->tunnel.gtpu_msgtype, dev->tnl_cfg.dst_port,
+            flow->tunnel.tp_src, flow->tunnel.tp_dst,
+            IP_ARGS(flow->tunnel.ip_dst), IP_ARGS(in6_addr_get_mapped_ipv4(&dev->tnl_cfg.ipv6_src)));
+
+    *res = (flow->tunnel.gtpu_msgtype == 1) &&                  // echo request msg type
+           (flow->tunnel.gtpu_flags == 0x32) &&              // needs seq in packet.
+           (flow->tunnel.ip_dst == in6_addr_get_mapped_ipv4(&dev->tnl_cfg.ipv6_src)) &&
+           (flow->tunnel.tp_src == dev->tnl_cfg.dst_port) &&
+           (flow->tunnel.tp_dst == dev->tnl_cfg.dst_port);
+    return 0;
+}
+
+static struct keep_alive_info *
+gtp_get_keep_alive_info(struct netdev *netdev, ovs_be32 ip_src)
+{
+    struct netdev_vport *dev = netdev_vport_cast(netdev);
+    struct keep_alive_info *kai;
+
+    HMAP_FOR_EACH_WITH_HASH(kai, hmap_node, hash_2words(ip_src, 0), &dev->keep_alives) {
+        if (kai->ip_src == ip_src) {
+            return kai;
+        }
+    }
+    kai = xzalloc(sizeof *kai);
+    kai->ip_src = ip_src;
+    hmap_insert(&dev->keep_alives, &kai->hmap_node, hash_2words(ip_src, 0));
+    return kai;
+}
+
+static int
+gtp_process_keep_alive_pkt(struct netdev *netdev, const struct flow *flow,
+                           const struct dp_packet *p)
+{
+    struct netdev_vport *dev = netdev_vport_cast(netdev);
+    struct keep_alive_info *kai;
+    bool is_keep_alive;
+
+    ovs_mutex_lock(&dev->mutex);
+    gtp_is_keep_alive_pkt(netdev, flow, NULL, &is_keep_alive);
+
+    VLOG_DBG("is_keep_alive %d",(int) is_keep_alive);
+    if (is_keep_alive) {
+        struct gtp1_cntr_echo_req_header *hdr;
+
+        kai = gtp_get_keep_alive_info(netdev, flow->tunnel.ip_src);
+
+        if (dp_packet_size(p) >= sizeof(struct gtp1_cntr_echo_req_header) &&
+            dp_packet_data(p) != NULL &&
+            flow->tunnel.gtpu_flags & GTP_FLAGS_SEQ) {
+            hdr = dp_packet_data(p);
+            kai->seq = ntohs(hdr->seq);
+            VLOG_DBG("got seq %d", kai->seq);
+        } else {
+            kai->seq++;
+        }
+        kai->timestamp = time_wall_msec();
+        kai->need_to_send = true;
+        kai->flags = flow->tunnel.gtpu_flags;
+        kai->csum = !!(flow->tunnel.flags & FLOW_TNL_F_CSUM);
+        kai->rx_cnt++;
+    }
+    ovs_mutex_unlock(&dev->mutex);
+
+    return 0;
+}
+
+static int
+gtp_build_keep_alive_pkt(struct netdev *netdev, struct dp_packet *p,
+                         struct ofpbuf *ofpacts, bool *more_pkts)
+{
+    struct netdev_vport *dev = netdev_vport_cast(netdev);
+    struct keep_alive_info *kai, *found = NULL;
+    struct gtp1_cntr_echo_rsp_header *hdr;
+    bool plus_one = false;
+    ovs_be32 ip_src_flow;
+    __u8 ttl;
+    __u8 tos;
+    __u8 gtpu_msgtype;
+    __u8 gtpu_flags;
+
+    ovs_mutex_lock(&dev->mutex);
+    ip_src_flow = dev->tnl_cfg.ip_src_flow;
+
+    HMAP_FOR_EACH(kai, hmap_node, &dev->keep_alives) {
+        if (kai->need_to_send) {
+                if (found == NULL) {
+                    kai->need_to_send = false;
+                    found = kai;
+                } if (plus_one == false) {
+                    plus_one = true;
+                    break;
+                } else {
+                    break;
+                }
+        }
+    }
+
+    if (!found) {
+        ovs_mutex_unlock(&dev->mutex);
+        return ENOENT;
+    }
+    *more_pkts = plus_one;
+
+    ttl = MAXTTL;
+    tos = IPTOS_PREC_INTERNETCONTROL;
+    gtpu_msgtype = 2;
+    gtpu_flags = found->flags;
+
+    ofpact_put_set_field(ofpacts, mf_from_id(MFF_TUN_SRC), &ip_src_flow, &ip_src_flow);
+    ofpact_put_set_field(ofpacts, mf_from_id(MFF_TUN_DST), &found->ip_src, &found->ip_src);
+    ofpact_put_set_field(ofpacts, mf_from_id(MFF_TUN_TOS), &tos, &tos);
+    ofpact_put_set_field(ofpacts, mf_from_id(MFF_TUN_TTL), &ttl, &ttl);
+    ofpact_put_set_field(ofpacts, mf_from_id(MFF_TUN_GTPU_FLAGS), &gtpu_flags, &gtpu_flags);
+    ofpact_put_set_field(ofpacts, mf_from_id(MFF_TUN_GTPU_MSGTYPE), &gtpu_msgtype, &gtpu_msgtype);
+
+    if (found->csum || 1) {
+        __be16 csum = htons(FLOW_TNL_F_CSUM);
+        ofpact_put_set_field(ofpacts, mf_from_id(MFF_TUN_FLAGS), &csum, &csum);
+    }
+    hdr = dp_packet_put_zeros(p, sizeof *hdr);
+    hdr->seq = htons(found->seq);
+    hdr->recovery.type = 14;  //htons(0x0E00); // this is added for backward compatibility only.
+    hdr->recovery.value = 0;
+    found->tx_cnt++;
+    ovs_mutex_unlock(&dev->mutex);
+    return 0;
+}
+
+static void
+netdev_gtp_echo_remote_end_points(struct unixctl_conn *conn, int argc OVS_UNUSED,
+                             const char *argv[] OVS_UNUSED, void *aux OVS_UNUSED)
+{
+    struct ds ds = DS_EMPTY_INITIALIZER;
+    struct netdev **vports;
+    size_t i, n_vports;
+
+    int rec = 0;
+
+    vports = netdev_get_vports(&n_vports);
+    for (i = 0; i < n_vports; i++) {
+        struct netdev *netdev_ = vports[i];
+        struct netdev_vport *netdev = netdev_vport_cast(netdev_);
+
+        ds_put_format(&ds, "Tunnel port: %s\n", netdev_->name);
+        ovs_mutex_lock(&netdev->mutex);
+        /* Finds all tunnel vports. */
+        gtp_get_remote_info(netdev, &ds);
+
+        ovs_mutex_unlock(&netdev->mutex);
+
+        netdev_close(netdev_);
+        rec++;
+    }
+    free(vports);
+    if (rec) {
+        unixctl_command_reply(conn, ds_cstr(&ds));
+    } else {
+        unixctl_command_reply(conn, "None");
+    }
+    ds_destroy(&ds);
+}
+
+static void
+netdev_gtp_echo_remote_end_points_purge(struct unixctl_conn *conn, int argc OVS_UNUSED,
+                             const char *argv[] OVS_UNUSED, void *aux OVS_UNUSED)
+{
+    struct ds ds = DS_EMPTY_INITIALIZER;
+    struct netdev **vports;
+    size_t i, n_vports;
+
+    int rec = 0;
+
+    vports = netdev_get_vports(&n_vports);
+    for (i = 0; i < n_vports; i++) {
+        struct netdev *netdev_ = vports[i];
+        struct netdev_vport *netdev = netdev_vport_cast(netdev_);
+
+        ovs_mutex_lock(&netdev->mutex);
+        gtp_del_remote_end_points_info(netdev);
+        ovs_mutex_unlock(&netdev->mutex);
+
+        netdev_close(netdev_);
+        rec++;
+    }
+    free(vports);
+    unixctl_command_reply(conn, "Done");
+    ds_destroy(&ds);
+}
+
+
 static int
 netdev_vport_get_ifindex(const struct netdev *netdev_)
 {
@@ -1254,6 +1508,11 @@ netdev_vport_tunnel_register(void)
               .build_header = netdev_gtpu_build_header,
               .push_header = netdev_gtpu_push_header,
               .pop_header = netdev_gtpu_pop_header,
+              .should_send_keep_alive_pkt = gtp_should_send_keep_alive_pkt,
+              .is_keep_alive_pkt = gtp_is_keep_alive_pkt,
+              .process_keep_alive_pkt = gtp_process_keep_alive_pkt,
+              .build_keep_alive_pkt = gtp_build_keep_alive_pkt,
+              .get_ifindex = NETDEV_VPORT_GET_IFINDEX,
           },
           {{NULL, NULL, 0, 0}}
         },
@@ -1272,6 +1531,12 @@ netdev_vport_tunnel_register(void)
         unixctl_command_register("tnl/egress_port_range", "min max", 0, 2,
                                  netdev_tnl_egress_port_range, NULL);
 
+        unixctl_command_register("tnl/gtp_echo_remote_end_points", "", 0, 0,
+                                 netdev_gtp_echo_remote_end_points, NULL);
+
+        unixctl_command_register("tnl/gtp_echo_remote_end_points_purge", "", 0, 0,
+                                 netdev_gtp_echo_remote_end_points_purge, NULL);
+
         ovsthread_once_done(&once);
     }
 }
diff --git a/lib/netdev.c b/lib/netdev.c
index 91e91955c..1bc5abfc8 100644
--- a/lib/netdev.c
+++ b/lib/netdev.c
@@ -2297,3 +2297,41 @@ netdev_free_custom_stats_counters(struct netdev_custom_stats *custom_stats)
         }
     }
 }
+
+int netdev_should_send_keep_alive_pkt(struct netdev *netdev, bool *res)
+{
+
+    if (netdev->netdev_class->should_send_keep_alive_pkt) {
+        return netdev->netdev_class->should_send_keep_alive_pkt(netdev, res);
+    }
+    return EOPNOTSUPP;
+}
+
+int
+netdev_is_keep_alive_pkt(struct netdev *netdev, const struct flow *flow,
+                              struct flow_wildcards *wc, bool *res)
+{
+    if (netdev->netdev_class->is_keep_alive_pkt) {
+        return netdev->netdev_class->is_keep_alive_pkt(netdev, flow, wc, res);
+    }
+    return EOPNOTSUPP;
+}
+
+int
+netdev_process_keep_alive_pkt(struct netdev *netdev, const struct flow *flow,
+                                  const struct dp_packet *p)
+{
+    if (netdev->netdev_class->process_keep_alive_pkt) {
+        return netdev->netdev_class->process_keep_alive_pkt(netdev, flow, p);
+    }
+    return EOPNOTSUPP;
+}
+
+int netdev_build_keep_alive_pkt(struct netdev *netdev, struct dp_packet *p,
+                                struct ofpbuf *ofpacts, bool *more_pkts)
+{
+    if (netdev->netdev_class->build_keep_alive_pkt) {
+        return netdev->netdev_class->build_keep_alive_pkt(netdev, p, ofpacts, more_pkts);
+    }
+    return EOPNOTSUPP;
+}
diff --git a/lib/netdev.h b/lib/netdev.h
index 4877df5ff..de532a9dc 100644
--- a/lib/netdev.h
+++ b/lib/netdev.h
@@ -329,6 +329,17 @@ bool netdev_queue_dump_next(struct netdev_queue_dump *,
                             unsigned int *queue_id, struct smap *details);
 int netdev_queue_dump_done(struct netdev_queue_dump *);
 
+int netdev_should_send_keep_alive_pkt(struct netdev *, bool *res);
+
+int netdev_is_keep_alive_pkt(struct netdev *, const struct flow *flow,
+                               struct flow_wildcards *wc, bool *res);
+
+int netdev_process_keep_alive_pkt(struct netdev *, const struct flow *flow,
+                               const struct dp_packet *p);
+
+int netdev_build_keep_alive_pkt(struct netdev *, struct dp_packet *p,
+                                struct ofpbuf *ofpacts, bool *more_pkts);
+
 /* Iterates through each queue in NETDEV, using DUMP as state.  Fills QUEUE_ID
  * and DETAILS with information about queues.  The client must initialize and
  * destroy DETAILS.
diff --git a/ofproto/ofproto-dpif-monitor.c b/ofproto/ofproto-dpif-monitor.c
index bb0e49091..42bf211e9 100644
--- a/ofproto/ofproto-dpif-monitor.c
+++ b/ofproto/ofproto-dpif-monitor.c
@@ -280,11 +280,17 @@ monitor_mport_run(struct mport *mport, struct dp_packet *packet)
         ofproto_dpif_send_packet(mport->ofport, false, packet);
     }
     if (mport->bfd && bfd_should_send_packet(mport->bfd)) {
-        bool oam;
+        uint64_t ofpacts_stub[4192 / 8];
+        struct ofpbuf ofpacts;
+        int err;
+
+        ofpbuf_use_stack(&ofpacts, ofpacts_stub, sizeof ofpacts_stub);
 
         dp_packet_clear(packet);
-        bfd_put_packet(mport->bfd, packet, mport->hw_addr, &oam);
-        ofproto_dpif_send_packet(mport->ofport, oam, packet);
+        err = bfd_put_packet(mport->bfd, packet, mport->hw_addr, &ofpacts);
+        if (!err) {
+            ofproto_dpif_send_packet_with_acts(mport->ofport, packet, &ofpacts);
+        }
     }
     if (mport->lldp && lldp_should_send_packet(mport->lldp)) {
         dp_packet_clear(packet);
@@ -307,6 +313,7 @@ monitor_mport_run(struct mport *mport, struct dp_packet *packet)
     next_wake_time = MIN(bfd_wake_time,
                          cfm_wake_time);
     next_wake_time = MIN(next_wake_time, lldp_wake_time);
+
     heap_change(&monitor_heap, &mport->heap_node,
                 MSEC_TO_PRIO(next_wake_time));
 }
diff --git a/ofproto/ofproto-dpif-xlate.c b/ofproto/ofproto-dpif-xlate.c
index 1f78da105..1ee6845e6 100644
--- a/ofproto/ofproto-dpif-xlate.c
+++ b/ofproto/ofproto-dpif-xlate.c
@@ -7954,17 +7954,14 @@ xlate_resume(struct ofproto_dpif *ofproto,
  * May modify 'packet'.
  * Returns 0 if successful, otherwise a positive errno value. */
 int
-xlate_send_packet(const struct ofport_dpif *ofport, bool oam,
-                  struct dp_packet *packet)
+xlate_send_packet_with_acts(const struct ofport_dpif *ofport,
+                  struct dp_packet *packet, struct ofpbuf *ofpacts)
 {
     struct xlate_cfg *xcfg = ovsrcu_get(struct xlate_cfg *, &xcfgp);
     struct xport *xport;
-    uint64_t ofpacts_stub[1024 / 8];
-    struct ofpbuf ofpacts;
     struct flow flow;
 
-    ofpbuf_use_stack(&ofpacts, ofpacts_stub, sizeof ofpacts_stub);
-    /* Use OFPP_NONE as the in_port to avoid special packet processing. */
+
     flow_extract(packet, &flow);
     flow.in_port.ofp_port = OFPP_NONE;
 
@@ -7973,19 +7970,31 @@ xlate_send_packet(const struct ofport_dpif *ofport, bool oam,
         return EINVAL;
     }
 
+    ofpact_put_OUTPUT(ofpacts)->port = xport->ofp_port;
+
+    /* Actions here are not referring to anything versionable (flow tables or
+     * groups) so we don't need to worry about the version here. */
+    return ofproto_dpif_execute_actions(xport->xbridge->ofproto,
+                                        OVS_VERSION_MAX, &flow, NULL,
+                                        ofpacts->data, ofpacts->size, packet);
+}
+
+int
+xlate_send_packet(const struct ofport_dpif *ofport, bool oam,
+                  struct dp_packet *packet)
+{
+    uint64_t ofpacts_stub[1024 / 8];
+    struct ofpbuf ofpacts;
+
+    ofpbuf_use_stack(&ofpacts, ofpacts_stub, sizeof ofpacts_stub);
+    /* Use OFPP_NONE as the in_port to avoid special packet processing. */
     if (oam) {
         const ovs_be16 flag = htons(NX_TUN_FLAG_OAM);
         ofpact_put_set_field(&ofpacts, mf_from_id(MFF_TUN_FLAGS),
                              &flag, &flag);
     }
 
-    ofpact_put_OUTPUT(&ofpacts)->port = xport->ofp_port;
-
-    /* Actions here are not referring to anything versionable (flow tables or
-     * groups) so we don't need to worry about the version here. */
-    return ofproto_dpif_execute_actions(xport->xbridge->ofproto,
-                                        OVS_VERSION_MAX, &flow, NULL,
-                                        ofpacts.data, ofpacts.size, packet);
+    return xlate_send_packet_with_acts(ofport, packet, &ofpacts);
 }
 
 void
diff --git a/ofproto/ofproto-dpif-xlate.h b/ofproto/ofproto-dpif-xlate.h
index 3426a27b2..5d1bd84d5 100644
--- a/ofproto/ofproto-dpif-xlate.h
+++ b/ofproto/ofproto-dpif-xlate.h
@@ -221,6 +221,8 @@ enum ofperr xlate_resume(struct ofproto_dpif *,
                          struct ofpbuf *odp_actions, enum slow_path_reason *,
                          struct flow *, struct xlate_cache *);
 int xlate_send_packet(const struct ofport_dpif *, bool oam, struct dp_packet *);
+int xlate_send_packet_with_acts(const struct ofport_dpif *ofport,
+                  struct dp_packet *packet, struct ofpbuf *ofpacts);
 
 void xlate_mac_learning_update(const struct ofproto_dpif *ofproto,
                                ofp_port_t in_port, struct eth_addr dl_src,
diff --git a/ofproto/ofproto-dpif.c b/ofproto/ofproto-dpif.c
index 0f8ae8a73..a8a49adf0 100644
--- a/ofproto/ofproto-dpif.c
+++ b/ofproto/ofproto-dpif.c
@@ -5265,6 +5265,23 @@ ofproto_dpif_send_packet(const struct ofport_dpif *ofport, bool oam,
     ovs_mutex_unlock(&ofproto->stats_mutex);
     return error;
 }
+
+int
+ofproto_dpif_send_packet_with_acts(const struct ofport_dpif *ofport, 
+                                   struct dp_packet *packet, struct ofpbuf *ofpacts)
+{
+    struct ofproto_dpif *ofproto = ofproto_dpif_cast(ofport->up.ofproto);
+    int error;
+
+    error = xlate_send_packet_with_acts(ofport, packet, ofpacts);
+
+    ovs_mutex_lock(&ofproto->stats_mutex);
+    ofproto->stats.tx_packets++;
+    ofproto->stats.tx_bytes += dp_packet_size(packet);
+    ovs_mutex_unlock(&ofproto->stats_mutex);
+    return error;
+}
+
 
 /* Return the version string of the datapath that backs up
  * this 'ofproto'.
diff --git a/ofproto/ofproto-dpif.h b/ofproto/ofproto-dpif.h
index 1f5794f03..c57ec5a35 100644
--- a/ofproto/ofproto-dpif.h
+++ b/ofproto/ofproto-dpif.h
@@ -370,6 +370,8 @@ void ofproto_dpif_send_async_msg(struct ofproto_dpif *,
                                  struct ofproto_async_msg *);
 int ofproto_dpif_send_packet(const struct ofport_dpif *, bool oam,
                              struct dp_packet *);
+int ofproto_dpif_send_packet_with_acts(const struct ofport_dpif *,
+                             struct dp_packet *, struct ofpbuf *ofpacts);
 enum ofperr ofproto_dpif_flow_mod_init_for_learn(
     struct ofproto_dpif *, const struct ofputil_flow_mod *,
     struct ofproto_flow_mod *);
diff --git a/tests/automake.mk b/tests/automake.mk
index 498d016e0..5138f91a2 100644
--- a/tests/automake.mk
+++ b/tests/automake.mk
@@ -503,6 +503,9 @@ tests_test_strtok_r_SOURCES = tests/test-strtok_r.c
 noinst_PROGRAMS += tests/test-type-props
 tests_test_type_props_SOURCES = tests/test-type-props.c
 
+noinst_PROGRAMS += tests/test-gtp
+tests_test_gtp_SOURCES = tests/test-gtp.c
+
 # Python tests.
 CHECK_PYFILES = \
 	tests/appctl.py \
diff --git a/tests/system-common-macros.at b/tests/system-common-macros.at
index 490c59e04..bc94680f0 100644
--- a/tests/system-common-macros.at
+++ b/tests/system-common-macros.at
@@ -160,6 +160,25 @@ m4_define([ADD_CVLAN],
     ]
 )
 
+# ADD_OVS_TUNNEL_NO_REMOTE([type], [bridge], [port], [overlay-addr],
+#                [tunnel-args])
+#
+# Add an ovs-based tunnel device in the root namespace, with name 'port' and
+# type 'type'. The tunnel device will be configured as point-to-point with the
+# 'remote-addr' as the underlay address of the remote tunnel endpoint.
+#
+# 'port will be configured with the address 'overlay-addr'.
+#
+m4_define([ADD_OVS_TUNNEL_NO_REMOTE],
+   [AT_CHECK([ovs-vsctl add-port $2 $3 -- \
+              set int $3 type=$1 options:remote_ip=flow $5])
+    AT_CHECK([ip addr add dev $2 $4])
+    AT_CHECK([ip link set dev $2 up])
+    AT_CHECK([ip link set dev $2 mtu 1450])
+    on_exit 'ip addr del dev $2 $4'
+   ]
+)
+
 # ADD_OVS_TUNNEL([type], [bridge], [port], [remote-addr], [overlay-addr],
 #                [tunnel-args])
 #
diff --git a/tests/system-layer3-tunnels.at b/tests/system-layer3-tunnels.at
index 141a7afb4..4bbb2198e 100644
--- a/tests/system-layer3-tunnels.at
+++ b/tests/system-layer3-tunnels.at
@@ -49,58 +49,6 @@ NS_CHECK_EXEC([at_ns0], [ping -s 3200 -q -c 3 -i 0.3 -w 2 10.1.1.2 | FORMAT_PING
 OVS_TRAFFIC_VSWITCHD_STOP
 AT_CLEANUP
 
-AT_SETUP([layer3 - ping over GTP])
-OVS_TRAFFIC_VSWITCHD_START([set Bridge br0 other-config:hwaddr="00:12:34:56:78:bb"])
-OVS_CHECK_GTP_L3()
-
-ADD_BR([br-underlay])
-
-ADD_NAMESPACES(at_ns0)
-
-dnl Set up underlay link from host into the namespace using veth pair.
-ADD_VETH(p0, at_ns0, br-underlay, "172.31.1.1/24")
-AT_CHECK([ip addr add dev br-underlay "172.31.1.100/24"])
-AT_CHECK([ip link set dev br-underlay up])
-AT_CHECK([modprobe vport-gtp])
-
-dnl Set up tunnel endpoints on OVS outside the namespace and with a native
-dnl linux device inside the namespace.
-ADD_OVS_TUNNEL([gtpu], [br0], [at_gtp0], [172.31.1.1], [10.1.1.2/24])
-AT_CHECK([ip neigh add 10.1.1.1 lladdr 00:12:34:56:78:aa dev br0])
-NS_CHECK_EXEC([at_ns0], [gtp-link add at_gtp1 --sgsn &], [0], [ignore])
-NS_CHECK_EXEC([at_ns0], [gtp-tunnel add at_gtp1 v1 0 0 10.1.1.1 172.31.1.100], [0], [ignore], [ignore])
-NS_CHECK_EXEC([at_ns0], [ip addr add dev at_gtp1 10.1.1.1/24])
-NS_CHECK_EXEC([at_ns0], [ip link set dev at_gtp1 mtu 1450 up])
-NS_CHECK_EXEC([at_ns0], [ip link set dev p0 mtu 1480 up])
-
-AT_CHECK([ovs-ofctl add-flow br-underlay "actions=normal"])
-
-AT_CHECK([ovs-appctl vlog/set dbg], [0], [ignore])
-AT_CHECK([echo 'module openvswitch +p' > /sys/kernel/debug/dynamic_debug/control])
-
-dnl Now add rules for OVS to forward to the tunnel and local port
-AT_CHECK([ovs-ofctl add-flow br0 "priority=1 action=drop"])
-AT_CHECK([ovs-ofctl add-flow br0 "priority=100 ip,nw_dst=10.1.1.1 action=output:at_gtp0"])
-AT_CHECK([ovs-ofctl add-flow br0 "priority=100 ip,nw_dst=10.1.1.2 action=mod_dl_src:00:12:34:56:78:aa,mod_dl_dst:00:12:34:56:78:bb,local"])
-
-
-dnl First, check the underlay
-NS_CHECK_EXEC([at_ns0], [ping -q -c 3 -i 0.3 -w 2 172.31.1.100 | FORMAT_PING], [0], [dnl
-3 packets transmitted, 3 received, 0% packet loss, time 0ms
-])
-
-OVS_WAIT_UNTIL([ip netns exec at_ns0 ping -c 1 10.1.1.2])
-dnl Okay, now check the overlay with different packet sizes
-NS_CHECK_EXEC([at_ns0], [ping -q -c 3 -i 0.3 -w 2 10.1.1.2 | FORMAT_PING], [0], [dnl
-3 packets transmitted, 3 received, 0% packet loss, time 0ms
-])
-NS_CHECK_EXEC([at_ns0], [ping -s 3200 -q -c 3 -i 0.3 -w 2 10.1.1.2 | FORMAT_PING], [0], [dnl
-3 packets transmitted, 3 received, 0% packet loss, time 0ms
-])
-
-OVS_TRAFFIC_VSWITCHD_STOP
-AT_CLEANUP
-
 AT_SETUP([layer3 - ping over GRE])
 OVS_TRAFFIC_VSWITCHD_START([set Bridge br0 other-config:hwaddr="00:12:34:56:78:bb"])
 OVS_CHECK_GRE_L3()
@@ -205,3 +153,224 @@ AT_CHECK([tail -1 stdout], [0],
 
 OVS_VSWITCHD_STOP
 AT_CLEANUP
+
+AT_SETUP([layer3 - ping over GTP])
+OVS_TRAFFIC_VSWITCHD_START([set Bridge br0 other-config:hwaddr="00:12:34:56:78:bb"])
+OVS_CHECK_GTP_L3()
+
+ADD_BR([br-underlay])
+
+ADD_NAMESPACES(at_ns0)
+
+dnl Set up underlay link from host into the namespace using veth pair.
+ADD_VETH(p0, at_ns0, br-underlay, "172.31.1.1/24")
+AT_CHECK([ip addr add dev br-underlay "172.31.1.100/24"])
+AT_CHECK([ip link set dev br-underlay up])
+AT_CHECK([modprobe vport_gtp])
+
+dnl Set up tunnel endpoints on OVS outside the namespace and with a native
+dnl linux device inside the namespace.
+
+ADD_OVS_TUNNEL([gtpu], [br0], [at_gtp0], [172.31.1.1], [10.1.1.2/24])
+AT_CHECK([ip neigh add 10.1.1.1 lladdr 00:12:34:56:78:aa dev br0])
+NS_CHECK_EXEC([at_ns0], [gtp-link add at_gtp1 --sgsn &], [0], [ignore])
+NS_CHECK_EXEC([at_ns0], [gtp-tunnel add at_gtp1 v1 0 0 10.1.1.1 172.31.1.100], [0], [ignore], [ignore])
+NS_CHECK_EXEC([at_ns0], [ip addr add dev at_gtp1 10.1.1.1/24])
+NS_CHECK_EXEC([at_ns0], [ip link set dev at_gtp1 mtu 1450 up])
+NS_CHECK_EXEC([at_ns0], [ip link set dev p0 mtu 1480 up])
+
+AT_CHECK([ovs-ofctl add-flow br-underlay "actions=normal"])
+
+AT_CHECK([ovs-appctl vlog/set dbg], [0], [ignore])
+AT_CHECK([echo 'module openvswitch +p' > /sys/kernel/debug/dynamic_debug/control])
+
+dnl Now add rules for OVS to forward to the tunnel and local port
+AT_CHECK([ovs-ofctl add-flow br0 "priority=1 action=drop"])
+AT_CHECK([ovs-ofctl add-flow br0 "priority=100 ip,nw_dst=10.1.1.1 action=output:at_gtp0"])
+AT_CHECK([ovs-ofctl add-flow br0 "priority=100 ip,nw_dst=10.1.1.2 action=mod_dl_src:00:12:34:56:78:aa,mod_dl_dst:00:12:34:56:78:bb,local"])
+
+
+dnl First, check the underlay
+NS_CHECK_EXEC([at_ns0], [ping -q -c 3 -i 0.3 -w 2 172.31.1.100 | FORMAT_PING], [0], [dnl
+3 packets transmitted, 3 received, 0% packet loss, time 0ms
+])
+
+OVS_WAIT_UNTIL([ip netns exec at_ns0 ping -c 1 10.1.1.2])
+dnl Okay, now check the overlay with different packet sizes
+NS_CHECK_EXEC([at_ns0], [ping -q -c 3 -i 0.3 -w 2 10.1.1.2 | FORMAT_PING], [0], [dnl
+3 packets transmitted, 3 received, 0% packet loss, time 0ms
+])
+NS_CHECK_EXEC([at_ns0], [ping -s 3200 -q -c 3 -i 0.3 -w 2 10.1.1.2 | FORMAT_PING], [0], [dnl
+3 packets transmitted, 3 received, 0% packet loss, time 0ms
+])
+
+OVS_TRAFFIC_VSWITCHD_STOP
+AT_CLEANUP
+
+AT_SETUP([layer3 - GTP echo match test])
+OVS_TRAFFIC_VSWITCHD_START([set Bridge br0 other-config:hwaddr="00:12:34:56:78:bb"])
+
+ADD_BR([br-underlay])
+
+ADD_NAMESPACES(at_ns0)
+
+dnl Set up underlay link from host into the namespace using veth pair.
+ADD_VETH(p0, at_ns0, br-underlay, "172.31.1.1/24")
+AT_CHECK([ip addr add dev br-underlay "172.31.1.100/24"])
+AT_CHECK([ip link set dev br-underlay up])
+
+dnl Set up tunnel endpoints on OVS outside the namespace and with a native
+dnl linux device inside the namespace.
+
+AT_CHECK([modprobe vport_gtp])
+ADD_OVS_TUNNEL([gtpu], [br0], [at_gtp0], [172.31.1.1], [10.1.1.2/24])
+AT_CHECK([ip neigh add 10.1.1.1 lladdr 00:12:34:56:78:aa dev br0])
+
+NS_CHECK_EXEC([at_ns0], [ip link set dev p0 mtu 1480 up])
+
+AT_CHECK([ovs-ofctl add-flow br-underlay "actions=normal"])
+
+AT_CHECK([ovs-ofctl add-flow br0 "priority=100 in_port=at_gtp0,tun_gtpu_msgtype=1,tun_gtpu_flags=0x32 action=drop"])
+
+dnl First, check the underlay
+NS_CHECK_EXEC([at_ns0], [ping -q -c 3 -i 0.3 -w 2 172.31.1.100 | FORMAT_PING], [0], [dnl
+3 packets transmitted, 3 received, 0% packet loss, time 0ms
+])
+
+dnl AT_CHECK([ovs-appctl vlog/set dbg], [0], [ignore])
+dnl AT_CHECK([echo 'module openvswitch +p' > /sys/kernel/debug/dynamic_debug/control])
+    
+NS_CHECK_EXEC([at_ns0], [test-gtp 172.31.1.100 3201000a0000000000010000ff0003000a01], [0], [ignore])
+
+AT_CHECK([ovs-ofctl dump-flows br0 | ofctl_strip | grep gtpu], [0], [dnl
+ n_packets=1, n_bytes=10, priority=100,gtpu_flags=0x32,gtpu_msgtype=1,in_port=1 actions=drop
+])
+
+OVS_TRAFFIC_VSWITCHD_STOP
+AT_CLEANUP
+
+AT_SETUP([layer3 - GTP echo response test])
+OVS_TRAFFIC_VSWITCHD_START([set Bridge br0 other-config:hwaddr="00:12:34:56:78:bb"])
+
+ADD_BR([br-underlay])
+
+ADD_NAMESPACES(at_ns0)
+
+dnl Set up underlay link from host into the namespace using veth pair.
+ADD_VETH(p0, at_ns0, br-underlay, "172.31.1.1/24")
+AT_CHECK([ip addr add dev br-underlay "172.31.1.100/24"])
+AT_CHECK([ip link set dev br-underlay up])
+AT_CHECK([modprobe vport_gtp])
+
+dnl Set up tunnel endpoints on OVS outside the namespace and with a native
+dnl linux device inside the namespace.
+
+ADD_OVS_TUNNEL([gtpu], [br0], [at_gtp0], [172.31.1.1], [10.1.1.2/24], [options:local_ip=172.31.1.100])
+AT_CHECK([ip neigh add 10.1.1.1 lladdr 00:12:34:56:78:aa dev br0])
+
+NS_CHECK_EXEC([at_ns0], [ip link set dev p0 mtu 1480 up])
+AT_CHECK([ovs-vsctl set interface at_gtp0 bfd:min_tx=500 bfd:min_rx=500])
+AT_CHECK([ovs-vsctl set interface at_gtp0 bfd:enable=true])
+
+AT_CHECK([ovs-ofctl add-flow br-underlay "actions=normal"])
+
+AT_CHECK([ovs-appctl vlog/set dbg], [0], [ignore])
+AT_CHECK([echo 'module openvswitch +p' > /sys/kernel/debug/dynamic_debug/control])
+
+AT_CHECK([ovs-appctl tnl/gtp_echo_remote_end_points], [0], [dnl
+Tunnel port: at_gtp0
+])  
+
+NS_CHECK_EXEC([at_ns0], [test-gtp 172.31.1.100 3201000a0000000000010000ff0003000a01], [0], [ignore])
+sleep 2
+AT_CHECK([ovs-appctl tnl/gtp_echo_remote_end_points | sed -e  's/^.*: RX/RX/'], [0], [dnl
+Tunnel port: at_gtp0
+RX: 1 TX: 1 remote ip: 172.31.1.1, seq 1, pending send 0
+])  
+
+NS_CHECK_EXEC([at_ns0], [tcpdump -l -n -xx -U udp -i p0 > p1.pcap &])
+sleep 1
+
+NS_CHECK_EXEC([at_ns0], [test-gtp 172.31.1.100 3201000a0000000000030000ff0003000a01], [0], [ignore])
+sleep 2
+AT_CHECK([ovs-appctl tnl/gtp_echo_remote_end_points | sed -e  's/^.*: RX/RX/'], [0], [dnl
+Tunnel port: at_gtp0
+RX: 2 TX: 2 remote ip: 172.31.1.1, seq 3, pending send 0
+])
+
+OVS_WAIT_UNTIL([cat p1.pcap | egrep "IP 172.31.1.100.2152 > 172.31.1.1.2152: UDP, length 12" 2>&1 1>/dev/null])
+OVS_WAIT_UNTIL([cat p1.pcap | egrep "0x0000:.*0800 4500"                                     2>&1 1>/dev/null])
+OVS_WAIT_UNTIL([cat p1.pcap | egrep "0x0010:.*ac1f 0164 ac1f"       2>&1 1>/dev/null])
+OVS_WAIT_UNTIL([cat p1.pcap | egrep "0x0020:  0101 0868 0868 0014 5ac9 3202 0004 0000"       2>&1 1>/dev/null])
+OVS_WAIT_UNTIL([cat p1.pcap | egrep "0x0030:  0000 0003 0e00"                                2>&1 1>/dev/null])
+
+OVS_TRAFFIC_VSWITCHD_STOP
+AT_CLEANUP
+
+AT_SETUP([layer3 - GTP echo response test multi endpoint])
+OVS_TRAFFIC_VSWITCHD_START([set Bridge br0 other-config:hwaddr="00:12:34:56:78:bb"])
+
+ADD_BR([br-underlay])
+
+ADD_NAMESPACES(at_ns0)
+ADD_NAMESPACES(at_ns1)
+
+dnl Set up underlay link from host into the namespace using veth pair.
+ADD_VETH(p0, at_ns0, br-underlay, "172.31.1.1/24")
+ADD_VETH(p1, at_ns1, br-underlay, "172.31.1.2/24")
+AT_CHECK([ip addr add dev br-underlay "172.31.1.100/24"])
+AT_CHECK([ip link set dev br-underlay up])
+
+AT_CHECK([modprobe vport_gtp])
+dnl Set up tunnel endpoints on OVS outside the namespace and with a native
+dnl linux device inside the namespace.
+
+ADD_OVS_TUNNEL_NO_REMOTE([gtpu], [br0], [at_gtp0], [10.1.1.2/24], [options:local_ip=172.31.1.100])
+AT_CHECK([ip neigh add 10.1.1.1 lladdr 00:12:34:56:78:aa dev br0])
+
+NS_CHECK_EXEC([at_ns0], [ip link set dev p0 mtu 1480 up])
+NS_CHECK_EXEC([at_ns1], [ip link set dev p1 mtu 1480 up])
+
+AT_CHECK([ovs-vsctl set interface at_gtp0 bfd:min_tx=500 bfd:min_rx=500])
+AT_CHECK([ovs-vsctl set interface at_gtp0 bfd:enable=true])
+
+AT_CHECK([ovs-ofctl add-flow br-underlay "actions=normal"])
+
+AT_CHECK([ovs-appctl vlog/set dbg], [0], [ignore])
+AT_CHECK([echo 'module openvswitch +p' > /sys/kernel/debug/dynamic_debug/control])
+
+AT_CHECK([ovs-appctl tnl/gtp_echo_remote_end_points], [0], [dnl
+Tunnel port: at_gtp0
+])  
+
+NS_CHECK_EXEC([at_ns0], [test-gtp 172.31.1.100 3201000a0000000000010000ff0003000a01], [0], [ignore])
+sleep 2
+AT_CHECK([ovs-appctl tnl/gtp_echo_remote_end_points | sed -e  's/^.*: RX/RX/'], [0], [dnl
+Tunnel port: at_gtp0
+RX: 1 TX: 1 remote ip: 172.31.1.1, seq 1, pending send 0
+])  
+
+NS_CHECK_EXEC([at_ns1], [test-gtp 172.31.1.100 3201000a0000000000030000ff0003000a01], [0], [ignore])
+sleep 2
+AT_CHECK([ovs-appctl tnl/gtp_echo_remote_end_points | sed -e  's/^.*: RX/RX/'], [0], [dnl
+Tunnel port: at_gtp0
+RX: 1 TX: 1 remote ip: 172.31.1.1, seq 1, pending send 0
+RX: 1 TX: 1 remote ip: 172.31.1.2, seq 3, pending send 0
+])  
+
+AT_CHECK([ovs-appctl tnl/gtp_echo_remote_end_points_purge], [0], [dnl
+Done
+])
+AT_CHECK([ovs-appctl tnl/gtp_echo_remote_end_points | sed -e  's/^.*: RX/RX/'], [0], [dnl
+Tunnel port: at_gtp0
+])  
+
+NS_CHECK_EXEC([at_ns0], [test-gtp 172.31.1.100 3201000a0000000000040000ff0003000a01], [0], [ignore])
+sleep 2
+AT_CHECK([ovs-appctl tnl/gtp_echo_remote_end_points | sed -e  's/^.*: RX/RX/'], [0], [dnl
+Tunnel port: at_gtp0
+RX: 1 TX: 1 remote ip: 172.31.1.1, seq 4, pending send 0
+])
+
+OVS_TRAFFIC_VSWITCHD_STOP
+AT_CLEANUP
diff --git a/tests/test-gtp.c b/tests/test-gtp.c
new file mode 100644
index 000000000..aede93daf
--- /dev/null
+++ b/tests/test-gtp.c
@@ -0,0 +1,111 @@
+#include <config.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include <string.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+
+#define DST_PORT  2152
+#define SRC_PORT  2152
+
+
+static int
+charToHex(char ch)
+{
+        if (ch >= 'A' && ch <= 'F') {
+                return 10 + (ch - 'A');
+        }
+        if (ch >= 'a' && ch <= 'f') {
+                return 10 + (ch - 'a');
+        }
+        if (ch >= '0' && ch <= '9') {
+                return ch - '0';
+        }
+        return -1;
+}
+
+int
+main(int argc, char *argv[])
+{
+    struct sockaddr_in addr, srcaddr;
+    int fd;
+    unsigned char *msg;
+    char *str_buf;
+    char *dst_ip;
+    int len, i, j;
+
+    if (argc != 3) {
+        printf("two param expected\n");
+        exit(1);
+    }
+
+    dst_ip = argv[1];
+    printf("dst IP %s\n", dst_ip);
+    str_buf = argv[2];
+    len = strlen(str_buf);
+
+    if (len % 2) {
+        printf("len should be multiple of 2\n");
+        exit (1);
+    }
+
+    msg = calloc(1, len);
+    if (!msg) {
+        exit(1);
+    }
+    j = 0;
+    for (i = 0; i < len; i+=2) {
+
+        int d1 = charToHex(str_buf[i]);
+        if (d1 < 0) {
+                printf("buf parse error\n");
+                exit (1);
+        }
+        int d2 = charToHex(str_buf[i+1]);
+        if (d2 < 0) {
+                printf("buf parse error\n");
+                exit (1);
+        }
+        msg[j++] = (d1 << 4) | d2;
+    }
+    len = len / 2;
+
+#if 0
+    printf("%d: ", len);
+    for (i = 0; i < len; i++) {
+        printf("%x", (int)msg[i]);
+    }
+    printf("\n");
+#endif
+
+    if ((fd = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {
+        perror("socket");
+        exit(1);
+    }
+
+    memset(&addr, 0, sizeof(addr));
+    addr.sin_family = AF_INET;
+    addr.sin_addr.s_addr = inet_addr(dst_ip);
+    addr.sin_port = htons(DST_PORT);
+
+    memset(&srcaddr, 0, sizeof(srcaddr));
+    srcaddr.sin_family = AF_INET;
+    srcaddr.sin_addr.s_addr = htonl(INADDR_ANY);
+    srcaddr.sin_port = htons(SRC_PORT);
+
+    if (bind(fd, (struct sockaddr *) &srcaddr, sizeof(srcaddr)) < 0) {
+        perror("bind");
+        exit(1);
+    }
+
+    if (sendto(fd, msg, len, 0, (struct sockaddr *) &addr,
+                sizeof(addr)) < 0) {
+        perror("sendto");
+    }
+    printf("done\n");
+    close(fd);
+    return 0;
+}
-- 
2.17.1


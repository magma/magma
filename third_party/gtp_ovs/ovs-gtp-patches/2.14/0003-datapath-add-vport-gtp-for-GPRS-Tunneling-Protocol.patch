From ee2a0eebb6085adc47f20ed94fd90ca08b8acef0 Mon Sep 17 00:00:00 2001
From: Pravin B Shelar <pbshelar@fb.com>
Date: Sat, 28 Nov 2020 00:55:30 -0800
Subject: [PATCH 03/19] datapath: add vport-gtp for GPRS Tunneling Protocol

Add vport-gtp which uses gtp_create_flow_based_dev exported by the Linux GTP
module to create a flow based net_device

tested with ubuntu kernel 5.6.19-050619-generic.

Signed-off-by: Pravin B Shelar <pbshelar@fb.com>
---
 acinclude.m4                                  |    4 +
 datapath/Modules.mk                           |    2 +
 datapath/linux/Modules.mk                     |    3 +
 datapath/linux/compat/gtp.c                   | 1797 +++++++++++++++++
 datapath/linux/compat/include/linux/gtp.h     |   10 +
 datapath/linux/compat/include/linux/if_link.h |   16 +
 datapath/linux/compat/include/net/dst_cache.h |    1 -
 datapath/linux/compat/include/net/gtp.h       |   24 +
 .../linux/compat/include/net/udp_tunnel.h     |    2 +-
 datapath/linux/compat/nf_conntrack_reasm.c    |    1 +
 datapath/linux/compat/udp_tunnel.c            |    2 +-
 datapath/vport-gtp.c                          |  147 ++
 datapath/vport.c                              |    8 +-
 tests/automake.mk                             |    2 +-
 tests/system-common-macros.at                 |    7 +
 tests/system-layer3-tunnels.at                |   53 +
 tests/tunnel.at                               |   28 +
 17 files changed, 2102 insertions(+), 5 deletions(-)
 create mode 100644 datapath/linux/compat/gtp.c
 create mode 100644 datapath/linux/compat/include/linux/gtp.h
 create mode 100644 datapath/linux/compat/include/net/gtp.h
 create mode 100644 datapath/vport-gtp.c

diff --git a/acinclude.m4 b/acinclude.m4
index 49ad9e8d0..d14cde02b 100644
--- a/acinclude.m4
+++ b/acinclude.m4
@@ -647,6 +647,8 @@ AC_DEFUN([OVS_CHECK_LINUX_COMPAT], [
 
   OVS_GREP_IFELSE([$KSRC/include/uapi/linux/if_link.h], [IFLA_GENEVE_TOS])
   OVS_GREP_IFELSE([$KSRC/include/uapi/linux/if_link.h], [rtnl_link_stats64])
+  OVS_GREP_IFELSE([$KSRC/include/uapi/linux/if_link.h], [GTP_ROLE_GGSN])
+  OVS_GREP_IFELSE([$KSRC/include/uapi/linux/if_link.h], [IFLA_GTP_ROLE])
   OVS_GREP_IFELSE([$KSRC/include/linux/if_link.h], [rtnl_link_stats64])
   OVS_GREP_IFELSE([$KSRC/include/linux/if_vlan.h], [vlan_set_encap_proto])
   OVS_GREP_IFELSE([$KSRC/include/linux/if_vlan.h], [vlan_hwaccel_push_inside])
@@ -681,6 +683,7 @@ AC_DEFUN([OVS_CHECK_LINUX_COMPAT], [
                   [OVS_DEFINE([HAVE_INET_FRAGS_LAST_IN])])
   OVS_GREP_IFELSE([$KSRC/include/net/inet_frag.h], [inet_frag_evicting])
   OVS_GREP_IFELSE([$KSRC/include/net/inet_frag.h], [inet_frag_evictor])
+  OVS_GREP_IFELSE([$KSRC/include/net/ipv6_frag.h], [_IPV6_FRAG_H])
   OVS_FIND_FIELD_IFELSE([$KSRC/include/net/inet_frag.h], [inet_frags],
                         [frags_work])
   OVS_FIND_FIELD_IFELSE([$KSRC/include/net/inet_frag.h], [inet_frags],
@@ -981,6 +984,7 @@ AC_DEFUN([OVS_CHECK_LINUX_COMPAT], [
                   [OVS_DEFINE([HAVE_NET_NAME_UNKNOWN])])
 
   OVS_GREP_IFELSE([$KSRC/include/net/sock.h], [sk_no_check_tx])
+  OVS_GREP_IFELSE([$KSRC/include/net/sock.h], [refcount_read], [OVS_DEFINE([HAVE_SOCK_REFCNT])])
   OVS_GREP_IFELSE([$KSRC/include/linux/udp.h], [no_check6_tx])
   OVS_FIND_PARAM_IFELSE([$KSRC/include/net/protocol.h],
                         [udp_add_offload], [net],
diff --git a/datapath/Modules.mk b/datapath/Modules.mk
index 3c4ae366c..9d930f7a1 100644
--- a/datapath/Modules.mk
+++ b/datapath/Modules.mk
@@ -8,6 +8,7 @@ both_modules = \
 	$(build_multi_modules) \
 	vport_geneve \
 	vport_gre \
+	vport_gtp \
 	vport_lisp \
 	vport_stt \
 	vport_vxlan
@@ -33,6 +34,7 @@ openvswitch_sources = \
 vport_geneve_sources = vport-geneve.c
 vport_vxlan_sources = vport-vxlan.c
 vport_gre_sources = vport-gre.c
+vport_gtp_sources = vport-gtp.c
 vport_lisp_sources = vport-lisp.c
 vport_stt_sources = vport-stt.c
 nsh_sources = nsh.c
diff --git a/datapath/linux/Modules.mk b/datapath/linux/Modules.mk
index 63a5cbae4..83df7ac5b 100644
--- a/datapath/linux/Modules.mk
+++ b/datapath/linux/Modules.mk
@@ -4,6 +4,7 @@ openvswitch_sources += \
 	linux/compat/exthdrs_core.c \
 	linux/compat/geneve.c \
 	linux/compat/gre.c \
+	linux/compat/gtp.c \
 	linux/compat/gso.c \
 	linux/compat/genetlink-openvswitch.c \
 	linux/compat/inet_fragment.c \
@@ -41,6 +42,7 @@ openvswitch_headers += \
 	linux/compat/include/linux/err.h \
 	linux/compat/include/linux/etherdevice.h \
 	linux/compat/include/linux/genetlink.h \
+	linux/compat/include/linux/gtp.h \
 	linux/compat/include/linux/if.h \
 	linux/compat/include/linux/if_ether.h \
 	linux/compat/include/linux/if_link.h \
@@ -78,6 +80,7 @@ openvswitch_headers += \
 	linux/compat/include/net/genetlink.h \
 	linux/compat/include/net/geneve.h \
 	linux/compat/include/net/gre.h \
+	linux/compat/include/net/gtp.h \
 	linux/compat/include/net/inet_ecn.h \
 	linux/compat/include/net/inet_frag.h \
 	linux/compat/include/net/inetpeer.h \
diff --git a/datapath/linux/compat/gtp.c b/datapath/linux/compat/gtp.c
new file mode 100644
index 000000000..29f742e47
--- /dev/null
+++ b/datapath/linux/compat/gtp.c
@@ -0,0 +1,1797 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/* GTP according to GSM TS 09.60 / 3GPP TS 29.060
+ *
+ * (C) 2012-2014 by sysmocom - s.f.m.c. GmbH
+ * (C) 2016 by Pablo Neira Ayuso <pablo@netfilter.org>
+ *
+ * Author: Harald Welte <hwelte@sysmocom.de>
+ *	   Pablo Neira Ayuso <pablo@netfilter.org>
+ *	   Andreas Schultz <aschultz@travelping.com>
+ */
+
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
+#include <linux/module.h>
+#include <linux/skbuff.h>
+#include <linux/udp.h>
+#include <linux/rculist.h>
+#include <linux/jhash.h>
+#include <linux/if_tunnel.h>
+#include <linux/net.h>
+#include <linux/file.h>
+#include <linux/gtp.h>
+
+#include <net/dst_cache.h>
+#include <net/dst_metadata.h>
+#include <net/net_namespace.h>
+#include <net/protocol.h>
+#include <net/ip.h>
+#include <net/udp.h>
+#include <net/udp_tunnel.h>
+#include <net/icmp.h>
+#include <net/xfrm.h>
+#include <net/genetlink.h>
+#include <net/netns/generic.h>
+#include <net/gtp.h>
+
+#include "gso.h"
+#include "vport-netdev.h"
+#include "compat.h"
+
+
+#define GTP_PDP_HASHSIZE 1024
+
+/* An active session for the subscriber. */
+struct pdp_ctx {
+	struct hlist_node	hlist_tid;
+	struct hlist_node	hlist_addr;
+
+	union {
+		struct {
+			u64	tid;
+			u16	flow;
+		} v0;
+		struct {
+			u32	i_tei;
+			u32	o_tei;
+		} v1;
+	} u;
+	u8			gtp_version;
+	u16			af;
+
+	struct in_addr		ms_addr_ip4;
+	struct in_addr		peer_addr_ip4;
+
+	struct sock		*sk;
+	struct net_device       *dev;
+
+	atomic_t		tx_seq;
+	struct rcu_head		rcu_head;
+};
+
+/* One instance of the GTP device. */
+struct gtp_dev {
+	struct list_head	list;
+
+	struct net_device	*dev;
+	struct sock		*sk0;
+	struct sock		*sk1u;
+
+	unsigned int		role;
+	unsigned int		hash_size;
+	struct hlist_head	*tid_hash;
+	struct hlist_head	*addr_hash;
+	/* Used by flow based tunnel. */
+	unsigned int            collect_md;
+	__be16			gtph_port;
+};
+
+static unsigned int gtp_net_id __read_mostly;
+
+struct gtp_net {
+	struct list_head gtp_dev_list;
+};
+
+static u32 gtp_h_initval;
+
+static void pdp_context_delete(struct pdp_ctx *pctx);
+
+static inline u32 gtp0_hashfn(u64 tid)
+{
+	u32 *tid32 = (u32 *) &tid;
+	return jhash_2words(tid32[0], tid32[1], gtp_h_initval);
+}
+
+static inline u32 gtp1u_hashfn(u32 tid)
+{
+	return jhash_1word(tid, gtp_h_initval);
+}
+
+static inline u32 ipv4_hashfn(__be32 ip)
+{
+	return jhash_1word((__force u32)ip, gtp_h_initval);
+}
+
+/* Resolve a PDP context structure based on the 64bit TID. */
+static struct pdp_ctx *gtp0_pdp_find(struct gtp_dev *gtp, u64 tid)
+{
+	struct hlist_head *head;
+	struct pdp_ctx *pdp;
+
+	head = &gtp->tid_hash[gtp0_hashfn(tid) % gtp->hash_size];
+
+	hlist_for_each_entry_rcu(pdp, head, hlist_tid) {
+		if (pdp->gtp_version == GTP_V0 &&
+		    pdp->u.v0.tid == tid)
+			return pdp;
+	}
+	return NULL;
+}
+
+/* Resolve a PDP context structure based on the 32bit TEI. */
+static struct pdp_ctx *gtp1_pdp_find(struct gtp_dev *gtp, u32 tid)
+{
+	struct hlist_head *head;
+	struct pdp_ctx *pdp;
+
+	head = &gtp->tid_hash[gtp1u_hashfn(tid) % gtp->hash_size];
+
+	hlist_for_each_entry_rcu(pdp, head, hlist_tid) {
+		if (pdp->gtp_version == GTP_V1 &&
+		    pdp->u.v1.i_tei == tid)
+			return pdp;
+	}
+	return NULL;
+}
+
+/* Resolve a PDP context based on IPv4 address of MS. */
+static struct pdp_ctx *ipv4_pdp_find(struct gtp_dev *gtp, __be32 ms_addr)
+{
+	struct hlist_head *head;
+	struct pdp_ctx *pdp;
+
+	head = &gtp->addr_hash[ipv4_hashfn(ms_addr) % gtp->hash_size];
+
+	hlist_for_each_entry_rcu(pdp, head, hlist_addr) {
+		if (pdp->af == AF_INET &&
+		    pdp->ms_addr_ip4.s_addr == ms_addr)
+			return pdp;
+	}
+
+	return NULL;
+}
+
+static bool gtp_check_ms_ipv4(struct sk_buff *skb, struct pdp_ctx *pctx,
+				  unsigned int hdrlen, unsigned int role)
+{
+	struct iphdr *iph;
+
+	if (!pskb_may_pull(skb, hdrlen + sizeof(struct iphdr)))
+		return false;
+
+	iph = (struct iphdr *)(skb->data + hdrlen);
+
+	if (role == GTP_ROLE_SGSN)
+		return iph->daddr == pctx->ms_addr_ip4.s_addr;
+	else
+		return iph->saddr == pctx->ms_addr_ip4.s_addr;
+}
+
+/* Check if the inner IP address in this packet is assigned to any
+ * existing mobile subscriber.
+ */
+static bool gtp_check_ms(struct sk_buff *skb, struct pdp_ctx *pctx,
+			     unsigned int hdrlen, unsigned int role)
+{
+	switch (ntohs(skb->protocol)) {
+	case ETH_P_IP:
+		return gtp_check_ms_ipv4(skb, pctx, hdrlen, role);
+	}
+	return false;
+}
+
+static int gtp_rx(struct gtp_dev *gtp, struct sk_buff *skb,
+			unsigned int hdrlen, u8 gtp_version, unsigned int role,
+			__be64 tid)
+{
+#ifndef USE_UPSTREAM_TUNNEL
+	union {
+		struct metadata_dst dst;
+		char buf[sizeof(struct metadata_dst) + 0];
+	} buf;
+#endif
+	struct pcpu_sw_netstats *stats;
+	int err;
+
+	if (ip_tunnel_collect_metadata() || gtp->collect_md) {
+#ifndef USE_UPSTREAM_TUNNEL
+		struct metadata_dst *tun_dst = &buf.dst;
+
+		//udp_tun_rx_dst
+		ovs_udp_tun_rx_dst(tun_dst, skb, gtp->sk1u->sk_family, TUNNEL_KEY, tid, 0);
+#else
+		struct metadata_dst *tun_dst =
+			udp_tun_rx_dst(skb, gtp->sk1u->sk_family, TUNNEL_KEY, tid, 0);
+#endif
+		netdev_dbg(gtp->dev, "attaching metadata_dst to skb\n");
+		/* Get rid of the GTP + UDP headers. */
+		if (iptunnel_pull_header(skb, hdrlen, skb->protocol,
+					 !net_eq(sock_net(gtp->sk1u), dev_net(gtp->dev)))) {
+			err = -1;
+			gtp->dev->stats.rx_length_errors++;
+			goto err;
+		}
+		ovs_skb_dst_set(skb, &tun_dst->dst);
+	} else {
+		struct pdp_ctx *pctx;
+		if (gtp_version == GTP_V0) {
+			pctx = gtp0_pdp_find(gtp, be64_to_cpu(tid));
+			if (!pctx) {
+				netdev_dbg(gtp->dev, "No PDP ctx to decap skb=%p\n", skb);
+				return 1;
+			}
+		} else 	{
+			pctx = gtp1_pdp_find(gtp, be64_to_cpu(tid));
+			if (!pctx) {
+				netdev_dbg(gtp->dev, "No PDP ctx to decap skb=%p\n", skb);
+				return 1;
+			}
+		}
+
+		if (!gtp_check_ms(skb, pctx, hdrlen, role)) {
+			netdev_dbg(pctx->dev, "No PDP ctx for this MS\n");
+			return 1;
+		}
+		/* Get rid of the GTP + UDP headers. */
+		if (iptunnel_pull_header(skb, hdrlen, skb->protocol,
+					 !net_eq(sock_net(pctx->sk), dev_net(gtp->dev)))) {
+			err = -1;
+			gtp->dev->stats.rx_length_errors++;
+			goto err;
+		}
+	}
+	netdev_dbg(gtp->dev, "forwarding packet from GGSN to uplink\n");
+
+	/* Now that the UDP and the GTP header have been removed, set up the
+	 * new network header. This is required by the upper layer to
+	 * calculate the transport header.
+	 */
+	skb_reset_network_header(skb);
+
+	skb->dev = gtp->dev;
+
+	stats = this_cpu_ptr(gtp->dev->tstats);
+	u64_stats_update_begin(&stats->syncp);
+	stats->rx_packets++;
+	stats->rx_bytes += skb->len;
+	u64_stats_update_end(&stats->syncp);
+
+#ifndef USE_UPSTREAM_TUNNEL
+	netdev_port_receive(skb, skb_tunnel_info(skb));
+#else
+	netif_rx(skb);
+#endif
+	return 0;
+
+err:
+	gtp->dev->stats.rx_dropped++;
+	return err;
+}
+
+/* 1 means pass up to the stack, -1 means drop and 0 means decapsulated. */
+static int gtp0_udp_encap_recv(struct gtp_dev *gtp, struct sk_buff *skb)
+{
+	unsigned int hdrlen = sizeof(struct udphdr) +
+			      sizeof(struct gtp0_header);
+	struct gtp0_header *gtp0;
+
+	if (!pskb_may_pull(skb, hdrlen))
+		return -1;
+
+	gtp0 = (struct gtp0_header *)(skb->data + sizeof(struct udphdr));
+
+	if ((gtp0->flags >> 5) != GTP_V0)
+		return 1;
+
+	if (gtp0->type != GTP_TPDU)
+		return 1;
+
+	return gtp_rx(gtp, skb, hdrlen, GTP_V0, gtp->role, gtp0->tid);
+}
+
+static int gtp1u_udp_encap_recv(struct gtp_dev *gtp, struct sk_buff *skb)
+{
+	unsigned int hdrlen = sizeof(struct udphdr) +
+			      sizeof(struct gtp1_header);
+	struct gtp1_header *gtp1;
+
+	if (!pskb_may_pull(skb, hdrlen))
+		return -1;
+
+	gtp1 = (struct gtp1_header *)(skb->data + sizeof(struct udphdr));
+
+	if ((gtp1->flags >> 5) != GTP_V1)
+		return 1;
+
+	if (gtp1->type != GTP_TPDU)
+		return 1;
+
+	/* From 29.060: "This field shall be present if and only if any one or
+	 * more of the S, PN and E flags are set.".
+	 *
+	 * If any of the bit is set, then the remaining ones also have to be
+	 * set.
+	 */
+	if (gtp1->flags & GTP1_F_MASK)
+		hdrlen += 4;
+
+	/* Make sure the header is larger enough, including extensions. */
+	if (!pskb_may_pull(skb, hdrlen))
+		return -1;
+
+	gtp1 = (struct gtp1_header *)(skb->data + sizeof(struct udphdr));
+
+	return gtp_rx(gtp, skb, hdrlen, GTP_V1, gtp->role, key32_to_tunnel_id(gtp1->tid));
+}
+
+static void __gtp_encap_destroy(struct sock *sk)
+{
+	struct gtp_dev *gtp;
+
+	lock_sock(sk);
+	gtp = sk->sk_user_data;
+	if (gtp) {
+		if (gtp->sk0 == sk)
+			gtp->sk0 = NULL;
+		else
+			gtp->sk1u = NULL;
+		udp_sk(sk)->encap_type = 0;
+		rcu_assign_sk_user_data(sk, NULL);
+		sock_put(sk);
+	}
+	release_sock(sk);
+}
+
+static void gtp_encap_destroy(struct sock *sk)
+{
+	__gtp_encap_destroy(sk);
+}
+
+static void gtp_encap_disable_sock(struct sock *sk)
+{
+	if (!sk)
+		return;
+
+	__gtp_encap_destroy(sk);
+}
+
+static void gtp_encap_disable(struct gtp_dev *gtp)
+{
+	gtp_encap_disable_sock(gtp->sk0);
+	gtp_encap_disable_sock(gtp->sk1u);
+}
+
+/* UDP encapsulation receive handler. See net/ipv4/udp.c.
+ * Return codes: 0: success, <0: error, >0: pass up to userspace UDP socket.
+ */
+static int gtp_encap_recv(struct sock *sk, struct sk_buff *skb)
+{
+	struct gtp_dev *gtp;
+	int ret = 0;
+
+	gtp = rcu_dereference_sk_user_data(sk);
+	if (!gtp)
+		return 1;
+
+	netdev_dbg(gtp->dev, "encap_recv sk=%p\n", sk);
+
+	switch (udp_sk(sk)->encap_type) {
+	case UDP_ENCAP_GTP0:
+		netdev_dbg(gtp->dev, "received GTP0 packet\n");
+		ret = gtp0_udp_encap_recv(gtp, skb);
+		break;
+	case UDP_ENCAP_GTP1U:
+		netdev_dbg(gtp->dev, "received GTP1U packet\n");
+		ret = gtp1u_udp_encap_recv(gtp, skb);
+		break;
+	default:
+		ret = -1; /* Shouldn't happen. */
+	}
+
+	switch (ret) {
+	case 1:
+		netdev_dbg(gtp->dev, "pass up to the process\n");
+		break;
+	case 0:
+		break;
+	case -1:
+		netdev_dbg(gtp->dev, "GTP packet has been dropped\n");
+		kfree_skb(skb);
+		ret = 0;
+		break;
+	}
+
+	return ret;
+}
+
+static int gtp_dev_init(struct net_device *dev)
+{
+	struct gtp_dev *gtp = netdev_priv(dev);
+
+	gtp->dev = dev;
+
+	dev->tstats = netdev_alloc_pcpu_stats(struct pcpu_sw_netstats);
+	if (!dev->tstats)
+		return -ENOMEM;
+
+	return 0;
+}
+
+static void gtp_dev_uninit(struct net_device *dev)
+{
+	struct gtp_dev *gtp = netdev_priv(dev);
+
+	gtp_encap_disable(gtp);
+	free_percpu(dev->tstats);
+}
+
+static struct rtable *ip4_route_output_gtp(struct flowi4 *fl4,
+					   const struct sock *sk,
+					   __be32 daddr)
+{
+	memset(fl4, 0, sizeof(*fl4));
+	fl4->flowi4_oif		= sk->sk_bound_dev_if;
+	fl4->daddr		= daddr;
+	fl4->saddr		= inet_sk(sk)->inet_saddr;
+	fl4->flowi4_tos		= RT_CONN_FLAGS(sk);
+	fl4->flowi4_proto	= sk->sk_protocol;
+
+	return ip_route_output_key(sock_net(sk), fl4);
+}
+
+static inline void gtp0_push_header(struct sk_buff *skb, struct pdp_ctx *pctx)
+{
+	int payload_len = skb->len;
+	struct gtp0_header *gtp0;
+
+	gtp0 = (struct gtp0_header *) skb_push(skb, sizeof(*gtp0));
+
+	gtp0->flags	= 0x1e; /* v0, GTP-non-prime. */
+	gtp0->type	= GTP_TPDU;
+	gtp0->length	= htons(payload_len);
+	gtp0->seq	= htons((atomic_inc_return(&pctx->tx_seq) - 1) % 0xffff);
+	gtp0->flow	= htons(pctx->u.v0.flow);
+	gtp0->number	= 0xff;
+	gtp0->spare[0]	= gtp0->spare[1] = gtp0->spare[2] = 0xff;
+	gtp0->tid	= cpu_to_be64(pctx->u.v0.tid);
+}
+
+static inline void gtp1_push_header(struct sk_buff *skb, __be64 tid)
+{
+	int payload_len = skb->len;
+	struct gtp1_header *gtp1;
+
+	gtp1 = (struct gtp1_header *) skb_push(skb, sizeof(*gtp1));
+
+	/* Bits    8  7  6  5  4  3  2	1
+	 *	  +--+--+--+--+--+--+--+--+
+	 *	  |version |PT| 0| E| S|PN|
+	 *	  +--+--+--+--+--+--+--+--+
+	 *	    0  0  1  1	1  0  0  0
+	 */
+	gtp1->flags	= 0x30; /* v1, GTP-non-prime. */
+	gtp1->type	= GTP_TPDU;
+	gtp1->length	= htons(payload_len);
+	gtp1->tid	= tid;
+
+	/* TODO: Suppport for extension header, sequence number and N-PDU.
+	 *	 Update the length field if any of them is available.
+	 */
+}
+
+struct gtp_pktinfo {
+	struct sock		*sk;
+	struct iphdr		*iph;
+	struct flowi4		fl4;
+	struct rtable		*rt;
+	struct pdp_ctx		*pctx;
+	struct net_device	*dev;
+	__be16			gtph_port;
+};
+
+static void gtp_push_header(struct sk_buff *skb, struct gtp_pktinfo *pktinfo)
+{
+	switch (pktinfo->pctx->gtp_version) {
+	case GTP_V0:
+		pktinfo->gtph_port = htons(GTP0_PORT);
+		gtp0_push_header(skb, pktinfo->pctx);
+		break;
+	case GTP_V1:
+		pktinfo->gtph_port = htons(GTP1U_PORT);
+		gtp1_push_header(skb, htonl(pktinfo->pctx->u.v1.o_tei));
+		break;
+	}
+}
+
+static inline void gtp_set_pktinfo_ipv4(struct gtp_pktinfo *pktinfo,
+					struct sock *sk, struct iphdr *iph,
+					struct pdp_ctx *pctx, struct rtable *rt,
+					struct flowi4 *fl4,
+					struct net_device *dev)
+{
+	pktinfo->sk	= sk;
+	pktinfo->iph	= iph;
+	pktinfo->pctx	= pctx;
+	pktinfo->rt	= rt;
+	pktinfo->fl4	= *fl4;
+	pktinfo->dev	= dev;
+}
+
+static struct rtable *gtp_get_v4_rt(struct sk_buff *skb,
+                                       struct net_device *dev,
+                                       struct sock *gs4,
+                                       struct flowi4 *fl4,
+                                       const struct ip_tunnel_info *info)
+{
+	bool use_cache = ip_tunnel_dst_cache_usable(skb, info);
+	struct dst_cache *dst_cache;
+	struct rtable *rt = NULL;
+
+	if (!gs4)
+		return ERR_PTR(-EIO);
+
+	memset(fl4, 0, sizeof(*fl4));
+	fl4->flowi4_mark = skb->mark;
+	fl4->flowi4_proto = IPPROTO_UDP;
+	fl4->daddr = info->key.u.ipv4.dst;
+	fl4->saddr = info->key.u.ipv4.src;
+	fl4->flowi4_tos = RT_TOS(info->key.tos);
+
+	dst_cache = (struct dst_cache *)&info->dst_cache;
+	if (use_cache) {
+		rt = dst_cache_get_ip4(dst_cache, &fl4->saddr);
+		if (rt)
+			return rt;
+	}
+	rt = ip_route_output_key(dev_net(dev), fl4);
+	if (IS_ERR(rt)) {
+		netdev_dbg(dev, "no route to %pI4\n", &fl4->daddr);
+		return ERR_PTR(-ENETUNREACH);
+	}
+	if (rt->dst.dev == dev) { /* is this necessary? */
+		netdev_dbg(dev, "circular route to %pI4\n", &fl4->daddr);
+		ip_rt_put(rt);
+		return ERR_PTR(-ELOOP);
+	}
+	if (use_cache)
+		dst_cache_set_ip4(dst_cache, &rt->dst, fl4->saddr);
+	return rt;
+}
+
+static netdev_tx_t gtp_dev_xmit_fb(struct sk_buff *skb, struct net_device *dev)
+{
+	struct ip_tunnel_info *info = skb_tunnel_info(skb);
+	struct gtp_dev *gtp = netdev_priv(dev);
+	struct iphdr *iph = ip_hdr(skb);
+	struct rtable *rt;
+	struct flowi4 fl4;
+	__be16 df;
+	int mtu;
+
+	/* Read the IP destination address and resolve the PDP context.
+	 * Prepend PDP header with TEI/TID from PDP ctx.
+	 */
+
+	if (!info) {
+		netdev_dbg(dev, "no info for FB tunnel xmit\n");
+		goto err;
+	}
+	rt = gtp_get_v4_rt(skb, dev, gtp->sk1u, &fl4, info);
+	if (IS_ERR(rt)) {
+		netdev_dbg(dev, "no route to SSGN %pI4\n", &fl4.daddr);
+		dev->stats.tx_carrier_errors++;
+		goto err;
+	}
+
+	skb_dst_drop(skb);
+
+	df = iph->frag_off;
+	if (df) {
+		mtu = dst_mtu(&rt->dst) - dev->hard_header_len -
+			sizeof(struct iphdr) - sizeof(struct udphdr);
+		mtu -= sizeof(struct gtp1_header);
+	} else {
+		mtu = dst_mtu(&rt->dst);
+	}
+#ifndef HAVE_DST_OPS_CONFIRM_NEIGH
+	rt->dst.ops->update_pmtu(&rt->dst, NULL, skb, mtu);
+#else
+	rt->dst.ops->update_pmtu(&rt->dst, NULL, skb, mtu, false);
+#endif
+
+	if (!skb_is_gso(skb) && (iph->frag_off & htons(IP_DF)) &&
+	    mtu < ntohs(iph->tot_len)) {
+		netdev_dbg(dev, "packet too big, fragmentation needed\n");
+		dev->stats.tx_carrier_errors++;
+		goto err_rt;
+	}
+
+	gtp1_push_header(skb, tunnel_id_to_key32(info->key.tun_id));
+	udp_tunnel_xmit_skb(rt, gtp->sk1u, skb,
+			    fl4.saddr, fl4.daddr, fl4.flowi4_tos,
+			    ip4_dst_hoplimit(&rt->dst),
+			    0,
+			    gtp->gtph_port, gtp->gtph_port,
+			    false, false);
+
+	return NETDEV_TX_OK;
+err_rt:
+	ip_rt_put(rt);
+err:
+	dev->stats.tx_errors++;
+	dev_kfree_skb(skb);
+	return NETDEV_TX_OK;
+}
+
+static int gtp_build_skb_ip4(struct sk_buff *skb, struct net_device *dev,
+			     struct gtp_pktinfo *pktinfo)
+{
+	struct gtp_dev *gtp = netdev_priv(dev);
+	struct pdp_ctx *pctx;
+	struct rtable *rt;
+	struct flowi4 fl4;
+	struct iphdr *iph;
+	__be16 df;
+	int mtu;
+
+	/* Read the IP destination address and resolve the PDP context.
+	 * Prepend PDP header with TEI/TID from PDP ctx.
+	 */
+	iph = ip_hdr(skb);
+	if (gtp->role == GTP_ROLE_SGSN)
+		pctx = ipv4_pdp_find(gtp, iph->saddr);
+	else
+		pctx = ipv4_pdp_find(gtp, iph->daddr);
+
+	if (!pctx) {
+		netdev_dbg(dev, "no PDP ctx found for %pI4, skip\n",
+			   &iph->daddr);
+		return -ENOENT;
+	}
+	netdev_dbg(dev, "found PDP context %p\n", pctx);
+
+	rt = ip4_route_output_gtp(&fl4, pctx->sk, pctx->peer_addr_ip4.s_addr);
+	if (IS_ERR(rt)) {
+		netdev_dbg(dev, "no route to SSGN %pI4\n",
+			   &pctx->peer_addr_ip4.s_addr);
+		dev->stats.tx_carrier_errors++;
+		goto err;
+	}
+
+	if (rt->dst.dev == dev) {
+		netdev_dbg(dev, "circular route to SSGN %pI4\n",
+			   &pctx->peer_addr_ip4.s_addr);
+		dev->stats.collisions++;
+		goto err_rt;
+	}
+
+	skb_dst_drop(skb);
+
+	/* This is similar to tnl_update_pmtu(). */
+	df = iph->frag_off;
+	if (df) {
+		mtu = dst_mtu(&rt->dst) - dev->hard_header_len -
+			sizeof(struct iphdr) - sizeof(struct udphdr);
+		switch (pctx->gtp_version) {
+		case GTP_V0:
+			mtu -= sizeof(struct gtp0_header);
+			break;
+		case GTP_V1:
+			mtu -= sizeof(struct gtp1_header);
+			break;
+		}
+	} else {
+		mtu = dst_mtu(&rt->dst);
+	}
+
+#ifndef HAVE_DST_OPS_CONFIRM_NEIGH
+	rt->dst.ops->update_pmtu(&rt->dst, NULL, skb, mtu);
+#else
+	rt->dst.ops->update_pmtu(&rt->dst, NULL, skb, mtu, false);
+#endif
+	if (!skb_is_gso(skb) && (iph->frag_off & htons(IP_DF)) &&
+	    mtu < ntohs(iph->tot_len)) {
+		netdev_dbg(dev, "packet too big, fragmentation needed\n");
+		memset(IPCB(skb), 0, sizeof(*IPCB(skb)));
+		icmp_send(skb, ICMP_DEST_UNREACH, ICMP_FRAG_NEEDED,
+			  htonl(mtu));
+		goto err_rt;
+	}
+
+	gtp_set_pktinfo_ipv4(pktinfo, pctx->sk, iph, pctx, rt, &fl4, dev);
+	gtp_push_header(skb, pktinfo);
+
+	return 0;
+err_rt:
+	ip_rt_put(rt);
+err:
+	return -EBADMSG;
+}
+
+static netdev_tx_t gtp_dev_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+	unsigned int proto = ntohs(skb->protocol);
+	struct gtp_dev *gtp = netdev_priv(dev);
+	struct gtp_pktinfo pktinfo;
+	int err;
+
+	/* Ensure there is sufficient headroom. */
+	if (skb_cow_head(skb, dev->needed_headroom))
+		goto tx_err;
+
+	skb_reset_inner_headers(skb);
+	if (gtp->collect_md) {
+		return gtp_dev_xmit_fb(skb, dev);
+	}
+
+	/* PDP context lookups in gtp_build_skb_*() need rcu read-side lock. */
+	rcu_read_lock();
+	switch (proto) {
+	case ETH_P_IP:
+		err = gtp_build_skb_ip4(skb, dev, &pktinfo);
+		break;
+	default:
+		err = -EOPNOTSUPP;
+		break;
+	}
+	rcu_read_unlock();
+
+	if (err < 0)
+		goto tx_err;
+
+	switch (proto) {
+	case ETH_P_IP:
+		netdev_dbg(pktinfo.dev, "gtp -> IP src: %pI4 dst: %pI4\n",
+			   &pktinfo.iph->saddr, &pktinfo.iph->daddr);
+		udp_tunnel_xmit_skb(pktinfo.rt, pktinfo.sk, skb,
+				    pktinfo.fl4.saddr, pktinfo.fl4.daddr,
+				    pktinfo.iph->tos,
+				    ip4_dst_hoplimit(&pktinfo.rt->dst),
+				    0,
+				    pktinfo.gtph_port, pktinfo.gtph_port,
+				    false, false);
+		break;
+	}
+
+	return NETDEV_TX_OK;
+tx_err:
+	dev->stats.tx_errors++;
+	dev_kfree_skb(skb);
+	return NETDEV_TX_OK;
+}
+
+static int gtp_hashtable_new(struct gtp_dev *gtp, int hsize);
+static int gtp_encap_enable(struct gtp_dev *gtp, struct nlattr *data[]);
+
+static int gtp_change_mtu(struct net_device *dev, int new_mtu, bool strict)
+{
+        int max_mtu = IP_MAX_MTU - dev->hard_header_len - sizeof(struct iphdr)
+                        - sizeof(struct udphdr) - sizeof(struct gtp1_header);
+
+        if (new_mtu < ETH_MIN_MTU)
+                return -EINVAL;
+
+        if (new_mtu > max_mtu) {
+                if (strict)
+                        return -EINVAL;
+
+                new_mtu = max_mtu;
+        }
+
+        dev->mtu = new_mtu;
+        return 0;
+}
+
+static int gtp_dev_open(struct net_device *dev)
+{
+	struct gtp_dev *gtp = netdev_priv(dev);
+	struct net *net = dev_net(dev);
+	struct socket *sock1u;
+	struct udp_tunnel_sock_cfg tunnel_cfg;
+	struct udp_port_cfg udp_conf;
+	int err;
+
+	if (gtp->sk1u) {
+		sock_hold(gtp->sk1u);
+		return 0;
+	}
+
+	memset(&udp_conf, 0, sizeof(udp_conf));
+
+	udp_conf.family = AF_INET;
+	udp_conf.local_ip.s_addr = htonl(INADDR_ANY);
+	udp_conf.local_udp_port = htons(GTP1U_PORT);
+
+	err = udp_sock_create(dev_net(dev), &udp_conf, &sock1u);
+	if (err < 0)
+		return err;
+
+	memset(&tunnel_cfg, 0, sizeof(tunnel_cfg));
+	tunnel_cfg.sk_user_data = gtp;
+	tunnel_cfg.encap_rcv = gtp_encap_recv;
+	tunnel_cfg.encap_destroy = gtp_encap_destroy;
+	tunnel_cfg.encap_type = UDP_ENCAP_GTP1U;
+
+	setup_udp_tunnel_sock(net, sock1u, &tunnel_cfg);
+
+	sock_hold(sock1u->sk);
+
+	gtp->sk1u = sock1u->sk;
+	gtp->gtph_port = htons(GTP1U_PORT);
+
+	return 0;
+}
+
+static int gtp_dev_stop(struct net_device *dev)
+{
+	struct gtp_dev *gtp = netdev_priv(dev);
+
+	ASSERT_RTNL();
+	if (gtp->sk0)
+		udp_tunnel_sock_release(gtp->sk0->sk_socket);
+	if (gtp->sk1u) {
+		struct sock *sk = gtp->sk1u;
+
+		sock_put(sk);
+#ifdef HAVE_SOCK_REFCNT
+		if (refcount_read(&sk->sk_refcnt) == 2) {
+#else
+		if (atomic_read(&sk->sk_refcnt) == 2) {
+#endif
+			udp_tunnel_sock_release(gtp->sk1u->sk_socket);
+		}
+	}
+
+	return 0;
+}
+
+static const struct net_device_ops gtp_netdev_ops = {
+	.ndo_init		= gtp_dev_init,
+	.ndo_uninit		= gtp_dev_uninit,
+	.ndo_open               = gtp_dev_open,
+	.ndo_stop               = gtp_dev_stop,
+	.ndo_start_xmit		= gtp_dev_xmit,
+	.ndo_get_stats64	= ip_tunnel_get_stats64,
+};
+
+static struct gtp_dev *gtp_find_flow_based_dev(
+		struct net *net)
+{
+	struct gtp_net *gn = net_generic(net, gtp_net_id);
+	struct gtp_dev *gtp, *t = NULL;
+
+	list_for_each_entry(gtp, &gn->gtp_dev_list, list) {
+		if (gtp->collect_md)
+			t = gtp;
+	}
+
+	return t;
+}
+
+static void gtp_link_setup(struct net_device *dev)
+{
+	dev->netdev_ops		= &gtp_netdev_ops;
+
+#ifdef HAVE_NEEDS_FREE_NETDEV
+	dev->needs_free_netdev	= true;
+#endif
+	dev->hard_header_len = 0;
+	dev->addr_len = 0;
+
+	/* Zero header length. */
+	dev->type = ARPHRD_NONE;
+	dev->flags = IFF_POINTOPOINT | IFF_NOARP | IFF_MULTICAST;
+
+	dev->priv_flags	|= IFF_NO_QUEUE;
+	dev->features	|= NETIF_F_LLTX;
+	netif_keep_dst(dev);
+
+	/* Assume largest header, ie. GTPv0. */
+	dev->needed_headroom	= LL_MAX_HEADER +
+				  sizeof(struct iphdr) +
+				  sizeof(struct udphdr) +
+				  sizeof(struct gtp0_header);
+}
+
+static int gtp_hashtable_new(struct gtp_dev *gtp, int hsize);
+static int gtp_encap_enable(struct gtp_dev *gtp, struct nlattr *data[]);
+
+static void gtp_destructor(struct net_device *dev)
+{
+	struct gtp_dev *gtp = netdev_priv(dev);
+
+	kfree(gtp->addr_hash);
+	kfree(gtp->tid_hash);
+}
+
+#ifdef HAVE_EXT_ACK_IN_RTNL_LINKOPS
+static int gtp_newlink(struct net *src_net, struct net_device *dev,
+		       struct nlattr *tb[], struct nlattr *data[],
+		       struct netlink_ext_ack *extack)
+#else
+static int gtp_newlink(struct net *src_net, struct net_device *dev,
+		       struct nlattr *tb[], struct nlattr *data[])
+#endif
+{
+	struct gtp_dev *gtp;
+	struct gtp_net *gn;
+	int hashsize, err;
+
+	if (!data[IFLA_GTP_FD0] && !data[IFLA_GTP_FD1])
+		return -EINVAL;
+
+	gtp = netdev_priv(dev);
+
+	err = gtp_encap_enable(gtp, data);
+	if (err < 0)
+		return err;
+
+	if (!data[IFLA_GTP_PDP_HASHSIZE]) {
+		hashsize = 1024;
+	} else {
+		hashsize = nla_get_u32(data[IFLA_GTP_PDP_HASHSIZE]);
+		if (!hashsize)
+			hashsize = 1024;
+	}
+
+	err = gtp_hashtable_new(gtp, hashsize);
+	if (err < 0)
+		goto out_encap;
+
+	err = register_netdevice(dev);
+	if (err < 0) {
+		netdev_dbg(dev, "failed to register new netdev %d\n", err);
+		goto out_hashtable;
+	}
+
+	gn = net_generic(dev_net(dev), gtp_net_id);
+	list_add_rcu(&gtp->list, &gn->gtp_dev_list);
+#ifdef HAVE_NEEDS_FREE_NETDEV
+	dev->priv_destructor = gtp_destructor;
+#else
+	dev->destructor = gtp_destructor;
+#endif
+	netdev_dbg(dev, "registered new GTP interface\n");
+
+	return 0;
+
+out_hashtable:
+	kfree(gtp->addr_hash);
+	kfree(gtp->tid_hash);
+out_encap:
+	gtp_encap_disable(gtp);
+	return err;
+}
+
+static void gtp_hashtable_free(struct net_device *dev)
+{
+	struct gtp_dev *gtp = netdev_priv(dev);
+	struct pdp_ctx *pctx;
+	int i;
+
+	for (i = 0; i < gtp->hash_size; i++)
+		hlist_for_each_entry_rcu(pctx, &gtp->tid_hash[i], hlist_tid)
+			pdp_context_delete(pctx);
+
+	list_del_rcu(&gtp->list);
+}
+
+static void gtp_dellink(struct net_device *dev, struct list_head *head)
+{
+	gtp_hashtable_free(dev);
+	unregister_netdevice_queue(dev, head);
+}
+
+static const struct nla_policy gtp_policy[IFLA_GTP_MAX + 3] = {
+	[IFLA_GTP_FD0]			= { .type = NLA_U32 },
+	[IFLA_GTP_FD1]			= { .type = NLA_U32 },
+	[IFLA_GTP_PDP_HASHSIZE]		= { .type = NLA_U32 },
+	[IFLA_GTP_ROLE]			= { .type = NLA_U32 },
+};
+
+#ifdef HAVE_EXT_ACK_IN_RTNL_LINKOPS
+static int gtp_validate(struct nlattr *tb[], struct nlattr *data[],
+			struct netlink_ext_ack *extack)
+#else
+static int gtp_validate(struct nlattr *tb[], struct nlattr *data[])
+#endif
+{
+	if (!data)
+		return -EINVAL;
+
+	return 0;
+}
+
+static size_t gtp_get_size(const struct net_device *dev)
+{
+	return nla_total_size(sizeof(__u32));	/* IFLA_GTP_PDP_HASHSIZE */
+}
+
+static int gtp_fill_info(struct sk_buff *skb, const struct net_device *dev)
+{
+	struct gtp_dev *gtp = netdev_priv(dev);
+
+	if (nla_put_u32(skb, IFLA_GTP_PDP_HASHSIZE, gtp->hash_size))
+		goto nla_put_failure;
+
+	return 0;
+
+nla_put_failure:
+	return -EMSGSIZE;
+}
+
+static struct rtnl_link_ops gtp_link_ops __read_mostly = {
+	.kind		= "ovs_gtp",
+	.maxtype	= IFLA_GTP_MAX,
+	.policy		= gtp_policy,
+	.priv_size	= sizeof(struct gtp_dev),
+	.setup		= gtp_link_setup,
+	.validate	= gtp_validate,
+	.newlink	= gtp_newlink,
+	.dellink	= gtp_dellink,
+	.get_size	= gtp_get_size,
+	.fill_info	= gtp_fill_info,
+};
+
+static int gtp_hashtable_new(struct gtp_dev *gtp, int hsize)
+{
+	int i;
+
+	gtp->addr_hash = kmalloc_array(hsize, sizeof(struct hlist_head),
+				       GFP_KERNEL);
+	if (gtp->addr_hash == NULL)
+		return -ENOMEM;
+
+	gtp->tid_hash = kmalloc_array(hsize, sizeof(struct hlist_head),
+				      GFP_KERNEL);
+	if (gtp->tid_hash == NULL)
+		goto err1;
+
+	gtp->hash_size = hsize;
+
+	for (i = 0; i < hsize; i++) {
+		INIT_HLIST_HEAD(&gtp->addr_hash[i]);
+		INIT_HLIST_HEAD(&gtp->tid_hash[i]);
+	}
+	return 0;
+err1:
+	kfree(gtp->addr_hash);
+	return -ENOMEM;
+}
+
+static struct sock *gtp_encap_enable_socket(int fd, int type,
+					    struct gtp_dev *gtp)
+{
+	struct udp_tunnel_sock_cfg tuncfg = {NULL};
+	struct socket *sock;
+	struct sock *sk;
+	int err;
+
+	pr_debug("enable gtp on %d, %d\n", fd, type);
+
+	sock = sockfd_lookup(fd, &err);
+	if (!sock) {
+		pr_debug("gtp socket fd=%d not found\n", fd);
+		return NULL;
+	}
+
+	sk = sock->sk;
+	if (sk->sk_protocol != IPPROTO_UDP ||
+	    sk->sk_type != SOCK_DGRAM ||
+	    (sk->sk_family != AF_INET && sk->sk_family != AF_INET6)) {
+		pr_debug("socket fd=%d not UDP\n", fd);
+		sk = ERR_PTR(-EINVAL);
+		goto out_sock;
+	}
+
+	lock_sock(sk);
+	if (sk->sk_user_data) {
+		sk = ERR_PTR(-EBUSY);
+		goto out_rel_sock;
+	}
+
+	sock_hold(sk);
+
+	tuncfg.sk_user_data = gtp;
+	tuncfg.encap_type = type;
+	tuncfg.encap_rcv = gtp_encap_recv;
+	tuncfg.encap_destroy = gtp_encap_destroy;
+
+	setup_udp_tunnel_sock(sock_net(sock->sk), sock, &tuncfg);
+
+out_rel_sock:
+	release_sock(sock->sk);
+out_sock:
+	sockfd_put(sock);
+	return sk;
+}
+
+static int gtp_encap_enable(struct gtp_dev *gtp, struct nlattr *data[])
+{
+	struct sock *sk1u = NULL;
+	struct sock *sk0 = NULL;
+	unsigned int role = GTP_ROLE_GGSN;
+
+	if (data[IFLA_GTP_FD0]) {
+		u32 fd0 = nla_get_u32(data[IFLA_GTP_FD0]);
+
+		sk0 = gtp_encap_enable_socket(fd0, UDP_ENCAP_GTP0, gtp);
+		if (IS_ERR(sk0))
+			return PTR_ERR(sk0);
+	}
+
+	if (data[IFLA_GTP_FD1]) {
+		u32 fd1 = nla_get_u32(data[IFLA_GTP_FD1]);
+
+		sk1u = gtp_encap_enable_socket(fd1, UDP_ENCAP_GTP1U, gtp);
+		if (IS_ERR(sk1u)) {
+			gtp_encap_disable_sock(sk0);
+			return PTR_ERR(sk1u);
+		}
+	}
+
+	if (data[IFLA_GTP_ROLE]) {
+		role = nla_get_u32(data[IFLA_GTP_ROLE]);
+		if (role > GTP_ROLE_SGSN) {
+			gtp_encap_disable_sock(sk0);
+			gtp_encap_disable_sock(sk1u);
+			return -EINVAL;
+		}
+	}
+
+	gtp->sk0 = sk0;
+	gtp->sk1u = sk1u;
+	gtp->role = role;
+
+	return 0;
+}
+
+static struct gtp_dev *gtp_find_dev(struct net *src_net, struct nlattr *nla[])
+{
+	struct gtp_dev *gtp = NULL;
+	struct net_device *dev;
+	struct net *net;
+
+	/* Examine the link attributes and figure out which network namespace
+	 * we are talking about.
+	 */
+	if (nla[GTPA_NET_NS_FD])
+		net = get_net_ns_by_fd(nla_get_u32(nla[GTPA_NET_NS_FD]));
+	else
+		net = get_net(src_net);
+
+	if (IS_ERR(net))
+		return NULL;
+
+	/* Check if there's an existing gtpX device to configure */
+	dev = dev_get_by_index_rcu(net, nla_get_u32(nla[GTPA_LINK]));
+	if (dev && dev->netdev_ops == &gtp_netdev_ops)
+		gtp = netdev_priv(dev);
+
+	put_net(net);
+	return gtp;
+}
+
+static void ipv4_pdp_fill(struct pdp_ctx *pctx, struct genl_info *info)
+{
+	pctx->gtp_version = nla_get_u32(info->attrs[GTPA_VERSION]);
+	pctx->af = AF_INET;
+	pctx->peer_addr_ip4.s_addr =
+		nla_get_be32(info->attrs[GTPA_PEER_ADDRESS]);
+	pctx->ms_addr_ip4.s_addr =
+		nla_get_be32(info->attrs[GTPA_MS_ADDRESS]);
+
+	switch (pctx->gtp_version) {
+	case GTP_V0:
+		/* According to TS 09.60, sections 7.5.1 and 7.5.2, the flow
+		 * label needs to be the same for uplink and downlink packets,
+		 * so let's annotate this.
+		 */
+		pctx->u.v0.tid = nla_get_u64(info->attrs[GTPA_TID]);
+		pctx->u.v0.flow = nla_get_u16(info->attrs[GTPA_FLOW]);
+		break;
+	case GTP_V1:
+		pctx->u.v1.i_tei = nla_get_u32(info->attrs[GTPA_I_TEI]);
+		pctx->u.v1.o_tei = nla_get_u32(info->attrs[GTPA_O_TEI]);
+		break;
+	default:
+		break;
+	}
+}
+
+static int gtp_pdp_add(struct gtp_dev *gtp, struct sock *sk,
+		       struct genl_info *info)
+{
+	struct pdp_ctx *pctx, *pctx_tid = NULL;
+	struct net_device *dev = gtp->dev;
+	u32 hash_ms, hash_tid = 0;
+	unsigned int version;
+	bool found = false;
+	__be32 ms_addr;
+
+	ms_addr = nla_get_be32(info->attrs[GTPA_MS_ADDRESS]);
+	hash_ms = ipv4_hashfn(ms_addr) % gtp->hash_size;
+	version = nla_get_u32(info->attrs[GTPA_VERSION]);
+
+	pctx = ipv4_pdp_find(gtp, ms_addr);
+	if (pctx)
+		found = true;
+	if (version == GTP_V0)
+		pctx_tid = gtp0_pdp_find(gtp,
+					 nla_get_u64(info->attrs[GTPA_TID]));
+	else if (version == GTP_V1)
+		pctx_tid = gtp1_pdp_find(gtp,
+					 nla_get_u32(info->attrs[GTPA_I_TEI]));
+	if (pctx_tid)
+		found = true;
+
+	if (found) {
+		if (info->nlhdr->nlmsg_flags & NLM_F_EXCL)
+			return -EEXIST;
+		if (info->nlhdr->nlmsg_flags & NLM_F_REPLACE)
+			return -EOPNOTSUPP;
+
+		if (pctx && pctx_tid)
+			return -EEXIST;
+		if (!pctx)
+			pctx = pctx_tid;
+
+		ipv4_pdp_fill(pctx, info);
+
+		if (pctx->gtp_version == GTP_V0)
+			netdev_dbg(dev, "GTPv0-U: update tunnel id = %llx (pdp %p)\n",
+				   pctx->u.v0.tid, pctx);
+		else if (pctx->gtp_version == GTP_V1)
+			netdev_dbg(dev, "GTPv1-U: update tunnel id = %x/%x (pdp %p)\n",
+				   pctx->u.v1.i_tei, pctx->u.v1.o_tei, pctx);
+
+		return 0;
+
+	}
+
+	pctx = kmalloc(sizeof(*pctx), GFP_ATOMIC);
+	if (pctx == NULL)
+		return -ENOMEM;
+
+	sock_hold(sk);
+	pctx->sk = sk;
+	pctx->dev = gtp->dev;
+	ipv4_pdp_fill(pctx, info);
+	atomic_set(&pctx->tx_seq, 0);
+
+	switch (pctx->gtp_version) {
+	case GTP_V0:
+		/* TS 09.60: "The flow label identifies unambiguously a GTP
+		 * flow.". We use the tid for this instead, I cannot find a
+		 * situation in which this doesn't unambiguosly identify the
+		 * PDP context.
+		 */
+		hash_tid = gtp0_hashfn(pctx->u.v0.tid) % gtp->hash_size;
+		break;
+	case GTP_V1:
+		hash_tid = gtp1u_hashfn(pctx->u.v1.i_tei) % gtp->hash_size;
+		break;
+	}
+
+	hlist_add_head_rcu(&pctx->hlist_addr, &gtp->addr_hash[hash_ms]);
+	hlist_add_head_rcu(&pctx->hlist_tid, &gtp->tid_hash[hash_tid]);
+
+	switch (pctx->gtp_version) {
+	case GTP_V0:
+		netdev_dbg(dev, "GTPv0-U: new PDP ctx id=%llx ssgn=%pI4 ms=%pI4 (pdp=%p)\n",
+			   pctx->u.v0.tid, &pctx->peer_addr_ip4,
+			   &pctx->ms_addr_ip4, pctx);
+		break;
+	case GTP_V1:
+		netdev_dbg(dev, "GTPv1-U: new PDP ctx id=%x/%x ssgn=%pI4 ms=%pI4 (pdp=%p)\n",
+			   pctx->u.v1.i_tei, pctx->u.v1.o_tei,
+			   &pctx->peer_addr_ip4, &pctx->ms_addr_ip4, pctx);
+		break;
+	}
+
+	return 0;
+}
+
+static void pdp_context_free(struct rcu_head *head)
+{
+	struct pdp_ctx *pctx = container_of(head, struct pdp_ctx, rcu_head);
+
+	sock_put(pctx->sk);
+	kfree(pctx);
+}
+
+static void pdp_context_delete(struct pdp_ctx *pctx)
+{
+	hlist_del_rcu(&pctx->hlist_tid);
+	hlist_del_rcu(&pctx->hlist_addr);
+	call_rcu(&pctx->rcu_head, pdp_context_free);
+}
+
+static int gtp_genl_new_pdp(struct sk_buff *skb, struct genl_info *info)
+{
+	unsigned int version;
+	struct gtp_dev *gtp;
+	struct sock *sk;
+	int err;
+
+	if (!info->attrs[GTPA_VERSION] ||
+	    !info->attrs[GTPA_LINK] ||
+	    !info->attrs[GTPA_PEER_ADDRESS] ||
+	    !info->attrs[GTPA_MS_ADDRESS])
+		return -EINVAL;
+
+	version = nla_get_u32(info->attrs[GTPA_VERSION]);
+
+	switch (version) {
+	case GTP_V0:
+		if (!info->attrs[GTPA_TID] ||
+		    !info->attrs[GTPA_FLOW])
+			return -EINVAL;
+		break;
+	case GTP_V1:
+		if (!info->attrs[GTPA_I_TEI] ||
+		    !info->attrs[GTPA_O_TEI])
+			return -EINVAL;
+		break;
+
+	default:
+		return -EINVAL;
+	}
+
+	rtnl_lock();
+	rcu_read_lock();
+
+	gtp = gtp_find_dev(sock_net(skb->sk), info->attrs);
+	if (!gtp) {
+		err = -ENODEV;
+		goto out_unlock;
+	}
+
+	if (version == GTP_V0)
+		sk = gtp->sk0;
+	else if (version == GTP_V1)
+		sk = gtp->sk1u;
+	else
+		sk = NULL;
+
+	if (!sk) {
+		err = -ENODEV;
+		goto out_unlock;
+	}
+
+	err = gtp_pdp_add(gtp, sk, info);
+
+out_unlock:
+	rcu_read_unlock();
+	rtnl_unlock();
+	return err;
+}
+
+static struct pdp_ctx *gtp_find_pdp_by_link(struct net *net,
+					    struct nlattr *nla[])
+{
+	struct gtp_dev *gtp;
+
+	gtp = gtp_find_dev(net, nla);
+	if (!gtp)
+		return ERR_PTR(-ENODEV);
+
+	if (nla[GTPA_MS_ADDRESS]) {
+		__be32 ip = nla_get_be32(nla[GTPA_MS_ADDRESS]);
+
+		return ipv4_pdp_find(gtp, ip);
+	} else if (nla[GTPA_VERSION]) {
+		u32 gtp_version = nla_get_u32(nla[GTPA_VERSION]);
+
+		if (gtp_version == GTP_V0 && nla[GTPA_TID])
+			return gtp0_pdp_find(gtp, nla_get_u64(nla[GTPA_TID]));
+		else if (gtp_version == GTP_V1 && nla[GTPA_I_TEI])
+			return gtp1_pdp_find(gtp, nla_get_u32(nla[GTPA_I_TEI]));
+	}
+
+	return ERR_PTR(-EINVAL);
+}
+
+static struct pdp_ctx *gtp_find_pdp(struct net *net, struct nlattr *nla[])
+{
+	struct pdp_ctx *pctx;
+
+	if (nla[GTPA_LINK])
+		pctx = gtp_find_pdp_by_link(net, nla);
+	else
+		pctx = ERR_PTR(-EINVAL);
+
+	if (!pctx)
+		pctx = ERR_PTR(-ENOENT);
+
+	return pctx;
+}
+
+static int gtp_genl_del_pdp(struct sk_buff *skb, struct genl_info *info)
+{
+	struct pdp_ctx *pctx;
+	int err = 0;
+
+	if (!info->attrs[GTPA_VERSION])
+		return -EINVAL;
+
+	rcu_read_lock();
+
+	pctx = gtp_find_pdp(sock_net(skb->sk), info->attrs);
+	if (IS_ERR(pctx)) {
+		err = PTR_ERR(pctx);
+		goto out_unlock;
+	}
+
+	if (pctx->gtp_version == GTP_V0)
+		netdev_dbg(pctx->dev, "GTPv0-U: deleting tunnel id = %llx (pdp %p)\n",
+			   pctx->u.v0.tid, pctx);
+	else if (pctx->gtp_version == GTP_V1)
+		netdev_dbg(pctx->dev, "GTPv1-U: deleting tunnel id = %x/%x (pdp %p)\n",
+			   pctx->u.v1.i_tei, pctx->u.v1.o_tei, pctx);
+
+	pdp_context_delete(pctx);
+
+out_unlock:
+	rcu_read_unlock();
+	return err;
+}
+
+static struct genl_family gtp_genl_family;
+
+static int gtp_genl_fill_info(struct sk_buff *skb, u32 snd_portid, u32 snd_seq,
+			      u32 type, struct pdp_ctx *pctx)
+{
+	void *genlh;
+
+	genlh = genlmsg_put(skb, snd_portid, snd_seq, &gtp_genl_family, 0,
+			    type);
+	if (genlh == NULL)
+		goto nlmsg_failure;
+
+	if (nla_put_u32(skb, GTPA_VERSION, pctx->gtp_version) ||
+	    nla_put_be32(skb, GTPA_PEER_ADDRESS, pctx->peer_addr_ip4.s_addr) ||
+	    nla_put_be32(skb, GTPA_MS_ADDRESS, pctx->ms_addr_ip4.s_addr))
+		goto nla_put_failure;
+
+	switch (pctx->gtp_version) {
+	case GTP_V0:
+		if (nla_put_u64_64bit(skb, GTPA_TID, pctx->u.v0.tid, GTPA_PAD) ||
+		    nla_put_u16(skb, GTPA_FLOW, pctx->u.v0.flow))
+			goto nla_put_failure;
+		break;
+	case GTP_V1:
+		if (nla_put_u32(skb, GTPA_I_TEI, pctx->u.v1.i_tei) ||
+		    nla_put_u32(skb, GTPA_O_TEI, pctx->u.v1.o_tei))
+			goto nla_put_failure;
+		break;
+	}
+	genlmsg_end(skb, genlh);
+	return 0;
+
+nlmsg_failure:
+nla_put_failure:
+	genlmsg_cancel(skb, genlh);
+	return -EMSGSIZE;
+}
+
+static int gtp_genl_get_pdp(struct sk_buff *skb, struct genl_info *info)
+{
+	struct pdp_ctx *pctx = NULL;
+	struct sk_buff *skb2;
+	int err;
+
+	if (!info->attrs[GTPA_VERSION])
+		return -EINVAL;
+
+	rcu_read_lock();
+
+	pctx = gtp_find_pdp(sock_net(skb->sk), info->attrs);
+	if (IS_ERR(pctx)) {
+		err = PTR_ERR(pctx);
+		goto err_unlock;
+	}
+
+	skb2 = genlmsg_new(NLMSG_GOODSIZE, GFP_ATOMIC);
+	if (skb2 == NULL) {
+		err = -ENOMEM;
+		goto err_unlock;
+	}
+
+	err = gtp_genl_fill_info(skb2, NETLINK_CB(skb).portid,
+				 info->snd_seq, info->nlhdr->nlmsg_type, pctx);
+	if (err < 0)
+		goto err_unlock_free;
+
+	rcu_read_unlock();
+	return genlmsg_unicast(genl_info_net(info), skb2, info->snd_portid);
+
+err_unlock_free:
+	kfree_skb(skb2);
+err_unlock:
+	rcu_read_unlock();
+	return err;
+}
+
+static int gtp_genl_dump_pdp(struct sk_buff *skb,
+				struct netlink_callback *cb)
+{
+	struct gtp_dev *last_gtp = (struct gtp_dev *)cb->args[2], *gtp;
+	int i, j, bucket = cb->args[0], skip = cb->args[1];
+	struct net *net = sock_net(skb->sk);
+	struct pdp_ctx *pctx;
+	struct gtp_net *gn;
+
+	gn = net_generic(net, gtp_net_id);
+
+	if (cb->args[4])
+		return 0;
+
+	rcu_read_lock();
+	list_for_each_entry_rcu(gtp, &gn->gtp_dev_list, list) {
+		if (last_gtp && last_gtp != gtp)
+			continue;
+		else
+			last_gtp = NULL;
+
+		for (i = bucket; i < gtp->hash_size; i++) {
+			j = 0;
+			hlist_for_each_entry_rcu(pctx, &gtp->tid_hash[i],
+						 hlist_tid) {
+				if (j >= skip &&
+				    gtp_genl_fill_info(skb,
+					    NETLINK_CB(cb->skb).portid,
+					    cb->nlh->nlmsg_seq,
+					    cb->nlh->nlmsg_type, pctx)) {
+					cb->args[0] = i;
+					cb->args[1] = j;
+					cb->args[2] = (unsigned long)gtp;
+					goto out;
+				}
+				j++;
+			}
+			skip = 0;
+		}
+		bucket = 0;
+	}
+	cb->args[4] = 1;
+out:
+	rcu_read_unlock();
+	return skb->len;
+}
+
+static const struct nla_policy gtp_genl_policy[GTPA_MAX + 1] = {
+	[GTPA_LINK]		= { .type = NLA_U32, },
+	[GTPA_VERSION]		= { .type = NLA_U32, },
+	[GTPA_TID]		= { .type = NLA_U64, },
+	[GTPA_PEER_ADDRESS]	= { .type = NLA_U32, },
+	[GTPA_MS_ADDRESS]	= { .type = NLA_U32, },
+	[GTPA_FLOW]		= { .type = NLA_U16, },
+	[GTPA_NET_NS_FD]	= { .type = NLA_U32, },
+	[GTPA_I_TEI]		= { .type = NLA_U32, },
+	[GTPA_O_TEI]		= { .type = NLA_U32, },
+};
+
+static const struct genl_ops gtp_genl_ops[] = {
+	{
+		.cmd = GTP_CMD_NEWPDP,
+		.doit = gtp_genl_new_pdp,
+#ifdef HAVE_GENL_OPS_POLICY
+		.policy = gtp_genl_policy,
+#endif
+		.flags = GENL_ADMIN_PERM,
+	},
+	{
+		.cmd = GTP_CMD_DELPDP,
+		.doit = gtp_genl_del_pdp,
+#ifdef HAVE_GENL_OPS_POLICY
+		.policy = gtp_genl_policy,
+#endif
+		.flags = GENL_ADMIN_PERM,
+	},
+	{
+		.cmd = GTP_CMD_GETPDP,
+		.doit = gtp_genl_get_pdp,
+		.dumpit = gtp_genl_dump_pdp,
+#ifdef HAVE_GENL_OPS_POLICY
+		.policy = gtp_genl_policy,
+#endif
+		.flags = GENL_ADMIN_PERM,
+	},
+};
+
+static struct genl_family gtp_genl_family __ro_after_init = {
+	.name		= "ovs_gtp",
+	.version	= 0,
+	.hdrsize	= 0,
+	.maxattr	= GTPA_MAX,
+#ifndef HAVE_GENL_OPS_POLICY
+	.policy = gtp_genl_policy,
+#endif
+	.netnsok	= true,
+	.module		= THIS_MODULE,
+	.ops		= gtp_genl_ops,
+	.n_ops		= ARRAY_SIZE(gtp_genl_ops),
+};
+
+static int gtp_configure(struct net *net, struct net_device *dev)
+{
+	struct gtp_net *gn = net_generic(net, gtp_net_id);
+	struct gtp_dev *gtp = netdev_priv(dev);
+	int err;
+
+	gtp->dev = dev;
+
+	if (gtp_find_flow_based_dev(net))
+		return -EBUSY;
+
+	dev->netdev_ops         = &gtp_netdev_ops;
+
+#ifdef HAVE_NEEDS_FREE_NETDEV
+	dev->priv_destructor = gtp_destructor;
+#else
+	dev->destructor = gtp_destructor;
+#endif
+
+	dev->hard_header_len = 0;
+	dev->addr_len = 0;
+
+	/* Zero header length. */
+	dev->type = ARPHRD_NONE;
+	dev->flags = IFF_POINTOPOINT | IFF_NOARP | IFF_MULTICAST;
+
+	dev->priv_flags |= IFF_NO_QUEUE;
+	dev->features   |= NETIF_F_LLTX;
+	netif_keep_dst(dev);
+
+	/* Assume largest header, ie. GTPv0. */
+	dev->needed_headroom    = LL_MAX_HEADER +
+		sizeof(struct iphdr) +
+		sizeof(struct udphdr) +
+		sizeof(struct gtp0_header);
+
+	gtp->collect_md = true;
+
+	err = gtp_hashtable_new(gtp, GTP_PDP_HASHSIZE);
+	if (err < 0) {
+		pr_err("Error gtp_hashtable_new");
+		return err;
+	}
+
+	err = register_netdevice(dev);
+	if (err) {
+		pr_err("Error when registering net device");
+		return err;
+	}
+
+	list_add_rcu(&gtp->list, &gn->gtp_dev_list);
+	return 0;
+}
+
+struct net_device *rpl_gtp_create_flow_based_dev(struct net *net,
+		const char *name,
+		u8 name_assign_type,
+		u16 dst_port)
+{
+	struct nlattr *tb[IFLA_MAX + 1];
+	struct net_device *dev;
+	LIST_HEAD(list_kill);
+	int err;
+
+	memset(&tb, 0, sizeof(tb));
+	dev = rtnl_create_link(net, name, name_assign_type,
+			&gtp_link_ops, tb);
+	if (IS_ERR(dev)) {
+		pr_err("error rtnl_create_link");
+		return dev;
+	}
+
+	err = gtp_configure(net, dev);
+	if (err < 0) {
+		pr_err("error gtp_configure");
+		free_netdev(dev);
+		return ERR_PTR(err);
+	}
+
+	/* openvswitch users expect packet sizes to be unrestricted,
+	 * so set the largest MTU we can.
+	 */
+	err = gtp_change_mtu(dev, IP_MAX_MTU, false);
+	if (err) {
+		pr_err("error gtp_change_mtu");
+		goto err;
+	}
+
+	err = rtnl_configure_link(dev, NULL);
+	if (err < 0)  {
+		pr_err("error rtnl_configure_link");
+		goto err;
+	}
+
+	return dev;
+
+err:
+	gtp_dellink(dev, &list_kill);
+	unregister_netdevice_many(&list_kill);
+	return ERR_PTR(err);
+}
+EXPORT_SYMBOL_GPL(rpl_gtp_create_flow_based_dev);
+
+static int __net_init gtp_net_init(struct net *net)
+{
+	struct gtp_net *gn = net_generic(net, gtp_net_id);
+
+	INIT_LIST_HEAD(&gn->gtp_dev_list);
+	return 0;
+}
+
+static void __net_exit gtp_net_exit(struct net *net)
+{
+	struct gtp_net *gn = net_generic(net, gtp_net_id);
+	struct gtp_dev *gtp;
+	LIST_HEAD(list);
+
+	rtnl_lock();
+	list_for_each_entry(gtp, &gn->gtp_dev_list, list)
+		gtp_dellink(gtp->dev, &list);
+
+	unregister_netdevice_many(&list);
+	rtnl_unlock();
+}
+
+static struct pernet_operations gtp_net_ops = {
+	.init	= gtp_net_init,
+	.exit	= gtp_net_exit,
+	.id	= &gtp_net_id,
+	.size	= sizeof(struct gtp_net),
+};
+
+int rpl_gtp_init_module(void)
+{
+	int err;
+
+	get_random_bytes(&gtp_h_initval, sizeof(gtp_h_initval));
+
+	err = rtnl_link_register(&gtp_link_ops);
+	if (err < 0)
+		goto error_out;
+
+	err = genl_register_family(&gtp_genl_family);
+	if (err < 0)
+		goto unreg_rtnl_link;
+
+	err = register_pernet_subsys(&gtp_net_ops);
+	if (err < 0)
+		goto unreg_genl_family;
+
+	pr_info("GTP module with tunnel metadata support (pdp ctx size %zd bytes)\n",
+		sizeof(struct pdp_ctx));
+	return 0;
+
+unreg_genl_family:
+	genl_unregister_family(&gtp_genl_family);
+unreg_rtnl_link:
+	rtnl_link_unregister(&gtp_link_ops);
+error_out:
+	pr_err("error loading GTP module loaded\n");
+	return err;
+}
+
+void rpl_gtp_cleanup_module(void)
+{
+	genl_unregister_family(&gtp_genl_family);
+	rtnl_link_unregister(&gtp_link_ops);
+	unregister_pernet_subsys(&gtp_net_ops);
+
+	pr_info("GTP module unloaded\n");
+}
diff --git a/datapath/linux/compat/include/linux/gtp.h b/datapath/linux/compat/include/linux/gtp.h
new file mode 100644
index 000000000..6d3443389
--- /dev/null
+++ b/datapath/linux/compat/include/linux/gtp.h
@@ -0,0 +1,10 @@
+#ifndef _WRAPPER_UAPI_LINUX_GTP_H_
+#define _WRAPPER_UAPI_LINUX_GTP_H_
+
+#include_next <linux/gtp.h>
+
+#ifndef GTPA_PEER_ADDRESS
+#define GTPA_PEER_ADDRESS GTPA_SGSN_ADDRESS
+#endif
+
+#endif
diff --git a/datapath/linux/compat/include/linux/if_link.h b/datapath/linux/compat/include/linux/if_link.h
index bd77e33d3..092d79468 100644
--- a/datapath/linux/compat/include/linux/if_link.h
+++ b/datapath/linux/compat/include/linux/if_link.h
@@ -168,4 +168,20 @@ struct rtnl_link_stats64 {
 };
 #endif
 
+#ifndef HAVE_GTP_ROLE_GGSN
+/* GTP section */
+
+enum ifla_gtp_role {
+        GTP_ROLE_GGSN = 0,
+        GTP_ROLE_SGSN,
+};
+#endif
+
+#ifndef HAVE_IFLA_GTP_ROLE
+
+enum {
+	IFLA_GTP_ROLE = (IFLA_GTP_PDP_HASHSIZE + 1)
+};
+#endif
+
 #endif
diff --git a/datapath/linux/compat/include/net/dst_cache.h b/datapath/linux/compat/include/net/dst_cache.h
index 6084d4eea..37c219e87 100644
--- a/datapath/linux/compat/include/net/dst_cache.h
+++ b/datapath/linux/compat/include/net/dst_cache.h
@@ -4,7 +4,6 @@
 #ifdef USE_BUILTIN_DST_CACHE
 #include_next <net/dst_cache.h>
 #else
-
 #include <linux/jiffies.h>
 #include <net/dst.h>
 #if IS_ENABLED(CONFIG_IPV6)
diff --git a/datapath/linux/compat/include/net/gtp.h b/datapath/linux/compat/include/net/gtp.h
new file mode 100644
index 000000000..327f64d1e
--- /dev/null
+++ b/datapath/linux/compat/include/net/gtp.h
@@ -0,0 +1,24 @@
+#ifndef __NET_GTP_WRAPPER_H
+#define __NET_GTP_WRAPPER_H  1
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)
+#ifdef CONFIG_INET
+#include <net/udp_tunnel.h>
+#endif /* ifdef CONFIG_INET */
+
+#include_next <net/gtp.h>
+
+#define gtp_xmit dev_queue_xmit
+
+struct net_device *rpl_gtp_dev_create_fb(
+	struct net *net, const char *name, u8 name_assign_type, u16 dst_port);
+#define gtp_create_flow_based_dev rpl_gtp_create_flow_based_dev
+
+
+#define gtp_init_module rpl_gtp_init_module
+#define gtp_cleanup_module rpl_gtp_cleanup_module
+int rpl_gtp_init_module(void);
+void rpl_gtp_cleanup_module(void);
+
+#endif /* 4.7 kernel */
+#endif /* __NET_GTP_WRAPPER_H */
diff --git a/datapath/linux/compat/include/net/udp_tunnel.h b/datapath/linux/compat/include/net/udp_tunnel.h
index 6e4063359..2db7e1afb 100644
--- a/datapath/linux/compat/include/net/udp_tunnel.h
+++ b/datapath/linux/compat/include/net/udp_tunnel.h
@@ -203,6 +203,6 @@ static inline void ovs_udp_tun_rx_dst(struct metadata_dst *md_dst,
 	if (udp_hdr(skb)->check)
 		info->key.tun_flags |= TUNNEL_CSUM;
 }
-#endif /* USE_UPSTREAM_TUNNEL */
 
+#endif /* USE_UPSTREAM_TUNNEL */
 #endif
diff --git a/datapath/linux/compat/nf_conntrack_reasm.c b/datapath/linux/compat/nf_conntrack_reasm.c
index 77b4b2548..debea478c 100644
--- a/datapath/linux/compat/nf_conntrack_reasm.c
+++ b/datapath/linux/compat/nf_conntrack_reasm.c
@@ -36,6 +36,7 @@
 #include <linux/random.h>
 #include <linux/slab.h>
 
+#include <net/ipv6_frag.h>
 #include <net/sock.h>
 #include <net/snmp.h>
 #include <net/inet_frag.h>
diff --git a/datapath/linux/compat/udp_tunnel.c b/datapath/linux/compat/udp_tunnel.c
index 852069f62..349839b2b 100644
--- a/datapath/linux/compat/udp_tunnel.c
+++ b/datapath/linux/compat/udp_tunnel.c
@@ -14,6 +14,7 @@
 #include <net/net_namespace.h>
 #include <net/ip6_checksum.h>
 #include <net/ip6_tunnel.h>
+#include <net/dst_metadata.h>
 
 #include "gso.h"
 
@@ -288,5 +289,4 @@ void ovs_udp_csum_gso(struct sk_buff *skb)
 }
 EXPORT_SYMBOL_GPL(ovs_udp_csum_gso);
 #endif /* USE_UPSTREAM_TUNNEL_GSO */
-
 #endif
diff --git a/datapath/vport-gtp.c b/datapath/vport-gtp.c
new file mode 100644
index 000000000..3a97956f6
--- /dev/null
+++ b/datapath/vport-gtp.c
@@ -0,0 +1,147 @@
+/*
+ * Copyright 2020 The Magma Authors.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ */
+
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
+#include <linux/in.h>
+#include <linux/ip.h>
+#include <linux/net.h>
+#include <linux/rculist.h>
+#include <linux/udp.h>
+#include <linux/if_vlan.h>
+#include <linux/module.h>
+
+#include <net/gtp.h>
+#include <net/icmp.h>
+#include <net/ip.h>
+#include <net/route.h>
+#include <net/udp.h>
+#include <net/xfrm.h>
+
+#include "datapath.h"
+#include "vport.h"
+#include "vport-netdev.h"
+
+extern struct net_device *gtp_create_flow_based_dev(struct net *net, const char *name,
+						u8 name_assign_type, u16 dst_port);
+
+static struct vport_ops ovs_gtp_vport_ops;
+/**
+ * struct gtp_port - Keeps track of open UDP ports
+ * @dst_port: destination port.
+ */
+struct gtp_port {
+    u16 port_no;
+};
+
+static inline struct gtp_port *gtp_vport(const struct vport *vport)
+{
+    return vport_priv(vport);
+}
+
+static int gtp_get_options(const struct vport *vport,
+                           struct sk_buff *skb)
+{
+    struct gtp_port *gtp_port = gtp_vport(vport);
+
+    if (nla_put_u16(skb, OVS_TUNNEL_ATTR_DST_PORT, gtp_port->port_no))
+        return -EMSGSIZE;
+    return 0;
+}
+
+static struct vport *gtp_tnl_create(const struct vport_parms *parms)
+{
+    struct net *net = ovs_dp_get_net(parms->dp);
+    struct nlattr *options = parms->options;
+    struct gtp_port *gtp_port;
+    struct net_device *dev;
+    struct vport *vport;
+    struct nlattr *a;
+    u16 dst_port;
+    int err;
+
+    if (!options) {
+        err = -EINVAL;
+        goto error;
+    }
+
+    a = nla_find_nested(options, OVS_TUNNEL_ATTR_DST_PORT);
+    if (a && nla_len(a) == sizeof(u16)) {
+        dst_port = nla_get_u16(a);
+    } else {
+        /* Require destination port from userspace. */
+        err = -EINVAL;
+        goto error;
+    }
+
+    vport = ovs_vport_alloc(sizeof(struct gtp_port),
+                            &ovs_gtp_vport_ops, parms);
+    if (IS_ERR(vport))
+        return vport;
+
+    gtp_port = gtp_vport(vport);
+    gtp_port->port_no = dst_port;
+
+    rtnl_lock();
+    dev = gtp_create_flow_based_dev(net, parms->name, NET_NAME_USER, dst_port);
+    if (IS_ERR(dev)) {
+        rtnl_unlock();
+        ovs_vport_free(vport);
+        return ERR_CAST(dev);
+    }
+
+    err = dev_change_flags(dev, dev->flags | IFF_UP, NULL);
+    if (err < 0) {
+	rtnl_delete_link(dev);
+	rtnl_unlock();
+	ovs_vport_free(vport);
+	goto error;
+    }
+
+    rtnl_unlock();
+    return vport;
+error:
+    return ERR_PTR(err);
+}
+
+static struct vport *gtp_create(const struct vport_parms *parms)
+{
+    struct vport *vport;
+    vport = gtp_tnl_create(parms);
+    if (IS_ERR(vport))
+        return vport;
+
+    return ovs_netdev_link(vport, parms->name);
+}
+
+
+static struct vport_ops ovs_gtp_vport_ops = {
+    .type                = OVS_VPORT_TYPE_GTPU,
+    .create              = gtp_create,
+    .get_options         = gtp_get_options,
+    .destroy		 = ovs_netdev_tunnel_destroy,
+    .send                = gtp_xmit,
+};
+
+static int __init ovs_gtp_tnl_init(void)
+{
+    return ovs_vport_ops_register(&ovs_gtp_vport_ops);
+}
+
+static void __exit ovs_gtp_tnl_exit(void)
+{
+    ovs_vport_ops_unregister(&ovs_gtp_vport_ops);
+}
+
+module_init(ovs_gtp_tnl_init);
+module_exit(ovs_gtp_tnl_exit);
+
+MODULE_DESCRIPTION("OVS: GTP switching port");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("vport-type-110");
diff --git a/datapath/vport.c b/datapath/vport.c
index f929282dc..dfb6dcca4 100644
--- a/datapath/vport.c
+++ b/datapath/vport.c
@@ -33,6 +33,7 @@
 #include <net/lisp.h>
 #include <net/gre.h>
 #include <net/geneve.h>
+#include <net/gtp.h>
 #include <net/stt.h>
 #include <net/vxlan.h>
 
@@ -107,8 +108,12 @@ skip_ip6_tunnel_init:
 	err = ovs_stt_init_module();
 	if (err)
 		goto err_stt;
-
+	err = gtp_init_module();
+	if (err)
+		goto err_gtp;
+ 
 	return 0;
+err_gtp:
 	ovs_stt_cleanup_module();
 err_stt:
 	vxlan_cleanup_module();
@@ -136,6 +141,7 @@ err_lisp:
  */
 void ovs_vport_exit(void)
 {
+	gtp_cleanup_module();
 	if (compat_gre_loaded) {
 		gre_exit();
 		ipgre_fini();
diff --git a/tests/automake.mk b/tests/automake.mk
index fc80e027d..498d016e0 100644
--- a/tests/automake.mk
+++ b/tests/automake.mk
@@ -335,7 +335,7 @@ check-kernel: all
 # Testing the out of tree Kernel module
 check-kmod: all
 	$(MAKE) modules_install
-	modprobe -r -a vport-geneve vport-gre vport-lisp vport-stt vport-vxlan openvswitch
+	modprobe -r -a vport-geneve vport-gre vport-lisp vport-stt vport-vxlan vport-gtp openvswitch
 	$(MAKE) check-kernel
 
 check-system-userspace: all
diff --git a/tests/system-common-macros.at b/tests/system-common-macros.at
index 9d5e24a29..490c59e04 100644
--- a/tests/system-common-macros.at
+++ b/tests/system-common-macros.at
@@ -323,6 +323,13 @@ m4_define([OVS_CHECK_GENEVE_UDP6ZEROCSUM],
     [AT_SKIP_IF([! ip link add foo type geneve help 2>&1 | grep udp6zerocsum >/dev/null])
      OVS_CHECK_FIREWALL()])
 
+# OVS_CHECK_GTP_L3()
+# GTP Unit test depends on http://git.osmocom.org/libgtpnl/
+m4_define([OVS_CHECK_GTP_L3],
+    [AT_SKIP_IF([! gtp-tunnel list >/dev/null])
+     OVS_CHECK_FIREWALL()])
+
+
 # OVS_CHECK_8021AD()
 m4_define([OVS_CHECK_8021AD],
     [AT_SKIP_IF([! grep -q "VLAN header stack length probed as" ovs-vswitchd.log])
diff --git a/tests/system-layer3-tunnels.at b/tests/system-layer3-tunnels.at
index 1232964bb..141a7afb4 100644
--- a/tests/system-layer3-tunnels.at
+++ b/tests/system-layer3-tunnels.at
@@ -49,11 +49,64 @@ NS_CHECK_EXEC([at_ns0], [ping -s 3200 -q -c 3 -i 0.3 -w 2 10.1.1.2 | FORMAT_PING
 OVS_TRAFFIC_VSWITCHD_STOP
 AT_CLEANUP
 
+AT_SETUP([layer3 - ping over GTP])
+OVS_TRAFFIC_VSWITCHD_START([set Bridge br0 other-config:hwaddr="00:12:34:56:78:bb"])
+OVS_CHECK_GTP_L3()
+
+ADD_BR([br-underlay])
+
+ADD_NAMESPACES(at_ns0)
+
+dnl Set up underlay link from host into the namespace using veth pair.
+ADD_VETH(p0, at_ns0, br-underlay, "172.31.1.1/24")
+AT_CHECK([ip addr add dev br-underlay "172.31.1.100/24"])
+AT_CHECK([ip link set dev br-underlay up])
+AT_CHECK([modprobe vport-gtp])
+
+dnl Set up tunnel endpoints on OVS outside the namespace and with a native
+dnl linux device inside the namespace.
+ADD_OVS_TUNNEL([gtpu], [br0], [at_gtp0], [172.31.1.1], [10.1.1.2/24])
+AT_CHECK([ip neigh add 10.1.1.1 lladdr 00:12:34:56:78:aa dev br0])
+NS_CHECK_EXEC([at_ns0], [gtp-link add at_gtp1 --sgsn &], [0], [ignore])
+NS_CHECK_EXEC([at_ns0], [gtp-tunnel add at_gtp1 v1 0 0 10.1.1.1 172.31.1.100], [0], [ignore], [ignore])
+NS_CHECK_EXEC([at_ns0], [ip addr add dev at_gtp1 10.1.1.1/24])
+NS_CHECK_EXEC([at_ns0], [ip link set dev at_gtp1 mtu 1450 up])
+NS_CHECK_EXEC([at_ns0], [ip link set dev p0 mtu 1480 up])
+
+AT_CHECK([ovs-ofctl add-flow br-underlay "actions=normal"])
+
+AT_CHECK([ovs-appctl vlog/set dbg], [0], [ignore])
+AT_CHECK([echo 'module openvswitch +p' > /sys/kernel/debug/dynamic_debug/control])
+
+dnl Now add rules for OVS to forward to the tunnel and local port
+AT_CHECK([ovs-ofctl add-flow br0 "priority=1 action=drop"])
+AT_CHECK([ovs-ofctl add-flow br0 "priority=100 ip,nw_dst=10.1.1.1 action=output:at_gtp0"])
+AT_CHECK([ovs-ofctl add-flow br0 "priority=100 ip,nw_dst=10.1.1.2 action=mod_dl_src:00:12:34:56:78:aa,mod_dl_dst:00:12:34:56:78:bb,local"])
+
+
+dnl First, check the underlay
+NS_CHECK_EXEC([at_ns0], [ping -q -c 3 -i 0.3 -w 2 172.31.1.100 | FORMAT_PING], [0], [dnl
+3 packets transmitted, 3 received, 0% packet loss, time 0ms
+])
+
+OVS_WAIT_UNTIL([ip netns exec at_ns0 ping -c 1 10.1.1.2])
+dnl Okay, now check the overlay with different packet sizes
+NS_CHECK_EXEC([at_ns0], [ping -q -c 3 -i 0.3 -w 2 10.1.1.2 | FORMAT_PING], [0], [dnl
+3 packets transmitted, 3 received, 0% packet loss, time 0ms
+])
+NS_CHECK_EXEC([at_ns0], [ping -s 3200 -q -c 3 -i 0.3 -w 2 10.1.1.2 | FORMAT_PING], [0], [dnl
+3 packets transmitted, 3 received, 0% packet loss, time 0ms
+])
+
+OVS_TRAFFIC_VSWITCHD_STOP
+AT_CLEANUP
+
 AT_SETUP([layer3 - ping over GRE])
 OVS_TRAFFIC_VSWITCHD_START([set Bridge br0 other-config:hwaddr="00:12:34:56:78:bb"])
 OVS_CHECK_GRE_L3()
 OVS_CHECK_IPROUTE_ENCAP()
 
+
 ADD_BR([br-underlay])
 
 ADD_NAMESPACES(at_ns0)
diff --git a/tests/tunnel.at b/tests/tunnel.at
index e104b5c8c..3dfd9675d 100644
--- a/tests/tunnel.at
+++ b/tests/tunnel.at
@@ -1253,3 +1253,31 @@ AT_CHECK([tail -1 stdout], [0],
 ])
 OVS_VSWITCHD_STOP
 AT_CLEANUP
+
+AT_SETUP([tunnel - GTP-C using tun optios])
+OVS_VSWITCHD_START([add-port br0 p1 -- set Interface p1 type=gtpu \
+                    options:remote_ip=1.1.1.1 options:key=flow ofport_request=1 \
+                    -- add-port br0 p2 -- set Interface p2 type=dummy \
+                    ofport_request=2 ofport_request=2 \
+                    -- add-port br0 p3 -- set Interface p3 type=gtpu \
+                    options:remote_ip=2.2.2.2 options:key=123 ofport_request=3])
+OVS_VSWITCHD_DISABLE_TUNNEL_PUSH_POP
+
+AT_DATA([flows.txt], [dnl
+actions=load:0x8->NXM_NX_TUN_FLAGS[[]],output:1
+table=2,actions=move:NXM_NX_TUN_FLAGS[[]]->NXM_NX_REG4[[0..3]],output:1
+])
+AT_CHECK([ovs-ofctl add-flows br0 flows.txt])
+
+AT_CHECK([ovs-ofctl dump-flows br0], [0], [stdout])
+AT_CHECK([strip_xids < stdout | sed -n 's/duration=[[0-9]]*\.[[0-9]]*s/duration=0.0s/p' | sort], [0], [dnl
+ cookie=0x0, duration=0.0s, table=0, n_packets=0, n_bytes=0, idle_age=0, actions=load:0x8->NXM_NX_TUN_FLAGS[[]],output:1
+ cookie=0x0, duration=0.0s, table=2, n_packets=0, n_bytes=0, idle_age=0, actions=move:NXM_NX_TUN_FLAGS[[]]->NXM_NX_REG4[[0..3]],output:1
+])
+
+AT_CHECK([ovs-appctl ofproto/trace ovs-dummy 'in_port(2),eth(src=50:54:00:00:00:05,dst=50:54:00:00:00:07),eth_type(0x0800),ipv4(src=192.168.0.1,dst=192.168.0.2,proto=6,tos=4,ttl=128,frag=no),tcp(src=8,dst=9)'], [0], [stdout])
+AT_CHECK([tail -1 stdout], [0],
+  [Datapath actions: set(tunnel(tun_id=0x0,dst=1.1.1.1,ttl=64,tp_dst=2152,flags(df|key))),pop_eth,2152
+])
+OVS_VSWITCHD_STOP
+AT_CLEANUP
-- 
2.17.1


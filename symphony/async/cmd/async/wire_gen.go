// Code generated by Wire. DO NOT EDIT.

//go:generate wire
//+build !wireinject

package main

import (
	"context"
	"fmt"
	"github.com/facebookincubator/symphony/async/handler"
	"github.com/facebookincubator/symphony/pkg/log"
	"github.com/facebookincubator/symphony/pkg/mysql"
	"github.com/facebookincubator/symphony/pkg/pubsub"
	"github.com/facebookincubator/symphony/pkg/server"
	"github.com/facebookincubator/symphony/pkg/server/xserver"
	"github.com/facebookincubator/symphony/pkg/telemetry"
	"github.com/facebookincubator/symphony/pkg/viewer"
	"github.com/gorilla/mux"
	"go.opencensus.io/stats/view"
	"go.uber.org/zap"
	"gocloud.dev/server/health"
)

import (
	_ "github.com/go-sql-driver/mysql"
	_ "gocloud.dev/pubsub/mempubsub"
	_ "gocloud.dev/pubsub/natspubsub"
)

// Injectors from wire.go:

func NewApplication(ctx context.Context, flags *cliFlags) (*application, func(), error) {
	config := flags.MySQLConfig
	logConfig := flags.LogConfig
	logger, cleanup, err := log.ProvideLogger(logConfig)
	if err != nil {
		return nil, nil, err
	}
	mySQLTenancy, err := newMySQLTenancy(config, logger)
	if err != nil {
		cleanup()
		return nil, nil, err
	}
	pubsubConfig := flags.EventConfig
	topicEmitter, cleanup2, err := pubsub.ProvideEmitter(ctx, pubsubConfig)
	if err != nil {
		cleanup()
		return nil, nil, err
	}
	tenancy, err := newTenancy(mySQLTenancy, logger, topicEmitter)
	if err != nil {
		cleanup2()
		cleanup()
		return nil, nil, err
	}
	urlSubscriber := pubsub.ProvideSubscriber(pubsubConfig)
	telemetryConfig := &flags.TelemetryConfig
	handlerConfig := handler.Config{
		Tenancy:    tenancy,
		Logger:     logger,
		Subscriber: urlSubscriber,
		Telemetry:  telemetryConfig,
	}
	handlerServer := handler.NewServer(handlerConfig)
	router := mux.NewRouter()
	zapLogger := xserver.NewRequestLogger(logger)
	v := newHealthChecks(mySQLTenancy)
	v2 := provideViews()
	exporter, err := telemetry.ProvideViewExporter(telemetryConfig)
	if err != nil {
		cleanup2()
		cleanup()
		return nil, nil, err
	}
	traceExporter, cleanup3, err := telemetry.ProvideTraceExporter(telemetryConfig)
	if err != nil {
		cleanup2()
		cleanup()
		return nil, nil, err
	}
	profilingEnabler := _wireProfilingEnablerValue
	sampler := telemetry.ProvideTraceSampler(telemetryConfig)
	handlerFunc := xserver.NewRecoveryHandler(logger)
	defaultDriver := _wireDefaultDriverValue
	options := &server.Options{
		RequestLogger:         zapLogger,
		HealthChecks:          v,
		Views:                 v2,
		ViewExporter:          exporter,
		TraceExporter:         traceExporter,
		EnableProfiling:       profilingEnabler,
		DefaultSamplingPolicy: sampler,
		RecoveryHandler:       handlerFunc,
		Driver:                defaultDriver,
	}
	serverServer := server.New(router, options)
	logger2 := log.ProvideZapLogger(logger)
	mainApplication := newApplication(handlerServer, serverServer, logger2)
	return mainApplication, func() {
		cleanup3()
		cleanup2()
		cleanup()
	}, nil
}

var (
	_wireProfilingEnablerValue = server.ProfilingEnabler(true)
	_wireDefaultDriverValue    = &server.DefaultDriver{}
)

// wire.go:

func newApplication(server2 *handler.Server, http *server.Server, logger *zap.Logger) *application {
	var app application
	app.logger = logger
	app.server = server2
	app.http = http
	return &app
}

func newTenancy(tenancy *viewer.MySQLTenancy, logger log.Logger, emitter pubsub.Emitter) (viewer.Tenancy, error) {
	return viewer.NewCacheTenancy(tenancy, nil), nil
}

func newHealthChecks(tenancy *viewer.MySQLTenancy) []health.Checker {
	return []health.Checker{tenancy}
}

func newMySQLTenancy(config mysql.Config, logger log.Logger) (*viewer.MySQLTenancy, error) {
	tenancy, err := viewer.NewMySQLTenancy(config.String())
	if err != nil {
		return nil, fmt.Errorf("creating mysql tenancy: %w", err)
	}
	tenancy.SetLogger(logger)
	mysql.SetLogger(logger)
	return tenancy, nil
}

func provideViews() []*view.View {
	views := xserver.DefaultViews()
	views = append(views, mysql.DefaultViews...)
	views = append(views, pubsub.DefaultViews...)
	return views
}

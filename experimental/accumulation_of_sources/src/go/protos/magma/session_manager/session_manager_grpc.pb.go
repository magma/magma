// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package session_manager

import (
	context "context"
	orc8r "github.com/magma/magma/src/go/protos/magma/orc8r"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// LocalSessionManagerClient is the client API for LocalSessionManager service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type LocalSessionManagerClient interface {
	ReportRuleStats(ctx context.Context, in *RuleRecordTable, opts ...grpc.CallOption) (*orc8r.Void, error)
	CreateSession(ctx context.Context, in *LocalCreateSessionRequest, opts ...grpc.CallOption) (*LocalCreateSessionResponse, error)
	EndSession(ctx context.Context, in *LocalEndSessionRequest, opts ...grpc.CallOption) (*LocalEndSessionResponse, error)
	// A response to CreateBearer request defined in spgw service. Sends a mapping of dedicated bearer ID <-> policy.
	BindPolicy2Bearer(ctx context.Context, in *PolicyBearerBindingRequest, opts ...grpc.CallOption) (*PolicyBearerBindingResponse, error)
	// A set interface of subscribers -> currently active rules
	SetSessionRules(ctx context.Context, in *SessionRules, opts ...grpc.CallOption) (*orc8r.Void, error)
	UpdateTunnelIds(ctx context.Context, in *UpdateTunnelIdsRequest, opts ...grpc.CallOption) (*UpdateTunnelIdsResponse, error)
}

type localSessionManagerClient struct {
	cc grpc.ClientConnInterface
}

func NewLocalSessionManagerClient(cc grpc.ClientConnInterface) LocalSessionManagerClient {
	return &localSessionManagerClient{cc}
}

func (c *localSessionManagerClient) ReportRuleStats(ctx context.Context, in *RuleRecordTable, opts ...grpc.CallOption) (*orc8r.Void, error) {
	out := new(orc8r.Void)
	err := c.cc.Invoke(ctx, "/magma.lte.LocalSessionManager/ReportRuleStats", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *localSessionManagerClient) CreateSession(ctx context.Context, in *LocalCreateSessionRequest, opts ...grpc.CallOption) (*LocalCreateSessionResponse, error) {
	out := new(LocalCreateSessionResponse)
	err := c.cc.Invoke(ctx, "/magma.lte.LocalSessionManager/CreateSession", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *localSessionManagerClient) EndSession(ctx context.Context, in *LocalEndSessionRequest, opts ...grpc.CallOption) (*LocalEndSessionResponse, error) {
	out := new(LocalEndSessionResponse)
	err := c.cc.Invoke(ctx, "/magma.lte.LocalSessionManager/EndSession", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *localSessionManagerClient) BindPolicy2Bearer(ctx context.Context, in *PolicyBearerBindingRequest, opts ...grpc.CallOption) (*PolicyBearerBindingResponse, error) {
	out := new(PolicyBearerBindingResponse)
	err := c.cc.Invoke(ctx, "/magma.lte.LocalSessionManager/BindPolicy2Bearer", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *localSessionManagerClient) SetSessionRules(ctx context.Context, in *SessionRules, opts ...grpc.CallOption) (*orc8r.Void, error) {
	out := new(orc8r.Void)
	err := c.cc.Invoke(ctx, "/magma.lte.LocalSessionManager/SetSessionRules", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *localSessionManagerClient) UpdateTunnelIds(ctx context.Context, in *UpdateTunnelIdsRequest, opts ...grpc.CallOption) (*UpdateTunnelIdsResponse, error) {
	out := new(UpdateTunnelIdsResponse)
	err := c.cc.Invoke(ctx, "/magma.lte.LocalSessionManager/UpdateTunnelIds", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// LocalSessionManagerServer is the server API for LocalSessionManager service.
// All implementations must embed UnimplementedLocalSessionManagerServer
// for forward compatibility
type LocalSessionManagerServer interface {
	ReportRuleStats(context.Context, *RuleRecordTable) (*orc8r.Void, error)
	CreateSession(context.Context, *LocalCreateSessionRequest) (*LocalCreateSessionResponse, error)
	EndSession(context.Context, *LocalEndSessionRequest) (*LocalEndSessionResponse, error)
	// A response to CreateBearer request defined in spgw service. Sends a mapping of dedicated bearer ID <-> policy.
	BindPolicy2Bearer(context.Context, *PolicyBearerBindingRequest) (*PolicyBearerBindingResponse, error)
	// A set interface of subscribers -> currently active rules
	SetSessionRules(context.Context, *SessionRules) (*orc8r.Void, error)
	UpdateTunnelIds(context.Context, *UpdateTunnelIdsRequest) (*UpdateTunnelIdsResponse, error)
	mustEmbedUnimplementedLocalSessionManagerServer()
}

// UnimplementedLocalSessionManagerServer must be embedded to have forward compatible implementations.
type UnimplementedLocalSessionManagerServer struct {
}

func (UnimplementedLocalSessionManagerServer) ReportRuleStats(context.Context, *RuleRecordTable) (*orc8r.Void, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReportRuleStats not implemented")
}
func (UnimplementedLocalSessionManagerServer) CreateSession(context.Context, *LocalCreateSessionRequest) (*LocalCreateSessionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateSession not implemented")
}
func (UnimplementedLocalSessionManagerServer) EndSession(context.Context, *LocalEndSessionRequest) (*LocalEndSessionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EndSession not implemented")
}
func (UnimplementedLocalSessionManagerServer) BindPolicy2Bearer(context.Context, *PolicyBearerBindingRequest) (*PolicyBearerBindingResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BindPolicy2Bearer not implemented")
}
func (UnimplementedLocalSessionManagerServer) SetSessionRules(context.Context, *SessionRules) (*orc8r.Void, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetSessionRules not implemented")
}
func (UnimplementedLocalSessionManagerServer) UpdateTunnelIds(context.Context, *UpdateTunnelIdsRequest) (*UpdateTunnelIdsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateTunnelIds not implemented")
}
func (UnimplementedLocalSessionManagerServer) mustEmbedUnimplementedLocalSessionManagerServer() {}

// UnsafeLocalSessionManagerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to LocalSessionManagerServer will
// result in compilation errors.
type UnsafeLocalSessionManagerServer interface {
	mustEmbedUnimplementedLocalSessionManagerServer()
}

func RegisterLocalSessionManagerServer(s grpc.ServiceRegistrar, srv LocalSessionManagerServer) {
	s.RegisterService(&LocalSessionManager_ServiceDesc, srv)
}

func _LocalSessionManager_ReportRuleStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RuleRecordTable)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LocalSessionManagerServer).ReportRuleStats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.lte.LocalSessionManager/ReportRuleStats",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LocalSessionManagerServer).ReportRuleStats(ctx, req.(*RuleRecordTable))
	}
	return interceptor(ctx, in, info, handler)
}

func _LocalSessionManager_CreateSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LocalCreateSessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LocalSessionManagerServer).CreateSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.lte.LocalSessionManager/CreateSession",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LocalSessionManagerServer).CreateSession(ctx, req.(*LocalCreateSessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LocalSessionManager_EndSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LocalEndSessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LocalSessionManagerServer).EndSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.lte.LocalSessionManager/EndSession",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LocalSessionManagerServer).EndSession(ctx, req.(*LocalEndSessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LocalSessionManager_BindPolicy2Bearer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PolicyBearerBindingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LocalSessionManagerServer).BindPolicy2Bearer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.lte.LocalSessionManager/BindPolicy2Bearer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LocalSessionManagerServer).BindPolicy2Bearer(ctx, req.(*PolicyBearerBindingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LocalSessionManager_SetSessionRules_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SessionRules)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LocalSessionManagerServer).SetSessionRules(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.lte.LocalSessionManager/SetSessionRules",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LocalSessionManagerServer).SetSessionRules(ctx, req.(*SessionRules))
	}
	return interceptor(ctx, in, info, handler)
}

func _LocalSessionManager_UpdateTunnelIds_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateTunnelIdsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LocalSessionManagerServer).UpdateTunnelIds(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.lte.LocalSessionManager/UpdateTunnelIds",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LocalSessionManagerServer).UpdateTunnelIds(ctx, req.(*UpdateTunnelIdsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// LocalSessionManager_ServiceDesc is the grpc.ServiceDesc for LocalSessionManager service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var LocalSessionManager_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "magma.lte.LocalSessionManager",
	HandlerType: (*LocalSessionManagerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ReportRuleStats",
			Handler:    _LocalSessionManager_ReportRuleStats_Handler,
		},
		{
			MethodName: "CreateSession",
			Handler:    _LocalSessionManager_CreateSession_Handler,
		},
		{
			MethodName: "EndSession",
			Handler:    _LocalSessionManager_EndSession_Handler,
		},
		{
			MethodName: "BindPolicy2Bearer",
			Handler:    _LocalSessionManager_BindPolicy2Bearer_Handler,
		},
		{
			MethodName: "SetSessionRules",
			Handler:    _LocalSessionManager_SetSessionRules_Handler,
		},
		{
			MethodName: "UpdateTunnelIds",
			Handler:    _LocalSessionManager_UpdateTunnelIds_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "session_manager.proto",
}

// SessionProxyResponderClient is the client API for SessionProxyResponder service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SessionProxyResponderClient interface {
	ChargingReAuth(ctx context.Context, in *ChargingReAuthRequest, opts ...grpc.CallOption) (*ChargingReAuthAnswer, error)
	// NOTE: if no session_id is specified, apply to all sessions for the IMSI
	PolicyReAuth(ctx context.Context, in *PolicyReAuthRequest, opts ...grpc.CallOption) (*PolicyReAuthAnswer, error)
}

type sessionProxyResponderClient struct {
	cc grpc.ClientConnInterface
}

func NewSessionProxyResponderClient(cc grpc.ClientConnInterface) SessionProxyResponderClient {
	return &sessionProxyResponderClient{cc}
}

func (c *sessionProxyResponderClient) ChargingReAuth(ctx context.Context, in *ChargingReAuthRequest, opts ...grpc.CallOption) (*ChargingReAuthAnswer, error) {
	out := new(ChargingReAuthAnswer)
	err := c.cc.Invoke(ctx, "/magma.lte.SessionProxyResponder/ChargingReAuth", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sessionProxyResponderClient) PolicyReAuth(ctx context.Context, in *PolicyReAuthRequest, opts ...grpc.CallOption) (*PolicyReAuthAnswer, error) {
	out := new(PolicyReAuthAnswer)
	err := c.cc.Invoke(ctx, "/magma.lte.SessionProxyResponder/PolicyReAuth", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SessionProxyResponderServer is the server API for SessionProxyResponder service.
// All implementations must embed UnimplementedSessionProxyResponderServer
// for forward compatibility
type SessionProxyResponderServer interface {
	ChargingReAuth(context.Context, *ChargingReAuthRequest) (*ChargingReAuthAnswer, error)
	// NOTE: if no session_id is specified, apply to all sessions for the IMSI
	PolicyReAuth(context.Context, *PolicyReAuthRequest) (*PolicyReAuthAnswer, error)
	mustEmbedUnimplementedSessionProxyResponderServer()
}

// UnimplementedSessionProxyResponderServer must be embedded to have forward compatible implementations.
type UnimplementedSessionProxyResponderServer struct {
}

func (UnimplementedSessionProxyResponderServer) ChargingReAuth(context.Context, *ChargingReAuthRequest) (*ChargingReAuthAnswer, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ChargingReAuth not implemented")
}
func (UnimplementedSessionProxyResponderServer) PolicyReAuth(context.Context, *PolicyReAuthRequest) (*PolicyReAuthAnswer, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PolicyReAuth not implemented")
}
func (UnimplementedSessionProxyResponderServer) mustEmbedUnimplementedSessionProxyResponderServer() {}

// UnsafeSessionProxyResponderServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SessionProxyResponderServer will
// result in compilation errors.
type UnsafeSessionProxyResponderServer interface {
	mustEmbedUnimplementedSessionProxyResponderServer()
}

func RegisterSessionProxyResponderServer(s grpc.ServiceRegistrar, srv SessionProxyResponderServer) {
	s.RegisterService(&SessionProxyResponder_ServiceDesc, srv)
}

func _SessionProxyResponder_ChargingReAuth_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChargingReAuthRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SessionProxyResponderServer).ChargingReAuth(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.lte.SessionProxyResponder/ChargingReAuth",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SessionProxyResponderServer).ChargingReAuth(ctx, req.(*ChargingReAuthRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SessionProxyResponder_PolicyReAuth_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PolicyReAuthRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SessionProxyResponderServer).PolicyReAuth(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.lte.SessionProxyResponder/PolicyReAuth",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SessionProxyResponderServer).PolicyReAuth(ctx, req.(*PolicyReAuthRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// SessionProxyResponder_ServiceDesc is the grpc.ServiceDesc for SessionProxyResponder service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var SessionProxyResponder_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "magma.lte.SessionProxyResponder",
	HandlerType: (*SessionProxyResponderServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ChargingReAuth",
			Handler:    _SessionProxyResponder_ChargingReAuth_Handler,
		},
		{
			MethodName: "PolicyReAuth",
			Handler:    _SessionProxyResponder_PolicyReAuth_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "session_manager.proto",
}

// CentralSessionControllerClient is the client API for CentralSessionController service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CentralSessionControllerClient interface {
	// Notify OCS/PCRF of new session and return rules associated with subscriber
	// along with credits for each rule
	CreateSession(ctx context.Context, in *CreateSessionRequest, opts ...grpc.CallOption) (*CreateSessionResponse, error)
	// Updates OCS/PCRF with used credit and terminations from gateway
	UpdateSession(ctx context.Context, in *UpdateSessionRequest, opts ...grpc.CallOption) (*UpdateSessionResponse, error)
	// Terminates session in OCS/PCRF for a subscriber
	TerminateSession(ctx context.Context, in *SessionTerminateRequest, opts ...grpc.CallOption) (*SessionTerminateResponse, error)
}

type centralSessionControllerClient struct {
	cc grpc.ClientConnInterface
}

func NewCentralSessionControllerClient(cc grpc.ClientConnInterface) CentralSessionControllerClient {
	return &centralSessionControllerClient{cc}
}

func (c *centralSessionControllerClient) CreateSession(ctx context.Context, in *CreateSessionRequest, opts ...grpc.CallOption) (*CreateSessionResponse, error) {
	out := new(CreateSessionResponse)
	err := c.cc.Invoke(ctx, "/magma.lte.CentralSessionController/CreateSession", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *centralSessionControllerClient) UpdateSession(ctx context.Context, in *UpdateSessionRequest, opts ...grpc.CallOption) (*UpdateSessionResponse, error) {
	out := new(UpdateSessionResponse)
	err := c.cc.Invoke(ctx, "/magma.lte.CentralSessionController/UpdateSession", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *centralSessionControllerClient) TerminateSession(ctx context.Context, in *SessionTerminateRequest, opts ...grpc.CallOption) (*SessionTerminateResponse, error) {
	out := new(SessionTerminateResponse)
	err := c.cc.Invoke(ctx, "/magma.lte.CentralSessionController/TerminateSession", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CentralSessionControllerServer is the server API for CentralSessionController service.
// All implementations must embed UnimplementedCentralSessionControllerServer
// for forward compatibility
type CentralSessionControllerServer interface {
	// Notify OCS/PCRF of new session and return rules associated with subscriber
	// along with credits for each rule
	CreateSession(context.Context, *CreateSessionRequest) (*CreateSessionResponse, error)
	// Updates OCS/PCRF with used credit and terminations from gateway
	UpdateSession(context.Context, *UpdateSessionRequest) (*UpdateSessionResponse, error)
	// Terminates session in OCS/PCRF for a subscriber
	TerminateSession(context.Context, *SessionTerminateRequest) (*SessionTerminateResponse, error)
	mustEmbedUnimplementedCentralSessionControllerServer()
}

// UnimplementedCentralSessionControllerServer must be embedded to have forward compatible implementations.
type UnimplementedCentralSessionControllerServer struct {
}

func (UnimplementedCentralSessionControllerServer) CreateSession(context.Context, *CreateSessionRequest) (*CreateSessionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateSession not implemented")
}
func (UnimplementedCentralSessionControllerServer) UpdateSession(context.Context, *UpdateSessionRequest) (*UpdateSessionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateSession not implemented")
}
func (UnimplementedCentralSessionControllerServer) TerminateSession(context.Context, *SessionTerminateRequest) (*SessionTerminateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TerminateSession not implemented")
}
func (UnimplementedCentralSessionControllerServer) mustEmbedUnimplementedCentralSessionControllerServer() {
}

// UnsafeCentralSessionControllerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CentralSessionControllerServer will
// result in compilation errors.
type UnsafeCentralSessionControllerServer interface {
	mustEmbedUnimplementedCentralSessionControllerServer()
}

func RegisterCentralSessionControllerServer(s grpc.ServiceRegistrar, srv CentralSessionControllerServer) {
	s.RegisterService(&CentralSessionController_ServiceDesc, srv)
}

func _CentralSessionController_CreateSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateSessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CentralSessionControllerServer).CreateSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.lte.CentralSessionController/CreateSession",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CentralSessionControllerServer).CreateSession(ctx, req.(*CreateSessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CentralSessionController_UpdateSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateSessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CentralSessionControllerServer).UpdateSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.lte.CentralSessionController/UpdateSession",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CentralSessionControllerServer).UpdateSession(ctx, req.(*UpdateSessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CentralSessionController_TerminateSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SessionTerminateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CentralSessionControllerServer).TerminateSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.lte.CentralSessionController/TerminateSession",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CentralSessionControllerServer).TerminateSession(ctx, req.(*SessionTerminateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// CentralSessionController_ServiceDesc is the grpc.ServiceDesc for CentralSessionController service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CentralSessionController_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "magma.lte.CentralSessionController",
	HandlerType: (*CentralSessionControllerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateSession",
			Handler:    _CentralSessionController_CreateSession_Handler,
		},
		{
			MethodName: "UpdateSession",
			Handler:    _CentralSessionController_UpdateSession_Handler,
		},
		{
			MethodName: "TerminateSession",
			Handler:    _CentralSessionController_TerminateSession_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "session_manager.proto",
}

// SetInterfaceForUserPlaneClient is the client API for SetInterfaceForUserPlane service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SetInterfaceForUserPlaneClient interface {
	SetUPFNodeState(ctx context.Context, in *UPFNodeState, opts ...grpc.CallOption) (*SmContextVoid, error)
	SetUPFSessionsConfig(ctx context.Context, in *UPFSessionConfigState, opts ...grpc.CallOption) (*SmContextVoid, error)
	SendPagingRequest(ctx context.Context, in *UPFPagingInfo, opts ...grpc.CallOption) (*SmContextVoid, error)
}

type setInterfaceForUserPlaneClient struct {
	cc grpc.ClientConnInterface
}

func NewSetInterfaceForUserPlaneClient(cc grpc.ClientConnInterface) SetInterfaceForUserPlaneClient {
	return &setInterfaceForUserPlaneClient{cc}
}

func (c *setInterfaceForUserPlaneClient) SetUPFNodeState(ctx context.Context, in *UPFNodeState, opts ...grpc.CallOption) (*SmContextVoid, error) {
	out := new(SmContextVoid)
	err := c.cc.Invoke(ctx, "/magma.lte.SetInterfaceForUserPlane/SetUPFNodeState", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *setInterfaceForUserPlaneClient) SetUPFSessionsConfig(ctx context.Context, in *UPFSessionConfigState, opts ...grpc.CallOption) (*SmContextVoid, error) {
	out := new(SmContextVoid)
	err := c.cc.Invoke(ctx, "/magma.lte.SetInterfaceForUserPlane/SetUPFSessionsConfig", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *setInterfaceForUserPlaneClient) SendPagingRequest(ctx context.Context, in *UPFPagingInfo, opts ...grpc.CallOption) (*SmContextVoid, error) {
	out := new(SmContextVoid)
	err := c.cc.Invoke(ctx, "/magma.lte.SetInterfaceForUserPlane/SendPagingRequest", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SetInterfaceForUserPlaneServer is the server API for SetInterfaceForUserPlane service.
// All implementations must embed UnimplementedSetInterfaceForUserPlaneServer
// for forward compatibility
type SetInterfaceForUserPlaneServer interface {
	SetUPFNodeState(context.Context, *UPFNodeState) (*SmContextVoid, error)
	SetUPFSessionsConfig(context.Context, *UPFSessionConfigState) (*SmContextVoid, error)
	SendPagingRequest(context.Context, *UPFPagingInfo) (*SmContextVoid, error)
	mustEmbedUnimplementedSetInterfaceForUserPlaneServer()
}

// UnimplementedSetInterfaceForUserPlaneServer must be embedded to have forward compatible implementations.
type UnimplementedSetInterfaceForUserPlaneServer struct {
}

func (UnimplementedSetInterfaceForUserPlaneServer) SetUPFNodeState(context.Context, *UPFNodeState) (*SmContextVoid, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetUPFNodeState not implemented")
}
func (UnimplementedSetInterfaceForUserPlaneServer) SetUPFSessionsConfig(context.Context, *UPFSessionConfigState) (*SmContextVoid, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetUPFSessionsConfig not implemented")
}
func (UnimplementedSetInterfaceForUserPlaneServer) SendPagingRequest(context.Context, *UPFPagingInfo) (*SmContextVoid, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendPagingRequest not implemented")
}
func (UnimplementedSetInterfaceForUserPlaneServer) mustEmbedUnimplementedSetInterfaceForUserPlaneServer() {
}

// UnsafeSetInterfaceForUserPlaneServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SetInterfaceForUserPlaneServer will
// result in compilation errors.
type UnsafeSetInterfaceForUserPlaneServer interface {
	mustEmbedUnimplementedSetInterfaceForUserPlaneServer()
}

func RegisterSetInterfaceForUserPlaneServer(s grpc.ServiceRegistrar, srv SetInterfaceForUserPlaneServer) {
	s.RegisterService(&SetInterfaceForUserPlane_ServiceDesc, srv)
}

func _SetInterfaceForUserPlane_SetUPFNodeState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UPFNodeState)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SetInterfaceForUserPlaneServer).SetUPFNodeState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.lte.SetInterfaceForUserPlane/SetUPFNodeState",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SetInterfaceForUserPlaneServer).SetUPFNodeState(ctx, req.(*UPFNodeState))
	}
	return interceptor(ctx, in, info, handler)
}

func _SetInterfaceForUserPlane_SetUPFSessionsConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UPFSessionConfigState)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SetInterfaceForUserPlaneServer).SetUPFSessionsConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.lte.SetInterfaceForUserPlane/SetUPFSessionsConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SetInterfaceForUserPlaneServer).SetUPFSessionsConfig(ctx, req.(*UPFSessionConfigState))
	}
	return interceptor(ctx, in, info, handler)
}

func _SetInterfaceForUserPlane_SendPagingRequest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UPFPagingInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SetInterfaceForUserPlaneServer).SendPagingRequest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.lte.SetInterfaceForUserPlane/SendPagingRequest",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SetInterfaceForUserPlaneServer).SendPagingRequest(ctx, req.(*UPFPagingInfo))
	}
	return interceptor(ctx, in, info, handler)
}

// SetInterfaceForUserPlane_ServiceDesc is the grpc.ServiceDesc for SetInterfaceForUserPlane service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var SetInterfaceForUserPlane_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "magma.lte.SetInterfaceForUserPlane",
	HandlerType: (*SetInterfaceForUserPlaneServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SetUPFNodeState",
			Handler:    _SetInterfaceForUserPlane_SetUPFNodeState_Handler,
		},
		{
			MethodName: "SetUPFSessionsConfig",
			Handler:    _SetInterfaceForUserPlane_SetUPFSessionsConfig_Handler,
		},
		{
			MethodName: "SendPagingRequest",
			Handler:    _SetInterfaceForUserPlane_SendPagingRequest_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "session_manager.proto",
}

// AmfPduSessionSmContextClient is the client API for AmfPduSessionSmContext service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AmfPduSessionSmContextClient interface {
	// PDU session related configuration from amf to smf
	SetAmfSessionContext(ctx context.Context, in *SetSMSessionContext, opts ...grpc.CallOption) (*SmContextVoid, error)
	// PDU session related notification from amf to smf
	SetSmfNotification(ctx context.Context, in *SetSmNotificationContext, opts ...grpc.CallOption) (*SmContextVoid, error)
}

type amfPduSessionSmContextClient struct {
	cc grpc.ClientConnInterface
}

func NewAmfPduSessionSmContextClient(cc grpc.ClientConnInterface) AmfPduSessionSmContextClient {
	return &amfPduSessionSmContextClient{cc}
}

func (c *amfPduSessionSmContextClient) SetAmfSessionContext(ctx context.Context, in *SetSMSessionContext, opts ...grpc.CallOption) (*SmContextVoid, error) {
	out := new(SmContextVoid)
	err := c.cc.Invoke(ctx, "/magma.lte.AmfPduSessionSmContext/SetAmfSessionContext", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *amfPduSessionSmContextClient) SetSmfNotification(ctx context.Context, in *SetSmNotificationContext, opts ...grpc.CallOption) (*SmContextVoid, error) {
	out := new(SmContextVoid)
	err := c.cc.Invoke(ctx, "/magma.lte.AmfPduSessionSmContext/SetSmfNotification", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AmfPduSessionSmContextServer is the server API for AmfPduSessionSmContext service.
// All implementations must embed UnimplementedAmfPduSessionSmContextServer
// for forward compatibility
type AmfPduSessionSmContextServer interface {
	// PDU session related configuration from amf to smf
	SetAmfSessionContext(context.Context, *SetSMSessionContext) (*SmContextVoid, error)
	// PDU session related notification from amf to smf
	SetSmfNotification(context.Context, *SetSmNotificationContext) (*SmContextVoid, error)
	mustEmbedUnimplementedAmfPduSessionSmContextServer()
}

// UnimplementedAmfPduSessionSmContextServer must be embedded to have forward compatible implementations.
type UnimplementedAmfPduSessionSmContextServer struct {
}

func (UnimplementedAmfPduSessionSmContextServer) SetAmfSessionContext(context.Context, *SetSMSessionContext) (*SmContextVoid, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetAmfSessionContext not implemented")
}
func (UnimplementedAmfPduSessionSmContextServer) SetSmfNotification(context.Context, *SetSmNotificationContext) (*SmContextVoid, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetSmfNotification not implemented")
}
func (UnimplementedAmfPduSessionSmContextServer) mustEmbedUnimplementedAmfPduSessionSmContextServer() {
}

// UnsafeAmfPduSessionSmContextServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AmfPduSessionSmContextServer will
// result in compilation errors.
type UnsafeAmfPduSessionSmContextServer interface {
	mustEmbedUnimplementedAmfPduSessionSmContextServer()
}

func RegisterAmfPduSessionSmContextServer(s grpc.ServiceRegistrar, srv AmfPduSessionSmContextServer) {
	s.RegisterService(&AmfPduSessionSmContext_ServiceDesc, srv)
}

func _AmfPduSessionSmContext_SetAmfSessionContext_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetSMSessionContext)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AmfPduSessionSmContextServer).SetAmfSessionContext(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.lte.AmfPduSessionSmContext/SetAmfSessionContext",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AmfPduSessionSmContextServer).SetAmfSessionContext(ctx, req.(*SetSMSessionContext))
	}
	return interceptor(ctx, in, info, handler)
}

func _AmfPduSessionSmContext_SetSmfNotification_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetSmNotificationContext)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AmfPduSessionSmContextServer).SetSmfNotification(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.lte.AmfPduSessionSmContext/SetSmfNotification",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AmfPduSessionSmContextServer).SetSmfNotification(ctx, req.(*SetSmNotificationContext))
	}
	return interceptor(ctx, in, info, handler)
}

// AmfPduSessionSmContext_ServiceDesc is the grpc.ServiceDesc for AmfPduSessionSmContext service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AmfPduSessionSmContext_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "magma.lte.AmfPduSessionSmContext",
	HandlerType: (*AmfPduSessionSmContextServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SetAmfSessionContext",
			Handler:    _AmfPduSessionSmContext_SetAmfSessionContext_Handler,
		},
		{
			MethodName: "SetSmfNotification",
			Handler:    _AmfPduSessionSmContext_SetSmfNotification_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "session_manager.proto",
}

// SmfPduSessionSmContextClient is the client API for SmfPduSessionSmContext service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SmfPduSessionSmContextClient interface {
	SetAmfNotification(ctx context.Context, in *SetSmNotificationContext, opts ...grpc.CallOption) (*SmContextVoid, error)
	SetSmfSessionContext(ctx context.Context, in *SetSMSessionContextAccess, opts ...grpc.CallOption) (*SmContextVoid, error)
}

type smfPduSessionSmContextClient struct {
	cc grpc.ClientConnInterface
}

func NewSmfPduSessionSmContextClient(cc grpc.ClientConnInterface) SmfPduSessionSmContextClient {
	return &smfPduSessionSmContextClient{cc}
}

func (c *smfPduSessionSmContextClient) SetAmfNotification(ctx context.Context, in *SetSmNotificationContext, opts ...grpc.CallOption) (*SmContextVoid, error) {
	out := new(SmContextVoid)
	err := c.cc.Invoke(ctx, "/magma.lte.SmfPduSessionSmContext/SetAmfNotification", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *smfPduSessionSmContextClient) SetSmfSessionContext(ctx context.Context, in *SetSMSessionContextAccess, opts ...grpc.CallOption) (*SmContextVoid, error) {
	out := new(SmContextVoid)
	err := c.cc.Invoke(ctx, "/magma.lte.SmfPduSessionSmContext/SetSmfSessionContext", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SmfPduSessionSmContextServer is the server API for SmfPduSessionSmContext service.
// All implementations must embed UnimplementedSmfPduSessionSmContextServer
// for forward compatibility
type SmfPduSessionSmContextServer interface {
	SetAmfNotification(context.Context, *SetSmNotificationContext) (*SmContextVoid, error)
	SetSmfSessionContext(context.Context, *SetSMSessionContextAccess) (*SmContextVoid, error)
	mustEmbedUnimplementedSmfPduSessionSmContextServer()
}

// UnimplementedSmfPduSessionSmContextServer must be embedded to have forward compatible implementations.
type UnimplementedSmfPduSessionSmContextServer struct {
}

func (UnimplementedSmfPduSessionSmContextServer) SetAmfNotification(context.Context, *SetSmNotificationContext) (*SmContextVoid, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetAmfNotification not implemented")
}
func (UnimplementedSmfPduSessionSmContextServer) SetSmfSessionContext(context.Context, *SetSMSessionContextAccess) (*SmContextVoid, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetSmfSessionContext not implemented")
}
func (UnimplementedSmfPduSessionSmContextServer) mustEmbedUnimplementedSmfPduSessionSmContextServer() {
}

// UnsafeSmfPduSessionSmContextServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SmfPduSessionSmContextServer will
// result in compilation errors.
type UnsafeSmfPduSessionSmContextServer interface {
	mustEmbedUnimplementedSmfPduSessionSmContextServer()
}

func RegisterSmfPduSessionSmContextServer(s grpc.ServiceRegistrar, srv SmfPduSessionSmContextServer) {
	s.RegisterService(&SmfPduSessionSmContext_ServiceDesc, srv)
}

func _SmfPduSessionSmContext_SetAmfNotification_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetSmNotificationContext)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SmfPduSessionSmContextServer).SetAmfNotification(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.lte.SmfPduSessionSmContext/SetAmfNotification",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SmfPduSessionSmContextServer).SetAmfNotification(ctx, req.(*SetSmNotificationContext))
	}
	return interceptor(ctx, in, info, handler)
}

func _SmfPduSessionSmContext_SetSmfSessionContext_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetSMSessionContextAccess)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SmfPduSessionSmContextServer).SetSmfSessionContext(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.lte.SmfPduSessionSmContext/SetSmfSessionContext",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SmfPduSessionSmContextServer).SetSmfSessionContext(ctx, req.(*SetSMSessionContextAccess))
	}
	return interceptor(ctx, in, info, handler)
}

// SmfPduSessionSmContext_ServiceDesc is the grpc.ServiceDesc for SmfPduSessionSmContext service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var SmfPduSessionSmContext_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "magma.lte.SmfPduSessionSmContext",
	HandlerType: (*SmfPduSessionSmContextServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SetAmfNotification",
			Handler:    _SmfPduSessionSmContext_SetAmfNotification_Handler,
		},
		{
			MethodName: "SetSmfSessionContext",
			Handler:    _SmfPduSessionSmContext_SetSmfSessionContext_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "session_manager.proto",
}

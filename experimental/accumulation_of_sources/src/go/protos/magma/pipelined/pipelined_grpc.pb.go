// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package pipelined

import (
	context "context"
	orc8r "github.com/magma/magma/src/go/protos/magma/orc8r"
	session_manager "github.com/magma/magma/src/go/protos/magma/session_manager"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// PipelinedClient is the client API for Pipelined service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type PipelinedClient interface {
	// Setup pipelined basic controllers
	SetupDefaultControllers(ctx context.Context, in *SetupDefaultRequest, opts ...grpc.CallOption) (*SetupFlowsResult, error)
	SetSMFSessions(ctx context.Context, in *SessionSet, opts ...grpc.CallOption) (*UPFSessionContextState, error)
	// Setup flows for subscribers (used on restarts)
	SetupPolicyFlows(ctx context.Context, in *SetupPolicyRequest, opts ...grpc.CallOption) (*SetupFlowsResult, error)
	// Activate flows for a subscriber based on predefined flow templates
	ActivateFlows(ctx context.Context, in *ActivateFlowsRequest, opts ...grpc.CallOption) (*ActivateFlowsResult, error)
	// Deactivate flows for a subscriber
	DeactivateFlows(ctx context.Context, in *DeactivateFlowsRequest, opts ...grpc.CallOption) (*DeactivateFlowsResult, error)
	// Get policy usage stats
	GetPolicyUsage(ctx context.Context, in *orc8r.Void, opts ...grpc.CallOption) (*session_manager.RuleRecordTable, error)
	GetStats(ctx context.Context, in *GetStatsRequest, opts ...grpc.CallOption) (*session_manager.RuleRecordTable, error)
	// Add new dpi flow
	CreateFlow(ctx context.Context, in *FlowRequest, opts ...grpc.CallOption) (*FlowResponse, error)
	// Remove dpi flow
	RemoveFlow(ctx context.Context, in *FlowRequest, opts ...grpc.CallOption) (*FlowResponse, error)
	// Update flow stats
	UpdateFlowStats(ctx context.Context, in *FlowRequest, opts ...grpc.CallOption) (*FlowResponse, error)
	// Setup subscribers flows (used on restarts)
	SetupQuotaFlows(ctx context.Context, in *SetupQuotaRequest, opts ...grpc.CallOption) (*SetupFlowsResult, error)
	// Synchronize subscribers quota check flows
	UpdateSubscriberQuotaState(ctx context.Context, in *UpdateSubscriberQuotaStateRequest, opts ...grpc.CallOption) (*FlowResponse, error)
	// Setup subscribers flows (used on restarts)
	SetupUEMacFlows(ctx context.Context, in *SetupUEMacRequest, opts ...grpc.CallOption) (*SetupFlowsResult, error)
	// Add a flow for a subscriber by matching the provided UE MAC address
	AddUEMacFlow(ctx context.Context, in *UEMacFlowRequest, opts ...grpc.CallOption) (*FlowResponse, error)
	// Delete a flow for a subscriber by matching the provided UE MAC address
	DeleteUEMacFlow(ctx context.Context, in *UEMacFlowRequest, opts ...grpc.CallOption) (*FlowResponse, error)
	// Update subscriber IPFIX flows
	UpdateIPFIXFlow(ctx context.Context, in *UEMacFlowRequest, opts ...grpc.CallOption) (*FlowResponse, error)
	// Get the flow table assignment for all apps ordered by main table number
	// and name
	GetAllTableAssignments(ctx context.Context, in *orc8r.Void, opts ...grpc.CallOption) (*AllTableAssignments, error)
	UpdateUEState(ctx context.Context, in *UESessionSet, opts ...grpc.CallOption) (*UESessionContextResponse, error)
}

type pipelinedClient struct {
	cc grpc.ClientConnInterface
}

func NewPipelinedClient(cc grpc.ClientConnInterface) PipelinedClient {
	return &pipelinedClient{cc}
}

func (c *pipelinedClient) SetupDefaultControllers(ctx context.Context, in *SetupDefaultRequest, opts ...grpc.CallOption) (*SetupFlowsResult, error) {
	out := new(SetupFlowsResult)
	err := c.cc.Invoke(ctx, "/magma.lte.Pipelined/SetupDefaultControllers", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pipelinedClient) SetSMFSessions(ctx context.Context, in *SessionSet, opts ...grpc.CallOption) (*UPFSessionContextState, error) {
	out := new(UPFSessionContextState)
	err := c.cc.Invoke(ctx, "/magma.lte.Pipelined/SetSMFSessions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pipelinedClient) SetupPolicyFlows(ctx context.Context, in *SetupPolicyRequest, opts ...grpc.CallOption) (*SetupFlowsResult, error) {
	out := new(SetupFlowsResult)
	err := c.cc.Invoke(ctx, "/magma.lte.Pipelined/SetupPolicyFlows", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pipelinedClient) ActivateFlows(ctx context.Context, in *ActivateFlowsRequest, opts ...grpc.CallOption) (*ActivateFlowsResult, error) {
	out := new(ActivateFlowsResult)
	err := c.cc.Invoke(ctx, "/magma.lte.Pipelined/ActivateFlows", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pipelinedClient) DeactivateFlows(ctx context.Context, in *DeactivateFlowsRequest, opts ...grpc.CallOption) (*DeactivateFlowsResult, error) {
	out := new(DeactivateFlowsResult)
	err := c.cc.Invoke(ctx, "/magma.lte.Pipelined/DeactivateFlows", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pipelinedClient) GetPolicyUsage(ctx context.Context, in *orc8r.Void, opts ...grpc.CallOption) (*session_manager.RuleRecordTable, error) {
	out := new(session_manager.RuleRecordTable)
	err := c.cc.Invoke(ctx, "/magma.lte.Pipelined/GetPolicyUsage", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pipelinedClient) GetStats(ctx context.Context, in *GetStatsRequest, opts ...grpc.CallOption) (*session_manager.RuleRecordTable, error) {
	out := new(session_manager.RuleRecordTable)
	err := c.cc.Invoke(ctx, "/magma.lte.Pipelined/GetStats", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pipelinedClient) CreateFlow(ctx context.Context, in *FlowRequest, opts ...grpc.CallOption) (*FlowResponse, error) {
	out := new(FlowResponse)
	err := c.cc.Invoke(ctx, "/magma.lte.Pipelined/CreateFlow", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pipelinedClient) RemoveFlow(ctx context.Context, in *FlowRequest, opts ...grpc.CallOption) (*FlowResponse, error) {
	out := new(FlowResponse)
	err := c.cc.Invoke(ctx, "/magma.lte.Pipelined/RemoveFlow", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pipelinedClient) UpdateFlowStats(ctx context.Context, in *FlowRequest, opts ...grpc.CallOption) (*FlowResponse, error) {
	out := new(FlowResponse)
	err := c.cc.Invoke(ctx, "/magma.lte.Pipelined/UpdateFlowStats", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pipelinedClient) SetupQuotaFlows(ctx context.Context, in *SetupQuotaRequest, opts ...grpc.CallOption) (*SetupFlowsResult, error) {
	out := new(SetupFlowsResult)
	err := c.cc.Invoke(ctx, "/magma.lte.Pipelined/SetupQuotaFlows", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pipelinedClient) UpdateSubscriberQuotaState(ctx context.Context, in *UpdateSubscriberQuotaStateRequest, opts ...grpc.CallOption) (*FlowResponse, error) {
	out := new(FlowResponse)
	err := c.cc.Invoke(ctx, "/magma.lte.Pipelined/UpdateSubscriberQuotaState", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pipelinedClient) SetupUEMacFlows(ctx context.Context, in *SetupUEMacRequest, opts ...grpc.CallOption) (*SetupFlowsResult, error) {
	out := new(SetupFlowsResult)
	err := c.cc.Invoke(ctx, "/magma.lte.Pipelined/SetupUEMacFlows", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pipelinedClient) AddUEMacFlow(ctx context.Context, in *UEMacFlowRequest, opts ...grpc.CallOption) (*FlowResponse, error) {
	out := new(FlowResponse)
	err := c.cc.Invoke(ctx, "/magma.lte.Pipelined/AddUEMacFlow", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pipelinedClient) DeleteUEMacFlow(ctx context.Context, in *UEMacFlowRequest, opts ...grpc.CallOption) (*FlowResponse, error) {
	out := new(FlowResponse)
	err := c.cc.Invoke(ctx, "/magma.lte.Pipelined/DeleteUEMacFlow", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pipelinedClient) UpdateIPFIXFlow(ctx context.Context, in *UEMacFlowRequest, opts ...grpc.CallOption) (*FlowResponse, error) {
	out := new(FlowResponse)
	err := c.cc.Invoke(ctx, "/magma.lte.Pipelined/UpdateIPFIXFlow", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pipelinedClient) GetAllTableAssignments(ctx context.Context, in *orc8r.Void, opts ...grpc.CallOption) (*AllTableAssignments, error) {
	out := new(AllTableAssignments)
	err := c.cc.Invoke(ctx, "/magma.lte.Pipelined/GetAllTableAssignments", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pipelinedClient) UpdateUEState(ctx context.Context, in *UESessionSet, opts ...grpc.CallOption) (*UESessionContextResponse, error) {
	out := new(UESessionContextResponse)
	err := c.cc.Invoke(ctx, "/magma.lte.Pipelined/UpdateUEState", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PipelinedServer is the server API for Pipelined service.
// All implementations must embed UnimplementedPipelinedServer
// for forward compatibility
type PipelinedServer interface {
	// Setup pipelined basic controllers
	SetupDefaultControllers(context.Context, *SetupDefaultRequest) (*SetupFlowsResult, error)
	SetSMFSessions(context.Context, *SessionSet) (*UPFSessionContextState, error)
	// Setup flows for subscribers (used on restarts)
	SetupPolicyFlows(context.Context, *SetupPolicyRequest) (*SetupFlowsResult, error)
	// Activate flows for a subscriber based on predefined flow templates
	ActivateFlows(context.Context, *ActivateFlowsRequest) (*ActivateFlowsResult, error)
	// Deactivate flows for a subscriber
	DeactivateFlows(context.Context, *DeactivateFlowsRequest) (*DeactivateFlowsResult, error)
	// Get policy usage stats
	GetPolicyUsage(context.Context, *orc8r.Void) (*session_manager.RuleRecordTable, error)
	GetStats(context.Context, *GetStatsRequest) (*session_manager.RuleRecordTable, error)
	// Add new dpi flow
	CreateFlow(context.Context, *FlowRequest) (*FlowResponse, error)
	// Remove dpi flow
	RemoveFlow(context.Context, *FlowRequest) (*FlowResponse, error)
	// Update flow stats
	UpdateFlowStats(context.Context, *FlowRequest) (*FlowResponse, error)
	// Setup subscribers flows (used on restarts)
	SetupQuotaFlows(context.Context, *SetupQuotaRequest) (*SetupFlowsResult, error)
	// Synchronize subscribers quota check flows
	UpdateSubscriberQuotaState(context.Context, *UpdateSubscriberQuotaStateRequest) (*FlowResponse, error)
	// Setup subscribers flows (used on restarts)
	SetupUEMacFlows(context.Context, *SetupUEMacRequest) (*SetupFlowsResult, error)
	// Add a flow for a subscriber by matching the provided UE MAC address
	AddUEMacFlow(context.Context, *UEMacFlowRequest) (*FlowResponse, error)
	// Delete a flow for a subscriber by matching the provided UE MAC address
	DeleteUEMacFlow(context.Context, *UEMacFlowRequest) (*FlowResponse, error)
	// Update subscriber IPFIX flows
	UpdateIPFIXFlow(context.Context, *UEMacFlowRequest) (*FlowResponse, error)
	// Get the flow table assignment for all apps ordered by main table number
	// and name
	GetAllTableAssignments(context.Context, *orc8r.Void) (*AllTableAssignments, error)
	UpdateUEState(context.Context, *UESessionSet) (*UESessionContextResponse, error)
	mustEmbedUnimplementedPipelinedServer()
}

// UnimplementedPipelinedServer must be embedded to have forward compatible implementations.
type UnimplementedPipelinedServer struct {
}

func (UnimplementedPipelinedServer) SetupDefaultControllers(context.Context, *SetupDefaultRequest) (*SetupFlowsResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetupDefaultControllers not implemented")
}
func (UnimplementedPipelinedServer) SetSMFSessions(context.Context, *SessionSet) (*UPFSessionContextState, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetSMFSessions not implemented")
}
func (UnimplementedPipelinedServer) SetupPolicyFlows(context.Context, *SetupPolicyRequest) (*SetupFlowsResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetupPolicyFlows not implemented")
}
func (UnimplementedPipelinedServer) ActivateFlows(context.Context, *ActivateFlowsRequest) (*ActivateFlowsResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ActivateFlows not implemented")
}
func (UnimplementedPipelinedServer) DeactivateFlows(context.Context, *DeactivateFlowsRequest) (*DeactivateFlowsResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeactivateFlows not implemented")
}
func (UnimplementedPipelinedServer) GetPolicyUsage(context.Context, *orc8r.Void) (*session_manager.RuleRecordTable, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPolicyUsage not implemented")
}
func (UnimplementedPipelinedServer) GetStats(context.Context, *GetStatsRequest) (*session_manager.RuleRecordTable, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetStats not implemented")
}
func (UnimplementedPipelinedServer) CreateFlow(context.Context, *FlowRequest) (*FlowResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateFlow not implemented")
}
func (UnimplementedPipelinedServer) RemoveFlow(context.Context, *FlowRequest) (*FlowResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveFlow not implemented")
}
func (UnimplementedPipelinedServer) UpdateFlowStats(context.Context, *FlowRequest) (*FlowResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateFlowStats not implemented")
}
func (UnimplementedPipelinedServer) SetupQuotaFlows(context.Context, *SetupQuotaRequest) (*SetupFlowsResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetupQuotaFlows not implemented")
}
func (UnimplementedPipelinedServer) UpdateSubscriberQuotaState(context.Context, *UpdateSubscriberQuotaStateRequest) (*FlowResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateSubscriberQuotaState not implemented")
}
func (UnimplementedPipelinedServer) SetupUEMacFlows(context.Context, *SetupUEMacRequest) (*SetupFlowsResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetupUEMacFlows not implemented")
}
func (UnimplementedPipelinedServer) AddUEMacFlow(context.Context, *UEMacFlowRequest) (*FlowResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddUEMacFlow not implemented")
}
func (UnimplementedPipelinedServer) DeleteUEMacFlow(context.Context, *UEMacFlowRequest) (*FlowResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteUEMacFlow not implemented")
}
func (UnimplementedPipelinedServer) UpdateIPFIXFlow(context.Context, *UEMacFlowRequest) (*FlowResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateIPFIXFlow not implemented")
}
func (UnimplementedPipelinedServer) GetAllTableAssignments(context.Context, *orc8r.Void) (*AllTableAssignments, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllTableAssignments not implemented")
}
func (UnimplementedPipelinedServer) UpdateUEState(context.Context, *UESessionSet) (*UESessionContextResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateUEState not implemented")
}
func (UnimplementedPipelinedServer) mustEmbedUnimplementedPipelinedServer() {}

// UnsafePipelinedServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PipelinedServer will
// result in compilation errors.
type UnsafePipelinedServer interface {
	mustEmbedUnimplementedPipelinedServer()
}

func RegisterPipelinedServer(s grpc.ServiceRegistrar, srv PipelinedServer) {
	s.RegisterService(&Pipelined_ServiceDesc, srv)
}

func _Pipelined_SetupDefaultControllers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetupDefaultRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PipelinedServer).SetupDefaultControllers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.lte.Pipelined/SetupDefaultControllers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PipelinedServer).SetupDefaultControllers(ctx, req.(*SetupDefaultRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Pipelined_SetSMFSessions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SessionSet)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PipelinedServer).SetSMFSessions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.lte.Pipelined/SetSMFSessions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PipelinedServer).SetSMFSessions(ctx, req.(*SessionSet))
	}
	return interceptor(ctx, in, info, handler)
}

func _Pipelined_SetupPolicyFlows_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetupPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PipelinedServer).SetupPolicyFlows(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.lte.Pipelined/SetupPolicyFlows",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PipelinedServer).SetupPolicyFlows(ctx, req.(*SetupPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Pipelined_ActivateFlows_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ActivateFlowsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PipelinedServer).ActivateFlows(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.lte.Pipelined/ActivateFlows",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PipelinedServer).ActivateFlows(ctx, req.(*ActivateFlowsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Pipelined_DeactivateFlows_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeactivateFlowsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PipelinedServer).DeactivateFlows(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.lte.Pipelined/DeactivateFlows",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PipelinedServer).DeactivateFlows(ctx, req.(*DeactivateFlowsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Pipelined_GetPolicyUsage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(orc8r.Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PipelinedServer).GetPolicyUsage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.lte.Pipelined/GetPolicyUsage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PipelinedServer).GetPolicyUsage(ctx, req.(*orc8r.Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _Pipelined_GetStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetStatsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PipelinedServer).GetStats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.lte.Pipelined/GetStats",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PipelinedServer).GetStats(ctx, req.(*GetStatsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Pipelined_CreateFlow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FlowRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PipelinedServer).CreateFlow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.lte.Pipelined/CreateFlow",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PipelinedServer).CreateFlow(ctx, req.(*FlowRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Pipelined_RemoveFlow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FlowRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PipelinedServer).RemoveFlow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.lte.Pipelined/RemoveFlow",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PipelinedServer).RemoveFlow(ctx, req.(*FlowRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Pipelined_UpdateFlowStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FlowRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PipelinedServer).UpdateFlowStats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.lte.Pipelined/UpdateFlowStats",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PipelinedServer).UpdateFlowStats(ctx, req.(*FlowRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Pipelined_SetupQuotaFlows_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetupQuotaRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PipelinedServer).SetupQuotaFlows(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.lte.Pipelined/SetupQuotaFlows",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PipelinedServer).SetupQuotaFlows(ctx, req.(*SetupQuotaRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Pipelined_UpdateSubscriberQuotaState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateSubscriberQuotaStateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PipelinedServer).UpdateSubscriberQuotaState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.lte.Pipelined/UpdateSubscriberQuotaState",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PipelinedServer).UpdateSubscriberQuotaState(ctx, req.(*UpdateSubscriberQuotaStateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Pipelined_SetupUEMacFlows_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetupUEMacRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PipelinedServer).SetupUEMacFlows(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.lte.Pipelined/SetupUEMacFlows",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PipelinedServer).SetupUEMacFlows(ctx, req.(*SetupUEMacRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Pipelined_AddUEMacFlow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UEMacFlowRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PipelinedServer).AddUEMacFlow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.lte.Pipelined/AddUEMacFlow",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PipelinedServer).AddUEMacFlow(ctx, req.(*UEMacFlowRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Pipelined_DeleteUEMacFlow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UEMacFlowRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PipelinedServer).DeleteUEMacFlow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.lte.Pipelined/DeleteUEMacFlow",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PipelinedServer).DeleteUEMacFlow(ctx, req.(*UEMacFlowRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Pipelined_UpdateIPFIXFlow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UEMacFlowRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PipelinedServer).UpdateIPFIXFlow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.lte.Pipelined/UpdateIPFIXFlow",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PipelinedServer).UpdateIPFIXFlow(ctx, req.(*UEMacFlowRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Pipelined_GetAllTableAssignments_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(orc8r.Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PipelinedServer).GetAllTableAssignments(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.lte.Pipelined/GetAllTableAssignments",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PipelinedServer).GetAllTableAssignments(ctx, req.(*orc8r.Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _Pipelined_UpdateUEState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UESessionSet)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PipelinedServer).UpdateUEState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.lte.Pipelined/UpdateUEState",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PipelinedServer).UpdateUEState(ctx, req.(*UESessionSet))
	}
	return interceptor(ctx, in, info, handler)
}

// Pipelined_ServiceDesc is the grpc.ServiceDesc for Pipelined service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Pipelined_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "magma.lte.Pipelined",
	HandlerType: (*PipelinedServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SetupDefaultControllers",
			Handler:    _Pipelined_SetupDefaultControllers_Handler,
		},
		{
			MethodName: "SetSMFSessions",
			Handler:    _Pipelined_SetSMFSessions_Handler,
		},
		{
			MethodName: "SetupPolicyFlows",
			Handler:    _Pipelined_SetupPolicyFlows_Handler,
		},
		{
			MethodName: "ActivateFlows",
			Handler:    _Pipelined_ActivateFlows_Handler,
		},
		{
			MethodName: "DeactivateFlows",
			Handler:    _Pipelined_DeactivateFlows_Handler,
		},
		{
			MethodName: "GetPolicyUsage",
			Handler:    _Pipelined_GetPolicyUsage_Handler,
		},
		{
			MethodName: "GetStats",
			Handler:    _Pipelined_GetStats_Handler,
		},
		{
			MethodName: "CreateFlow",
			Handler:    _Pipelined_CreateFlow_Handler,
		},
		{
			MethodName: "RemoveFlow",
			Handler:    _Pipelined_RemoveFlow_Handler,
		},
		{
			MethodName: "UpdateFlowStats",
			Handler:    _Pipelined_UpdateFlowStats_Handler,
		},
		{
			MethodName: "SetupQuotaFlows",
			Handler:    _Pipelined_SetupQuotaFlows_Handler,
		},
		{
			MethodName: "UpdateSubscriberQuotaState",
			Handler:    _Pipelined_UpdateSubscriberQuotaState_Handler,
		},
		{
			MethodName: "SetupUEMacFlows",
			Handler:    _Pipelined_SetupUEMacFlows_Handler,
		},
		{
			MethodName: "AddUEMacFlow",
			Handler:    _Pipelined_AddUEMacFlow_Handler,
		},
		{
			MethodName: "DeleteUEMacFlow",
			Handler:    _Pipelined_DeleteUEMacFlow_Handler,
		},
		{
			MethodName: "UpdateIPFIXFlow",
			Handler:    _Pipelined_UpdateIPFIXFlow_Handler,
		},
		{
			MethodName: "GetAllTableAssignments",
			Handler:    _Pipelined_GetAllTableAssignments_Handler,
		},
		{
			MethodName: "UpdateUEState",
			Handler:    _Pipelined_UpdateUEState_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "pipelined.proto",
}

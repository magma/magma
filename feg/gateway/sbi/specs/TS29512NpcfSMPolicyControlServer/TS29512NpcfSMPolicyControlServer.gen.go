// Package TS29512NpcfSMPolicyControlServer provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.9.0 DO NOT EDIT.
package TS29512NpcfSMPolicyControlServer

import (
	"encoding/json"
	"fmt"
	"net/http"
	"time"

	externalRef0 "magma/feg/gateway/sbi/specs/TS29122CommonData"
	externalRef1 "magma/feg/gateway/sbi/specs/TS29507NpcfAMPolicyControl"
	externalRef2 "magma/feg/gateway/sbi/specs/TS29514NpcfPolicyAuthorization"
	externalRef3 "magma/feg/gateway/sbi/specs/TS29519PolicyData"
	externalRef4 "magma/feg/gateway/sbi/specs/TS29571CommonData"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/labstack/echo/v4"
)

const (
	OAuth2ClientcredentialsScopes = "oAuth2Clientcredentials.Scopes"
)

// Defines values for FailureCause.
const (
	FailureCausePCCQOSFLOWEVENT FailureCause = "PCC_QOS_FLOW_EVENT"

	FailureCausePCCRULEEVENT FailureCause = "PCC_RULE_EVENT"

	FailureCauseRULEPERMANENTERROR FailureCause = "RULE_PERMANENT_ERROR"

	FailureCauseRULETEMPORARYERROR FailureCause = "RULE_TEMPORARY_ERROR"
)

// Defines values for FailureCode.
const (
	FailureCodeAPPIDERR FailureCode = "APP_ID_ERR"

	FailureCodeCMAUTHREJ FailureCode = "CM_AUTH_REJ"

	FailureCodeCMCREDITCONNOTAPP FailureCode = "CM_CREDIT_CON_NOT_APP"

	FailureCodeCMENDUSERSERDENIED FailureCode = "CM_END_USER_SER_DENIED"

	FailureCodeCMRATFAILED FailureCode = "CM_RAT_FAILED"

	FailureCodeCMUSERUNK FailureCode = "CM_USER_UNK"

	FailureCodeFILTERRES FailureCode = "FILTER_RES"

	FailureCodeINCORFLOWINFO FailureCode = "INCOR_FLOW_INFO"

	FailureCodeMAXNRQoSFLOW FailureCode = "MAX_NR_QoS_FLOW"

	FailureCodeMISSFLOWINFO FailureCode = "MISS_FLOW_INFO"

	FailureCodeMISSREDISERADDR FailureCode = "MISS_REDI_SER_ADDR"

	FailureCodeNFMAL FailureCode = "NF_MAL"

	FailureCodeNOQOSFLOWBOUND FailureCode = "NO_QOS_FLOW_BOUND"

	FailureCodePSTOCSHAN FailureCode = "PS_TO_CS_HAN"

	FailureCodeRAGRERR FailureCode = "RA_GR_ERR"

	FailureCodeRESALLOFAIL FailureCode = "RES_ALLO_FAIL"

	FailureCodeRESLIM FailureCode = "RES_LIM"

	FailureCodeSERIDERR FailureCode = "SER_ID_ERR"

	FailureCodeUESTASUSP FailureCode = "UE_STA_SUSP"

	FailureCodeUNKRULEID FailureCode = "UNK_RULE_ID"

	FailureCodeUNSUCCQOSVAL FailureCode = "UNSUCC_QOS_VAL"
)

// Defines values for PolicyControlRequestTrigger.
const (
	PolicyControlRequestTriggerACTYCH PolicyControlRequestTrigger = "AC_TY_CH"

	PolicyControlRequestTriggerANCHCOR PolicyControlRequestTrigger = "AN_CH_COR"

	PolicyControlRequestTriggerANINFO PolicyControlRequestTrigger = "AN_INFO"

	PolicyControlRequestTriggerAPPSTA PolicyControlRequestTrigger = "APP_STA"

	PolicyControlRequestTriggerAPPSTO PolicyControlRequestTrigger = "APP_STO"

	PolicyControlRequestTriggerCMSESFAIL PolicyControlRequestTrigger = "CM_SES_FAIL"

	PolicyControlRequestTriggerDEFQOSCH PolicyControlRequestTrigger = "DEF_QOS_CH"

	PolicyControlRequestTriggerNOCREDIT PolicyControlRequestTrigger = "NO_CREDIT"

	PolicyControlRequestTriggerNUMOFPACKETFILTER PolicyControlRequestTrigger = "NUM_OF_PACKET_FILTER"

	PolicyControlRequestTriggerPLMNCH PolicyControlRequestTrigger = "PLMN_CH"

	PolicyControlRequestTriggerPRACH PolicyControlRequestTrigger = "PRA_CH"

	PolicyControlRequestTriggerPSDAOFF PolicyControlRequestTrigger = "PS_DA_OFF"

	PolicyControlRequestTriggerQOSNOTIF PolicyControlRequestTrigger = "QOS_NOTIF"

	PolicyControlRequestTriggerRATTYCH PolicyControlRequestTrigger = "RAT_TY_CH"

	PolicyControlRequestTriggerREFQOSINDCH PolicyControlRequestTrigger = "REF_QOS_IND_CH"

	PolicyControlRequestTriggerRESMORE PolicyControlRequestTrigger = "RES_MO_RE"

	PolicyControlRequestTriggerRESRELEASE PolicyControlRequestTrigger = "RES_RELEASE"

	PolicyControlRequestTriggerRETIMEOUT PolicyControlRequestTrigger = "RE_TIMEOUT"

	PolicyControlRequestTriggerSAREACH PolicyControlRequestTrigger = "SAREA_CH"

	PolicyControlRequestTriggerSCNNCH PolicyControlRequestTrigger = "SCNN_CH"

	PolicyControlRequestTriggerSEAMBRCH PolicyControlRequestTrigger = "SE_AMBR_CH"

	PolicyControlRequestTriggerSUCCRESALLO PolicyControlRequestTrigger = "SUCC_RES_ALLO"

	PolicyControlRequestTriggerUEIPCH PolicyControlRequestTrigger = "UE_IP_CH"

	PolicyControlRequestTriggerUEMACCH PolicyControlRequestTrigger = "UE_MAC_CH"

	PolicyControlRequestTriggerUESTATUSRESUME PolicyControlRequestTrigger = "UE_STATUS_RESUME"

	PolicyControlRequestTriggerUETZCH PolicyControlRequestTrigger = "UE_TZ_CH"

	PolicyControlRequestTriggerUSRE PolicyControlRequestTrigger = "US_RE"
)

// Defines values for QosFlowUsage.
const (
	QosFlowUsageGENERAL QosFlowUsage = "GENERAL"

	QosFlowUsageIMSSIG QosFlowUsage = "IMS_SIG"
)

// Defines values for RedirectAddressType.
const (
	RedirectAddressTypeIPV4ADDR RedirectAddressType = "IPV4_ADDR"

	RedirectAddressTypeIPV6ADDR RedirectAddressType = "IPV6_ADDR"

	RedirectAddressTypeSIPURI RedirectAddressType = "SIP_URI"

	RedirectAddressTypeURL RedirectAddressType = "URL"
)

// Defines values for RuleOperation.
const (
	RuleOperationCREATEPCCRULE RuleOperation = "CREATE_PCC_RULE"

	RuleOperationDELETEPCCRULE RuleOperation = "DELETE_PCC_RULE"

	RuleOperationMODIFYPCCRULEANDADDPACKETFILTERS RuleOperation = "MODIFY_PCC_RULE_AND_ADD_PACKET_FILTERS"

	RuleOperationMODIFYPCCRULEANDDELETEPACKETFILTERS RuleOperation = "MODIFY_ PCC_RULE_AND_DELETE_PACKET_FILTERS"

	RuleOperationMODIFYPCCRULEANDREPLACEPACKETFILTERS RuleOperation = "MODIFY_ PCC_RULE_AND_REPLACE_PACKET_FILTERS"

	RuleOperationMODIFYPCCRULEWITHOUTMODIFYPACKETFILTERS RuleOperation = "MODIFY_PCC_RULE_WITHOUT_MODIFY_PACKET_FILTERS"
)

// Defines values for RuleStatus.
const (
	RuleStatusACTIVE RuleStatus = "ACTIVE"

	RuleStatusINACTIVE RuleStatus = "INACTIVE"
)

// N5GSmCause defines model for 5GSmCause.
type N5GSmCause externalRef4.Uinteger

// AccNetChId defines model for AccNetChId.
type AccNetChId struct {
	AccNetChaIdValue externalRef4.ChargingId `json:"accNetChaIdValue"`

	// Contains the identifier of the PCC rule(s) associated to the provided Access Network Charging Identifier.
	RefPccRuleIds *[]string `json:"refPccRuleIds,omitempty"`

	// When it is included and set to true, indicates the Access Network Charging Identifier applies to the whole PDU Session
	SessionChScope *bool `json:"sessionChScope,omitempty"`
}

// Describes the network entity within the access network performing charging
type AccNetChargingAddress interface{}

// AccuUsageReport defines model for AccuUsageReport.
type AccuUsageReport struct {
	NextTimeUsage *externalRef4.DurationSec `json:"nextTimeUsage,omitempty"`

	// Unsigned integer identifying a volume in units of bytes.
	NextVolUsage *externalRef0.Volume `json:"nextVolUsage,omitempty"`

	// Unsigned integer identifying a volume in units of bytes.
	NextVolUsageDownlink *externalRef0.Volume `json:"nextVolUsageDownlink,omitempty"`

	// Unsigned integer identifying a volume in units of bytes.
	NextVolUsageUplink *externalRef0.Volume `json:"nextVolUsageUplink,omitempty"`

	// An id referencing UsageMonitoringData objects associated with this usage report.
	RefUmIds  string                    `json:"refUmIds"`
	TimeUsage *externalRef4.DurationSec `json:"timeUsage,omitempty"`

	// Unsigned integer identifying a volume in units of bytes.
	VolUsage *externalRef0.Volume `json:"volUsage,omitempty"`

	// Unsigned integer identifying a volume in units of bytes.
	VolUsageDownlink *externalRef0.Volume `json:"volUsageDownlink,omitempty"`

	// Unsigned integer identifying a volume in units of bytes.
	VolUsageUplink *externalRef0.Volume `json:"volUsageUplink,omitempty"`
}

// Possible values are - NO_INFORMATION: Indicate that no information about the AF signalling protocol is being provided. - SIP: Indicate that the signalling protocol is Session Initiation Protocol.
type AfSigProtocol interface{}

// AppDetectionInfo defines model for AppDetectionInfo.
type AppDetectionInfo struct {
	// A reference to the application detection filter configured at the UPF
	AppId string `json:"appId"`

	// Identifier sent by the SMF in order to allow correlation of application Start and Stop events to the specific service data flow description, if service data flow descriptions are deducible.
	InstanceId *string `json:"instanceId,omitempty"`

	// Contains the detected service data flow descriptions if they are deducible.
	SdfDescriptions *[]FlowInformation `json:"sdfDescriptions,omitempty"`
}

// AuthorizedDefaultQos defines model for AuthorizedDefaultQos.
type AuthorizedDefaultQos struct {
	N5qi            *externalRef4.N5Qi                `json:"5qi,omitempty"`
	Arp             *externalRef4.Arp                 `json:"arp,omitempty"`
	AverWindow      *externalRef4.AverWindowRm        `json:"averWindow"`
	GbrDl           *externalRef4.BitRateRm           `json:"gbrDl"`
	GbrUl           *externalRef4.BitRateRm           `json:"gbrUl"`
	MaxDataBurstVol *externalRef4.MaxDataBurstVolRm   `json:"maxDataBurstVol"`
	MaxbrDl         *externalRef4.BitRateRm           `json:"maxbrDl"`
	MaxbrUl         *externalRef4.BitRateRm           `json:"maxbrUl"`
	PriorityLevel   *externalRef4.N5QiPriorityLevelRm `json:"priorityLevel"`

	// Indicates whether notifications are requested from 3GPP NG-RAN when the GFBR can no longer (or again) be guaranteed for a QoS Flow during the lifetime of the QoS Flow.
	Qnc *bool `json:"qnc,omitempty"`
}

// ChargingData defines model for ChargingData.
type ChargingData struct {
	AfChargId            *externalRef4.ApplicationChargingId `json:"afChargId,omitempty"`
	AfChargingIdentifier *externalRef4.ChargingId            `json:"afChargingIdentifier,omitempty"`

	// Indicates the application service provider identity.
	AppSvcProvId *string `json:"appSvcProvId,omitempty"`

	// Univocally identifies the charging control policy data within a PDU session.
	ChgId string `json:"chgId"`

	// Possible values are - DURATION: Indicates that the duration of the service data flow traffic shall be metered. - VOLUME: Indicates that volume of the service data flow traffic shall be metered. - DURATION_VOLUME: Indicates that the duration and the volume of the service data flow traffic shall be metered. - EVENT: Indicates that events of the service data flow traffic shall be metered.
	MeteringMethod *MeteringMethod `json:"meteringMethod"`

	// Indicates the offline charging is applicable to the PCC rule when it is included and set to true.
	Offline *bool `json:"offline,omitempty"`

	// Indicates the online charging is applicable to the PCC rule when it is included and set to true.
	Online      *bool                     `json:"online,omitempty"`
	RatingGroup *externalRef4.RatingGroup `json:"ratingGroup,omitempty"`

	// Possible values are - SER_ID_LEVEL: Indicates that the usage shall be reported on service id and rating group combination level. - RAT_GR_LEVEL: Indicates that the usage shall be reported on rating group level. - SPON_CON_LEVEL: Indicates that the usage shall be reported on sponsor identity and rating group combination level.
	ReportingLevel *ReportingLevel `json:"reportingLevel"`

	// Indicates whether the service data flow is allowed to start while the SMF is waiting for the response to the credit request.
	SdfHandl  *bool                   `json:"sdfHandl,omitempty"`
	ServiceId *externalRef4.ServiceId `json:"serviceId,omitempty"`

	// Indicates the sponsor identity.
	SponsorId *string `json:"sponsorId,omitempty"`
}

// ConditionData defines model for ConditionData.
type ConditionData struct {
	ActivationTime *time.Time `json:"activationTime,omitempty"`

	// Uniquely identifies the condition data within a PDU session.
	CondId           string     `json:"condId"`
	DeactivationTime *time.Time `json:"deactivationTime,omitempty"`
}

// CreditManagementStatus defines model for CreditManagementStatus.
type CreditManagementStatus interface{}

// Defines the EPS RAN/NAS release cause.
type EpsRanNasRelCause string

// ErrorReport defines model for ErrorReport.
type ErrorReport struct {
	Error *externalRef4.ProblemDetails `json:"error,omitempty"`

	// Used to report the PCC rule failure.
	RuleReports *[]RuleReport `json:"ruleReports,omitempty"`

	// Used to report the session rule failure.
	SessRuleReports *[]SessionRuleReport `json:"sessRuleReports,omitempty"`
}

// FailureCause defines model for FailureCause.
type FailureCause string

// Possible values are
//   - UNK_RULE_ID: Indicates that the pre-provisioned PCC rule could not be successfully activated because the PCC rule identifier is unknown to the SMF.
//   - RA_GR_ERR: Indicate that the PCC rule could not be successfully installed or enforced because the Rating Group specified within the Charging Data policy decision which the PCC rule refers to is unknown or, invalid.
//   - SER_ID_ERR: Indicate that the PCC rule could not be successfully installed or enforced because the Service Identifier specified within the Charging Data policy decision which the PCC rule refers to is invalid, unknown, or not applicable to the service being charged.
//   - NF_MAL: Indicate that the PCC rule could not be successfully installed (for those provisioned from the PCF) or activated (for those pre-defined in SMF) or enforced (for those already successfully installed) due to SMF/UPF malfunction.
//   - RES_LIM: Indicate that the PCC rule could not be successfully installed (for those provisioned from PCF) or activated (for those pre-defined in SMF) or enforced (for those already successfully installed) due to a limitation of resources at the SMF/UPF.
//   - MAX_NR_QoS_FLOW: Indicate that the PCC rule could not be successfully installed (for those provisioned from PCF) or activated (for those pre-defined in SMF) or enforced (for those already successfully installed) due to the fact that the maximum number of QoS flows has been reached for the PDU session.
//   - MISS_FLOW_INFO: Indicate that the PCC rule could not be successfully installed or enforced because neither the "flowInfos" attribute nor the "appId" attribute is specified within the PccRule data structure by the PCF during the first install request of the PCC rule.
//   - RES_ALLO_FAIL: Indicate that the PCC rule could not be successfully installed or maintained since the QoS flow establishment/modification failed, or the QoS flow was released.
//   - UNSUCC_QOS_VAL: indicate that the QoS validation has failed or when Guaranteed Bandwidth > Max-Requested-Bandwidth.
//   - INCOR_FLOW_INFO: Indicate that the PCC rule could not be successfully installed or modified at the SMF because the provided flow information is not supported by the network (e.g. the provided IP address(es) or Ipv6 prefix(es) do not correspond to an IP version applicable for the PDU session).
//   - PS_TO_CS_HAN: Indicate that the PCC rule could not be maintained because of PS to CS handover.
//   - APP_ID_ERR: Indicate that the rule could not be successfully installed or enforced because the Application Identifier is invalid, unknown, or not applicable to the application required for detection.
//   - NO_QOS_FLOW_BOUND: Indicate that there is no QoS flow which the SMF can bind the PCC rule(s) to.
//   - FILTER_RES: Indicate that the Flow Information within the "flowInfos" attribute cannot be handled by the SMF because any of the restrictions defined in subclause 5.4.2 of 3GPP TS 29.212 was not met.
//   - MISS_REDI_SER_ADDR: Indicate that the PCC rule could not be successfully installed or enforced at the SMF because there is no valid Redirect Server Address within the Traffic Control Data policy decision which the PCC rule refers to provided by the PCF and no preconfigured redirection address for this PCC rule at the SMF.
//   - CM_END_USER_SER_DENIED: Indicate that the charging system denied the service request due to service restrictions (e.g. terminate rating group) or limitations related to the end-user, for example the end-user's account could not cover the requested service.
//   - CM_CREDIT_CON_NOT_APP: Indicate that the charging system determined that the service can be granted to the end user but no further credit control is needed for the service (e.g. service is free of charge or is treated for offline charging).
//   - CM_AUTH_REJ: Indicate that the charging system denied the service request in order to terminate the service for which credit is requested.
//   - CM_USER_UNK: Indicate that the specified end user could not be found in the charging system.
//   - CM_RAT_FAILED: Indicate that the charging system cannot rate the service request due to insufficient rating input, incorrect AVP combination or due to an attribute or an attribute value that is not recognized or supported in the rating.
//   - UE_STA_SUSP: Indicates that the UE is in suspend state.
type FailureCode string

// Defines a packet filter for an IP flow.
type FlowDescription string

// Possible values are - DOWNLINK: The corresponding filter applies for traffic to the UE. - UPLINK: The corresponding filter applies for traffic from the UE. - BIDIRECTIONAL: The corresponding filter applies for traffic both to and from the UE. - UNSPECIFIED: The corresponding filter applies for traffic to the UE (downlink), but has no specific direction declared. The service data flow detection shall apply the filter for uplink traffic as if the filter was bidirectional. The PCF shall not use the value UNSPECIFIED in filters created by the network in NW-initiated procedures. The PCF shall only include the value UNSPECIFIED in filters in UE-initiated procedures if the same value is received from the SMF.
type FlowDirectionRm interface{}

// FlowInformation defines model for FlowInformation.
type FlowInformation struct {
	// Identifies an Ethernet flow
	EthFlowDescription *externalRef2.EthFlowDescription `json:"ethFlowDescription,omitempty"`

	// Defines a packet filter for an IP flow.
	FlowDescription *FlowDescription `json:"flowDescription,omitempty"`

	// Possible values are - DOWNLINK: The corresponding filter applies for traffic to the UE. - UPLINK: The corresponding filter applies for traffic from the UE. - BIDIRECTIONAL: The corresponding filter applies for traffic both to and from the UE. - UNSPECIFIED: The corresponding filter applies for traffic to the UE (downlink), but has no specific direction declared. The service data flow detection shall apply the filter for uplink traffic as if the filter was bidirectional. The PCF shall not use the value UNSPECIFIED in filters created by the network in NW-initiated procedures. The PCF shall only include the value UNSPECIFIED in filters in UE-initiated procedures if the same value is received from the SMF.
	FlowDirection *FlowDirectionRm `json:"flowDirection"`

	// the Ipv6 flow label header field.
	FlowLabel *string `json:"flowLabel"`

	// An identifier of packet filter.
	PackFiltId *string `json:"packFiltId,omitempty"`

	// The packet shall be sent to the UE.
	PacketFilterUsage *bool `json:"packetFilterUsage,omitempty"`

	// the security parameter index of the IPSec packet.
	Spi *string `json:"spi"`

	// Contains the Ipv4 Type-of-Service and mask field or the Ipv6 Traffic-Class field and mask field.
	TosTrafficClass *string `json:"tosTrafficClass"`
}

// Possible values are - DURATION: Indicates that the duration of the service data flow traffic shall be metered. - VOLUME: Indicates that volume of the service data flow traffic shall be metered. - DURATION_VOLUME: Indicates that the duration and the volume of the service data flow traffic shall be metered. - EVENT: Indicates that events of the service data flow traffic shall be metered.
type MeteringMethod interface{}

// Possible values are - ANR_NOT_SUPPORTED: Indicates that the access network does not support the report of access network information. - TZR_NOT_SUPPORTED: Indicates that the access network does not support the report of UE time zone. - LOC_NOT_SUPPORTED: Indicates that the access network does not support the report of UE Location (or PLMN Id).
type NetLocAccessSupport interface{}

// Defines a packet filter for an IP flow.
type PacketFilterContent string

// PacketFilterInfo defines model for PacketFilterInfo.
type PacketFilterInfo struct {
	// Possible values are - DOWNLINK: The corresponding filter applies for traffic to the UE. - UPLINK: The corresponding filter applies for traffic from the UE. - BIDIRECTIONAL: The corresponding filter applies for traffic both to and from the UE. - UNSPECIFIED: The corresponding filter applies for traffic to the UE (downlink), but has no specific direction declared. The service data flow detection shall apply the filter for uplink traffic as if the filter was bidirectional. The PCF shall not use the value UNSPECIFIED in filters created by the network in NW-initiated procedures. The PCF shall only include the value UNSPECIFIED in filters in UE-initiated procedures if the same value is received from the SMF.
	FlowDirection *externalRef0.FlowDirection `json:"flowDirection,omitempty"`

	// The Ipv6 flow label header field.
	FlowLabel *string `json:"flowLabel,omitempty"`

	// Defines a packet filter for an IP flow.
	PackFiltCont *PacketFilterContent `json:"packFiltCont,omitempty"`

	// An identifier of packet filter.
	PackFiltId *string `json:"packFiltId,omitempty"`

	// The security parameter index of the IPSec packet.
	Spi *string `json:"spi,omitempty"`

	// Contains the Ipv4 Type-of-Service and mask field or the Ipv6 Traffic-Class field and mask field.
	TosTrafficClass *string `json:"tosTrafficClass,omitempty"`
}

// PartialSuccessReport defines model for PartialSuccessReport.
type PartialSuccessReport struct {
	FailureCause FailureCause `json:"failureCause"`

	// Information about the PCC rules provisioned by the PCF not successfully installed/activated.
	RuleReports *[]RuleReport `json:"ruleReports,omitempty"`

	// Information about the session rules provisioned by the PCF not successfully installed.
	SessRuleReports *[]SessionRuleReport `json:"sessRuleReports,omitempty"`
	UeCampingRep    *UeCampingRep        `json:"ueCampingRep,omitempty"`
}

// PccRule defines model for PccRule.
type PccRule struct {
	// Possible values are - NO_INFORMATION: Indicate that no information about the AF signalling protocol is being provided. - SIP: Indicate that the signalling protocol is Session Initiation Protocol.
	AfSigProtocol *AfSigProtocol `json:"afSigProtocol"`

	// A reference to the application detection filter configured at the UPF.
	AppId *string `json:"appId,omitempty"`

	// Indication of application relocation possibility.
	AppReloc *bool `json:"appReloc,omitempty"`

	// Represents the content version of some content.
	ContVer *externalRef2.ContentVersion `json:"contVer,omitempty"`

	// An array of IP flow packet filter information.
	FlowInfos *[]FlowInformation `json:"flowInfos,omitempty"`

	// Univocally identifies the PCC rule within a PDU session.
	PccRuleId  string                 `json:"pccRuleId"`
	Precedence *externalRef4.Uinteger `json:"precedence,omitempty"`

	// A reference to the ChargingData policy decision type. It is the chgId described in subclause 5.6.2.11.
	RefChgData *[]string `json:"refChgData"`

	// A reference to the condition data. It is the condId described in subclause 5.6.2.9.
	RefCondData *string `json:"refCondData"`

	// A reference to the QosData policy decision type. It is the qosId described in subclause 5.6.2.8.
	RefQosData *[]string `json:"refQosData,omitempty"`

	// A reference to the TrafficControlData policy decision type. It is the tcId described in subclause 5.6.2.10.
	RefTcData *[]string `json:"refTcData,omitempty"`

	// A reference to UsageMonitoringData policy decision type. It is the umId described in subclause 5.6.2.12.
	RefUmData *[]string `json:"refUmData"`
}

// Possible values are - PLMN_CH: PLMN Change - RES_MO_RE: A request for resource modification has been received by the SMF. The SMF always reports to the PCF. - AC_TY_CH: Access Type Change - UE_IP_CH: UE IP address change. The SMF always reports to the PCF. - UE_MAC_CH: A new UE MAC address is detected or a used UE MAC address is inactive for a specific period - AN_CH_COR: Access Network Charging Correlation Information - US_RE: The PDU Session or the Monitoring key specific resources consumed by a UE either reached the threshold or needs to be reported for other reasons. - APP_STA: The start of application traffic has been detected. - APP_STO: The stop of application traffic has been detected. - AN_INFO: Access Network Information report - CM_SES_FAIL: Credit management session failure - PS_DA_OFF: The SMF reports when the 3GPP PS Data Off status changes. The SMF always reports to the PCF. - DEF_QOS_CH: Default QoS Change. The SMF always reports to the PCF. - SE_AMBR_CH: Session AMBR Change. The SMF always reports to the PCF. - QOS_NOTIF: The SMF notify the PCF when receiving notification from RAN that QoS targets of the QoS Flow cannot be guranteed or gurateed again. - NO_CREDIT: Out of credit - PRA_CH: Change of UE presence in Presence Reporting Area - SAREA_CH: Location Change with respect to the Serving Area - SCNN_CH: Location Change with respect to the Serving CN node - RE_TIMEOUT: Indicates the SMF generated the request because there has been a PCC revalidation timeout - RES_RELEASE: Indicate that the SMF can inform the PCF of the outcome of the release of resources for those rules that require so. - SUCC_RES_ALLO: Indicates that the requested rule data is the successful resource allocation. - RAT_TY_CH: RAT Type Change. - REF_QOS_IND_CH: Reflective QoS indication Change - NUM_OF_PACKET_FILTER: Indicates that the SMF shall report the number of supported packet filter for signalled QoS rules - UE_STATUS_RESUME: Indicates that the UEâ€™s status is resumed. - UE_TZ_CH: UE Time Zone Change
type PolicyControlRequestTrigger string

// QosCharacteristics defines model for QosCharacteristics.
type QosCharacteristics struct {
	N5qi              externalRef4.N5Qi              `json:"5qi"`
	AveragingWindow   *externalRef4.AverWindow       `json:"averagingWindow,omitempty"`
	MaxDataBurstVol   *externalRef4.MaxDataBurstVol  `json:"maxDataBurstVol,omitempty"`
	PacketDelayBudget externalRef4.PacketDelBudget   `json:"packetDelayBudget"`
	PacketErrorRate   externalRef4.PacketErrRate     `json:"packetErrorRate"`
	PriorityLevel     externalRef4.N5QiPriorityLevel `json:"priorityLevel"`
	ResourceType      externalRef4.QosResourceType   `json:"resourceType"`
}

// QosData defines model for QosData.
type QosData struct {
	N5qi       *externalRef4.N5Qi         `json:"5qi,omitempty"`
	Arp        *externalRef4.Arp          `json:"arp,omitempty"`
	AverWindow *externalRef4.AverWindowRm `json:"averWindow"`

	// Indicates that the dynamic PCC rule shall always have its binding with the QoS Flow associated with the default QoS rule
	DefQosFlowIndication *bool                             `json:"defQosFlowIndication,omitempty"`
	GbrDl                *externalRef4.BitRateRm           `json:"gbrDl"`
	GbrUl                *externalRef4.BitRateRm           `json:"gbrUl"`
	MaxDataBurstVol      *externalRef4.MaxDataBurstVolRm   `json:"maxDataBurstVol"`
	MaxPacketLossRateDl  *externalRef4.PacketLossRateRm    `json:"maxPacketLossRateDl"`
	MaxPacketLossRateUl  *externalRef4.PacketLossRateRm    `json:"maxPacketLossRateUl"`
	MaxbrDl              *externalRef4.BitRateRm           `json:"maxbrDl"`
	MaxbrUl              *externalRef4.BitRateRm           `json:"maxbrUl"`
	PriorityLevel        *externalRef4.N5QiPriorityLevelRm `json:"priorityLevel"`

	// Indicates whether notifications are requested from 3GPP NG-RAN when the GFBR can no longer (or again) be guaranteed for a QoS Flow during the lifetime of the QoS Flow.
	Qnc *bool `json:"qnc,omitempty"`

	// Univocally identifies the QoS control policy data within a PDU session.
	QosId string `json:"qosId"`

	// Indicates whether the QoS information is reflective for the corresponding service data flow.
	ReflectiveQos *bool `json:"reflectiveQos,omitempty"`

	// Indicates, by containing the same value, what PCC rules may share resource in downlink direction.
	SharingKeyDl *string `json:"sharingKeyDl,omitempty"`

	// Indicates, by containing the same value, what PCC rules may share resource in uplink direction.
	SharingKeyUl *string `json:"sharingKeyUl,omitempty"`
}

// Possible values are - GENERAL: Indicate no specific QoS flow usage information is available. - IMS_SIG: Indicate that the QoS flow is used for IMS signalling only.
type QosFlowUsage string

// QosNotificationControlInfo defines model for QosNotificationControlInfo.
type QosNotificationControlInfo struct {
	// Represents the content version of some content.
	ContVer   *externalRef2.ContentVersion `json:"contVer,omitempty"`
	NotifType externalRef2.QosNotifType    `json:"notifType"`

	// An array of PCC rule id references to the PCC rules associated with the QoS notification control info.
	RefPccRuleIds []string `json:"refPccRuleIds"`
}

// RanNasRelCause defines model for RanNasRelCause.
type RanNasRelCause struct {
	N5gMmCause *externalRef4.N5GMmCause `json:"5gMmCause,omitempty"`
	N5gSmCause *N5GSmCause              `json:"5gSmCause,omitempty"`

	// Defines the EPS RAN/NAS release cause.
	EpsCause  *EpsRanNasRelCause      `json:"epsCause,omitempty"`
	NgApCause *externalRef4.NgApCause `json:"ngApCause,omitempty"`
}

// Possible values are - IPV4_ADDR: Indicates that the address type is in the form of "dotted-decimal" IPv4 address. - IPV6_ADDR: Indicates that the address type is in the form of IPv6 address. - URL: Indicates that the address type is in the form of Uniform Resource Locator. - SIP_URI: Indicates that the address type is in the form of SIP Uniform Resource Identifier.
type RedirectAddressType string

// RedirectInformation defines model for RedirectInformation.
type RedirectInformation struct {
	// Possible values are - IPV4_ADDR: Indicates that the address type is in the form of "dotted-decimal" IPv4 address. - IPV6_ADDR: Indicates that the address type is in the form of IPv6 address. - URL: Indicates that the address type is in the form of Uniform Resource Locator. - SIP_URI: Indicates that the address type is in the form of SIP Uniform Resource Identifier.
	RedirectAddressType *RedirectAddressType `json:"redirectAddressType,omitempty"`

	// Indicates the redirect is enable.
	RedirectEnabled *bool `json:"redirectEnabled,omitempty"`

	// Indicates the address of the redirect server. If "redirectAddressType" attribute indicates the IPV4_ADDR, the encoding is the same as the Ipv4Addr data type defined in 3GPP TS 29.571.If "redirectAddressType" attribute indicates the IPV6_ADDR, the encoding is the same as the Ipv6Addr data type defined in 3GPP TS 29.571.If "redirectAddressType" attribute indicates the URL or SIP_URI, the encoding is the same as the Uri data type defined in 3GPP TS 29.571.
	RedirectServerAddress *string `json:"redirectServerAddress,omitempty"`
}

// Possible values are - SER_ID_LEVEL: Indicates that the usage shall be reported on service id and rating group combination level. - RAT_GR_LEVEL: Indicates that the usage shall be reported on rating group level. - SPON_CON_LEVEL: Indicates that the usage shall be reported on sponsor identity and rating group combination level.
type ReportingLevel interface{}

// RequestedQos defines model for RequestedQos.
type RequestedQos struct {
	N5qi  externalRef4.N5Qi     `json:"5qi"`
	GbrDl *externalRef4.BitRate `json:"gbrDl,omitempty"`
	GbrUl *externalRef4.BitRate `json:"gbrUl,omitempty"`
}

// RequestedRuleData defines model for RequestedRuleData.
type RequestedRuleData struct {
	// An array of PCC rule id references to the PCC rules associated with the control data.
	RefPccRuleIds []string `json:"refPccRuleIds"`

	// Array of requested rule data type elements indicating what type of rule data is requested for the corresponding referenced PCC rules.
	ReqData []RequestedRuleDataType `json:"reqData"`
}

// Possible values are - CH_ID: Indicates that the requested rule data is the charging identifier. - MS_TIME_ZONE: Indicates that the requested access network info type is the UE's timezone. - USER_LOC_INFO: Indicates that the requested access network info type is the UE's location. - RES_RELEASE: Indicates that the requested rule data is the result of the release of resource. - SUCC_RES_ALLO: Indicates that the requested rule data is the successful resource allocation.
type RequestedRuleDataType interface{}

// RequestedUsageData defines model for RequestedUsageData.
type RequestedUsageData struct {
	// Thooleanean indicates whether requested usage data applies to all usage monitoring data instances. When it's not included, it means requested usage data shall only apply to the usage monitoring data instances referenced by the refUmIds attribute.
	AllUmIds *bool `json:"allUmIds,omitempty"`

	// An array of usage monitoring data id references to the usage monitoring data instances for which the PCF is requesting a usage report. This attribute shall only be provided when allUmIds is not set to true.
	RefUmIds *[]string `json:"refUmIds,omitempty"`
}

// Possible values are - CREATE_PCC_RULE: Indicates to create a new PCC rule to reserve the resource requested by the UE. - DELETE_PCC_RULE: Indicates to delete a PCC rule corresponding to reserve the resource requested by the UE.. - MODIFY_PCC_RULE_AND_ADD_PACKET_FILTERS: Indicates to modify the PCC rule by adding new packet filter(s). - MODIFY_ PCC_RULE_AND_REPLACE_PACKET_FILTERS: Indicates to modify the PCC rule by replacing the existing packet filter(s). - MODIFY_ PCC_RULE_AND_DELETE_PACKET_FILTERS: Indicates to modify the PCC rule by deleting the existing packet filter(s). - MODIFY_PCC_RULE_WITHOUT_MODIFY_PACKET_FILTERS: Indicates to modify the PCC rule by modifying the QoS of the PCC rule.
type RuleOperation string

// RuleReport defines model for RuleReport.
type RuleReport struct {
	// Indicates the version of a PCC rule.
	ContVers *[]externalRef2.ContentVersion `json:"contVers,omitempty"`

	// Possible values are
	//   - UNK_RULE_ID: Indicates that the pre-provisioned PCC rule could not be successfully activated because the PCC rule identifier is unknown to the SMF.
	//   - RA_GR_ERR: Indicate that the PCC rule could not be successfully installed or enforced because the Rating Group specified within the Charging Data policy decision which the PCC rule refers to is unknown or, invalid.
	//   - SER_ID_ERR: Indicate that the PCC rule could not be successfully installed or enforced because the Service Identifier specified within the Charging Data policy decision which the PCC rule refers to is invalid, unknown, or not applicable to the service being charged.
	//   - NF_MAL: Indicate that the PCC rule could not be successfully installed (for those provisioned from the PCF) or activated (for those pre-defined in SMF) or enforced (for those already successfully installed) due to SMF/UPF malfunction.
	//   - RES_LIM: Indicate that the PCC rule could not be successfully installed (for those provisioned from PCF) or activated (for those pre-defined in SMF) or enforced (for those already successfully installed) due to a limitation of resources at the SMF/UPF.
	//   - MAX_NR_QoS_FLOW: Indicate that the PCC rule could not be successfully installed (for those provisioned from PCF) or activated (for those pre-defined in SMF) or enforced (for those already successfully installed) due to the fact that the maximum number of QoS flows has been reached for the PDU session.
	//   - MISS_FLOW_INFO: Indicate that the PCC rule could not be successfully installed or enforced because neither the "flowInfos" attribute nor the "appId" attribute is specified within the PccRule data structure by the PCF during the first install request of the PCC rule.
	//   - RES_ALLO_FAIL: Indicate that the PCC rule could not be successfully installed or maintained since the QoS flow establishment/modification failed, or the QoS flow was released.
	//   - UNSUCC_QOS_VAL: indicate that the QoS validation has failed or when Guaranteed Bandwidth > Max-Requested-Bandwidth.
	//   - INCOR_FLOW_INFO: Indicate that the PCC rule could not be successfully installed or modified at the SMF because the provided flow information is not supported by the network (e.g. the provided IP address(es) or Ipv6 prefix(es) do not correspond to an IP version applicable for the PDU session).
	//   - PS_TO_CS_HAN: Indicate that the PCC rule could not be maintained because of PS to CS handover.
	//   - APP_ID_ERR: Indicate that the rule could not be successfully installed or enforced because the Application Identifier is invalid, unknown, or not applicable to the application required for detection.
	//   - NO_QOS_FLOW_BOUND: Indicate that there is no QoS flow which the SMF can bind the PCC rule(s) to.
	//   - FILTER_RES: Indicate that the Flow Information within the "flowInfos" attribute cannot be handled by the SMF because any of the restrictions defined in subclause 5.4.2 of 3GPP TS 29.212 was not met.
	//   - MISS_REDI_SER_ADDR: Indicate that the PCC rule could not be successfully installed or enforced at the SMF because there is no valid Redirect Server Address within the Traffic Control Data policy decision which the PCC rule refers to provided by the PCF and no preconfigured redirection address for this PCC rule at the SMF.
	//   - CM_END_USER_SER_DENIED: Indicate that the charging system denied the service request due to service restrictions (e.g. terminate rating group) or limitations related to the end-user, for example the end-user's account could not cover the requested service.
	//   - CM_CREDIT_CON_NOT_APP: Indicate that the charging system determined that the service can be granted to the end user but no further credit control is needed for the service (e.g. service is free of charge or is treated for offline charging).
	//   - CM_AUTH_REJ: Indicate that the charging system denied the service request in order to terminate the service for which credit is requested.
	//   - CM_USER_UNK: Indicate that the specified end user could not be found in the charging system.
	//   - CM_RAT_FAILED: Indicate that the charging system cannot rate the service request due to insufficient rating input, incorrect AVP combination or due to an attribute or an attribute value that is not recognized or supported in the rating.
	//   - UE_STA_SUSP: Indicates that the UE is in suspend state.
	FailureCode *FailureCode                  `json:"failureCode,omitempty"`
	FinUnitAct  *externalRef0.FinalUnitAction `json:"finUnitAct,omitempty"`

	// Contains the identifier of the affected PCC rule(s).
	PccRuleIds []string `json:"pccRuleIds"`

	// indicates the RAN or NAS release cause code information.
	RanNasRelCauses *[]RanNasRelCause `json:"ranNasRelCauses,omitempty"`

	// Possible values are - ACTIVE: Indicates that the PCC rule(s) are successfully installed (for those provisioned from PCF) or activated (for those pre-defined in SMF), or the session rule(s) are successfully installed - INACTIVE: Indicates that the PCC rule(s) are removed (for those provisioned from PCF) or inactive (for those pre-defined in SMF) or the session rule(s) are removed.
	RuleStatus RuleStatus `json:"ruleStatus"`
}

// Possible values are - ACTIVE: Indicates that the PCC rule(s) are successfully installed (for those provisioned from PCF) or activated (for those pre-defined in SMF), or the session rule(s) are successfully installed - INACTIVE: Indicates that the PCC rule(s) are removed (for those provisioned from PCF) or inactive (for those pre-defined in SMF) or the session rule(s) are removed.
type RuleStatus string

// ServingNfIdentity defines model for ServingNfIdentity.
type ServingNfIdentity struct {
	// describes the address of the access network gateway control node
	AnGwAddr     *externalRef2.AnGwAddress  `json:"anGwAddr,omitempty"`
	Guami        *externalRef4.Guami        `json:"guami,omitempty"`
	ServNfInstId *externalRef4.NfInstanceId `json:"servNfInstId,omitempty"`
}

// SessionRule defines model for SessionRule.
type SessionRule struct {
	AuthDefQos   *AuthorizedDefaultQos `json:"authDefQos,omitempty"`
	AuthSessAmbr *externalRef4.Ambr    `json:"authSessAmbr,omitempty"`

	// A reference to the condition data. It is the condId described in subclause 5.6.2.9.
	RefCondData *string `json:"refCondData"`

	// A reference to UsageMonitoringData policy decision type. It is the umId described in subclause 5.6.2.12.
	RefUmData *string `json:"refUmData"`

	// Univocally identifies the session rule within a PDU session.
	SessRuleId string `json:"sessRuleId"`
}

// Possible values are
//   - NF_MAL: Indicate that the PCC rule could not be successfully installed (for those provisioned from the PCF) or activated (for those pre-defined in SMF) or enforced (for those already successfully installed) due to SMF/UPF malfunction.
//   - RES_LIM: Indicate that the PCC rule could not be successfully installed (for those provisioned from PCF) or activated (for those pre-defined in SMF) or enforced (for those already successfully installed) due to a limitation of resources at the SMF/UPF.
//   - UNSUCC_QOS_VAL: indicate that the QoS validation has failed.
//   - UE_STA_SUSP: Indicates that the UE is in suspend state.
type SessionRuleFailureCode interface{}

// SessionRuleReport defines model for SessionRuleReport.
type SessionRuleReport struct {
	// Contains the identifier of the affected session rule(s).
	RuleIds []string `json:"ruleIds"`

	// Possible values are - ACTIVE: Indicates that the PCC rule(s) are successfully installed (for those provisioned from PCF) or activated (for those pre-defined in SMF), or the session rule(s) are successfully installed - INACTIVE: Indicates that the PCC rule(s) are removed (for those provisioned from PCF) or inactive (for those pre-defined in SMF) or the session rule(s) are removed.
	RuleStatus RuleStatus `json:"ruleStatus"`

	// Possible values are
	//   - NF_MAL: Indicate that the PCC rule could not be successfully installed (for those provisioned from the PCF) or activated (for those pre-defined in SMF) or enforced (for those already successfully installed) due to SMF/UPF malfunction.
	//   - RES_LIM: Indicate that the PCC rule could not be successfully installed (for those provisioned from PCF) or activated (for those pre-defined in SMF) or enforced (for those already successfully installed) due to a limitation of resources at the SMF/UPF.
	//   - UNSUCC_QOS_VAL: indicate that the QoS validation has failed.
	//   - UE_STA_SUSP: Indicates that the UE is in suspend state.
	SessRuleFailureCode *SessionRuleFailureCode `json:"sessRuleFailureCode,omitempty"`
}

// SmPolicyContextData defines model for SmPolicyContextData.
type SmPolicyContextData struct {
	// If it is included and set to true, the 3GPP PS Data Off is activated by the UE.
	N3gppPsDataOffStatus *bool                    `json:"3gppPsDataOffStatus,omitempty"`
	AccNetChId           *AccNetChId              `json:"accNetChId,omitempty"`
	AccessType           *externalRef4.AccessType `json:"accessType,omitempty"`

	// Describes the network entity within the access network performing charging
	ChargEntityAddr         *AccNetChargingAddress  `json:"chargEntityAddr,omitempty"`
	Chargingcharacteristics *string                 `json:"chargingcharacteristics,omitempty"`
	Dnn                     externalRef4.Dnn        `json:"dnn"`
	Gpsi                    *externalRef4.Gpsi      `json:"gpsi,omitempty"`
	InterGrpIds             *[]externalRef4.GroupId `json:"interGrpIds,omitempty"`

	// When this attribute is included and set to true, it indicates that the supi attribute contains an invalid value.This attribute shall be present if the SUPI is not available in the SMF or the SUPI is unauthenticated. When present it shall be set to true for an invalid SUPI and false (default) for a valid SUPI.
	InvalidSupi *bool `json:"invalidSupi,omitempty"`

	// Indicates the IPv4 address domain
	IpDomain          *string                  `json:"ipDomain,omitempty"`
	Ipv4Address       *externalRef4.Ipv4Addr   `json:"ipv4Address,omitempty"`
	Ipv6AddressPrefix *externalRef4.Ipv6Prefix `json:"ipv6AddressPrefix,omitempty"`
	NotificationUri   externalRef4.Uri         `json:"notificationUri"`

	// Contains the number of supported packet filter for signalled QoS rules.
	NumOfPackFilter *int `json:"numOfPackFilter,omitempty"`

	// If it is included and set to true, the offline charging is applied to the PDU session.
	Offline *bool `json:"offline,omitempty"`

	// If it is included and set to true, the online charging is applied to the PDU session.
	Online         *bool                       `json:"online,omitempty"`
	PduSessionId   externalRef4.PduSessionId   `json:"pduSessionId"`
	PduSessionType externalRef4.PduSessionType `json:"pduSessionType"`
	Pei            *externalRef4.Pei           `json:"pei,omitempty"`

	// Possible values are - GENERAL: Indicate no specific QoS flow usage information is available. - IMS_SIG: Indicate that the QoS flow is used for IMS signalling only.
	QosFlowUsage *QosFlowUsage          `json:"qosFlowUsage,omitempty"`
	RatType      *externalRef4.RatType  `json:"ratType,omitempty"`
	RecoveryTime *externalRef4.DateTime `json:"recoveryTime,omitempty"`

	// If it is included and set to true, the reflective QoS is supported by the UE.
	RefQosIndication *bool                              `json:"refQosIndication,omitempty"`
	ServNfId         *ServingNfIdentity                 `json:"servNfId,omitempty"`
	ServingNetwork   *externalRef4.NetworkId            `json:"servingNetwork,omitempty"`
	SliceInfo        externalRef4.Snssai                `json:"sliceInfo"`
	SmfId            *externalRef4.NfInstanceId         `json:"smfId,omitempty"`
	SubsDefQos       *externalRef4.SubscribedDefaultQos `json:"subsDefQos,omitempty"`
	SubsSessAmbr     *externalRef4.Ambr                 `json:"subsSessAmbr,omitempty"`
	Supi             externalRef4.Supi                  `json:"supi"`
	SuppFeat         *externalRef4.SupportedFeatures    `json:"suppFeat,omitempty"`
	TraceReq         *externalRef4.TraceData            `json:"traceReq"`
	UeTimeZone       *externalRef4.TimeZone             `json:"ueTimeZone,omitempty"`
	UserLocationInfo *externalRef4.UserLocation         `json:"userLocationInfo,omitempty"`
}

// SmPolicyControl defines model for SmPolicyControl.
type SmPolicyControl struct {
	Context SmPolicyContextData `json:"context"`
	Policy  SmPolicyDecision    `json:"policy"`
}

// SmPolicyDecision defines model for SmPolicyDecision.
type SmPolicyDecision struct {
	ChargingInfo *externalRef0.ChargingInformation `json:"chargingInfo,omitempty"`

	// Map of Charging data policy decisions.
	ChgDecs *SmPolicyDecision_ChgDecs `json:"chgDecs"`

	// A map of condition data with the content being as described in subclause 5.6.2.9.
	Conds     *SmPolicyDecision_Conds `json:"conds"`
	Ipv4Index *externalRef3.IpIndex   `json:"ipv4Index,omitempty"`
	Ipv6Index *externalRef3.IpIndex   `json:"ipv6Index,omitempty"`

	// Defines the last list of rule control data requested by the PCF.
	LastReqRuleData  *[]RequestedRuleData `json:"lastReqRuleData,omitempty"`
	LastReqUsageData *RequestedUsageData  `json:"lastReqUsageData,omitempty"`

	// Indicates the offline charging is applicable to the PDU session when it is included and set to true.
	Offline *bool `json:"offline,omitempty"`

	// Indicates the online charging is applicable to the PDU session or PCC rule when it is included and set to true.
	Online *bool `json:"online,omitempty"`

	// A map of PCC rules with the content being the PCCRule as described in subclause 5.6.2.6.
	PccRules *SmPolicyDecision_PccRules `json:"pccRules"`

	// If it is included and set to true, it indicates the P-CSCF Restoration is requested.
	PcscfRestIndication *bool `json:"pcscfRestIndication,omitempty"`

	// Defines the policy control request triggers subscribed by the PCF.
	PolicyCtrlReqTriggers *[]PolicyControlRequestTrigger `json:"policyCtrlReqTriggers"`

	// Map of PRA information.
	PraInfos *SmPolicyDecision_PraInfos `json:"praInfos"`

	// Map of QoS characteristics for non standard 5QIs. This map uses the 5QI values as keys.
	QosChars *SmPolicyDecision_QosChars `json:"qosChars,omitempty"`

	// Map of QoS data policy decisions.
	QosDecs *SmPolicyDecision_QosDecs `json:"qosDecs,omitempty"`

	// Possible values are - GENERAL: Indicate no specific QoS flow usage information is available. - IMS_SIG: Indicate that the QoS flow is used for IMS signalling only.
	QosFlowUsage       *QosFlowUsage             `json:"qosFlowUsage,omitempty"`
	ReflectiveQoSTimer *externalRef4.DurationSec `json:"reflectiveQoSTimer,omitempty"`
	RevalidationTime   *time.Time                `json:"revalidationTime,omitempty"`

	// A map of Sessionrules with the content being the SessionRule as described in subclause 5.6.2.7.
	SessRules *SmPolicyDecision_SessRules     `json:"sessRules,omitempty"`
	SuppFeat  *externalRef4.SupportedFeatures `json:"suppFeat,omitempty"`

	// Map of Traffic Control data policy decisions.
	TraffContDecs *SmPolicyDecision_TraffContDecs `json:"traffContDecs,omitempty"`

	// Map of Usage Monitoring data policy decisions.
	UmDecs *SmPolicyDecision_UmDecs `json:"umDecs"`
}

// Map of Charging data policy decisions.
type SmPolicyDecision_ChgDecs struct {
	AdditionalProperties map[string]ChargingData `json:"-"`
}

// A map of condition data with the content being as described in subclause 5.6.2.9.
type SmPolicyDecision_Conds struct {
	AdditionalProperties map[string]ConditionData `json:"-"`
}

// A map of PCC rules with the content being the PCCRule as described in subclause 5.6.2.6.
type SmPolicyDecision_PccRules struct {
	AdditionalProperties map[string]PccRule `json:"-"`
}

// Map of PRA information.
type SmPolicyDecision_PraInfos struct {
	AdditionalProperties map[string]externalRef4.PresenceInfoRm `json:"-"`
}

// Map of QoS characteristics for non standard 5QIs. This map uses the 5QI values as keys.
type SmPolicyDecision_QosChars struct {
	AdditionalProperties map[string]QosCharacteristics `json:"-"`
}

// Map of QoS data policy decisions.
type SmPolicyDecision_QosDecs struct {
	AdditionalProperties map[string]QosData `json:"-"`
}

// A map of Sessionrules with the content being the SessionRule as described in subclause 5.6.2.7.
type SmPolicyDecision_SessRules struct {
	AdditionalProperties map[string]SessionRule `json:"-"`
}

// Map of Traffic Control data policy decisions.
type SmPolicyDecision_TraffContDecs struct {
	AdditionalProperties map[string]TrafficControlData `json:"-"`
}

// Map of Usage Monitoring data policy decisions.
type SmPolicyDecision_UmDecs struct {
	AdditionalProperties map[string]UsageMonitoringData `json:"-"`
}

// SmPolicyDeleteData defines model for SmPolicyDeleteData.
type SmPolicyDeleteData struct {
	// Contains the usage report
	AccuUsageReports *[]AccuUsageReport `json:"accuUsageReports,omitempty"`

	// Contains the RAN and/or NAS release cause.
	RanNasRelCauses      *[]RanNasRelCause          `json:"ranNasRelCauses,omitempty"`
	ServingNetwork       *externalRef4.NetworkId    `json:"servingNetwork,omitempty"`
	UeTimeZone           *externalRef4.TimeZone     `json:"ueTimeZone,omitempty"`
	UserLocationInfo     *externalRef4.UserLocation `json:"userLocationInfo,omitempty"`
	UserLocationInfoTime *externalRef4.DateTime     `json:"userLocationInfoTime,omitempty"`
}

// SmPolicyNotification defines model for SmPolicyNotification.
type SmPolicyNotification struct {
	ResourceUri      *externalRef4.Uri `json:"resourceUri,omitempty"`
	SmPolicyDecision *SmPolicyDecision `json:"smPolicyDecision,omitempty"`
}

// SmPolicyUpdateContextData defines model for SmPolicyUpdateContextData.
type SmPolicyUpdateContextData struct {
	// If it is included and set to true, the 3GPP PS Data Off is activated by the UE.
	N3gppPsDataOffStatus *bool `json:"3gppPsDataOffStatus,omitempty"`

	// Indicates the access network charging identifier for the PCC rule(s) or whole PDU session.
	AccNetChIds *[]AccNetChId            `json:"accNetChIds,omitempty"`
	AccessType  *externalRef4.AccessType `json:"accessType,omitempty"`

	// Contains the usage report
	AccuUsageReports *[]AccuUsageReport `json:"accuUsageReports,omitempty"`

	// Report the start/stop of the application traffic and detected SDF descriptions if applicable.
	AppDetectionInfos  *[]AppDetectionInfo     `json:"appDetectionInfos,omitempty"`
	CreditManageStatus *CreditManagementStatus `json:"creditManageStatus,omitempty"`

	// Indicates the IPv4 address domain
	IpDomain          *string                  `json:"ipDomain,omitempty"`
	Ipv4Address       *externalRef4.Ipv4Addr   `json:"ipv4Address,omitempty"`
	Ipv6AddressPrefix *externalRef4.Ipv6Prefix `json:"ipv6AddressPrefix,omitempty"`

	// Contains the number of supported packet filter for signalled QoS rules.
	NumOfPackFilter *int `json:"numOfPackFilter,omitempty"`

	// QoS Notification Control information.
	QncReports *[]QosNotificationControlInfo `json:"qncReports,omitempty"`

	// Possible values are - GENERAL: Indicate no specific QoS flow usage information is available. - IMS_SIG: Indicate that the QoS flow is used for IMS signalling only.
	QosFlowUsage *QosFlowUsage         `json:"qosFlowUsage,omitempty"`
	RatType      *externalRef4.RatType `json:"ratType,omitempty"`

	// If it is included and set to true, the reflective QoS is supported by the UE. If it is included and set to false, the reflective QoS is revoked by the UE.
	RefQosIndication     *bool                    `json:"refQosIndication,omitempty"`
	RelIpv4Address       *externalRef4.Ipv4Addr   `json:"relIpv4Address,omitempty"`
	RelIpv6AddressPrefix *externalRef4.Ipv6Prefix `json:"relIpv6AddressPrefix,omitempty"`
	RelUeMac             *externalRef4.MacAddr48  `json:"relUeMac,omitempty"`

	// The policy control reqeust trigges which are met.
	RepPolicyCtrlReqTriggers *[]PolicyControlRequestTrigger `json:"repPolicyCtrlReqTriggers,omitempty"`

	// Reports the changes of presence reporting area.
	RepPraInfos *SmPolicyUpdateContextData_RepPraInfos `json:"repPraInfos,omitempty"`

	// Used to report the PCC rule failure.
	RuleReports    *[]RuleReport           `json:"ruleReports,omitempty"`
	ServNfId       *ServingNfIdentity      `json:"servNfId,omitempty"`
	ServingNetwork *externalRef4.NetworkId `json:"servingNetwork,omitempty"`

	// Used to report the session rule failure.
	SessRuleReports      *[]SessionRuleReport               `json:"sessRuleReports,omitempty"`
	SubsDefQos           *externalRef4.SubscribedDefaultQos `json:"subsDefQos,omitempty"`
	SubsSessAmbr         *externalRef4.Ambr                 `json:"subsSessAmbr,omitempty"`
	TraceReq             *externalRef4.TraceData            `json:"traceReq"`
	UeInitResReq         *UeInitiatedResourceRequest        `json:"ueInitResReq,omitempty"`
	UeMac                *externalRef4.MacAddr48            `json:"ueMac,omitempty"`
	UeTimeZone           *externalRef4.TimeZone             `json:"ueTimeZone,omitempty"`
	UserLocationInfo     *externalRef4.UserLocation         `json:"userLocationInfo,omitempty"`
	UserLocationInfoTime *externalRef4.DateTime             `json:"userLocationInfoTime,omitempty"`
}

// Reports the changes of presence reporting area.
type SmPolicyUpdateContextData_RepPraInfos struct {
	AdditionalProperties map[string]externalRef4.PresenceInfo `json:"-"`
}

// TerminationNotification defines model for TerminationNotification.
type TerminationNotification struct {
	// Possible values are - UNSPECIFIED: This value is used for unspecified reasons. - UE_SUBSCRIPTION: This value is used to indicate that the session needs to be terminated because the subscription of UE has changed (e.g. was removed). - INSUFFICIENT_RES: This value is used to indicate that the server is overloaded and needs to abort the session.
	Cause       externalRef1.PolicyAssociationReleaseCause `json:"cause"`
	ResourceUri externalRef4.Uri                           `json:"resourceUri"`
}

// TrafficControlData defines model for TrafficControlData.
type TrafficControlData struct {
	FlowStatus *externalRef2.FlowStatus `json:"flowStatus,omitempty"`

	// Indicates whether applicat'on's start or stop notification is to be muted.
	MuteNotif    *bool                `json:"muteNotif,omitempty"`
	RedirectInfo *RedirectInformation `json:"redirectInfo,omitempty"`

	// A list of location which the traffic shall be routed to for the AF request
	RouteToLocs *[]externalRef4.RouteToLocation `json:"routeToLocs,omitempty"`

	// Univocally identifies the traffic control policy data within a PDU session.
	TcId string `json:"tcId"`

	// Reference to a pre-configured traffic steering policy for downlink traffic at the SMF.
	TrafficSteeringPolIdDl *string `json:"trafficSteeringPolIdDl"`

	// Reference to a pre-configured traffic steering policy for uplink traffic at the SMF.
	TrafficSteeringPolIdUl *string                      `json:"trafficSteeringPolIdUl"`
	UpPathChgEvent         *externalRef0.UpPathChgEvent `json:"upPathChgEvent"`
}

// UeCampingRep defines model for UeCampingRep.
type UeCampingRep struct {
	AccessType *externalRef4.AccessType `json:"accessType,omitempty"`

	// Possible values are - ANR_NOT_SUPPORTED: Indicates that the access network does not support the report of access network information. - TZR_NOT_SUPPORTED: Indicates that the access network does not support the report of UE time zone. - LOC_NOT_SUPPORTED: Indicates that the access network does not support the report of UE Location (or PLMN Id).
	NetLocAccSupp    *NetLocAccessSupport       `json:"netLocAccSupp,omitempty"`
	RatType          *externalRef4.RatType      `json:"ratType,omitempty"`
	ServNfId         *ServingNfIdentity         `json:"servNfId,omitempty"`
	ServingNetwork   *externalRef4.NetworkId    `json:"servingNetwork,omitempty"`
	UeTimeZone       *externalRef4.TimeZone     `json:"ueTimeZone,omitempty"`
	UserLocationInfo *externalRef4.UserLocation `json:"userLocationInfo,omitempty"`
}

// UeInitiatedResourceRequest defines model for UeInitiatedResourceRequest.
type UeInitiatedResourceRequest struct {
	PackFiltInfo []PacketFilterInfo `json:"packFiltInfo"`
	PccRuleId    *string            `json:"pccRuleId,omitempty"`
	Precedence   *int               `json:"precedence,omitempty"`
	ReqQos       *RequestedQos      `json:"reqQos,omitempty"`

	// Possible values are - CREATE_PCC_RULE: Indicates to create a new PCC rule to reserve the resource requested by the UE. - DELETE_PCC_RULE: Indicates to delete a PCC rule corresponding to reserve the resource requested by the UE.. - MODIFY_PCC_RULE_AND_ADD_PACKET_FILTERS: Indicates to modify the PCC rule by adding new packet filter(s). - MODIFY_ PCC_RULE_AND_REPLACE_PACKET_FILTERS: Indicates to modify the PCC rule by replacing the existing packet filter(s). - MODIFY_ PCC_RULE_AND_DELETE_PACKET_FILTERS: Indicates to modify the PCC rule by deleting the existing packet filter(s). - MODIFY_PCC_RULE_WITHOUT_MODIFY_PACKET_FILTERS: Indicates to modify the PCC rule by modifying the QoS of the PCC rule.
	RuleOp RuleOperation `json:"ruleOp"`
}

// UsageMonitoringData defines model for UsageMonitoringData.
type UsageMonitoringData struct {
	// Contains the PCC rule identifier(s) which corresponding service data flow(s) shall be excluded from PDU Session usage monitoring. It is only included in the UsageMonitoringData instance for session level usage monitoring.
	ExUsagePccRuleIds *[]string                   `json:"exUsagePccRuleIds"`
	InactivityTime    *externalRef4.DurationSecRm `json:"inactivityTime"`
	MonitoringTime    *externalRef4.DateTimeRm    `json:"monitoringTime"`
	NextTimeThreshold *externalRef4.DurationSecRm `json:"nextTimeThreshold"`

	// Unsigned integer identifying a volume in units of bytes with "nullable=true" property.
	NextVolThreshold *externalRef0.VolumeRm `json:"nextVolThreshold"`

	// Unsigned integer identifying a volume in units of bytes with "nullable=true" property.
	NextVolThresholdDownlink *externalRef0.VolumeRm `json:"nextVolThresholdDownlink"`

	// Unsigned integer identifying a volume in units of bytes with "nullable=true" property.
	NextVolThresholdUplink *externalRef0.VolumeRm      `json:"nextVolThresholdUplink"`
	TimeThreshold          *externalRef4.DurationSecRm `json:"timeThreshold"`

	// Univocally identifies the usage monitoring policy data within a PDU session.
	UmId string `json:"umId"`

	// Unsigned integer identifying a volume in units of bytes with "nullable=true" property.
	VolumeThreshold *externalRef0.VolumeRm `json:"volumeThreshold"`

	// Unsigned integer identifying a volume in units of bytes with "nullable=true" property.
	VolumeThresholdDownlink *externalRef0.VolumeRm `json:"volumeThresholdDownlink"`

	// Unsigned integer identifying a volume in units of bytes with "nullable=true" property.
	VolumeThresholdUplink *externalRef0.VolumeRm `json:"volumeThresholdUplink"`
}

// PostSmPoliciesJSONBody defines parameters for PostSmPolicies.
type PostSmPoliciesJSONBody SmPolicyContextData

// PostSmPoliciesSmPolicyIdDeleteJSONBody defines parameters for PostSmPoliciesSmPolicyIdDelete.
type PostSmPoliciesSmPolicyIdDeleteJSONBody SmPolicyDeleteData

// PostSmPoliciesSmPolicyIdUpdateJSONBody defines parameters for PostSmPoliciesSmPolicyIdUpdate.
type PostSmPoliciesSmPolicyIdUpdateJSONBody SmPolicyUpdateContextData

// PostSmPoliciesJSONRequestBody defines body for PostSmPolicies for application/json ContentType.
type PostSmPoliciesJSONRequestBody PostSmPoliciesJSONBody

// PostSmPoliciesSmPolicyIdDeleteJSONRequestBody defines body for PostSmPoliciesSmPolicyIdDelete for application/json ContentType.
type PostSmPoliciesSmPolicyIdDeleteJSONRequestBody PostSmPoliciesSmPolicyIdDeleteJSONBody

// PostSmPoliciesSmPolicyIdUpdateJSONRequestBody defines body for PostSmPoliciesSmPolicyIdUpdate for application/json ContentType.
type PostSmPoliciesSmPolicyIdUpdateJSONRequestBody PostSmPoliciesSmPolicyIdUpdateJSONBody

// Getter for additional properties for SmPolicyDecision_ChgDecs. Returns the specified
// element and whether it was found
func (a SmPolicyDecision_ChgDecs) Get(fieldName string) (value ChargingData, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for SmPolicyDecision_ChgDecs
func (a *SmPolicyDecision_ChgDecs) Set(fieldName string, value ChargingData) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]ChargingData)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for SmPolicyDecision_ChgDecs to handle AdditionalProperties
func (a *SmPolicyDecision_ChgDecs) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]ChargingData)
		for fieldName, fieldBuf := range object {
			var fieldVal ChargingData
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for SmPolicyDecision_ChgDecs to handle AdditionalProperties
func (a SmPolicyDecision_ChgDecs) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for SmPolicyDecision_Conds. Returns the specified
// element and whether it was found
func (a SmPolicyDecision_Conds) Get(fieldName string) (value ConditionData, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for SmPolicyDecision_Conds
func (a *SmPolicyDecision_Conds) Set(fieldName string, value ConditionData) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]ConditionData)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for SmPolicyDecision_Conds to handle AdditionalProperties
func (a *SmPolicyDecision_Conds) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]ConditionData)
		for fieldName, fieldBuf := range object {
			var fieldVal ConditionData
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for SmPolicyDecision_Conds to handle AdditionalProperties
func (a SmPolicyDecision_Conds) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for SmPolicyDecision_PccRules. Returns the specified
// element and whether it was found
func (a SmPolicyDecision_PccRules) Get(fieldName string) (value PccRule, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for SmPolicyDecision_PccRules
func (a *SmPolicyDecision_PccRules) Set(fieldName string, value PccRule) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]PccRule)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for SmPolicyDecision_PccRules to handle AdditionalProperties
func (a *SmPolicyDecision_PccRules) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]PccRule)
		for fieldName, fieldBuf := range object {
			var fieldVal PccRule
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for SmPolicyDecision_PccRules to handle AdditionalProperties
func (a SmPolicyDecision_PccRules) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for SmPolicyDecision_PraInfos. Returns the specified
// element and whether it was found
func (a SmPolicyDecision_PraInfos) Get(fieldName string) (value externalRef4.PresenceInfoRm, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for SmPolicyDecision_PraInfos
func (a *SmPolicyDecision_PraInfos) Set(fieldName string, value externalRef4.PresenceInfoRm) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]externalRef4.PresenceInfoRm)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for SmPolicyDecision_PraInfos to handle AdditionalProperties
func (a *SmPolicyDecision_PraInfos) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]externalRef4.PresenceInfoRm)
		for fieldName, fieldBuf := range object {
			var fieldVal externalRef4.PresenceInfoRm
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for SmPolicyDecision_PraInfos to handle AdditionalProperties
func (a SmPolicyDecision_PraInfos) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for SmPolicyDecision_QosChars. Returns the specified
// element and whether it was found
func (a SmPolicyDecision_QosChars) Get(fieldName string) (value QosCharacteristics, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for SmPolicyDecision_QosChars
func (a *SmPolicyDecision_QosChars) Set(fieldName string, value QosCharacteristics) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]QosCharacteristics)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for SmPolicyDecision_QosChars to handle AdditionalProperties
func (a *SmPolicyDecision_QosChars) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]QosCharacteristics)
		for fieldName, fieldBuf := range object {
			var fieldVal QosCharacteristics
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for SmPolicyDecision_QosChars to handle AdditionalProperties
func (a SmPolicyDecision_QosChars) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for SmPolicyDecision_QosDecs. Returns the specified
// element and whether it was found
func (a SmPolicyDecision_QosDecs) Get(fieldName string) (value QosData, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for SmPolicyDecision_QosDecs
func (a *SmPolicyDecision_QosDecs) Set(fieldName string, value QosData) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]QosData)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for SmPolicyDecision_QosDecs to handle AdditionalProperties
func (a *SmPolicyDecision_QosDecs) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]QosData)
		for fieldName, fieldBuf := range object {
			var fieldVal QosData
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for SmPolicyDecision_QosDecs to handle AdditionalProperties
func (a SmPolicyDecision_QosDecs) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for SmPolicyDecision_SessRules. Returns the specified
// element and whether it was found
func (a SmPolicyDecision_SessRules) Get(fieldName string) (value SessionRule, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for SmPolicyDecision_SessRules
func (a *SmPolicyDecision_SessRules) Set(fieldName string, value SessionRule) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]SessionRule)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for SmPolicyDecision_SessRules to handle AdditionalProperties
func (a *SmPolicyDecision_SessRules) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]SessionRule)
		for fieldName, fieldBuf := range object {
			var fieldVal SessionRule
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for SmPolicyDecision_SessRules to handle AdditionalProperties
func (a SmPolicyDecision_SessRules) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for SmPolicyDecision_TraffContDecs. Returns the specified
// element and whether it was found
func (a SmPolicyDecision_TraffContDecs) Get(fieldName string) (value TrafficControlData, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for SmPolicyDecision_TraffContDecs
func (a *SmPolicyDecision_TraffContDecs) Set(fieldName string, value TrafficControlData) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]TrafficControlData)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for SmPolicyDecision_TraffContDecs to handle AdditionalProperties
func (a *SmPolicyDecision_TraffContDecs) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]TrafficControlData)
		for fieldName, fieldBuf := range object {
			var fieldVal TrafficControlData
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for SmPolicyDecision_TraffContDecs to handle AdditionalProperties
func (a SmPolicyDecision_TraffContDecs) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for SmPolicyDecision_UmDecs. Returns the specified
// element and whether it was found
func (a SmPolicyDecision_UmDecs) Get(fieldName string) (value UsageMonitoringData, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for SmPolicyDecision_UmDecs
func (a *SmPolicyDecision_UmDecs) Set(fieldName string, value UsageMonitoringData) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]UsageMonitoringData)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for SmPolicyDecision_UmDecs to handle AdditionalProperties
func (a *SmPolicyDecision_UmDecs) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]UsageMonitoringData)
		for fieldName, fieldBuf := range object {
			var fieldVal UsageMonitoringData
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for SmPolicyDecision_UmDecs to handle AdditionalProperties
func (a SmPolicyDecision_UmDecs) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for SmPolicyUpdateContextData_RepPraInfos. Returns the specified
// element and whether it was found
func (a SmPolicyUpdateContextData_RepPraInfos) Get(fieldName string) (value externalRef4.PresenceInfo, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for SmPolicyUpdateContextData_RepPraInfos
func (a *SmPolicyUpdateContextData_RepPraInfos) Set(fieldName string, value externalRef4.PresenceInfo) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]externalRef4.PresenceInfo)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for SmPolicyUpdateContextData_RepPraInfos to handle AdditionalProperties
func (a *SmPolicyUpdateContextData_RepPraInfos) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]externalRef4.PresenceInfo)
		for fieldName, fieldBuf := range object {
			var fieldVal externalRef4.PresenceInfo
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for SmPolicyUpdateContextData_RepPraInfos to handle AdditionalProperties
func (a SmPolicyUpdateContextData_RepPraInfos) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (POST /sm-policies)
	PostSmPolicies(ctx echo.Context) error

	// (GET /sm-policies/{smPolicyId})
	GetSmPoliciesSmPolicyId(ctx echo.Context, smPolicyId string) error

	// (POST /sm-policies/{smPolicyId}/delete)
	PostSmPoliciesSmPolicyIdDelete(ctx echo.Context, smPolicyId string) error

	// (POST /sm-policies/{smPolicyId}/update)
	PostSmPoliciesSmPolicyIdUpdate(ctx echo.Context, smPolicyId string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// PostSmPolicies converts echo context to params.
func (w *ServerInterfaceWrapper) PostSmPolicies(ctx echo.Context) error {
	var err error

	ctx.Set(OAuth2ClientcredentialsScopes, []string{"npcf-smpolicycontrol"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostSmPolicies(ctx)
	return err
}

// GetSmPoliciesSmPolicyId converts echo context to params.
func (w *ServerInterfaceWrapper) GetSmPoliciesSmPolicyId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "smPolicyId" -------------
	var smPolicyId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "smPolicyId", runtime.ParamLocationPath, ctx.Param("smPolicyId"), &smPolicyId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter smPolicyId: %s", err))
	}

	ctx.Set(OAuth2ClientcredentialsScopes, []string{"npcf-smpolicycontrol"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSmPoliciesSmPolicyId(ctx, smPolicyId)
	return err
}

// PostSmPoliciesSmPolicyIdDelete converts echo context to params.
func (w *ServerInterfaceWrapper) PostSmPoliciesSmPolicyIdDelete(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "smPolicyId" -------------
	var smPolicyId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "smPolicyId", runtime.ParamLocationPath, ctx.Param("smPolicyId"), &smPolicyId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter smPolicyId: %s", err))
	}

	ctx.Set(OAuth2ClientcredentialsScopes, []string{"npcf-smpolicycontrol"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostSmPoliciesSmPolicyIdDelete(ctx, smPolicyId)
	return err
}

// PostSmPoliciesSmPolicyIdUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) PostSmPoliciesSmPolicyIdUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "smPolicyId" -------------
	var smPolicyId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "smPolicyId", runtime.ParamLocationPath, ctx.Param("smPolicyId"), &smPolicyId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter smPolicyId: %s", err))
	}

	ctx.Set(OAuth2ClientcredentialsScopes, []string{"npcf-smpolicycontrol"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostSmPoliciesSmPolicyIdUpdate(ctx, smPolicyId)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.POST(baseURL+"/sm-policies", wrapper.PostSmPolicies)
	router.GET(baseURL+"/sm-policies/:smPolicyId", wrapper.GetSmPoliciesSmPolicyId)
	router.POST(baseURL+"/sm-policies/:smPolicyId/delete", wrapper.PostSmPoliciesSmPolicyIdDelete)
	router.POST(baseURL+"/sm-policies/:smPolicyId/update", wrapper.PostSmPoliciesSmPolicyIdUpdate)

}

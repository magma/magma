// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package protos

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	protos1 "magma/lte/cloud/go/protos"
	protos "magma/orc8r/lib/go/protos"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// MockCoreConfiguratorClient is the client API for MockCoreConfigurator service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type MockCoreConfiguratorClient interface {
	ConfigServer(ctx context.Context, in *ServerConfiguration, opts ...grpc.CallOption) (*protos.Void, error)
	Reset(ctx context.Context, in *protos.Void, opts ...grpc.CallOption) (*protos.Void, error)
}

type mockCoreConfiguratorClient struct {
	cc grpc.ClientConnInterface
}

func NewMockCoreConfiguratorClient(cc grpc.ClientConnInterface) MockCoreConfiguratorClient {
	return &mockCoreConfiguratorClient{cc}
}

func (c *mockCoreConfiguratorClient) ConfigServer(ctx context.Context, in *ServerConfiguration, opts ...grpc.CallOption) (*protos.Void, error) {
	out := new(protos.Void)
	err := c.cc.Invoke(ctx, "/magma.feg.MockCoreConfigurator/ConfigServer", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mockCoreConfiguratorClient) Reset(ctx context.Context, in *protos.Void, opts ...grpc.CallOption) (*protos.Void, error) {
	out := new(protos.Void)
	err := c.cc.Invoke(ctx, "/magma.feg.MockCoreConfigurator/Reset", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MockCoreConfiguratorServer is the server API for MockCoreConfigurator service.
// All implementations should embed UnimplementedMockCoreConfiguratorServer
// for forward compatibility
type MockCoreConfiguratorServer interface {
	ConfigServer(context.Context, *ServerConfiguration) (*protos.Void, error)
	Reset(context.Context, *protos.Void) (*protos.Void, error)
}

// UnimplementedMockCoreConfiguratorServer should be embedded to have forward compatible implementations.
type UnimplementedMockCoreConfiguratorServer struct {
}

func (UnimplementedMockCoreConfiguratorServer) ConfigServer(context.Context, *ServerConfiguration) (*protos.Void, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfigServer not implemented")
}
func (UnimplementedMockCoreConfiguratorServer) Reset(context.Context, *protos.Void) (*protos.Void, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Reset not implemented")
}

// UnsafeMockCoreConfiguratorServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MockCoreConfiguratorServer will
// result in compilation errors.
type UnsafeMockCoreConfiguratorServer interface {
	mustEmbedUnimplementedMockCoreConfiguratorServer()
}

func RegisterMockCoreConfiguratorServer(s grpc.ServiceRegistrar, srv MockCoreConfiguratorServer) {
	s.RegisterService(&MockCoreConfigurator_ServiceDesc, srv)
}

func _MockCoreConfigurator_ConfigServer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ServerConfiguration)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MockCoreConfiguratorServer).ConfigServer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.feg.MockCoreConfigurator/ConfigServer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MockCoreConfiguratorServer).ConfigServer(ctx, req.(*ServerConfiguration))
	}
	return interceptor(ctx, in, info, handler)
}

func _MockCoreConfigurator_Reset_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(protos.Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MockCoreConfiguratorServer).Reset(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.feg.MockCoreConfigurator/Reset",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MockCoreConfiguratorServer).Reset(ctx, req.(*protos.Void))
	}
	return interceptor(ctx, in, info, handler)
}

// MockCoreConfigurator_ServiceDesc is the grpc.ServiceDesc for MockCoreConfigurator service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var MockCoreConfigurator_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "magma.feg.MockCoreConfigurator",
	HandlerType: (*MockCoreConfiguratorServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ConfigServer",
			Handler:    _MockCoreConfigurator_ConfigServer_Handler,
		},
		{
			MethodName: "Reset",
			Handler:    _MockCoreConfigurator_Reset_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "feg/protos/mock_core.proto",
}

// MockOCSClient is the client API for MockOCS service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type MockOCSClient interface {
	SetOCSSettings(ctx context.Context, in *OCSConfig, opts ...grpc.CallOption) (*protos.Void, error)
	SetCredit(ctx context.Context, in *CreditInfo, opts ...grpc.CallOption) (*protos.Void, error)
	CreateAccount(ctx context.Context, in *protos1.SubscriberID, opts ...grpc.CallOption) (*protos.Void, error)
	ClearSubscribers(ctx context.Context, in *protos.Void, opts ...grpc.CallOption) (*protos.Void, error)
	ReAuth(ctx context.Context, in *ChargingReAuthTarget, opts ...grpc.CallOption) (*ChargingReAuthAnswer, error)
	GetCredits(ctx context.Context, in *protos1.SubscriberID, opts ...grpc.CallOption) (*CreditInfos, error)
	AbortSession(ctx context.Context, in *AbortSessionRequest, opts ...grpc.CallOption) (*AbortSessionAnswer, error)
	// Todo
	SetExpectations(ctx context.Context, in *GyCreditControlExpectations, opts ...grpc.CallOption) (*protos.Void, error)
	AssertExpectations(ctx context.Context, in *protos.Void, opts ...grpc.CallOption) (*GyCreditControlResult, error)
}

type mockOCSClient struct {
	cc grpc.ClientConnInterface
}

func NewMockOCSClient(cc grpc.ClientConnInterface) MockOCSClient {
	return &mockOCSClient{cc}
}

func (c *mockOCSClient) SetOCSSettings(ctx context.Context, in *OCSConfig, opts ...grpc.CallOption) (*protos.Void, error) {
	out := new(protos.Void)
	err := c.cc.Invoke(ctx, "/magma.feg.MockOCS/SetOCSSettings", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mockOCSClient) SetCredit(ctx context.Context, in *CreditInfo, opts ...grpc.CallOption) (*protos.Void, error) {
	out := new(protos.Void)
	err := c.cc.Invoke(ctx, "/magma.feg.MockOCS/SetCredit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mockOCSClient) CreateAccount(ctx context.Context, in *protos1.SubscriberID, opts ...grpc.CallOption) (*protos.Void, error) {
	out := new(protos.Void)
	err := c.cc.Invoke(ctx, "/magma.feg.MockOCS/CreateAccount", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mockOCSClient) ClearSubscribers(ctx context.Context, in *protos.Void, opts ...grpc.CallOption) (*protos.Void, error) {
	out := new(protos.Void)
	err := c.cc.Invoke(ctx, "/magma.feg.MockOCS/ClearSubscribers", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mockOCSClient) ReAuth(ctx context.Context, in *ChargingReAuthTarget, opts ...grpc.CallOption) (*ChargingReAuthAnswer, error) {
	out := new(ChargingReAuthAnswer)
	err := c.cc.Invoke(ctx, "/magma.feg.MockOCS/ReAuth", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mockOCSClient) GetCredits(ctx context.Context, in *protos1.SubscriberID, opts ...grpc.CallOption) (*CreditInfos, error) {
	out := new(CreditInfos)
	err := c.cc.Invoke(ctx, "/magma.feg.MockOCS/GetCredits", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mockOCSClient) AbortSession(ctx context.Context, in *AbortSessionRequest, opts ...grpc.CallOption) (*AbortSessionAnswer, error) {
	out := new(AbortSessionAnswer)
	err := c.cc.Invoke(ctx, "/magma.feg.MockOCS/AbortSession", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mockOCSClient) SetExpectations(ctx context.Context, in *GyCreditControlExpectations, opts ...grpc.CallOption) (*protos.Void, error) {
	out := new(protos.Void)
	err := c.cc.Invoke(ctx, "/magma.feg.MockOCS/SetExpectations", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mockOCSClient) AssertExpectations(ctx context.Context, in *protos.Void, opts ...grpc.CallOption) (*GyCreditControlResult, error) {
	out := new(GyCreditControlResult)
	err := c.cc.Invoke(ctx, "/magma.feg.MockOCS/AssertExpectations", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MockOCSServer is the server API for MockOCS service.
// All implementations should embed UnimplementedMockOCSServer
// for forward compatibility
type MockOCSServer interface {
	SetOCSSettings(context.Context, *OCSConfig) (*protos.Void, error)
	SetCredit(context.Context, *CreditInfo) (*protos.Void, error)
	CreateAccount(context.Context, *protos1.SubscriberID) (*protos.Void, error)
	ClearSubscribers(context.Context, *protos.Void) (*protos.Void, error)
	ReAuth(context.Context, *ChargingReAuthTarget) (*ChargingReAuthAnswer, error)
	GetCredits(context.Context, *protos1.SubscriberID) (*CreditInfos, error)
	AbortSession(context.Context, *AbortSessionRequest) (*AbortSessionAnswer, error)
	// Todo
	SetExpectations(context.Context, *GyCreditControlExpectations) (*protos.Void, error)
	AssertExpectations(context.Context, *protos.Void) (*GyCreditControlResult, error)
}

// UnimplementedMockOCSServer should be embedded to have forward compatible implementations.
type UnimplementedMockOCSServer struct {
}

func (UnimplementedMockOCSServer) SetOCSSettings(context.Context, *OCSConfig) (*protos.Void, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetOCSSettings not implemented")
}
func (UnimplementedMockOCSServer) SetCredit(context.Context, *CreditInfo) (*protos.Void, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetCredit not implemented")
}
func (UnimplementedMockOCSServer) CreateAccount(context.Context, *protos1.SubscriberID) (*protos.Void, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateAccount not implemented")
}
func (UnimplementedMockOCSServer) ClearSubscribers(context.Context, *protos.Void) (*protos.Void, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ClearSubscribers not implemented")
}
func (UnimplementedMockOCSServer) ReAuth(context.Context, *ChargingReAuthTarget) (*ChargingReAuthAnswer, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReAuth not implemented")
}
func (UnimplementedMockOCSServer) GetCredits(context.Context, *protos1.SubscriberID) (*CreditInfos, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCredits not implemented")
}
func (UnimplementedMockOCSServer) AbortSession(context.Context, *AbortSessionRequest) (*AbortSessionAnswer, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AbortSession not implemented")
}
func (UnimplementedMockOCSServer) SetExpectations(context.Context, *GyCreditControlExpectations) (*protos.Void, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetExpectations not implemented")
}
func (UnimplementedMockOCSServer) AssertExpectations(context.Context, *protos.Void) (*GyCreditControlResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AssertExpectations not implemented")
}

// UnsafeMockOCSServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MockOCSServer will
// result in compilation errors.
type UnsafeMockOCSServer interface {
	mustEmbedUnimplementedMockOCSServer()
}

func RegisterMockOCSServer(s grpc.ServiceRegistrar, srv MockOCSServer) {
	s.RegisterService(&MockOCS_ServiceDesc, srv)
}

func _MockOCS_SetOCSSettings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OCSConfig)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MockOCSServer).SetOCSSettings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.feg.MockOCS/SetOCSSettings",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MockOCSServer).SetOCSSettings(ctx, req.(*OCSConfig))
	}
	return interceptor(ctx, in, info, handler)
}

func _MockOCS_SetCredit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreditInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MockOCSServer).SetCredit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.feg.MockOCS/SetCredit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MockOCSServer).SetCredit(ctx, req.(*CreditInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _MockOCS_CreateAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(protos1.SubscriberID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MockOCSServer).CreateAccount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.feg.MockOCS/CreateAccount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MockOCSServer).CreateAccount(ctx, req.(*protos1.SubscriberID))
	}
	return interceptor(ctx, in, info, handler)
}

func _MockOCS_ClearSubscribers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(protos.Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MockOCSServer).ClearSubscribers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.feg.MockOCS/ClearSubscribers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MockOCSServer).ClearSubscribers(ctx, req.(*protos.Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _MockOCS_ReAuth_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChargingReAuthTarget)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MockOCSServer).ReAuth(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.feg.MockOCS/ReAuth",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MockOCSServer).ReAuth(ctx, req.(*ChargingReAuthTarget))
	}
	return interceptor(ctx, in, info, handler)
}

func _MockOCS_GetCredits_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(protos1.SubscriberID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MockOCSServer).GetCredits(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.feg.MockOCS/GetCredits",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MockOCSServer).GetCredits(ctx, req.(*protos1.SubscriberID))
	}
	return interceptor(ctx, in, info, handler)
}

func _MockOCS_AbortSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AbortSessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MockOCSServer).AbortSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.feg.MockOCS/AbortSession",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MockOCSServer).AbortSession(ctx, req.(*AbortSessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MockOCS_SetExpectations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GyCreditControlExpectations)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MockOCSServer).SetExpectations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.feg.MockOCS/SetExpectations",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MockOCSServer).SetExpectations(ctx, req.(*GyCreditControlExpectations))
	}
	return interceptor(ctx, in, info, handler)
}

func _MockOCS_AssertExpectations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(protos.Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MockOCSServer).AssertExpectations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.feg.MockOCS/AssertExpectations",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MockOCSServer).AssertExpectations(ctx, req.(*protos.Void))
	}
	return interceptor(ctx, in, info, handler)
}

// MockOCS_ServiceDesc is the grpc.ServiceDesc for MockOCS service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var MockOCS_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "magma.feg.MockOCS",
	HandlerType: (*MockOCSServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SetOCSSettings",
			Handler:    _MockOCS_SetOCSSettings_Handler,
		},
		{
			MethodName: "SetCredit",
			Handler:    _MockOCS_SetCredit_Handler,
		},
		{
			MethodName: "CreateAccount",
			Handler:    _MockOCS_CreateAccount_Handler,
		},
		{
			MethodName: "ClearSubscribers",
			Handler:    _MockOCS_ClearSubscribers_Handler,
		},
		{
			MethodName: "ReAuth",
			Handler:    _MockOCS_ReAuth_Handler,
		},
		{
			MethodName: "GetCredits",
			Handler:    _MockOCS_GetCredits_Handler,
		},
		{
			MethodName: "AbortSession",
			Handler:    _MockOCS_AbortSession_Handler,
		},
		{
			MethodName: "SetExpectations",
			Handler:    _MockOCS_SetExpectations_Handler,
		},
		{
			MethodName: "AssertExpectations",
			Handler:    _MockOCS_AssertExpectations_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "feg/protos/mock_core.proto",
}

// MockPCRFClient is the client API for MockPCRF service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type MockPCRFClient interface {
	SetPCRFConfigs(ctx context.Context, in *PCRFConfigs, opts ...grpc.CallOption) (*protos.Void, error)
	CreateAccount(ctx context.Context, in *protos1.SubscriberID, opts ...grpc.CallOption) (*protos.Void, error)
	SetRules(ctx context.Context, in *AccountRules, opts ...grpc.CallOption) (*protos.Void, error)
	SetUsageMonitors(ctx context.Context, in *UsageMonitorConfiguration, opts ...grpc.CallOption) (*protos.Void, error)
	ClearSubscribers(ctx context.Context, in *protos.Void, opts ...grpc.CallOption) (*protos.Void, error)
	ReAuth(ctx context.Context, in *PolicyReAuthTarget, opts ...grpc.CallOption) (*PolicyReAuthAnswer, error)
	AbortSession(ctx context.Context, in *AbortSessionRequest, opts ...grpc.CallOption) (*AbortSessionAnswer, error)
	SetExpectations(ctx context.Context, in *GxCreditControlExpectations, opts ...grpc.CallOption) (*protos.Void, error)
	AssertExpectations(ctx context.Context, in *protos.Void, opts ...grpc.CallOption) (*GxCreditControlResult, error)
}

type mockPCRFClient struct {
	cc grpc.ClientConnInterface
}

func NewMockPCRFClient(cc grpc.ClientConnInterface) MockPCRFClient {
	return &mockPCRFClient{cc}
}

func (c *mockPCRFClient) SetPCRFConfigs(ctx context.Context, in *PCRFConfigs, opts ...grpc.CallOption) (*protos.Void, error) {
	out := new(protos.Void)
	err := c.cc.Invoke(ctx, "/magma.feg.MockPCRF/SetPCRFConfigs", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mockPCRFClient) CreateAccount(ctx context.Context, in *protos1.SubscriberID, opts ...grpc.CallOption) (*protos.Void, error) {
	out := new(protos.Void)
	err := c.cc.Invoke(ctx, "/magma.feg.MockPCRF/CreateAccount", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mockPCRFClient) SetRules(ctx context.Context, in *AccountRules, opts ...grpc.CallOption) (*protos.Void, error) {
	out := new(protos.Void)
	err := c.cc.Invoke(ctx, "/magma.feg.MockPCRF/SetRules", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mockPCRFClient) SetUsageMonitors(ctx context.Context, in *UsageMonitorConfiguration, opts ...grpc.CallOption) (*protos.Void, error) {
	out := new(protos.Void)
	err := c.cc.Invoke(ctx, "/magma.feg.MockPCRF/SetUsageMonitors", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mockPCRFClient) ClearSubscribers(ctx context.Context, in *protos.Void, opts ...grpc.CallOption) (*protos.Void, error) {
	out := new(protos.Void)
	err := c.cc.Invoke(ctx, "/magma.feg.MockPCRF/ClearSubscribers", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mockPCRFClient) ReAuth(ctx context.Context, in *PolicyReAuthTarget, opts ...grpc.CallOption) (*PolicyReAuthAnswer, error) {
	out := new(PolicyReAuthAnswer)
	err := c.cc.Invoke(ctx, "/magma.feg.MockPCRF/ReAuth", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mockPCRFClient) AbortSession(ctx context.Context, in *AbortSessionRequest, opts ...grpc.CallOption) (*AbortSessionAnswer, error) {
	out := new(AbortSessionAnswer)
	err := c.cc.Invoke(ctx, "/magma.feg.MockPCRF/AbortSession", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mockPCRFClient) SetExpectations(ctx context.Context, in *GxCreditControlExpectations, opts ...grpc.CallOption) (*protos.Void, error) {
	out := new(protos.Void)
	err := c.cc.Invoke(ctx, "/magma.feg.MockPCRF/SetExpectations", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mockPCRFClient) AssertExpectations(ctx context.Context, in *protos.Void, opts ...grpc.CallOption) (*GxCreditControlResult, error) {
	out := new(GxCreditControlResult)
	err := c.cc.Invoke(ctx, "/magma.feg.MockPCRF/AssertExpectations", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MockPCRFServer is the server API for MockPCRF service.
// All implementations should embed UnimplementedMockPCRFServer
// for forward compatibility
type MockPCRFServer interface {
	SetPCRFConfigs(context.Context, *PCRFConfigs) (*protos.Void, error)
	CreateAccount(context.Context, *protos1.SubscriberID) (*protos.Void, error)
	SetRules(context.Context, *AccountRules) (*protos.Void, error)
	SetUsageMonitors(context.Context, *UsageMonitorConfiguration) (*protos.Void, error)
	ClearSubscribers(context.Context, *protos.Void) (*protos.Void, error)
	ReAuth(context.Context, *PolicyReAuthTarget) (*PolicyReAuthAnswer, error)
	AbortSession(context.Context, *AbortSessionRequest) (*AbortSessionAnswer, error)
	SetExpectations(context.Context, *GxCreditControlExpectations) (*protos.Void, error)
	AssertExpectations(context.Context, *protos.Void) (*GxCreditControlResult, error)
}

// UnimplementedMockPCRFServer should be embedded to have forward compatible implementations.
type UnimplementedMockPCRFServer struct {
}

func (UnimplementedMockPCRFServer) SetPCRFConfigs(context.Context, *PCRFConfigs) (*protos.Void, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetPCRFConfigs not implemented")
}
func (UnimplementedMockPCRFServer) CreateAccount(context.Context, *protos1.SubscriberID) (*protos.Void, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateAccount not implemented")
}
func (UnimplementedMockPCRFServer) SetRules(context.Context, *AccountRules) (*protos.Void, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetRules not implemented")
}
func (UnimplementedMockPCRFServer) SetUsageMonitors(context.Context, *UsageMonitorConfiguration) (*protos.Void, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetUsageMonitors not implemented")
}
func (UnimplementedMockPCRFServer) ClearSubscribers(context.Context, *protos.Void) (*protos.Void, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ClearSubscribers not implemented")
}
func (UnimplementedMockPCRFServer) ReAuth(context.Context, *PolicyReAuthTarget) (*PolicyReAuthAnswer, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReAuth not implemented")
}
func (UnimplementedMockPCRFServer) AbortSession(context.Context, *AbortSessionRequest) (*AbortSessionAnswer, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AbortSession not implemented")
}
func (UnimplementedMockPCRFServer) SetExpectations(context.Context, *GxCreditControlExpectations) (*protos.Void, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetExpectations not implemented")
}
func (UnimplementedMockPCRFServer) AssertExpectations(context.Context, *protos.Void) (*GxCreditControlResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AssertExpectations not implemented")
}

// UnsafeMockPCRFServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MockPCRFServer will
// result in compilation errors.
type UnsafeMockPCRFServer interface {
	mustEmbedUnimplementedMockPCRFServer()
}

func RegisterMockPCRFServer(s grpc.ServiceRegistrar, srv MockPCRFServer) {
	s.RegisterService(&MockPCRF_ServiceDesc, srv)
}

func _MockPCRF_SetPCRFConfigs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PCRFConfigs)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MockPCRFServer).SetPCRFConfigs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.feg.MockPCRF/SetPCRFConfigs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MockPCRFServer).SetPCRFConfigs(ctx, req.(*PCRFConfigs))
	}
	return interceptor(ctx, in, info, handler)
}

func _MockPCRF_CreateAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(protos1.SubscriberID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MockPCRFServer).CreateAccount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.feg.MockPCRF/CreateAccount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MockPCRFServer).CreateAccount(ctx, req.(*protos1.SubscriberID))
	}
	return interceptor(ctx, in, info, handler)
}

func _MockPCRF_SetRules_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AccountRules)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MockPCRFServer).SetRules(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.feg.MockPCRF/SetRules",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MockPCRFServer).SetRules(ctx, req.(*AccountRules))
	}
	return interceptor(ctx, in, info, handler)
}

func _MockPCRF_SetUsageMonitors_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UsageMonitorConfiguration)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MockPCRFServer).SetUsageMonitors(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.feg.MockPCRF/SetUsageMonitors",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MockPCRFServer).SetUsageMonitors(ctx, req.(*UsageMonitorConfiguration))
	}
	return interceptor(ctx, in, info, handler)
}

func _MockPCRF_ClearSubscribers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(protos.Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MockPCRFServer).ClearSubscribers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.feg.MockPCRF/ClearSubscribers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MockPCRFServer).ClearSubscribers(ctx, req.(*protos.Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _MockPCRF_ReAuth_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PolicyReAuthTarget)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MockPCRFServer).ReAuth(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.feg.MockPCRF/ReAuth",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MockPCRFServer).ReAuth(ctx, req.(*PolicyReAuthTarget))
	}
	return interceptor(ctx, in, info, handler)
}

func _MockPCRF_AbortSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AbortSessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MockPCRFServer).AbortSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.feg.MockPCRF/AbortSession",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MockPCRFServer).AbortSession(ctx, req.(*AbortSessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MockPCRF_SetExpectations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GxCreditControlExpectations)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MockPCRFServer).SetExpectations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.feg.MockPCRF/SetExpectations",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MockPCRFServer).SetExpectations(ctx, req.(*GxCreditControlExpectations))
	}
	return interceptor(ctx, in, info, handler)
}

func _MockPCRF_AssertExpectations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(protos.Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MockPCRFServer).AssertExpectations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.feg.MockPCRF/AssertExpectations",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MockPCRFServer).AssertExpectations(ctx, req.(*protos.Void))
	}
	return interceptor(ctx, in, info, handler)
}

// MockPCRF_ServiceDesc is the grpc.ServiceDesc for MockPCRF service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var MockPCRF_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "magma.feg.MockPCRF",
	HandlerType: (*MockPCRFServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SetPCRFConfigs",
			Handler:    _MockPCRF_SetPCRFConfigs_Handler,
		},
		{
			MethodName: "CreateAccount",
			Handler:    _MockPCRF_CreateAccount_Handler,
		},
		{
			MethodName: "SetRules",
			Handler:    _MockPCRF_SetRules_Handler,
		},
		{
			MethodName: "SetUsageMonitors",
			Handler:    _MockPCRF_SetUsageMonitors_Handler,
		},
		{
			MethodName: "ClearSubscribers",
			Handler:    _MockPCRF_ClearSubscribers_Handler,
		},
		{
			MethodName: "ReAuth",
			Handler:    _MockPCRF_ReAuth_Handler,
		},
		{
			MethodName: "AbortSession",
			Handler:    _MockPCRF_AbortSession_Handler,
		},
		{
			MethodName: "SetExpectations",
			Handler:    _MockPCRF_SetExpectations_Handler,
		},
		{
			MethodName: "AssertExpectations",
			Handler:    _MockPCRF_AssertExpectations_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "feg/protos/mock_core.proto",
}

// MockPCFClient is the client API for MockPCF service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type MockPCFClient interface {
	SetPCFConfigs(ctx context.Context, in *PCFConfigs, opts ...grpc.CallOption) (*protos.Void, error)
	CreateAccount(ctx context.Context, in *protos1.SubscriberID, opts ...grpc.CallOption) (*protos.Void, error)
	SetAccountRules(ctx context.Context, in *PolicyDecision, opts ...grpc.CallOption) (*protos.Void, error)
	ClearSubscribers(ctx context.Context, in *protos.Void, opts ...grpc.CallOption) (*protos.Void, error)
	SmPolicyUpdateNotify(ctx context.Context, in *PolicyDecision, opts ...grpc.CallOption) (*UpdateNotificationAnswer, error)
	SmPolicyTerminate(ctx context.Context, in *TerminateNotification, opts ...grpc.CallOption) (*TerminateNotificationAnswer, error)
	SetExpectations(ctx context.Context, in *N7Expectations, opts ...grpc.CallOption) (*protos.Void, error)
	AssertExpectations(ctx context.Context, in *protos.Void, opts ...grpc.CallOption) (*N7ExpectationResult, error)
}

type mockPCFClient struct {
	cc grpc.ClientConnInterface
}

func NewMockPCFClient(cc grpc.ClientConnInterface) MockPCFClient {
	return &mockPCFClient{cc}
}

func (c *mockPCFClient) SetPCFConfigs(ctx context.Context, in *PCFConfigs, opts ...grpc.CallOption) (*protos.Void, error) {
	out := new(protos.Void)
	err := c.cc.Invoke(ctx, "/magma.feg.MockPCF/SetPCFConfigs", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mockPCFClient) CreateAccount(ctx context.Context, in *protos1.SubscriberID, opts ...grpc.CallOption) (*protos.Void, error) {
	out := new(protos.Void)
	err := c.cc.Invoke(ctx, "/magma.feg.MockPCF/CreateAccount", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mockPCFClient) SetAccountRules(ctx context.Context, in *PolicyDecision, opts ...grpc.CallOption) (*protos.Void, error) {
	out := new(protos.Void)
	err := c.cc.Invoke(ctx, "/magma.feg.MockPCF/SetAccountRules", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mockPCFClient) ClearSubscribers(ctx context.Context, in *protos.Void, opts ...grpc.CallOption) (*protos.Void, error) {
	out := new(protos.Void)
	err := c.cc.Invoke(ctx, "/magma.feg.MockPCF/ClearSubscribers", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mockPCFClient) SmPolicyUpdateNotify(ctx context.Context, in *PolicyDecision, opts ...grpc.CallOption) (*UpdateNotificationAnswer, error) {
	out := new(UpdateNotificationAnswer)
	err := c.cc.Invoke(ctx, "/magma.feg.MockPCF/SmPolicyUpdateNotify", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mockPCFClient) SmPolicyTerminate(ctx context.Context, in *TerminateNotification, opts ...grpc.CallOption) (*TerminateNotificationAnswer, error) {
	out := new(TerminateNotificationAnswer)
	err := c.cc.Invoke(ctx, "/magma.feg.MockPCF/SmPolicyTerminate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mockPCFClient) SetExpectations(ctx context.Context, in *N7Expectations, opts ...grpc.CallOption) (*protos.Void, error) {
	out := new(protos.Void)
	err := c.cc.Invoke(ctx, "/magma.feg.MockPCF/SetExpectations", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mockPCFClient) AssertExpectations(ctx context.Context, in *protos.Void, opts ...grpc.CallOption) (*N7ExpectationResult, error) {
	out := new(N7ExpectationResult)
	err := c.cc.Invoke(ctx, "/magma.feg.MockPCF/AssertExpectations", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MockPCFServer is the server API for MockPCF service.
// All implementations should embed UnimplementedMockPCFServer
// for forward compatibility
type MockPCFServer interface {
	SetPCFConfigs(context.Context, *PCFConfigs) (*protos.Void, error)
	CreateAccount(context.Context, *protos1.SubscriberID) (*protos.Void, error)
	SetAccountRules(context.Context, *PolicyDecision) (*protos.Void, error)
	ClearSubscribers(context.Context, *protos.Void) (*protos.Void, error)
	SmPolicyUpdateNotify(context.Context, *PolicyDecision) (*UpdateNotificationAnswer, error)
	SmPolicyTerminate(context.Context, *TerminateNotification) (*TerminateNotificationAnswer, error)
	SetExpectations(context.Context, *N7Expectations) (*protos.Void, error)
	AssertExpectations(context.Context, *protos.Void) (*N7ExpectationResult, error)
}

// UnimplementedMockPCFServer should be embedded to have forward compatible implementations.
type UnimplementedMockPCFServer struct {
}

func (UnimplementedMockPCFServer) SetPCFConfigs(context.Context, *PCFConfigs) (*protos.Void, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetPCFConfigs not implemented")
}
func (UnimplementedMockPCFServer) CreateAccount(context.Context, *protos1.SubscriberID) (*protos.Void, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateAccount not implemented")
}
func (UnimplementedMockPCFServer) SetAccountRules(context.Context, *PolicyDecision) (*protos.Void, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetAccountRules not implemented")
}
func (UnimplementedMockPCFServer) ClearSubscribers(context.Context, *protos.Void) (*protos.Void, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ClearSubscribers not implemented")
}
func (UnimplementedMockPCFServer) SmPolicyUpdateNotify(context.Context, *PolicyDecision) (*UpdateNotificationAnswer, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SmPolicyUpdateNotify not implemented")
}
func (UnimplementedMockPCFServer) SmPolicyTerminate(context.Context, *TerminateNotification) (*TerminateNotificationAnswer, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SmPolicyTerminate not implemented")
}
func (UnimplementedMockPCFServer) SetExpectations(context.Context, *N7Expectations) (*protos.Void, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetExpectations not implemented")
}
func (UnimplementedMockPCFServer) AssertExpectations(context.Context, *protos.Void) (*N7ExpectationResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AssertExpectations not implemented")
}

// UnsafeMockPCFServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MockPCFServer will
// result in compilation errors.
type UnsafeMockPCFServer interface {
	mustEmbedUnimplementedMockPCFServer()
}

func RegisterMockPCFServer(s grpc.ServiceRegistrar, srv MockPCFServer) {
	s.RegisterService(&MockPCF_ServiceDesc, srv)
}

func _MockPCF_SetPCFConfigs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PCFConfigs)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MockPCFServer).SetPCFConfigs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.feg.MockPCF/SetPCFConfigs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MockPCFServer).SetPCFConfigs(ctx, req.(*PCFConfigs))
	}
	return interceptor(ctx, in, info, handler)
}

func _MockPCF_CreateAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(protos1.SubscriberID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MockPCFServer).CreateAccount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.feg.MockPCF/CreateAccount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MockPCFServer).CreateAccount(ctx, req.(*protos1.SubscriberID))
	}
	return interceptor(ctx, in, info, handler)
}

func _MockPCF_SetAccountRules_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PolicyDecision)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MockPCFServer).SetAccountRules(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.feg.MockPCF/SetAccountRules",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MockPCFServer).SetAccountRules(ctx, req.(*PolicyDecision))
	}
	return interceptor(ctx, in, info, handler)
}

func _MockPCF_ClearSubscribers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(protos.Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MockPCFServer).ClearSubscribers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.feg.MockPCF/ClearSubscribers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MockPCFServer).ClearSubscribers(ctx, req.(*protos.Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _MockPCF_SmPolicyUpdateNotify_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PolicyDecision)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MockPCFServer).SmPolicyUpdateNotify(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.feg.MockPCF/SmPolicyUpdateNotify",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MockPCFServer).SmPolicyUpdateNotify(ctx, req.(*PolicyDecision))
	}
	return interceptor(ctx, in, info, handler)
}

func _MockPCF_SmPolicyTerminate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TerminateNotification)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MockPCFServer).SmPolicyTerminate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.feg.MockPCF/SmPolicyTerminate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MockPCFServer).SmPolicyTerminate(ctx, req.(*TerminateNotification))
	}
	return interceptor(ctx, in, info, handler)
}

func _MockPCF_SetExpectations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(N7Expectations)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MockPCFServer).SetExpectations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.feg.MockPCF/SetExpectations",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MockPCFServer).SetExpectations(ctx, req.(*N7Expectations))
	}
	return interceptor(ctx, in, info, handler)
}

func _MockPCF_AssertExpectations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(protos.Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MockPCFServer).AssertExpectations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.feg.MockPCF/AssertExpectations",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MockPCFServer).AssertExpectations(ctx, req.(*protos.Void))
	}
	return interceptor(ctx, in, info, handler)
}

// MockPCF_ServiceDesc is the grpc.ServiceDesc for MockPCF service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var MockPCF_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "magma.feg.MockPCF",
	HandlerType: (*MockPCFServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SetPCFConfigs",
			Handler:    _MockPCF_SetPCFConfigs_Handler,
		},
		{
			MethodName: "CreateAccount",
			Handler:    _MockPCF_CreateAccount_Handler,
		},
		{
			MethodName: "SetAccountRules",
			Handler:    _MockPCF_SetAccountRules_Handler,
		},
		{
			MethodName: "ClearSubscribers",
			Handler:    _MockPCF_ClearSubscribers_Handler,
		},
		{
			MethodName: "SmPolicyUpdateNotify",
			Handler:    _MockPCF_SmPolicyUpdateNotify_Handler,
		},
		{
			MethodName: "SmPolicyTerminate",
			Handler:    _MockPCF_SmPolicyTerminate_Handler,
		},
		{
			MethodName: "SetExpectations",
			Handler:    _MockPCF_SetExpectations_Handler,
		},
		{
			MethodName: "AssertExpectations",
			Handler:    _MockPCF_AssertExpectations_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "feg/protos/mock_core.proto",
}
